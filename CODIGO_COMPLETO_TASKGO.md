# C√≥digo Completo - TaskGo App
## An√°lise Completa de Todo o C√≥digo

**Data de Cria√ß√£o**: 2026-01-20 18:00:05
**Vers√£o**: 1.0.97
**Status**: C√≥digo Completo para An√°lise

---

# CLASSIFICA√á√ÉO: FRONTEND vs BACKEND

## [FRONTEND] (Android App)
- Todas as Features (Telas, ViewModels, Composables)
- Data Layer (Reposit√≥rios, Models)
- Core (Location, Firebase Helpers, Utils)
- Dependency Injection (Hilt Modules)
- Domain Layer (Interfaces, Use Cases)

## [BACKEND] (Firebase)
- Cloud Functions (functions/)
- Firestore Security Rules (firestore.rules)
- Firestore Indexes (firestore.indexes.json)

---


# Core - accessibility


## [FRONTEND]: core/accessibility/AccessibilityHelper.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.core.accessibility

import androidx.compose.ui.semantics.SemanticsPropertyKey
import androidx.compose.ui.semantics.SemanticsPropertyReceiver

// Accessibility property keys
val ContentDescriptionKey = SemanticsPropertyKey<String>("ContentDescription")
val TestTagKey = SemanticsPropertyKey<String>("TestTag")

// Extension functions for accessibility
fun SemanticsPropertyReceiver.contentDescription(description: String) {
    this[ContentDescriptionKey] = description
}

fun SemanticsPropertyReceiver.testTag(tag: String) {
    this[TestTagKey] = tag
}

// Common accessibility strings
object AccessibilityStrings {
    const val BACK_BUTTON = "Bot√£o voltar"
    const val SEARCH_BUTTON = "Bot√£o buscar"
    const val CART_BUTTON = "Bot√£o carrinho"
    const val NOTIFICATIONS_BUTTON = "Bot√£o notifica√ß√µes"
    const val PROFILE_BUTTON = "Bot√£o perfil"
    const val ADD_BUTTON = "Bot√£o adicionar"
    const val REMOVE_BUTTON = "Bot√£o remover"
    const val EDIT_BUTTON = "Bot√£o editar"
    const val DELETE_BUTTON = "Bot√£o excluir"
    const val SEND_BUTTON = "Bot√£o enviar"
    const val SAVE_BUTTON = "Bot√£o salvar"
    const val CANCEL_BUTTON = "Bot√£o cancelar"
    const val CONFIRM_BUTTON = "Bot√£o confirmar"
    const val ACCEPT_BUTTON = "Bot√£o aceitar"
    const val REJECT_BUTTON = "Bot√£o rejeitar"
    
    fun starRating(rating: Int) = "Avalia√ß√£o $rating estrelas"
    fun productImage(productName: String) = "Imagem do produto $productName"
    fun userAvatar(userName: String) = "Avatar do usu√°rio $userName"
    fun qrCode() = "C√≥digo QR"
    fun creditCard() = "Cart√£o de cr√©dito"
    fun debitCard() = "Cart√£o de d√©bito"
    fun pixPayment() = "Pagamento via Pix"
    
    // Form fields
    fun textField(label: String) = "Campo de texto $label"
    fun emailField() = "Campo de e-mail"
    fun passwordField() = "Campo de senha"
    fun phoneField() = "Campo de telefone"
    fun cepField() = "Campo de CEP"
    fun priceField() = "Campo de pre√ßo"
    
    // Navigation
    fun tabItem(tabName: String) = "Aba $tabName"
    fun navigationItem(itemName: String) = "Item de navega√ß√£o $itemName"
    
    // Lists and cards
    fun productCard(productName: String) = "Card do produto $productName"
    fun serviceCard(serviceName: String) = "Card do servi√ßo $serviceName"
    fun orderCard(orderId: String) = "Card do pedido $orderId"
    fun messageCard(senderName: String) = "Card de mensagem de $senderName"
    
    // Status indicators
    fun loadingState() = "Carregando"
    fun errorState() = "Erro"
    fun emptyState() = "Nenhum item encontrado"
    fun successState() = "Sucesso"
    
    // Actions
    fun addToCart(productName: String) = "Adicionar $productName ao carrinho"
    fun removeFromCart(productName: String) = "Remover $productName do carrinho"
    fun increaseQuantity(productName: String) = "Aumentar quantidade de $productName"
    fun decreaseQuantity(productName: String) = "Diminuir quantidade de $productName"
    fun viewDetails(itemName: String) = "Ver detalhes de $itemName"
    fun editItem(itemName: String) = "Editar $itemName"
    fun deleteItem(itemName: String) = "Excluir $itemName"
    
    // Notifications
    fun notificationItem(title: String) = "Notifica√ß√£o: $title"
    fun unreadNotification() = "Notifica√ß√£o n√£o lida"
    fun readNotification() = "Notifica√ß√£o lida"
    
    // Tracking
    fun trackingStep(stepName: String, isCompleted: Boolean) = 
        "Etapa $stepName ${if (isCompleted) "conclu√≠da" else "pendente"}"
    fun trackingCode(code: String) = "C√≥digo de rastreamento $code"
    
    // Chat
    fun messageBubble(isOwn: Boolean, message: String) = 
        "${if (isOwn) "Sua mensagem" else "Mensagem recebida"}: $message"
    fun typingIndicator() = "Digitando"
    fun messageInput() = "Campo de entrada de mensagem"
    
    // Settings
    fun switchSetting(settingName: String, isEnabled: Boolean) = 
        "Configura√ß√£o $settingName ${if (isEnabled) "ativada" else "desativada"}"
    fun languageOption(language: String) = "Idioma $language"
    fun themeOption(theme: String) = "Tema $theme"
}

```

# Core - ai


## [FRONTEND]: core/ai/AppSystemPrompt.kt

```kotlin
package com.taskgoapp.taskgo.core.ai

object AppSystemPrompt {
    const val SYSTEM_MESSAGE = """
Voc√™ √© o assistente de IA do TaskGo, um marketplace de servi√ßos e produtos. Sua fun√ß√£o √© ajudar os usu√°rios a entender e utilizar todas as funcionalidades do aplicativo.

## SOBRE O TASKGO

O TaskGo √© uma plataforma completa que conecta pessoas que precisam de servi√ßos com prestadores qualificados, al√©m de oferecer um marketplace de produtos.

## PRINCIPAIS FUNCIONALIDADES

### 1. SERVI√áOS
- Os usu√°rios podem criar ordens de servi√ßo descrevendo o que precisam
- Prestadores de servi√ßo podem visualizar e fazer propostas para essas ordens
- Sistema de avalia√ß√µes e coment√°rios para prestadores
- Rastreamento de servi√ßos em tempo real
- Hist√≥rico completo de servi√ßos contratados

### 2. PRODUTOS
- Marketplace de produtos com busca inteligente
- Carrinho de compras integrado
- Sistema de categorias e filtros
- Produtos com desconto destacados
- Avalia√ß√µes e coment√°rios de produtos

### 3. MENSAGENS
- Chat integrado para comunica√ß√£o entre usu√°rios e prestadores
- Notifica√ß√µes em tempo real
- Hist√≥rico de conversas

### 4. PAGAMENTOS
- M√∫ltiplas formas de pagamento: PIX, cart√£o de cr√©dito, cart√£o de d√©bito
- Integra√ß√£o com Google Pay
- Processamento seguro de transa√ß√µes
- Hist√≥rico de pagamentos

### 5. PERFIL E CONTA
- Perfil completo do usu√°rio com foto
- Edi√ß√£o de dados pessoais
- Hist√≥rico de pedidos e servi√ßos
- Sistema de avalia√ß√µes recebidas
- Verifica√ß√£o de identidade

### 6. BUSCA E NAVEGA√á√ÉO
- Busca universal inteligente
- Filtros avan√ßados para servi√ßos e produtos
- Navega√ß√£o intuitiva por categorias

## COMO AJUDAR OS USU√ÅRIOS

1. **Explique funcionalidades**: Quando perguntarem sobre como fazer algo no app, explique passo a passo
2. **Resolva d√∫vidas**: Responda perguntas sobre servi√ßos, produtos, pagamentos, etc.
3. **Oriente sobre problemas**: Ajude a resolver problemas comuns de uso
4. **Forne√ßa informa√ß√µes**: Compartilhe informa√ß√µes sobre recursos e funcionalidades
5. **Seja amig√°vel e profissional**: Use linguagem clara e acess√≠vel

## IMPORTANTE

- Sempre seja √∫til e prestativo
- Se n√£o souber algo espec√≠fico sobre o app, seja honesto
- Mantenha o foco nas funcionalidades do TaskGo
- Ajude os usu√°rios a aproveitarem ao m√°ximo a plataforma

Responda sempre em portugu√™s brasileiro, de forma clara e objetiva.
"""
}


```

## [FRONTEND]: core/ai/AudioRecorderManager.kt

```kotlin
package com.taskgoapp.taskgo.core.ai

import android.content.Context
import android.media.MediaRecorder
import android.os.Build
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.io.File
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class AudioRecorderManager @Inject constructor(
    private val context: Context
) {
    private var mediaRecorder: MediaRecorder? = null
    private var isRecording = false
    private var outputFile: File? = null
    
    /**
     * Inicia a grava√ß√£o de √°udio
     * Retorna o arquivo de sa√≠da onde o √°udio ser√° gravado
     */
    suspend fun startRecording(): Result<File> = withContext(Dispatchers.IO) {
        try {
            if (isRecording) {
                return@withContext Result.failure(Exception("J√° est√° gravando"))
            }
            
            // Criar arquivo tempor√°rio para o √°udio
            // IMPORTANTE: Usar formato LINEAR16 (WAV PCM) para melhor compatibilidade com Google Speech-to-Text API
            // O formato M4A/AAC pode causar problemas de encoding na API
            // Para Android Q+, usar formato que pode ser convertido para LINEAR16
            outputFile = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                // Tentar usar formato mais compat√≠vel (WAV se poss√≠vel, sen√£o M4A)
                try {
                    File.createTempFile("audio_recording_", ".wav", context.cacheDir)
                } catch (e: Exception) {
                    // Fallback para M4A se WAV n√£o for suportado
                    File.createTempFile("audio_recording_", ".m4a", context.cacheDir)
                }
            } else {
                File.createTempFile("audio_recording_", ".3gp", context.cacheDir)
            }
            val file = outputFile ?: return@withContext Result.failure(Exception("N√£o foi poss√≠vel criar arquivo"))
            
            // Criar MediaRecorder baseado na vers√£o do Android
            mediaRecorder = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                MediaRecorder(context)
            } else {
                @Suppress("DEPRECATION")
                MediaRecorder()
            }
            
            val recorder = mediaRecorder ?: return@withContext Result.failure(Exception("N√£o foi poss√≠vel criar MediaRecorder"))
            
            // Configurar MediaRecorder para melhor qualidade e compatibilidade com Speech-to-Text
            recorder.setAudioSource(MediaRecorder.AudioSource.MIC)
            
            // Usar formato apropriado baseado na vers√£o do Android e extens√£o do arquivo
            val fileName = file.name.lowercase()
            if (fileName.endsWith(".wav") && Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                // Tentar usar formato WAV (LINEAR16) se suportado
                try {
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                        recorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP) // Fallback, WAV n√£o √© suportado diretamente
                        recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB)
                    }
                } catch (e: Exception) {
                    // Se WAV falhar, usar M4A
                    recorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4)
                    recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC)
                }
            } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                // Android Q+: Usar M4A/AAC com configura√ß√µes otimizadas para Speech-to-Text
                recorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4)
                recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC)
                recorder.setAudioEncodingBitRate(128000)
                recorder.setAudioSamplingRate(16000) // Taxa de amostragem padr√£o para Speech-to-Text (16kHz)
            } else {
                // Android antigo: Usar 3GP/AMR
                @Suppress("DEPRECATION")
                recorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP)
                @Suppress("DEPRECATION")
                recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB)
                recorder.setAudioEncodingBitRate(12200)
                recorder.setAudioSamplingRate(8000) // Taxa de amostragem para AMR (8kHz)
            }
            
            recorder.setOutputFile(file.absolutePath)
            
            // Preparar e iniciar grava√ß√£o
            recorder.prepare()
            recorder.start()
            
            isRecording = true
            
            Result.success(file)
        } catch (e: Exception) {
            stopRecording()
            Result.failure(e)
        }
    }
    
    /**
     * Para a grava√ß√£o de √°udio
     * Retorna o arquivo gravado ou null se n√£o houver grava√ß√£o
     */
    suspend fun stopRecording(): Result<File?> = withContext(Dispatchers.IO) {
        try {
            if (!isRecording) {
                return@withContext Result.success(null)
            }
            
            val recorder = mediaRecorder
            val file = outputFile
            
            recorder?.apply {
                try {
                    stop()
                    release()
                } catch (e: Exception) {
                    // Ignorar erros ao parar (pode ocorrer se n√£o houver dados suficientes)
                }
            }
            
            mediaRecorder = null
            isRecording = false
            
            Result.success(file)
        } catch (e: Exception) {
            mediaRecorder?.release()
            mediaRecorder = null
            isRecording = false
            Result.failure(e)
        }
    }
    
    /**
     * Cancela a grava√ß√£o atual e remove o arquivo
     */
    suspend fun cancelRecording(): Result<Unit> = withContext(Dispatchers.IO) {
        try {
            stopRecording()
            outputFile?.delete()
            outputFile = null
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    /**
     * Retorna o status atual da grava√ß√£o
     */
    fun isCurrentlyRecording(): Boolean = isRecording
    
    /**
     * Obt√©m a amplitude atual do √°udio (0.0 a 1.0) para anima√ß√£o visual
     * Retorna 0.0 se n√£o estiver gravando
     */
    fun getAmplitude(): Double {
        return if (isRecording && mediaRecorder != null) {
            try {
                val maxAmplitude = mediaRecorder?.maxAmplitude ?: 0
                // Normalizar para 0.0 a 1.0
                (maxAmplitude / 32767.0).coerceIn(0.0, 1.0)
            } catch (e: Exception) {
                0.0
            }
        } else {
            0.0
        }
    }
}

```

## [FRONTEND]: core/ai/GoogleCloudAIService.kt

```kotlin
package com.taskgoapp.taskgo.core.ai

import com.google.gson.Gson
import com.google.gson.annotations.SerializedName
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.withContext
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.RequestBody.Companion.toRequestBody
import java.util.concurrent.TimeUnit
import javax.inject.Inject
import javax.inject.Singleton

data class ChatRequest(
    val contents: List<ContentRequest>
)

data class ContentRequest(
    val role: String, // "user" or "model"
    val parts: List<PartRequest>
)

data class PartRequest(
    val text: String? = null,
    val inlineData: InlineData? = null
)

data class InlineData(
    val mimeType: String,
    val data: String // Base64 encoded
)

// ChatMessage para uso interno do servi√ßo
data class ChatMessage(
    val role: String, // "user" or "assistant"
    val content: String,
    val imageData: List<ImageData> = emptyList()
)

data class ImageData(
    val mimeType: String,
    val base64Data: String
)

data class ChatResponse(
    val candidates: List<Candidate>?
)

data class Candidate(
    val content: Content?
)

data class Content(
    val parts: List<Part>?,
    val role: String?
)

data class Part(
    val text: String?
)

/**
 * Cache de resposta para melhorar performance e reduzir chamadas √† API
 * Baseado no padr√£o de cache dos arquivos Python de refer√™ncia
 */
private data class CachedResponse(
    val response: String,
    val timestamp: Long
)

@Singleton
class GoogleCloudAIService @Inject constructor(
    private val apiKey: String
) {
    // Cliente com timeout otimizado e retry autom√°tico
    private val client = OkHttpClient.Builder()
        .connectTimeout(10, TimeUnit.SECONDS)
        .readTimeout(60, TimeUnit.SECONDS) // Aumentado para respostas mais complexas
        .writeTimeout(30, TimeUnit.SECONDS)
        .retryOnConnectionFailure(true) // Retry autom√°tico em falhas de conex√£o
        .build()
    private val gson = Gson()
    
    private val baseUrl = "https://generativelanguage.googleapis.com/v1/models"
    private val primaryModel = "gemini-2.0-flash-exp"
    // Fallback para modelos alternativos caso o principal falhe
    private val fallbackModels = listOf(
        "gemini-1.5-flash-latest",
        "gemini-1.5-pro-latest"
    )
    
    // Cache de health check (baseado em ollama_api.py _check_ollama_running)
    @Volatile
    private var lastHealthCheck: Long = 0
    @Volatile
    private var isHealthy: Boolean = true
    private val healthCheckInterval = 300_000L // 5 minutos
    
    // Cache de respostas para perguntas frequentes (baseado em chat_manager.py)
    private val responseCache = mutableMapOf<String, CachedResponse>()
    private val cacheExpiry = 3600_000L // 1 hora
    
    /**
     * Verifica se a API est√° dispon√≠vel e funcionando
     * Baseado no padr√£o de ollama_api.py (_check_ollama_running)
     */
    suspend fun checkConnection(): Boolean = withContext(Dispatchers.IO) {
        val now = System.currentTimeMillis()
        if (now - lastHealthCheck < healthCheckInterval && isHealthy) {
            return@withContext true
        }
        
        try {
            // Fazer uma chamada simples para verificar conex√£o
            val testUrl = "$baseUrl/$primaryModel:generateContent?key=$apiKey"
            val testBody = mapOf(
                "contents" to listOf(
                    mapOf(
                        "role" to "user",
                        "parts" to listOf(mapOf("text" to "test"))
                    )
                ),
                "generationConfig" to mapOf(
                    "maxOutputTokens" to 1
                )
            )
            
            val request = Request.Builder()
                .url(testUrl)
                .post(gson.toJson(testBody).toRequestBody("application/json".toMediaType()))
                .build()
            
            val response = client.newCall(request).execute()
            val isOk = response.isSuccessful
            
            lastHealthCheck = now
            isHealthy = isOk
            
            if (!isOk) {
                // 404 pode indicar que a API n√£o est√° configurada ou endpoint incorreto
                // N√£o √© cr√≠tico, apenas usar fallback
                android.util.Log.w("GoogleCloudAIService", "Health check failed: ${response.code} - API pode n√£o estar dispon√≠vel, usando fallback")
            }
            
            isOk
        } catch (e: Exception) {
            android.util.Log.e("GoogleCloudAIService", "Health check error: ${e.message}", e)
            lastHealthCheck = now
            isHealthy = false
            false
        }
    }
    
    /**
     * Envia mensagem com sistema robusto de retry e fallback
     * Baseado no padr√£o de chat_manager.py e ollama_api.py
     */
    suspend fun sendMessage(
        messages: List<ChatMessage>, 
        systemInstruction: String? = null
    ): kotlin.Result<String> = withContext(Dispatchers.IO) {
        // Verificar conex√£o primeiro
        if (!checkConnection()) {
            android.util.Log.w("GoogleCloudAIService", "API n√£o est√° dispon√≠vel, usando fallback")
            return@withContext getFallbackResponse(messages.lastOrNull()?.content ?: "")
        }
        
        // Verificar cache
        val cacheKey = generateCacheKey(messages, systemInstruction)
        val cached = responseCache[cacheKey]
        if (cached != null && System.currentTimeMillis() - cached.timestamp < cacheExpiry) {
            android.util.Log.d("GoogleCloudAIService", "Resposta retornada do cache")
            return@withContext kotlin.Result.success(cached.response)
        }
        
        // Tentar com retry e backoff exponencial (baseado em engine.py)
        val maxRetries = 3
        var lastError: Exception? = null
        
        for (attempt in 0 until maxRetries) {
            try {
                val result = trySendWithRetry(messages, systemInstruction, attempt)
                if (result.isSuccess) {
                    val response = result.getOrNull() ?: ""
                    // Salvar no cache
                    responseCache[cacheKey] = CachedResponse(response, System.currentTimeMillis())
                    // Limpar cache antigo
                    cleanupCache()
                    return@withContext result
                } else {
                    lastError = result.exceptionOrNull() as? Exception
                }
            } catch (e: Exception) {
                lastError = e
            }
            
            // Backoff exponencial: 1s, 2s, 4s (baseado em adaptive_fuzzer.py)
            if (attempt < maxRetries - 1) {
                val delayMs = (1 shl attempt) * 1000L
                android.util.Log.w("GoogleCloudAIService", "Tentativa ${attempt + 1} falhou, aguardando ${delayMs}ms...")
                delay(delayMs)
            }
        }
        
        // Se todas as tentativas falharam, usar fallback
        android.util.Log.w("GoogleCloudAIService", "Todas as tentativas falharam, usando fallback")
        val fallback = getFallbackResponse(messages.lastOrNull()?.content ?: "")
        return@withContext fallback
    }
    
    private suspend fun trySendWithRetry(
        messages: List<ChatMessage>,
        systemInstruction: String?,
        attempt: Int
    ): kotlin.Result<String> {
        val modelsToTry = listOf(primaryModel) + fallbackModels
        
        for (modelName in modelsToTry) {
            try {
                val result = trySendMessageWithModel(messages, systemInstruction, modelName)
                if (result.isSuccess) {
                    return result
                }
            } catch (e: Exception) {
                android.util.Log.w("GoogleCloudAIService", "Modelo $modelName falhou na tentativa ${attempt + 1}: ${e.message}")
            }
        }
        
        return kotlin.Result.failure(Exception("Todos os modelos falharam"))
    }
    
    private fun generateCacheKey(
        messages: List<ChatMessage>,
        systemInstruction: String?
    ): String {
        val lastMessage = messages.lastOrNull()?.content ?: ""
        val hash = (lastMessage + (systemInstruction ?: "")).hashCode()
        return "msg_$hash"
    }
    
    private fun cleanupCache() {
        val now = System.currentTimeMillis()
        val toRemove = responseCache.entries.filter { 
            now - it.value.timestamp > cacheExpiry 
        }.map { it.key }
        toRemove.forEach { responseCache.remove(it) }
    }
    
    /**
     * Resposta de fallback quando a API n√£o est√° dispon√≠vel
     * Baseado no padr√£o de ollama_api.py (_fallback_response)
     */
    private fun getFallbackResponse(message: String): kotlin.Result<String> {
        val lowerMessage = message.lowercase()
        
        // Palavras-chave para diferentes categorias (baseado em ollama_api.py)
        val helpKeywords = listOf("ajuda", "help", "como", "guia", "tutorial", "instru√ß√£o", "manual")
        val serviceKeywords = listOf("servi√ßo", "service", "ordem", "order", "prestador", "provider", "contratar")
        val productKeywords = listOf("produto", "product", "compra", "buy", "carrinho", "cart", "loja", "store")
        val paymentKeywords = listOf("pagamento", "payment", "pix", "cart√£o", "card", "pagar", "pay")
        val greetingKeywords = listOf("ol√°", "oi", "bom dia", "boa tarde", "boa noite", "tudo bem", "e a√≠", "eai")
        val profileKeywords = listOf("perfil", "profile", "conta", "account", "dados", "editar", "edit")
        val searchKeywords = listOf("buscar", "search", "encontrar", "find", "procurar", "look")
        
        return when {
            helpKeywords.any { lowerMessage.contains(it) } -> {
                kotlin.Result.success(
                    "Ol√°! Sou o assistente do TaskGo e estou aqui para ajudar. " +
                    "Posso te ajudar com:\n\n" +
                    "‚Ä¢ **Servi√ßos**: criar ordens, encontrar prestadores, acompanhar servi√ßos\n" +
                    "‚Ä¢ **Produtos**: buscar, comprar, gerenciar carrinho\n" +
                    "‚Ä¢ **Pagamentos**: PIX, cart√£o, hist√≥rico de transa√ß√µes\n" +
                    "‚Ä¢ **Perfil**: editar dados, ver hist√≥rico, avalia√ß√µes\n" +
                    "‚Ä¢ **Busca**: encontrar servi√ßos e produtos rapidamente\n\n" +
                    "O que voc√™ gostaria de saber? üòä"
                )
            }
            serviceKeywords.any { lowerMessage.contains(it) } -> {
                kotlin.Result.success(
                    "No TaskGo voc√™ pode:\n\n" +
                    "1. **Criar ordem de servi√ßo**: Descreva o que precisa e receba propostas de prestadores qualificados\n" +
                    "2. **Encontrar prestadores**: Veja perfis, avalia√ß√µes e trabalhos anteriores\n" +
                    "3. **Acompanhar servi√ßos**: Rastreie o status em tempo real\n" +
                    "4. **Avaliar**: Deixe sua opini√£o ap√≥s o servi√ßo ser conclu√≠do\n\n" +
                    "Quer ajuda com algo espec√≠fico sobre servi√ßos?"
                )
            }
            productKeywords.any { lowerMessage.contains(it) } -> {
                kotlin.Result.success(
                    "No marketplace de produtos do TaskGo voc√™ pode:\n\n" +
                    "‚Ä¢ **Buscar produtos** por categoria ou nome\n" +
                    "‚Ä¢ **Ver detalhes** completos com fotos e avalia√ß√µes\n" +
                    "‚Ä¢ **Adicionar ao carrinho** e finalizar compra\n" +
                    "‚Ä¢ **Acompanhar pedidos** em tempo real\n\n" +
                    "Precisa de ajuda com alguma compra espec√≠fica?"
                )
            }
            paymentKeywords.any { lowerMessage.contains(it) } -> {
                kotlin.Result.success(
                    "O TaskGo aceita m√∫ltiplas formas de pagamento:\n\n" +
                    "‚Ä¢ **PIX**: Pagamento instant√¢neo e seguro\n" +
                    "‚Ä¢ **Cart√£o de Cr√©dito**: Parcelamento dispon√≠vel\n" +
                    "‚Ä¢ **Cart√£o de D√©bito**: D√©bito direto na conta\n" +
                    "‚Ä¢ **Google Pay**: Pagamento r√°pido e integrado\n\n" +
                    "Todas as transa√ß√µes s√£o seguras e protegidas. Precisa de ajuda com algum pagamento?"
                )
            }
            profileKeywords.any { lowerMessage.contains(it) } -> {
                kotlin.Result.success(
                    "No seu perfil do TaskGo voc√™ pode:\n\n" +
                    "‚Ä¢ **Editar dados pessoais**: nome, telefone, endere√ßo\n" +
                    "‚Ä¢ **Alterar foto de perfil**: personalize sua conta\n" +
                    "‚Ä¢ **Ver hist√≥rico**: servi√ßos contratados e produtos comprados\n" +
                    "‚Ä¢ **Avalia√ß√µes recebidas**: veja o que outros usu√°rios disseram\n" +
                    "‚Ä¢ **Configura√ß√µes**: ajuste prefer√™ncias e notifica√ß√µes\n\n" +
                    "Quer ajuda com alguma configura√ß√£o espec√≠fica?"
                )
            }
            searchKeywords.any { lowerMessage.contains(it) } -> {
                kotlin.Result.success(
                    "A busca do TaskGo permite encontrar:\n\n" +
                    "‚Ä¢ **Servi√ßos**: por categoria, localiza√ß√£o ou palavra-chave\n" +
                    "‚Ä¢ **Produtos**: por nome, categoria ou descri√ß√£o\n" +
                    "‚Ä¢ **Prestadores**: por especialidade ou avalia√ß√£o\n\n" +
                    "Use filtros avan√ßados para refinar sua busca. O que voc√™ est√° procurando?"
                )
            }
            greetingKeywords.any { lowerMessage.contains(it) } -> {
                kotlin.Result.success(
                    "Ol√°! Que bom te ver por aqui! üòä\n\n" +
                    "Sou o assistente do TaskGo e estou aqui para ajudar voc√™ a aproveitar " +
                    "ao m√°ximo nossa plataforma de servi√ßos e produtos.\n\n" +
                    "Posso te ajudar com servi√ßos, produtos, pagamentos, perfil e muito mais. " +
                    "Como posso te ajudar hoje?"
                )
            }
            else -> {
                kotlin.Result.success(
                    "Ol√°! Sou o assistente do TaskGo. " +
                    "No momento, estou com limita√ß√µes de conex√£o, mas posso te ajudar com informa√ß√µes b√°sicas.\n\n" +
                    "O TaskGo √© uma plataforma completa para contratar servi√ßos e comprar produtos. " +
                    "Voc√™ pode criar ordens de servi√ßo, buscar prestadores, comprar produtos e muito mais.\n\n" +
                    "Tente novamente em alguns instantes para uma resposta mais completa, ou me pergunte sobre " +
                    "servi√ßos, produtos, pagamentos ou qualquer funcionalidade do app! üòä"
                )
            }
        }
    }
    
    private suspend fun trySendMessageWithModel(
        messages: List<ChatMessage>,
        systemInstruction: String?,
        modelName: String
    ): kotlin.Result<String> {
        try {
            val modelUrl = "https://generativelanguage.googleapis.com/v1/models/$modelName:generateContent"
            
            // Converter mensagens para o formato da API Gemini
            val contents = messages.map { msg ->
                val parts = mutableListOf<Map<String, Any>>()
                
                // Adicionar texto se houver
                if (msg.content.isNotBlank()) {
                    parts.add(mapOf("text" to msg.content))
                }
                
                // Adicionar imagens se houver
                msg.imageData.forEach { imageData ->
                    parts.add(mapOf(
                        "inline_data" to mapOf(
                            "mime_type" to imageData.mimeType,
                            "data" to imageData.base64Data
                        )
                    ))
                }
                
                mapOf(
                    "role" to (if (msg.role == "assistant") "model" else "user"),
                    "parts" to parts
                )
            }
            
            // Construir request body - IMPORTANTE: systemInstruction n√£o √© suportado na API REST v1
            // Solu√ß√£o robusta: incorporar system instruction de forma contextual e natural
            val finalContents = if (systemInstruction != null && systemInstruction.isNotBlank() && contents.isNotEmpty()) {
                // Estrat√©gia avan√ßada: incorporar system instruction na primeira mensagem do usu√°rio
                // de forma que o modelo entenda o contexto sem poluir a conversa
                val firstMessage = contents[0]
                val firstMessageRole = firstMessage["role"] as? String ?: "user"
                
                // Se a primeira mensagem for do usu√°rio, incorporar system instruction de forma contextual
                if (firstMessageRole == "user") {
                    val originalParts = firstMessage["parts"] as? List<*> ?: emptyList<Any>()
                    val firstParts = mutableListOf<Map<String, Any>>()
                    
                    // Converter partes originais para o tipo correto
                    originalParts.forEach { part ->
                        when (val partMap = part as? Map<*, *>) {
                            null -> { /* Ignorar partes inv√°lidas */ }
                            else -> {
                                val typedPartMap = mutableMapOf<String, Any>()
                                partMap.forEach { (key, value) ->
                                    val stringKey = key?.toString() ?: ""
                                    if (stringKey.isNotEmpty() && value != null) {
                                        typedPartMap[stringKey] = value
                                    }
                                }
                                
                                if (typedPartMap.isNotEmpty()) {
                                    firstParts.add(typedPartMap)
                                }
                            }
                        }
                    }
                    
                    // Encontrar a primeira parte de texto
                    val firstTextPartIndex = firstParts.indexOfFirst { 
                        it.containsKey("text")
                    }
                    
                    if (firstTextPartIndex >= 0) {
                        // Modificar a primeira parte de texto para incluir system instruction
                        val originalTextPart = firstParts[firstTextPartIndex]
                        val originalText = originalTextPart["text"] as? String ?: ""
                        
                        // Incorporar system instruction de forma elegante e contextual
                        val enhancedText = buildString {
                            append(systemInstruction)
                            append("\n\n---\n\n")
                            append(originalText)
                        }
                        
                        val enhancedTextPart = originalTextPart.toMutableMap()
                        enhancedTextPart["text"] = enhancedText
                        firstParts[firstTextPartIndex] = enhancedTextPart
                    } else {
                        // Se n√£o houver parte de texto, adicionar system instruction como nova parte
                        firstParts.add(0, mapOf("text" to "$systemInstruction\n\n---\n\n"))
                    }
                    
                    val modifiedFirstMessage = firstMessage.toMutableMap()
                    modifiedFirstMessage["parts"] = firstParts
                    
                    listOf(modifiedFirstMessage) + contents.drop(1)
                } else {
                    // Se a primeira mensagem n√£o for do usu√°rio, adicionar system instruction como mensagem inicial
                val systemMessage = mapOf(
                    "role" to "user",
                    "parts" to listOf(mapOf("text" to systemInstruction))
                )
                    listOf(systemMessage) + contents
                }
            } else if (systemInstruction != null && systemInstruction.isNotBlank() && contents.isEmpty()) {
                // Se n√£o houver mensagens, criar uma mensagem com o system instruction
                listOf(
                    mapOf(
                        "role" to "user",
                        "parts" to listOf(mapOf("text" to systemInstruction))
                    )
                )
            } else {
                contents
            }
            
            val requestBody = mutableMapOf<String, Any>("contents" to finalContents)
            
            // Otimiza√ß√µes de performance: aumentar tokens para respostas mais completas
            // Baseado em chat_manager.py que usa max_tokens: 4000
            requestBody["generationConfig"] = mapOf(
                "maxOutputTokens" to 2048, // Aumentado para respostas mais completas
                "temperature" to 0.7,
                "topP" to 0.95,
                "topK" to 40
            )
            
            val jsonBody = gson.toJson(requestBody)
            
            val request = Request.Builder()
                .url("$modelUrl?key=$apiKey")
                .post(jsonBody.toRequestBody("application/json".toMediaType()))
                .addHeader("Content-Type", "application/json")
                .build()
            
            val response = client.newCall(request).execute()
            val responseBody = response.body?.string() ?: return kotlin.Result.failure(Exception("Empty response"))
            
            if (!response.isSuccessful) {
                // Se for erro 404 (modelo n√£o encontrado), tentar pr√≥ximo modelo
                if (response.code == 404) {
                    android.util.Log.w("GoogleCloudAIService", "Modelo $modelName n√£o encontrado (404). Tentando pr√≥ximo modelo...")
                    return kotlin.Result.failure(Exception("Model not found: $modelName"))
                }
                return kotlin.Result.failure(Exception("API Error: ${response.code} - $responseBody"))
            }
            
            val chatResponse = gson.fromJson(responseBody, ChatResponse::class.java)
            val text = chatResponse.candidates?.firstOrNull()?.content?.parts?.firstOrNull()?.text
                ?: return kotlin.Result.failure(Exception("No response text"))
            
            android.util.Log.d("GoogleCloudAIService", "Resposta recebida com sucesso do modelo $modelName")
            return kotlin.Result.success(text)
        } catch (e: Exception) {
            android.util.Log.e("GoogleCloudAIService", "Erro ao enviar mensagem para modelo $modelName: ${e.message}", e)
            return kotlin.Result.failure(e)
        }
    }
}


```

## [FRONTEND]: core/ai/GoogleSpeechToTextService.kt

```kotlin
package com.taskgoapp.taskgo.core.ai

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.media.AudioFormat
import android.media.AudioRecord
import android.media.MediaRecorder
import androidx.core.content.ContextCompat
import com.google.gson.Gson
import com.google.gson.JsonObject
import com.google.gson.JsonSyntaxException
import com.google.gson.annotations.SerializedName
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.withContext
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.MultipartBody
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.RequestBody.Companion.toRequestBody
import java.io.File
import java.io.FileOutputStream
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Request para Google Speech-to-Text API v1
 * Usar @SerializedName para garantir serializa√ß√£o correta do JSON
 */
data class SpeechRecognitionRequest(
    @SerializedName("config")
    val config: RecognitionConfig,
    @SerializedName("audio")
    val audio: RecognitionAudio
)

/**
 * Configura√ß√£o de reconhecimento de fala
 */
data class RecognitionConfig(
    @SerializedName("encoding")
    val encoding: String = "LINEAR16",
    @SerializedName("sampleRateHertz")
    val sampleRateHertz: Int = 16000,
    @SerializedName("languageCode")
    val languageCode: String = "pt-BR",
    @SerializedName("enableAutomaticPunctuation")
    val enableAutomaticPunctuation: Boolean = true
)

/**
 * √Åudio para reconhecimento (content em base64 ou URI)
 */
data class RecognitionAudio(
    @SerializedName("content")
    val content: String? = null,
    @SerializedName("uri")
    val uri: String? = null
)

/**
 * Response do Google Speech-to-Text API v1
 */
data class SpeechRecognitionResponse(
    @SerializedName("results")
    val results: List<SpeechResult>?
)

data class SpeechResult(
    @SerializedName("alternatives")
    val alternatives: List<Alternative>?
)

data class Alternative(
    @SerializedName("transcript")
    val transcript: String?,
    @SerializedName("confidence")
    val confidence: Double?
)

@Singleton
class GoogleSpeechToTextService @Inject constructor(
    private val apiKey: String,
    private val context: Context
) {
    private val client = OkHttpClient()
    private val gson = Gson()
    private val baseUrl = "https://speech.googleapis.com/v1/speech:recognize"
    
    fun hasMicrophonePermission(): Boolean {
        return ContextCompat.checkSelfPermission(
            context,
            Manifest.permission.RECORD_AUDIO
        ) == PackageManager.PERMISSION_GRANTED
    }
    
    suspend fun recognizeSpeech(audioFile: File): kotlin.Result<String> = withContext(Dispatchers.IO) {
        // Sistema de retry com backoff exponencial (baseado em engine.py e adaptive_fuzzer.py)
        val maxRetries = 3
        var lastError: Exception? = null
        
        for (attempt in 0 until maxRetries) {
            try {
                if (!hasMicrophonePermission()) {
                    return@withContext kotlin.Result.failure(Exception("Microphone permission not granted"))
                }
                
                val result = tryRecognizeSpeech(audioFile, attempt)
                if (result.isSuccess) {
                    return@withContext result
                } else {
                    lastError = result.exceptionOrNull() as? Exception
                }
            } catch (e: Exception) {
                lastError = e
            }
            
            // Backoff exponencial: 1s, 2s, 4s
            if (attempt < maxRetries - 1) {
                val delayMs = (1 shl attempt) * 1000L
                android.util.Log.w("GoogleSpeechToTextService", "Tentativa ${attempt + 1} falhou, aguardando ${delayMs}ms...")
                kotlinx.coroutines.delay(delayMs)
            }
        }
        
        // Se todas as tentativas falharam, retornar erro com mensagem amig√°vel
        android.util.Log.e("GoogleSpeechToTextService", "Todas as tentativas de reconhecimento falharam")
        return@withContext kotlin.Result.failure(
            lastError ?: Exception("N√£o foi poss√≠vel reconhecer o √°udio. Verifique sua conex√£o e tente novamente.")
        )
    }
    
    private suspend fun tryRecognizeSpeech(
        audioFile: File,
        attempt: Int
    ): kotlin.Result<String> = withContext(Dispatchers.IO) {
        try {
            
            // Detectar formato do arquivo e configurar encoding apropriado
            // IMPORTANTE: Google Speech-to-Text API requer encoding espec√≠fico baseado no formato real do arquivo
            val fileName = audioFile.name.lowercase()
            val (encoding, sampleRate) = when {
                fileName.endsWith(".wav") -> Pair("LINEAR16", 16000)
                fileName.endsWith(".flac") -> Pair("FLAC", 16000)
                fileName.endsWith(".m4a") || fileName.endsWith(".aac") -> Pair("MP3", 16000) // M4A/AAC s√£o tratados como MP3
                fileName.endsWith(".mp4") -> Pair("MP3", 16000)
                fileName.endsWith(".ogg") || fileName.endsWith(".opus") -> Pair("OGG_OPUS", 16000)
                fileName.endsWith(".amr") || fileName.endsWith(".3gp") -> Pair("AMR", 8000)
                fileName.endsWith(".amr_wb") -> Pair("AMR_WB", 16000)
                else -> {
                    // Para arquivos desconhecidos, tentar detectar pelo conte√∫do ou usar LINEAR16 como padr√£o
                    android.util.Log.w("GoogleSpeechToTextService", "Formato de arquivo desconhecido: $fileName. Usando LINEAR16 como padr√£o.")
                    Pair("LINEAR16", 16000)
                }
            }
            
            // Ler arquivo de √°udio e converter para base64
            val audioBytes = audioFile.readBytes()
            if (audioBytes.isEmpty()) {
                return@withContext kotlin.Result.failure(Exception("Arquivo de √°udio vazio"))
            }
            
            val audioBase64 = android.util.Base64.encodeToString(audioBytes, android.util.Base64.NO_WRAP)
            
            // Construir request body com serializa√ß√£o expl√≠cita para evitar campos inv√°lidos
            val requestBody = SpeechRecognitionRequest(
                config = RecognitionConfig(
                    encoding = encoding,
                    sampleRateHertz = sampleRate,
                    languageCode = "pt-BR",
                    enableAutomaticPunctuation = true
                ),
                audio = RecognitionAudio(content = audioBase64)
            )
            
            // Serializar JSON com configura√ß√£o expl√≠cita para evitar problemas de serializa√ß√£o
            val jsonBody = try {
                gson.toJson(requestBody)
            } catch (e: Exception) {
                android.util.Log.e("GoogleSpeechToTextService", "Erro ao serializar request body: ${e.message}", e)
                return@withContext kotlin.Result.failure(Exception("Erro ao preparar requisi√ß√£o: ${e.message}"))
            }
            
            // Log do JSON para debug (apenas em desenvolvimento)
            android.util.Log.d("GoogleSpeechToTextService", "JSON Request: $jsonBody")
            
            val request = Request.Builder()
                .url("$baseUrl?key=$apiKey")
                .post(jsonBody.toRequestBody("application/json".toMediaType()))
                .build()
            
            val response = client.newCall(request).execute()
            val responseBody = response.body?.string() ?: return@withContext kotlin.Result.failure(Exception("Resposta vazia da API"))
            
            if (!response.isSuccessful) {
                // Log detalhado do erro para debug
                android.util.Log.e("GoogleSpeechToTextService", "Speech API Error ${response.code}: $responseBody")
                
                // Tentar extrair mensagem de erro mais clara do JSON de resposta
                val errorMessage = try {
                    val errorJson = gson.fromJson(responseBody, Map::class.java) as? Map<*, *>
                    val error = errorJson?.get("error") as? Map<*, *>
                    error?.get("message") as? String ?: responseBody
                } catch (e: Exception) {
                    responseBody
                }
                
                return@withContext kotlin.Result.failure(
                    Exception("Erro ao converter √°udio para texto: Speech API Error: ${response.code} - $errorMessage")
                )
            }
            
            // Parse da resposta usando deserializa√ß√£o manual segura para evitar problemas com classes internas do Google
            val transcript = try {
                // Usar JsonObject para deserializa√ß√£o manual e segura
                val jsonObject = gson.fromJson(responseBody, JsonObject::class.java)
                
                // Extrair transcript de forma segura, ignorando campos desconhecidos
                val resultsArray = jsonObject.getAsJsonArray("results")
                if (resultsArray == null || resultsArray.size() == 0) {
                    android.util.Log.w("GoogleSpeechToTextService", "Nenhum resultado encontrado na resposta. Response: $responseBody")
                    return@withContext kotlin.Result.failure(Exception("Nenhum texto foi reconhecido no √°udio. Tente falar mais claramente."))
                }
                
                val firstResult = resultsArray[0].asJsonObject
                val alternativesArray = firstResult.getAsJsonArray("alternatives")
                
                if (alternativesArray == null || alternativesArray.size() == 0) {
                    android.util.Log.w("GoogleSpeechToTextService", "Nenhuma alternativa encontrada na resposta. Response: $responseBody")
                    return@withContext kotlin.Result.failure(Exception("Nenhum texto foi reconhecido no √°udio. Tente falar mais claramente."))
                }
                
                val firstAlternative = alternativesArray[0].asJsonObject
                val transcriptElement = firstAlternative.get("transcript")
                
                if (transcriptElement == null || transcriptElement.isJsonNull) {
                    android.util.Log.w("GoogleSpeechToTextService", "Transcript vazio na resposta. Response: $responseBody")
                    return@withContext kotlin.Result.failure(Exception("Nenhum texto foi reconhecido no √°udio. Tente falar mais claramente."))
                }
                
                transcriptElement.asString
            } catch (e: JsonSyntaxException) {
                android.util.Log.e("GoogleSpeechToTextService", "Erro de sintaxe JSON ao fazer parse da resposta: ${e.message}", e)
                android.util.Log.e("GoogleSpeechToTextService", "Response body: $responseBody")
                return@withContext kotlin.Result.failure(Exception("Erro ao processar resposta da API: Formato de resposta inv√°lido"))
            } catch (e: IllegalStateException) {
                android.util.Log.e("GoogleSpeechToTextService", "Erro de estado ao fazer parse da resposta: ${e.message}", e)
                android.util.Log.e("GoogleSpeechToTextService", "Response body: $responseBody")
                return@withContext kotlin.Result.failure(Exception("Erro ao processar resposta da API: Estrutura de resposta inesperada"))
            } catch (e: Exception) {
                android.util.Log.e("GoogleSpeechToTextService", "Erro ao fazer parse da resposta: ${e.message}", e)
                android.util.Log.e("GoogleSpeechToTextService", "Response body: $responseBody")
                return@withContext kotlin.Result.failure(Exception("Erro ao processar resposta da API: ${e.message}"))
            }
            
            if (transcript.isBlank()) {
                android.util.Log.w("GoogleSpeechToTextService", "Transcript vazio ap√≥s parse. Response: $responseBody")
                return@withContext kotlin.Result.failure(Exception("Nenhum texto foi reconhecido no √°udio. Tente falar mais claramente."))
            }
            
            android.util.Log.d("GoogleSpeechToTextService", "Transcri√ß√£o bem-sucedida: $transcript")
            kotlin.Result.success(transcript)
        } catch (e: Exception) {
            kotlin.Result.failure(e)
        }
    }
    
    fun createAudioRecord(): AudioRecord? {
        val sampleRate = 16000
        val channelConfig = AudioFormat.CHANNEL_IN_MONO
        val audioFormat = AudioFormat.ENCODING_PCM_16BIT
        val bufferSize = AudioRecord.getMinBufferSize(sampleRate, channelConfig, audioFormat)
        
        return AudioRecord(
            MediaRecorder.AudioSource.MIC,
            sampleRate,
            channelConfig,
            audioFormat,
            bufferSize
        )
    }
}


```

## [FRONTEND]: core/ai/GoogleTranslationService.kt

```kotlin
package com.taskgoapp.taskgo.core.ai

import com.google.gson.Gson
import com.google.gson.annotations.SerializedName
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.RequestBody.Companion.toRequestBody
import javax.inject.Inject
import javax.inject.Singleton

data class TranslationRequest(
    val q: List<String>,
    val target: String,
    val source: String? = null
)

data class TranslationResponse(
    val data: TranslationData?
)

data class TranslationData(
    val translations: List<Translation>?
)

data class Translation(
    val translatedText: String,
    val detectedSourceLanguage: String?
)

@Singleton
class GoogleTranslationService @Inject constructor(
    private val apiKey: String
) {
    private val client = OkHttpClient()
    private val gson = Gson()
    private val baseUrl = "https://translation.googleapis.com/language/translate/v2"
    
    suspend fun translateText(
        text: String,
        targetLanguage: String,
        sourceLanguage: String? = null
    ): kotlin.Result<String> = withContext(Dispatchers.IO) {
        try {
            val requestBody = TranslationRequest(
                q = listOf(text),
                target = targetLanguage,
                source = sourceLanguage
            )
            val jsonBody = gson.toJson(requestBody)
            
            val request = Request.Builder()
                .url("$baseUrl?key=$apiKey")
                .post(jsonBody.toRequestBody("application/json".toMediaType()))
                .build()
            
            val response = client.newCall(request).execute()
            val responseBody = response.body?.string() ?: return@withContext kotlin.Result.failure(Exception("Empty response"))
            
            if (!response.isSuccessful) {
                return@withContext kotlin.Result.failure(Exception("Translation API Error: ${response.code} - $responseBody"))
            }
            
            val translationResponse = gson.fromJson(responseBody, TranslationResponse::class.java)
            val translatedText = translationResponse.data?.translations?.firstOrNull()?.translatedText
                ?: return@withContext kotlin.Result.failure(Exception("No translation text"))
            
            kotlin.Result.success(translatedText)
        } catch (e: Exception) {
            kotlin.Result.failure(e)
        }
    }
    
    suspend fun detectLanguage(text: String): kotlin.Result<String> = withContext(Dispatchers.IO) {
        try {
            val requestBody = TranslationRequest(
                q = listOf(text),
                target = "en" // Target n√£o importa para detec√ß√£o
            )
            val jsonBody = gson.toJson(requestBody)
            
            val request = Request.Builder()
                .url("$baseUrl/detect?key=$apiKey")
                .post(jsonBody.toRequestBody("application/json".toMediaType()))
                .build()
            
            val response = client.newCall(request).execute()
            val responseBody = response.body?.string() ?: return@withContext kotlin.Result.failure(Exception("Empty response"))
            
            if (!response.isSuccessful) {
                return@withContext kotlin.Result.failure(Exception("Language Detection Error: ${response.code}"))
            }
            
            // Parse response para detectar idioma
            val detectedLanguage = "pt" // Simplificado - em produ√ß√£o, parsear JSON completo
            kotlin.Result.success(detectedLanguage)
        } catch (e: Exception) {
            kotlin.Result.failure(e)
        }
    }
}


```

## [FRONTEND]: core/ai/TextToSpeechManager.kt

```kotlin
package com.taskgoapp.taskgo.core.ai

import android.content.Context
import android.os.Build
import android.speech.tts.TextToSpeech
import android.speech.tts.UtteranceProgressListener
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.delay
import kotlinx.coroutines.withContext
import java.util.*
import javax.inject.Inject
import javax.inject.Singleton

data class TTSState(
    val isInitialized: Boolean = false,
    val isSpeaking: Boolean = false,
    val currentText: String? = null
)

@Singleton
class TextToSpeechManager @Inject constructor(
    private val context: Context
) {
    private var tts: TextToSpeech? = null
    private val _state = MutableStateFlow(TTSState())
    val state: StateFlow<TTSState> = _state.asStateFlow()
    
    private val utteranceId = "tts_utterance_${System.currentTimeMillis()}"
    
    /**
     * Inicializa o Text-to-Speech
     */
    suspend fun initialize(): Result<Unit> = withContext(Dispatchers.Main) {
        try {
            tts = TextToSpeech(context) { status ->
                if (status == TextToSpeech.SUCCESS) {
                    val result = tts?.setLanguage(Locale("pt", "BR"))
                    if (result == TextToSpeech.LANG_MISSING_DATA || result == TextToSpeech.LANG_NOT_SUPPORTED) {
                        // Tentar portugu√™s geral se BR n√£o estiver dispon√≠vel
                        tts?.setLanguage(Locale("pt"))
                    }
                    
                    // Configurar velocidade e tom da voz (similar ao ChatGPT)
                    tts?.setSpeechRate(0.95f) // Velocidade ligeiramente mais lenta
                    tts?.setPitch(1.0f) // Tom natural
                    
                    // Configurar listener para acompanhar o progresso
                    tts?.setOnUtteranceProgressListener(object : UtteranceProgressListener() {
                        override fun onStart(utteranceId: String?) {
                            _state.value = _state.value.copy(isSpeaking = true)
                        }
                        
                        override fun onDone(utteranceId: String?) {
                            _state.value = _state.value.copy(isSpeaking = false, currentText = null)
                        }
                        
                        override fun onError(utteranceId: String?) {
                            _state.value = _state.value.copy(isSpeaking = false, currentText = null)
                        }
                    })
                    
                    _state.value = _state.value.copy(isInitialized = true)
                } else {
                    _state.value = _state.value.copy(isInitialized = false)
                }
            }
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    /**
     * Fala um texto
     */
    suspend fun speak(text: String): Result<Unit> = withContext(Dispatchers.Main) {
        try {
            if (!_state.value.isInitialized) {
                initialize()
                // Aguardar um pouco para inicializar
                kotlinx.coroutines.delay(500)
            }
            
            val ttsInstance = tts
            if (ttsInstance == null || !_state.value.isInitialized) {
                return@withContext Result.failure(Exception("TextToSpeech n√£o inicializado"))
            }
            
            // Parar qualquer fala anterior
            stop()
            
            // Adicionar par√¢metros para melhor qualidade (similar ao ChatGPT)
            val params = android.os.Bundle().apply {
                putString(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID, utteranceId)
            }
            
            // Falar o texto
            val result = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                ttsInstance.speak(text, TextToSpeech.QUEUE_FLUSH, params, utteranceId)
            } else {
                @Suppress("DEPRECATION")
                ttsInstance.speak(text, TextToSpeech.QUEUE_FLUSH, null)
                0
            }
            
            if (result == TextToSpeech.ERROR) {
                return@withContext Result.failure(Exception("Erro ao falar texto"))
            }
            
            _state.value = _state.value.copy(currentText = text)
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    /**
     * Para a fala atual
     */
    suspend fun stop() = withContext(Dispatchers.Main) {
        try {
            tts?.stop()
            _state.value = _state.value.copy(isSpeaking = false, currentText = null)
        } catch (e: Exception) {
            // Ignorar erros
        }
    }
    
    /**
     * Libera recursos do TextToSpeech
     */
    fun shutdown() {
        try {
            tts?.stop()
            tts?.shutdown()
            tts = null
            _state.value = TTSState()
        } catch (e: Exception) {
            // Ignorar erros
        }
    }
    
    /**
     * Retorna se est√° falando no momento
     */
    fun isSpeaking(): Boolean = _state.value.isSpeaking
}

```

# Core - billing


## [FRONTEND]: core/billing/BillingManager.kt

```kotlin
package com.taskgoapp.taskgo.core.billing

import android.app.Activity
import android.content.Context
import com.android.billingclient.api.*
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow

class BillingManager(private val context: Context) : PurchasesUpdatedListener, BillingClientStateListener {

    private var billingClient: BillingClient? = null
    private val _purchaseState = MutableStateFlow<PurchaseState>(PurchaseState.Idle)
    val purchaseState: StateFlow<PurchaseState> = _purchaseState.asStateFlow()

    init {
        initializeBillingClient()
    }

    private fun initializeBillingClient() {
        billingClient = BillingClient.newBuilder(context)
            .setListener(this)
            .enablePendingPurchases()
            .build()
        
        billingClient?.startConnection(this)
    }

    override fun onBillingSetupFinished(billingResult: BillingResult) {
        when (billingResult.responseCode) {
            BillingClient.BillingResponseCode.OK -> {
                _purchaseState.value = PurchaseState.Connected
            }
            else -> {
                _purchaseState.value = PurchaseState.Error(billingResult.debugMessage)
            }
        }
    }

    override fun onBillingServiceDisconnected() {
        _purchaseState.value = PurchaseState.Disconnected
        // Tentar reconectar
        billingClient?.startConnection(this)
    }

    override fun onPurchasesUpdated(billingResult: BillingResult, purchases: MutableList<Purchase>?) {
        when (billingResult.responseCode) {
            BillingClient.BillingResponseCode.OK -> {
                purchases?.forEach { purchase ->
                    handlePurchase(purchase)
                }
            }
            BillingClient.BillingResponseCode.USER_CANCELED -> {
                _purchaseState.value = PurchaseState.Cancelled
            }
            else -> {
                _purchaseState.value = PurchaseState.Error(billingResult.debugMessage)
            }
        }
    }

    fun queryProducts(productIds: List<String>, @BillingClient.SkuType type: String) {
        val skuDetailsParams = SkuDetailsParams.newBuilder()
            .setSkusList(productIds)
            .setType(type)
            .build()
        
        billingClient?.querySkuDetailsAsync(skuDetailsParams) { billingResult, skuDetailsList ->
            if (billingResult.responseCode == BillingClient.BillingResponseCode.OK) {
                _purchaseState.value = PurchaseState.ProductsLoaded(skuDetailsList ?: emptyList())
            } else {
                _purchaseState.value = PurchaseState.Error(billingResult.debugMessage)
            }
        }
    }

    fun launchPurchaseFlow(activity: Activity, skuDetails: SkuDetails) {
        val flowParams = BillingFlowParams.newBuilder()
            .setSkuDetails(skuDetails)
            .build()

        val responseCode = billingClient?.launchBillingFlow(activity, flowParams)?.responseCode
        if (responseCode != BillingClient.BillingResponseCode.OK) {
            _purchaseState.value = PurchaseState.Error("Erro ao iniciar compra: $responseCode")
        }
    }

    fun queryPurchases(@BillingClient.SkuType type: String) {
        billingClient?.queryPurchasesAsync(type) { billingResult, purchases ->
            if (billingResult.responseCode == BillingClient.BillingResponseCode.OK) {
                _purchaseState.value = PurchaseState.PurchasesLoaded(purchases)
            } else {
                _purchaseState.value = PurchaseState.Error(billingResult.debugMessage)
            }
        }
    }

    fun acknowledgePurchase(purchase: Purchase) {
        if (purchase.purchaseState == Purchase.PurchaseState.PURCHASED && !purchase.isAcknowledged) {
            val acknowledgeParams = AcknowledgePurchaseParams.newBuilder()
                .setPurchaseToken(purchase.purchaseToken)
                .build()

            billingClient?.acknowledgePurchase(acknowledgeParams) { billingResult ->
                if (billingResult.responseCode == BillingClient.BillingResponseCode.OK) {
                    _purchaseState.value = PurchaseState.PurchaseAcknowledged(purchase)
                } else {
                    _purchaseState.value = PurchaseState.Error(billingResult.debugMessage)
                }
            }
        }
    }

    private fun handlePurchase(purchase: Purchase) {
        if (purchase.purchaseState == Purchase.PurchaseState.PURCHASED) {
            if (!purchase.isAcknowledged) {
                acknowledgePurchase(purchase)
            }
            _purchaseState.value = PurchaseState.PurchaseSuccess(purchase)
        } else if (purchase.purchaseState == Purchase.PurchaseState.PENDING) {
            _purchaseState.value = PurchaseState.PurchasePending(purchase)
        }
    }

    fun release() {
        billingClient?.endConnection()
    }
}

sealed class PurchaseState {
    object Idle : PurchaseState()
    object Connected : PurchaseState()
    object Disconnected : PurchaseState()
    data class ProductsLoaded(val skuDetailsList: List<SkuDetails>) : PurchaseState()
    data class PurchasesLoaded(val purchases: List<Purchase>) : PurchaseState()
    data class PurchaseSuccess(val purchase: Purchase) : PurchaseState()
    data class PurchasePending(val purchase: Purchase) : PurchaseState()
    data class PurchaseAcknowledged(val purchase: Purchase) : PurchaseState()
    data class PurchaseRestored(val purchases: List<Purchase>) : PurchaseState()
    object Cancelled : PurchaseState()
    data class Error(val message: String) : PurchaseState()
}



```

# Core - biometric


## [FRONTEND]: core/biometric/BiometricManager.kt

```kotlin
package com.taskgoapp.taskgo.core.biometric

import android.app.Activity
import android.content.Context
import androidx.biometric.BiometricManager as AndroidBiometricManager
import androidx.biometric.BiometricPrompt
import androidx.core.content.ContextCompat
import androidx.fragment.app.FragmentActivity

class BiometricManager(private val context: Context) {

    fun isBiometricAvailable(): BiometricStatus {
        val biometricManager = AndroidBiometricManager.from(context)
        return when (biometricManager.canAuthenticate(AndroidBiometricManager.Authenticators.BIOMETRIC_STRONG)) {
            AndroidBiometricManager.BIOMETRIC_SUCCESS -> BiometricStatus.AVAILABLE
            AndroidBiometricManager.BIOMETRIC_ERROR_NO_HARDWARE -> BiometricStatus.NO_HARDWARE
            AndroidBiometricManager.BIOMETRIC_ERROR_HW_UNAVAILABLE -> BiometricStatus.HARDWARE_UNAVAILABLE
            AndroidBiometricManager.BIOMETRIC_ERROR_NONE_ENROLLED -> BiometricStatus.NONE_ENROLLED
            else -> BiometricStatus.UNAVAILABLE
        }
    }

    fun authenticate(
        activity: Activity,
        title: String = "Autentica√ß√£o Biom√©trica",
        subtitle: String = "Use sua biometria para continuar",
        negativeButtonText: String = "Cancelar",
        onSuccess: () -> Unit,
        onError: (String) -> Unit,
        onCancel: () -> Unit = {}
    ) {
        val status = isBiometricAvailable()
        if (status != BiometricStatus.AVAILABLE) {
            onError(getStatusMessage(status))
            return
        }

        // Converter Activity para FragmentActivity se necess√°rio
        val fragmentActivity = activity as? FragmentActivity
            ?: run {
                // Se n√£o for FragmentActivity, n√£o podemos usar biometria
                onError("Biometria requer FragmentActivity")
                return
            }

        val executor = ContextCompat.getMainExecutor(activity)

        val promptInfo = BiometricPrompt.PromptInfo.Builder()
            .setTitle(title)
            .setSubtitle(subtitle)
            .setNegativeButtonText(negativeButtonText)
            .setAllowedAuthenticators(AndroidBiometricManager.Authenticators.BIOMETRIC_STRONG)
            .build()

        val biometricPrompt = BiometricPrompt(
            fragmentActivity,
            executor,
            object : BiometricPrompt.AuthenticationCallback() {
                override fun onAuthenticationSucceeded(result: BiometricPrompt.AuthenticationResult) {
                    super.onAuthenticationSucceeded(result)
                    onSuccess()
                }

                override fun onAuthenticationError(errorCode: Int, errString: CharSequence) {
                    super.onAuthenticationError(errorCode, errString)
                    when (errorCode) {
                        BiometricPrompt.ERROR_USER_CANCELED,
                        BiometricPrompt.ERROR_NEGATIVE_BUTTON -> onCancel()
                        else -> onError(errString.toString())
                    }
                }

                override fun onAuthenticationFailed() {
                    super.onAuthenticationFailed()
                    onError("Autentica√ß√£o falhou. Tente novamente.")
                }
            }
        )

        biometricPrompt.authenticate(promptInfo)
    }

    private fun getStatusMessage(status: BiometricStatus): String {
        return when (status) {
            BiometricStatus.NO_HARDWARE -> "Este dispositivo n√£o possui hardware biom√©trico."
            BiometricStatus.HARDWARE_UNAVAILABLE -> "Hardware biom√©trico n√£o est√° dispon√≠vel."
            BiometricStatus.NONE_ENROLLED -> "Nenhuma biometria cadastrada. Configure no dispositivo."
            BiometricStatus.UNAVAILABLE -> "Autentica√ß√£o biom√©trica n√£o dispon√≠vel."
            BiometricStatus.AVAILABLE -> "Dispon√≠vel"
        }
    }
}

enum class BiometricStatus {
    AVAILABLE,
    NO_HARDWARE,
    HARDWARE_UNAVAILABLE,
    NONE_ENROLLED,
    UNAVAILABLE
}


```

# Core - data


## [FRONTEND]: core/data/BrazilianBanks.kt

```kotlin
package com.taskgoapp.taskgo.core.data

/**
 * Lista de bancos brasileiros com c√≥digos COMPE
 * Fonte: Banco Central do Brasil
 */
data class BrazilianBank(
    val code: String,
    val name: String
)

object BrazilianBanks {
    val banks = listOf(
        BrazilianBank("001", "Banco do Brasil S.A."),
        BrazilianBank("003", "Banco da Amaz√¥nia S.A."),
        BrazilianBank("004", "Banco do Nordeste do Brasil S.A."),
        BrazilianBank("007", "Banco Nacional de Desenvolvimento Econ√¥mico e Social"),
        BrazilianBank("010", "Credicoamo Cr√©dito Rural Cooperativa"),
        BrazilianBank("011", "Credit Suisse Hedging-Griffo Corretora de Valores S.A."),
        BrazilianBank("012", "Banco Inbursa S.A."),
        BrazilianBank("014", "Natixis Brasil S.A. Banco M√∫ltiplo"),
        BrazilianBank("015", "UBS Brasil Corretora de C√¢mbio, T√≠tulos e Valores Mobili√°rios S.A."),
        BrazilianBank("016", "Coop de Cr√©d. M√∫ltiplo dos Func. P√∫blicos do Est. do RJ"),
        BrazilianBank("017", "BNY Mellon Banco S.A."),
        BrazilianBank("018", "Banco Tricury S.A."),
        BrazilianBank("021", "Banestes S.A. Banco do Estado do Esp√≠rito Santo"),
        BrazilianBank("024", "Banco Bandepe S.A."),
        BrazilianBank("025", "Banco Alfa S.A."),
        BrazilianBank("029", "Banco Ita√∫ Consignado S.A."),
        BrazilianBank("033", "Banco Santander (Brasil) S.A."),
        BrazilianBank("036", "Banco Bradesco BBI S.A."),
        BrazilianBank("037", "Banco do Estado do Par√° S.A."),
        BrazilianBank("040", "Banco Cargill S.A."),
        BrazilianBank("041", "Banco do Estado do Rio Grande do Sul S.A."),
        BrazilianBank("047", "Banco do Estado de Sergipe S.A."),
        BrazilianBank("060", "Confidence Corretora de C√¢mbio S.A."),
        BrazilianBank("062", "Hipercard Banco M√∫ltiplo S.A."),
        BrazilianBank("063", "Banco Bradescard S.A."),
        BrazilianBank("064", "Goldman Sachs do Brasil Banco M√∫ltiplo S.A."),
        BrazilianBank("065", "Banco AndBank (Brasil) S.A."),
        BrazilianBank("066", "Banco Morgan Stanley S.A."),
        BrazilianBank("069", "Banco Crefisa S.A."),
        BrazilianBank("070", "Banco de Bras√≠lia S.A."),
        BrazilianBank("074", "Banco J. Safra S.A."),
        BrazilianBank("075", "Banco ABN Amro S.A."),
        BrazilianBank("076", "Banco KDB do Brasil S.A."),
        BrazilianBank("077", "Banco Inter S.A."),
        BrazilianBank("078", "Haitong Banco de Investimento do Brasil S.A."),
        BrazilianBank("079", "Banco Original do Agroneg√≥cio S.A."),
        BrazilianBank("080", "BT Corretora de C√¢mbio Ltda."),
        BrazilianBank("081", "BBN Banco Brasileiro de Negocios S.A."),
        BrazilianBank("082", "Banco Topazio S.A."),
        BrazilianBank("083", "Banco da China Brasil S.A."),
        BrazilianBank("084", "Uniprime Norte do Paran√° - Cooperativa de Cr√©dito Ltda."),
        BrazilianBank("085", "Cooperativa Central de Cr√©dito - Ailos"),
        BrazilianBank("089", "Cooperativa de Cr√©dito Rural da Regi√£o de Mogiana"),
        BrazilianBank("091", "Central de Cooperativas de Economia e Cr√©dito M√∫ltiplo"),
        BrazilianBank("092", "BRK S.A. Cr√©dito, Financiamento e Investimento"),
        BrazilianBank("093", "P√≥locred Sociedade de Cr√©dito ao Microempreendedor e √† Empresa de Pequeno Porte"),
        BrazilianBank("094", "Banco Finaxis S.A."),
        BrazilianBank("095", "Banco Confidence de C√¢mbio S.A."),
        BrazilianBank("096", "Banco B3 S.A."),
        BrazilianBank("097", "Cooperativa Central de Cr√©dito do Brasil"),
        BrazilianBank("098", "Credialian√ßa Cooperativa de Cr√©dito Rural"),
        BrazilianBank("099", "Uniprime Central - Central Interestadual de Cooperativas de Cr√©dito Ltda."),
        BrazilianBank("102", "XP Investimentos CCTVM S/A"),
        BrazilianBank("104", "Caixa Econ√¥mica Federal"),
        BrazilianBank("105", "Lecca Cr√©dito, Financiamento e Investimento S/A"),
        BrazilianBank("107", "Banco Bocom BBM S.A."),
        BrazilianBank("108", "PortoCred S.A. Cr√©dito, Financiamento e Investimento"),
        BrazilianBank("111", "Oliveira Trust Distribuidora de T√≠tulos e Valores Mobili√°rios S.A."),
        BrazilianBank("113", "Magliano S.A. Corretora de C√¢mbio e Valores Mobili√°rios"),
        BrazilianBank("114", "Central Cooperativa de Cr√©dito no Estado do Esp√≠rito Santo"),
        BrazilianBank("117", "Advanced Corretora de C√¢mbio Ltda."),
        BrazilianBank("118", "Standard Chartered Bank (Brasil) S.A. Banco de Investimento"),
        BrazilianBank("119", "Banco Western Union do Brasil S.A."),
        BrazilianBank("120", "Banco Rodobens S.A."),
        BrazilianBank("121", "Banco Agibank S.A."),
        BrazilianBank("122", "Banco Bradesco BERJ S.A."),
        BrazilianBank("124", "Banco Woori Bank do Brasil S.A."),
        BrazilianBank("125", "Brasil Plural S.A. Banco M√∫ltiplo"),
        BrazilianBank("126", "BR Partners Banco de Investimento S.A."),
        BrazilianBank("127", "Codepe Corretora de C√¢mbio e Valores Mobili√°rios S.A."),
        BrazilianBank("128", "MS Bank S.A. Banco de C√¢mbio"),
        BrazilianBank("129", "UBS Brasil Banco de Investimento S.A."),
        BrazilianBank("130", "Caruana S.A. Sociedade de Cr√©dito, Financiamento e Investimento"),
        BrazilianBank("131", "Tullett Prebon Brasil Corretora de Valores e C√¢mbio Ltda."),
        BrazilianBank("132", "ICBC do Brasil Banco M√∫ltiplo S.A."),
        BrazilianBank("133", "Confedera√ß√£o Nacional das Cooperativas Centrais de Cr√©dito e Economia Familiar"),
        BrazilianBank("134", "BGC Liquidez Distribuidora de T√≠tulos e Valores Mobili√°rios Ltda."),
        BrazilianBank("136", "Confedera√ß√£o Nacional das Cooperativas Centrais Unicred"),
        BrazilianBank("138", "Get Money Corretora de C√¢mbio S.A."),
        BrazilianBank("139", "Intesa Sanpaolo Brasil S.A. - Banco M√∫ltiplo"),
        BrazilianBank("140", "Easynvest - T√≠tulo Corretora de Valores S.A."),
        BrazilianBank("142", "Broker Brasil Corretora de C√¢mbio Ltda."),
        BrazilianBank("143", "Treviso Corretora de C√¢mbio S.A."),
        BrazilianBank("144", "Bexs Banco de C√¢mbio S.A."),
        BrazilianBank("145", "Levycam - Corretora de C√¢mbio e Valores Mobili√°rios Ltda."),
        BrazilianBank("146", "Guitta Corretora de C√¢mbio Ltda."),
        BrazilianBank("149", "Facta Financeira S.A. - Cr√©dito Financiamento e Investimento"),
        BrazilianBank("157", "ICAP do Brasil Corretora de T√≠tulos e Valores Mobili√°rios Ltda."),
        BrazilianBank("159", "Casa do Cr√©dito S.A. Sociedade de Cr√©dito ao Microempreendedor"),
        BrazilianBank("163", "Commerzbank Brasil S.A. - Banco M√∫ltiplo"),
        BrazilianBank("169", "Banco Ol√© Bonsucesso Consignado S.A."),
        BrazilianBank("173", "BRL Trust Distribuidora de T√≠tulos e Valores Mobili√°rios S.A."),
        BrazilianBank("177", "Guide Investimentos S.A. Corretora de Valores"),
        BrazilianBank("180", "CM Capital Markets Corretora de C√¢mbio, T√≠tulos e Valores Mobili√°rios Ltda."),
        BrazilianBank("182", "Dacasa Financeira S/A - Sociedade de Cr√©dito, Financiamento e Investimento"),
        BrazilianBank("183", "Socred S.A. - Sociedade de Cr√©dito ao Microempreendedor"),
        BrazilianBank("184", "Banco Ita√∫ BBA S.A."),
        BrazilianBank("188", "Ativa Investimentos S.A. Corretora de T√≠tulos C√¢mbio e Valores"),
        BrazilianBank("189", "HS Financeira S/A Cr√©dito, Financiamento e Investimentos"),
        BrazilianBank("190", "Cooperativa de Economia e Cr√©dito M√∫ltiplo dos Servidores P√∫blicos"),
        BrazilianBank("191", "Nova Futura Corretora de T√≠tulos e Valores Mobili√°rios Ltda."),
        BrazilianBank("194", "Parmetal Distribuidora de T√≠tulos e Valores Mobili√°rios Ltda."),
        BrazilianBank("196", "Fair Corretora de C√¢mbio S.A."),
        BrazilianBank("197", "Stone Pagamentos S.A."),
        BrazilianBank("208", "Banco BTG Pactual S.A."),
        BrazilianBank("212", "Banco Original S.A."),
        BrazilianBank("213", "Banco Arbi S.A."),
        BrazilianBank("217", "Banco John Deere S.A."),
        BrazilianBank("218", "Banco BS2 S.A."),
        BrazilianBank("222", "Banco Credit Agr√≠cole Brasil S.A."),
        BrazilianBank("224", "Banco Fibra S.A."),
        BrazilianBank("233", "Banco Cifra S.A."),
        BrazilianBank("237", "Banco Bradesco S.A."),
        BrazilianBank("241", "Banco Cl√°ssico S.A."),
        BrazilianBank("243", "Banco M√°xima S.A."),
        BrazilianBank("246", "Banco ABC Brasil S.A."),
        BrazilianBank("249", "Banco Investcred Unibanco S.A."),
        BrazilianBank("250", "Banco de Cr√©dito e Varejo S.A."),
        BrazilianBank("253", "Bexs Corretora de C√¢mbio S/A"),
        BrazilianBank("254", "Parana Banco S.A."),
        BrazilianBank("260", "Nu Pagamentos S.A."),
        BrazilianBank("265", "Banco Fator S.A."),
        BrazilianBank("266", "Banco C√©dula S.A."),
        BrazilianBank("268", "Barigui Companhia Hipotec√°ria"),
        BrazilianBank("269", "HSBC Brasil S.A. - Banco de Investimento"),
        BrazilianBank("270", "Sagitur Corretora de C√¢mbio Ltda."),
        BrazilianBank("271", "IB Corretora de C√¢mbio, T√≠tulos e Valores Mobili√°rios S.A."),
        BrazilianBank("272", "AGK Corretora de C√¢mbio S.A."),
        BrazilianBank("273", "Cooperativa de Cr√©dito Rural de S√£o Miguel do Oeste - Sulcredi/S√£o Miguel"),
        BrazilianBank("274", "Money Plus Sociedade de Cr√©dito ao Microempreendedor e a Empresa de Pequeno Porte Ltda."),
        BrazilianBank("276", "Senff S.A. - Cr√©dito, Financiamento e Investimento"),
        BrazilianBank("278", "Genial Investimentos Corretora de Valores Mobili√°rios S.A."),
        BrazilianBank("279", "Cooperativa de Cr√©dito Rural de Primavera do Leste"),
        BrazilianBank("280", "Avista S.A. Cr√©dito, Financiamento e Investimento"),
        BrazilianBank("281", "Cooperativa de Cr√©dito Rural Coopavel"),
        BrazilianBank("283", "RB Capital Investimentos Distribuidora de T√≠tulos e Valores Mobili√°rios Ltda."),
        BrazilianBank("285", "Frente Corretora de C√¢mbio Ltda."),
        BrazilianBank("286", "Cooperativa de Cr√©dito Rural de Ouro Sulcredi Ouro"),
        BrazilianBank("288", "Carol Distribuidora de T√≠tulos e Valores Mobili√°rios Ltda."),
        BrazilianBank("289", "Decoradora de Cr√©dito Ltda. - Sociedade de Cr√©dito ao Microempreendedor"),
        BrazilianBank("290", "Paganet Ltda."),
        BrazilianBank("291", "PagSeguro Internet S.A."),
        BrazilianBank("292", "BS2 Distribuidora de T√≠tulos e Valores Mobili√°rios S.A."),
        BrazilianBank("293", "Lastro RDV Distribuidora de T√≠tulos e Valores Mobili√°rios Ltda."),
        BrazilianBank("296", "Vip's Corretora de C√¢mbio Ltda."),
        BrazilianBank("298", "Vortx Distribuidora de T√≠tulos e Valores Mobili√°rios Ltda."),
        BrazilianBank("299", "Soran Sociedade de Cr√©dito, Financiamento e Investimento"),
        BrazilianBank("300", "Banco de la Nacion Argentina"),
        BrazilianBank("301", "BPP Institui√ß√£o de Pagamento S.A."),
        BrazilianBank("307", "Terra Investimentos Distribuidora de T√≠tulos e Valores Mobili√°rios Ltda."),
        BrazilianBank("309", "CAMBIONET Corretora de C√¢mbio Ltda."),
        BrazilianBank("310", "VORTX Distribuidora de T√≠tulos e Valores Mobili√°rios Ltda."),
        BrazilianBank("311", "DOURADA CORRETORA DE C√ÇMBIO LTDA."),
        BrazilianBank("312", "HSCM - Sociedade de Cr√©dito ao Microempreendedor e √† Empresa de Pequeno Porte Ltda."),
        BrazilianBank("313", "AMAZ√îNIA CORRETORA DE C√ÇMBIO LTDA."),
        BrazilianBank("315", "PI Distribuidora de T√≠tulos e Valores Mobili√°rios S.A."),
        BrazilianBank("318", "Banco BMG S.A."),
        BrazilianBank("319", "OM Distribuidora de T√≠tulos e Valores Mobili√°rios Ltda."),
        BrazilianBank("320", "China Construction Bank (Brasil) Banco M√∫ltiplo S.A."),
        BrazilianBank("321", "CREFAZ Sociedade de Cr√©dito ao Microempreendedor Eireli"),
        BrazilianBank("322", "Cooperativa de Cr√©dito Rural de Abelardo Luz - Sulcredi/Crediluz"),
        BrazilianBank("323", "MERCADO PAGO INSTITUI√á√ÉO DE PAGAMENTO LTDA."),
        BrazilianBank("324", "CARTOS SOCIEDADE DE CR√âDITO DIRETO S.A."),
        BrazilianBank("325", "√ìTIMO SOCIEDADE DE CR√âDITO DIRETO S.A."),
        BrazilianBank("326", "PARATI - CR√âDITO, FINANCIAMENTO E INVESTIMENTO S.A."),
        BrazilianBank("329", "QI Sociedade de Cr√©dito Direto S.A."),
        BrazilianBank("330", "BANCO BARI DE INVESTIMENTOS E FINANCIAMENTOS S.A."),
        BrazilianBank("331", "FRAM CAPITAL DISTRIBUIDORA DE T√çTULOS E VALORES MOBILI√ÅRIOS S.A."),
        BrazilianBank("332", "ACESSO SOLU√á√ïES DE PAGAMENTO S.A. - INSTITUI√á√ÉO DE PAGAMENTO"),
        BrazilianBank("335", "Banco Digio S.A."),
        BrazilianBank("336", "BANCO C6 S.A."),
        BrazilianBank("340", "Super Pagamentos e Administra√ß√£o de Meios Eletr√¥nicos S.A."),
        BrazilianBank("341", "Ita√∫ Unibanco S.A."),
        BrazilianBank("342", "Creditas Sociedade de Cr√©dito Direto S.A."),
        BrazilianBank("343", "FFA SOCIEDADE DE CR√âDITO AO MICROEMPREENDEDOR E √Ä EMPRESA DE PEQUENO PORTE LTDA."),
        BrazilianBank("348", "Banco XP S.A."),
        BrazilianBank("349", "AL5 S.A. CR√âDITO, FINANCIAMENTO E INVESTIMENTO"),
        BrazilianBank("350", "COOPERATIVA DE CR√âDITO RURAL DE PEQUENOS AGRICULTORES E DA REFORMA AGR√ÅRIA DO CE"),
        BrazilianBank("352", "TORO CORRETORA DE T√çTULOS E VALORES MOBILI√ÅRIOS LTDA"),
        BrazilianBank("354", "NECTON INVESTIMENTOS S.A. CORRETORA DE VALORES MOBILI√ÅRIOS E COMMODITIES"),
        BrazilianBank("355", "√ìTIMO SOCIEDADE DE CR√âDITO DIRETO S.A."),
        BrazilianBank("358", "ZEMA CR√âDITO, FINANCIAMENTO E INVESTIMENTO S/A"),
        BrazilianBank("359", "ZIPDIN SOLU√á√ïES DIGITAIS SOCIEDADE DE CR√âDITO DIRETO S/A"),
        BrazilianBank("360", "TRINUS CAPITAL DISTRIBUIDORA DE T√çTULOS E VALORES MOBILI√ÅRIOS S.A."),
        BrazilianBank("362", "CIELO S.A. - INSTITUI√á√ÉO DE PAGAMENTO"),
        BrazilianBank("363", "SINGULARE CORRETORA DE T√çTULOS E VALORES MOBILI√ÅRIOS S.A."),
        BrazilianBank("364", "GERENCIANET PAGTOS BRASIL LTDA."),
        BrazilianBank("365", "SOLIDUS S.A. CORRETORA DE CAMBIO E VALORES MOBILIARIOS"),
        BrazilianBank("366", "BANCO SOCIETE GENERALE BRASIL S.A."),
        BrazilianBank("367", "VITREO DISTRIBUIDORA DE T√çTULOS E VALORES MOBILI√ÅRIOS S.A."),
        BrazilianBank("368", "BANCO MERCANTIL DO BRASIL S.A."),
        BrazilianBank("370", "BANCO MIZUHO S.A."),
        BrazilianBank("371", "WARREN CORRETORA DE VALORES MOBILI√ÅRIOS E C√ÇMBIO LTDA."),
        BrazilianBank("373", "UP.P SOCIEDADE DE EMPR√âSTIMO ENTRE PESSOAS S.A."),
        BrazilianBank("374", "REALIZE CR√âDITO, FINANCIAMENTO E INVESTIMENTO S.A."),
        BrazilianBank("376", "BANCO J.P. MORGAN S.A."),
        BrazilianBank("377", "MS SOCIEDADE DE CR√âDITO AO MICROEMPREENDEDOR E √Ä EMPRESA DE PEQUENO PORTE LTDA."),
        BrazilianBank("378", "BANCO BRASILEIRO DE CR√âDITO S.A."),
        BrazilianBank("379", "COOPERFORTE - COOPERATIVA DE ECONOMIA E CR√âDITO M√öLTIPLO DOS SERVIDORES DA UNI√ÉO"),
        BrazilianBank("380", "PICPAY INSTITUI√á√ÉO DE PAGAMENTO S.A."),
        BrazilianBank("381", "BANCO MERCEDES-BENZ DO BRASIL S.A."),
        BrazilianBank("382", "SUMUP SOCIEDADE DE CR√âDITO DIRETO S.A."),
        BrazilianBank("383", "BOLETOBANC√ÅRIO.COM TECNOLOGIA DE PAGAMENTOS LTDA."),
        BrazilianBank("384", "GLOBAL FINAN√áAS SOCIEDADE DE CR√âDITO AO MICROEMPREENDEDOR E √Ä EMPRESA DE PEQUENO PORTE LTDA."),
        BrazilianBank("385", "BANCO KEB HANA DO BRASIL S.A."),
        BrazilianBank("386", "BANCO TOP√ÅZIO S.A."),
        BrazilianBank("387", "BANCO TOYOTA DO BRASIL S.A."),
        BrazilianBank("388", "BANCO MERCANTIL DO BRASIL S.A."),
        BrazilianBank("389", "BANCO MERCANTIL DO BRASIL S.A."),
        BrazilianBank("390", "BANCO GM S.A."),
        BrazilianBank("391", "COOPERATIVA DE CREDITO RURAL DE IBIAM - SULCREDI/IBIAM"),
        BrazilianBank("393", "Banco Volkswagen S.A."),
        BrazilianBank("394", "Banco Bradesco Financiamentos S.A."),
        BrazilianBank("395", "BANCO VOLVO BRASIL S.A."),
        BrazilianBank("396", "BANCO CAPITAL S.A."),
        BrazilianBank("397", "LISTO SOCIEDADE DE CREDITO DIRETO S.A."),
        BrazilianBank("398", "IDEAL CORRETORA DE T√çTULOS E VALORES MOBILI√ÅRIOS S.A."),
        BrazilianBank("399", "Kirton Bank S.A. - Banco M√∫ltiplo"),
        BrazilianBank("400", "COOPERATIVA DE CR√âDITO, POUPAN√áA E SERVI√áOS FINANCEIROS DO CENTRO OESTE - CREDITOCRE"),
        BrazilianBank("401", "IUGU INSTITUI√á√ÉO DE PAGAMENTO S.A."),
        BrazilianBank("402", "COBUCCIO S.A. - SOCIEDADE DE CR√âDITO, FINANCIAMENTO E INVESTIMENTOS"),
        BrazilianBank("403", "CORA SOCIEDADE DE CR√âDITO DIRETO S.A."),
        BrazilianBank("404", "SUMUP SOCIEDADE DE CR√âDITO DIRETO S.A."),
        BrazilianBank("406", "ACCREDITO - SOCIEDADE DE CR√âDITO DIRETO S.A."),
        BrazilianBank("407", "√çNDIGO INVESTIMENTOS DISTRIBUIDORA DE T√çTULOS E VALORES MOBILI√ÅRIOS LTDA."),
        BrazilianBank("408", "BONUSPAGO SOCIEDADE DE CR√âDITO DIRETO S.A."),
        BrazilianBank("410", "PLANNER SOCIEDADE DE CR√âDITO DIRETO S.A."),
        BrazilianBank("411", "Via Certa Financiadora S.A. - Cr√©dito, Financiamento e Investimento"),
        BrazilianBank("412", "SOCIAL BANK BANCO M√öLTIPLO S.A."),
        BrazilianBank("413", "BANCO BV S.A."),
        BrazilianBank("414", "BANCO INTERCAP S.A."),
        BrazilianBank("415", "BANCO COOPERATIVO DO BRASIL S.A. - BANCOOB"),
        BrazilianBank("416", "BANCO SAFRA S.A."),
        BrazilianBank("417", "BANCO CETELEM S.A."),
        BrazilianBank("418", "ZIPDIN SOLU√á√ïES DIGITAIS SOCIEDADE DE CR√âDITO DIRETO S/A"),
        BrazilianBank("419", "NUMBRS SOCIEDADE DE CR√âDITO DIRETO S.A."),
        BrazilianBank("420", "LARIOS SOCIEDADE DE CR√âDITO DIRETO S.A."),
        BrazilianBank("421", "LEND SOCIEDADE DE CR√âDITO DIRETO S.A."),
        BrazilianBank("422", "BANCO VOITER S.A."),
        BrazilianBank("423", "COLUNA S.A. DISTRIBUIDORA DE T√çTULOS E VALORES MOBILI√ÅRIOS"),
        BrazilianBank("424", "BANCO CSF S.A."),
        BrazilianBank("425", "SOCIAL BANK BANCO M√öLTIPLO S.A."),
        BrazilianBank("426", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("427", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("428", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("429", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("430", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("431", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("432", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("433", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("434", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("435", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("436", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("437", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("438", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("439", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("440", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("441", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("442", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("443", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("444", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("445", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("446", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("447", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("448", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("449", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("450", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("451", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("452", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("453", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("454", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("455", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("456", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("457", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("458", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("459", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("460", "BANCO MUFG BRASIL S.A."),
        BrazilianBank("461", "BANCO SUMITOMO MITSUI BRASILEIRO S.A."),
        BrazilianBank("462", "STARK SOCIEDADE DE CR√âDITO DIRETO S.A."),
        BrazilianBank("463", "AZUMI DISTRIBUIDORA DE T√çTULOS E VALORES MOBILI√ÅRIOS LTDA."),
        BrazilianBank("464", "BANCO CASA DO CR√âDITO S.A."),
        BrazilianBank("465", "CAPITAL CONSIG SOCIEDADE DE CR√âDITO DIRETO S.A."),
        BrazilianBank("466", "PORTOCRED S.A. - CREDITO FINANCIAMENTO E INVESTIMENTO"),
        BrazilianBank("467", "MASTER S/A CORRETORA DE C√ÇMBIO T√çTULOS E VALORES MOBILI√ÅRIOS"),
        BrazilianBank("468", "PORTOSEG S.A. - CREDITO FINANCIAMENTO E INVESTIMENTO"),
        BrazilianBank("469", "BANCO BS2 S.A."),
        BrazilianBank("470", "COOP DE CREDITO RURAL DE PRIMAVERA DO LESTE - SULCREDI/PRIMAVERA"),
        BrazilianBank("471", "BANCO JBS S.A."),
        BrazilianBank("472", "Girotech Tecnologia S.A. Sociedade de Cr√©dito Direto"),
        BrazilianBank("473", "Banco Caixa Geral - Brasil S.A."),
        BrazilianBank("474", "BANCO SAFRA S.A."),
        BrazilianBank("475", "BANCO YAMAHA MOTOR DO BRASIL S.A."),
        BrazilianBank("476", "BANCO SENFF S.A."),
        BrazilianBank("477", "CITIBANK N.A."),
        BrazilianBank("478", "GAZINCRED S.A. SOCIEDADE DE CR√âDITO, FINANCIAMENTO E INVESTIMENTO"),
        BrazilianBank("479", "BANCO ITAU BANK S.A."),
        BrazilianBank("487", "DEUTSCHE BANK S.A. - BANCO ALEMAO"),
        BrazilianBank("488", "JPMORGAN CHASE BANK, NATIONAL ASSOCIATION"),
        BrazilianBank("489", "ING BANK N.V."),
        BrazilianBank("492", "BANCO FINAXIS"),
        BrazilianBank("493", "BANCO VOLVO BRASIL S.A."),
        BrazilianBank("494", "BANCO DE LA REPUBLICA ORIENTAL DEL URUGUAY"),
        BrazilianBank("495", "BANCO DE LA PROVINCIA DE BUENOS AIRES"),
        BrazilianBank("496", "BANCO DIGITAL FORTALEZA S.A."),
        BrazilianBank("497", "BANCO C6 S.A."),
        BrazilianBank("498", "BANCO BRADESCARD S.A."),
        BrazilianBank("499", "BANCO DIGIO S.A."),
        BrazilianBank("500", "BANCO ITA√ö S.A."),
        BrazilianBank("501", "BANCO BRADESCO S.A."),
        BrazilianBank("502", "BANCO SANTANDER (BRASIL) S.A."),
        BrazilianBank("505", "BANCO CREDIT SUISSE (BRASIL) S.A."),
        BrazilianBank("600", "BANCO LUSO BRASILEIRO S.A."),
        BrazilianBank("604", "BANCO INDUSTRIAL DO BRASIL S.A."),
        BrazilianBank("610", "BANCO VR S.A."),
        BrazilianBank("611", "BANCO PAULISTA S.A."),
        BrazilianBank("612", "BANCO GUANABARA S.A."),
        BrazilianBank("613", "BANCO PECUNIA S.A."),
        BrazilianBank("623", "BANCO PAN S.A."),
        BrazilianBank("626", "BANCO FICSA S.A."),
        BrazilianBank("630", "BANCO LETSBANK S.A."),
        BrazilianBank("633", "BANCO RENDIMENTO S.A."),
        BrazilianBank("634", "BANCO TRIANGULO S.A."),
        BrazilianBank("637", "BANCO SOFISA S.A."),
        BrazilianBank("638", "BANCO PROSPER S.A."),
        BrazilianBank("641", "BANCO ALVORADA S.A."),
        BrazilianBank("643", "BANCO PINE S.A."),
        BrazilianBank("652", "ITA√ö UNIBANCO HOLDING S.A."),
        BrazilianBank("653", "BANCO VOITER S.A."),
        BrazilianBank("654", "BANCO DIGITAL FORTALEZA S.A."),
        BrazilianBank("655", "NEON PAGAMENTOS S.A. - INSTITUI√á√ÉO DE PAGAMENTO"),
        BrazilianBank("707", "BANCO DAYCOVAL S.A."),
        BrazilianBank("712", "BANCO OURINVEST S.A."),
        BrazilianBank("719", "BANIF - BANCO INTERNACIONAL DO FUNCHAL (BRASIL) S.A."),
        BrazilianBank("735", "BANCO POTTENCIAL S.A."),
        BrazilianBank("739", "BANCO CETELEM S.A."),
        BrazilianBank("741", "BANCO RIBEIRAO PRETO S.A."),
        BrazilianBank("743", "BANCO SEMEAR S.A."),
        BrazilianBank("745", "BANCO CITIBANK S.A."),
        BrazilianBank("746", "BANCO MODAL S.A."),
        BrazilianBank("747", "BANCO RABOBANK INTERNATIONAL BRASIL S.A."),
        BrazilianBank("748", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("751", "SCOTIABANK BRASIL S.A. BANCO M√öLTIPLO"),
        BrazilianBank("752", "BANCO BNP PARIBAS BRASIL S.A."),
        BrazilianBank("753", "NOVO BANCO CONTINENTAL S.A. - BANCO M√öLTIPLO"),
        BrazilianBank("754", "BANCO SISTEMA S.A."),
        BrazilianBank("755", "BANCO MERCADANTIL DO BRASIL S.A."),
        BrazilianBank("756", "BANCO COOPERATIVO DO BRASIL S.A. - BANCOOB"),
        BrazilianBank("757", "BANCO KEB HANA DO BRASIL S.A."),
        BrazilianBank("758", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("759", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("760", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("761", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("762", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("763", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("764", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("765", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("766", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("767", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("768", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("769", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("770", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("771", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("772", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("773", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("774", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("775", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("776", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("777", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("778", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("779", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("780", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("781", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("782", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("783", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("784", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("785", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("786", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("787", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("788", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("789", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("790", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("791", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("792", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("793", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("794", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("795", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("796", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("797", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("798", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("799", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("801", "BANCO SEGURO S.A."),
        BrazilianBank("802", "BANCO TOP√ÅZIO S.A."),
        BrazilianBank("803", "BANCO DA CHINA BRASIL S.A."),
        BrazilianBank("806", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("807", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("808", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("809", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("810", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("811", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("812", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("813", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("814", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("815", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("816", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("817", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("818", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("819", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("820", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("821", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("822", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("823", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("824", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("825", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("826", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("827", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("828", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("829", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("830", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("831", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("832", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("833", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("834", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("835", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("836", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("837", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("838", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("839", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("840", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("841", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("842", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("843", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("844", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("845", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("846", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("847", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("848", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("849", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("850", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("851", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("852", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("853", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("854", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("855", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("856", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("857", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("858", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("859", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("860", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("861", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("862", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("863", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("864", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("865", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("866", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("867", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("868", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("869", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("870", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("871", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("872", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("873", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("874", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("875", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("876", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("877", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("878", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("879", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("880", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("881", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("882", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("883", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("884", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("885", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("886", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("887", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("888", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("889", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("890", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("891", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("892", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("893", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("894", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("895", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("896", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("897", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("898", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("899", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("900", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("901", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("902", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("903", "BANCO COOPERATIVO SICREDI SICREDI S.A."),
        BrazilianBank("904", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("905", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("906", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("907", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("908", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("909", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("910", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("911", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("912", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("913", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("914", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("915", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("916", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("917", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("918", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("919", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("920", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("921", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("922", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("923", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("924", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("925", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("926", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("927", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("928", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("929", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("930", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("931", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("932", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("933", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("934", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("935", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("936", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("937", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("938", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("939", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("940", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("941", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("942", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("943", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("944", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("945", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("946", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("947", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("948", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("949", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("950", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("951", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("952", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("953", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("954", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("955", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("956", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("957", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("958", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("959", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("960", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("961", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("962", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("963", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("964", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("965", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("966", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("967", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("968", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("969", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("970", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("971", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("972", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("973", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("974", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("975", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("976", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("977", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("978", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("979", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("980", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("981", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("982", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("983", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("984", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("985", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("986", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("987", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("988", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("989", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("990", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("991", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("992", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("993", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("994", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("995", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("996", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("997", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("998", "BANCO COOPERATIVO SICREDI S.A."),
        BrazilianBank("999", "BANCO COOPERATIVO SICREDI S.A.")
    )
    
    fun getBankByCode(code: String): BrazilianBank? {
        return banks.find { it.code == code }
    }
    
    fun getBankByName(name: String): BrazilianBank? {
        return banks.find { it.name.equals(name, ignoreCase = true) }
    }
    
    fun searchBanks(query: String): List<BrazilianBank> {
        val lowercaseQuery = query.lowercase()
        return banks.filter {
            it.name.lowercase().contains(lowercaseQuery) ||
            it.code.contains(query)
        }
    }
}


```

## [FRONTEND]: core/data/BrazilianCities.kt

```kotlin
package com.taskgoapp.taskgo.core.data

/**
 * Lista de estados brasileiros e suas cidades
 * Fonte: IBGE
 */
object BrazilianCities {
    val statesWithCities = mapOf(
        "AC" to listOf("Rio Branco", "Cruzeiro do Sul", "Sena Madureira", "Tarauac√°", "Feij√≥"),
        "AL" to listOf("Macei√≥", "Arapiraca", "Palmeira dos √çndios", "Rio Largo", "Penedo"),
        "AP" to listOf("Macap√°", "Santana", "Laranjal do Jari", "Oiapoque", "Mazag√£o"),
        "AM" to listOf("Manaus", "Parintins", "Itacoatiara", "Manacapuru", "Coari"),
        "BA" to listOf("Salvador", "Feira de Santana", "Vit√≥ria da Conquista", "Cama√ßari", "Juazeiro"),
        "CE" to listOf("Fortaleza", "Caucaia", "Juazeiro do Norte", "Maracana√∫", "Sobral"),
        "DF" to listOf("Bras√≠lia"),
        "ES" to listOf("Vit√≥ria", "Vila Velha", "Cariacica", "Serra", "Cachoeiro de Itapemirim"),
        "GO" to listOf("Goi√¢nia", "Aparecida de Goi√¢nia", "An√°polis", "Rio Verde", "Luzi√¢nia"),
        "MA" to listOf("S√£o Lu√≠s", "Imperatriz", "Caxias", "Timon", "Cod√≥"),
        "MT" to listOf("Cuiab√°", "V√°rzea Grande", "Rondon√≥polis", "Sinop", "Tangar√° da Serra"),
        "MS" to listOf("Campo Grande", "Dourados", "Tr√™s Lagoas", "Corumb√°", "Ponta Por√£"),
        "MG" to listOf("Belo Horizonte", "Uberl√¢ndia", "Contagem", "Juiz de Fora", "Betim"),
        "PA" to listOf("Bel√©m", "Ananindeua", "Marituba", "Paragominas", "Castanhal"),
        "PB" to listOf("Jo√£o Pessoa", "Campina Grande", "Santa Rita", "Patos", "Bayeux"),
        "PR" to listOf("Curitiba", "Londrina", "Maring√°", "Ponta Grossa", "Cascavel"),
        "PE" to listOf("Recife", "Jaboat√£o dos Guararapes", "Olinda", "Caruaru", "Petrolina"),
        "PI" to listOf("Teresina", "Parna√≠ba", "Picos", "Piripiri", "Campo Maior"),
        "RJ" to listOf("Rio de Janeiro", "S√£o Gon√ßalo", "Duque de Caxias", "Nova Igua√ßu", "Niter√≥i"),
        "RN" to listOf("Natal", "Mossor√≥", "Parnamirim", "S√£o Gon√ßalo do Amarante", "Maca√≠ba"),
        "RS" to listOf("Porto Alegre", "Caxias do Sul", "Pelotas", "Canoas", "Santa Maria"),
        "RO" to listOf("Porto Velho", "Ji-Paran√°", "Ariquemes", "Vilhena", "Cacoal"),
        "RR" to listOf("Boa Vista", "Rorain√≥polis", "Caracara√≠", "Alto Alegre", "Mucaja√≠"),
        "SC" to listOf("Florian√≥polis", "Joinville", "Blumenau", "S√£o Jos√©", "Crici√∫ma"),
        "SP" to listOf("S√£o Paulo", "Guarulhos", "Campinas", "S√£o Bernardo do Campo", "Santo Andr√©"),
        "SE" to listOf("Aracaju", "Nossa Senhora do Socorro", "Lagarto", "Itabaiana", "S√£o Crist√≥v√£o"),
        "TO" to listOf("Palmas", "Aragua√≠na", "Gurupi", "Porto Nacional", "Para√≠so do Tocantins")
    )
    
    val allStates = statesWithCities.keys.sorted()
    
    fun getCitiesForState(state: String): List<String> {
        return statesWithCities[state]?.sorted() ?: emptyList()
    }
}


```

## [FRONTEND]: core/data/models/Models.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.core.data.models

import java.time.LocalDateTime

// User Models
data class User(
    val id: Long,
    val name: String,
    val email: String,
    val phone: String,
    val accountType: AccountType,
    val timeOnTaskGo: String, // ex: "2 anos"
    val rating: Double,
    val reviewCount: Int,
    val city: String,
    val avatarUrl: String? = null
)

enum class AccountType {
    PROVIDER, SELLER, CLIENT
}

// Service Models
data class ServiceCategory(
    val id: Long,
    val name: String,
    val icon: String,
    val description: String
)

data class Provider(
    val id: Long,
    val name: String,
    val profession: String,
    val rating: Double,
    val reviewCount: Int,
    val serviceCount: String, // ex: "100+ servi√ßos"
    val avatarUrl: String? = null,
    val city: String
)

data class Service(
    val id: Long,
    val title: String,
    val description: String,
    val category: ServiceCategory,
    val provider: Provider,
    val price: Double,
    val location: String,
    val createdAt: LocalDateTime
)

data class WorkOrder(
    val id: Long,
    val category: ServiceCategory,
    val description: String,
    val date: LocalDateTime,
    val address: String,
    val city: String,
    val state: String,
    val status: WorkOrderStatus,
    val createdAt: LocalDateTime
)

enum class WorkOrderStatus {
    OPEN, IN_PROGRESS, COMPLETED, CANCELLED
}

data class Proposal(
    val id: Long,
    val workOrderId: Long,
    val provider: Provider,
    val title: String,
    val description: String,
    val price: Double,
    val date: LocalDateTime,
    val location: String,
    val status: ProposalStatus
)

enum class ProposalStatus {
    PENDING, ACCEPTED, REJECTED
}

data class Review(
    val id: Long,
    val rating: Double,
    val comment: String,
    val date: LocalDateTime,
    val reviewer: User,
    val provider: Provider
)

// Product Models
data class Product(
    val id: Long,
    val name: String,
    val description: String,
    val price: Double,
    val seller: User? = null,
    val imageUrl: String? = null,
    val category: String,
    val inStock: Boolean = true
)

data class CartItem(
    val id: Long,
    val product: Product,
    val quantity: Int
)

data class Order(
    val id: Long,
    val items: List<CartItem>,
    val total: Double,
    val shipping: Double,
    val status: OrderStatus,
    val trackingCode: String? = null,
    val createdAt: LocalDateTime,
    val estimatedDelivery: LocalDateTime? = null
)

enum class OrderStatus {
    PENDING, CONFIRMED, SHIPPED, IN_TRANSIT, OUT_FOR_DELIVERY, DELIVERED, CANCELLED
}

data class TrackingEvent(
    val id: Long,
    val orderId: Long,
    val status: OrderStatus,
    val description: String,
    val date: LocalDateTime,
    val location: String? = null
)

// Payment Models
data class PaymentMethod(
    val id: Long,
    val type: PaymentType,
    val lastFourDigits: String,
    val cardholderName: String,
    val expiryDate: String,
    val isDefault: Boolean = false
)

enum class PaymentType {
    CREDIT_CARD, DEBIT_CARD, PIX
}

data class Address(
    val id: Long,
    val name: String,
    val phone: String,
    val cep: String,
    val street: String,
    val neighborhood: String,
    val city: String,
    val state: String,
    val isDefault: Boolean = false
)

// Message Models
data class MessageThread(
    val id: Long,
    val title: String,
    val preview: String,
    val lastMessageTime: LocalDateTime,
    val unreadCount: Int = 0,
    val participants: List<User>
)

data class ChatMessage(
    val id: Long,
    val threadId: Long,
    val sender: User,
    val content: String,
    val timestamp: LocalDateTime,
    val isMine: Boolean
)

// Notification Models
data class NotificationItem(
    val id: Long,
    val type: NotificationType,
    val title: String,
    val message: String,
    val date: LocalDateTime,
    val isRead: Boolean = false,
    val actionRoute: String? = null
)

enum class NotificationType {
    ORDER_SHIPPED, PROPOSAL_APPROVED, NEW_MESSAGE, UPDATE_AVAILABLE, ORDER_PUBLISHED
}

// Plan Models
data class Plan(
    val id: Long,
    val name: String,
    val price: Double,
    val description: String,
    val features: List<String>
)

// Banner/Ads Models
data class Banner(
    val id: Long,
    val title: String,
    val description: String,
    val price: Double,
    val duration: String, // ex: "R$50/dia"
    val type: BannerType
)

enum class BannerType {
    SMALL, LARGE
}

```

## [FRONTEND]: core/data/models/OrderDto.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.core.data.models

import kotlinx.serialization.Serializable
import java.time.Instant

@Serializable
data class OrderDto(
    val id: Long,
    val items: List<OrderItemDto>,
    val total: Double,
    val status: String,
    val createdAt: String // ISO string
)

@Serializable
data class OrderItemDto(
    val productId: Long,
    val quantity: Int,
    val price: Double
)

@Serializable
data class OrdersResponse(
    val items: List<OrderDto>
)


```

## [FRONTEND]: core/data/PreferencesManager.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.core.data

import android.content.Context
import android.content.SharedPreferences

class PreferencesManager(context: Context) {
    private val prefs: SharedPreferences = context.getSharedPreferences("taskgo_prefs", Context.MODE_PRIVATE)

    // User Profile Data
    fun saveUserName(name: String) = prefs.edit().putString("user_name", name).apply()
    fun getUserName(): String = prefs.getString("user_name", "") ?: ""
    
    fun saveUserEmail(email: String) = prefs.edit().putString("user_email", email).apply()
    fun getUserEmail(): String = prefs.getString("user_email", "") ?: ""
    
    fun saveUserPhone(phone: String) = prefs.edit().putString("user_phone", phone).apply()
    fun getUserPhone(): String = prefs.getString("user_phone", "") ?: ""
    
    fun saveUserCpf(cpf: String) = prefs.edit().putString("user_cpf", cpf).apply()
    fun getUserCpf(): String = prefs.getString("user_cpf", "") ?: ""
    
    fun saveUserProfession(profession: String) = prefs.edit().putString("user_profession", profession).apply()
    fun getUserProfession(): String = prefs.getString("user_profession", "") ?: ""
    
    fun saveUserAvatarUri(avatarUri: String) = prefs.edit().putString("user_avatar_uri", avatarUri).apply()
    fun getUserAvatarUri(): String? = prefs.getString("user_avatar_uri", null)

    // Product Data
    fun saveProductName(name: String) = prefs.edit().putString("product_name", name).apply()
    fun getProductName(): String = prefs.getString("product_name", "") ?: ""
    
    fun saveProductDescription(description: String) = prefs.edit().putString("product_description", description).apply()
    fun getProductDescription(): String = prefs.getString("product_description", "") ?: ""
    
    fun saveProductPrice(price: String) = prefs.edit().putString("product_price", price).apply()
    fun getProductPrice(): String = prefs.getString("product_price", "") ?: ""
    
    fun saveProductCategory(category: String) = prefs.edit().putString("product_category", category).apply()
    fun getProductCategory(): String = prefs.getString("product_category", "") ?: ""
    
    fun saveProductAddress(address: String) = prefs.edit().putString("product_address", address).apply()
    fun getProductAddress(): String = prefs.getString("product_address", "") ?: ""
    
    fun saveProductImages(images: List<String>) = prefs.edit().putStringSet("product_images", images.toSet()).apply()
    fun getProductImages(): List<String> = prefs.getStringSet("product_images", emptySet())?.toList() ?: emptyList()
    
    fun saveUserProfileImages(images: List<String>) = prefs.edit().putStringSet("user_profile_images", images.toSet()).apply()
    fun getUserProfileImages(): List<String> = prefs.getStringSet("user_profile_images", emptySet())?.toList() ?: emptyList()

    // Cart Data
    fun saveCartQuantity(quantity: Int) = prefs.edit().putInt("cart_quantity", quantity).apply()
    fun getCartQuantity(): Int = prefs.getInt("cart_quantity", 1)

    // Settings Data
    fun saveNotificationEnabled(enabled: Boolean) = prefs.edit().putBoolean("notifications_enabled", enabled).apply()
    fun getNotificationEnabled(): Boolean = prefs.getBoolean("notifications_enabled", true)
    
    fun saveSoundEnabled(enabled: Boolean) = prefs.edit().putBoolean("sound_enabled", enabled).apply()
    fun getSoundEnabled(): Boolean = prefs.getBoolean("sound_enabled", true)
    
    fun saveLanguage(language: String) = prefs.edit().putString("language", language).apply()
    fun getLanguage(): String = prefs.getString("language", "pt") ?: "pt"

    // Auth
    fun saveAuthToken(token: String?) {
        if (token.isNullOrBlank()) {
            prefs.edit().remove("auth_token").apply()
        } else {
            prefs.edit().putString("auth_token", token).apply()
        }
    }
    fun getAuthToken(): String? = prefs.getString("auth_token", null)

    fun getAuthRole(): String? {
        val token = getAuthToken() ?: return null
        val parts = token.split('.')
        if (parts.size < 2) return null
        return try {
            val payloadBytes = android.util.Base64.decode(parts[1], android.util.Base64.URL_SAFE or android.util.Base64.NO_PADDING or android.util.Base64.NO_WRAP)
            val json = org.json.JSONObject(String(payloadBytes))
            json.optString("role").ifBlank { null }
        } catch (_: Exception) { null }
    }

    // Clear all data
    fun clearAll() = prefs.edit().clear().apply()
}

```

# Core - design


## [FRONTEND]: core/design/AccountTypeSelectionDialog.kt

```kotlin
package com.taskgoapp.taskgo.core.design

import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.window.Dialog
import com.taskgoapp.taskgo.core.model.AccountType
import com.taskgoapp.taskgo.core.theme.*

@Composable
fun AccountTypeSelectionDialog(
    onAccountTypeSelected: (AccountType) -> Unit,
    onDismiss: () -> Unit
) {
    var selectedAccountType by remember { 
        mutableStateOf(AccountType.CLIENTE) 
    }
    
    Dialog(onDismissRequest = onDismiss) {
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            shape = RoundedCornerShape(16.dp),
            colors = CardDefaults.cardColors(
                containerColor = TaskGoBackgroundWhite
            )
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(24.dp),
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                Text(
                    text = "Selecione o tipo de conta",
                    style = MaterialTheme.typography.headlineSmall,
                    color = TaskGoTextBlack,
                    fontWeight = FontWeight.Bold
                )
                
                Text(
                    text = "Escolha o tipo de conta que melhor descreve voc√™:",
                    style = MaterialTheme.typography.bodyMedium,
                    color = TaskGoTextGray
                )
                
                Spacer(modifier = Modifier.height(8.dp))
                
                Column(
                    verticalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    AccountTypeOption(
                        accountType = AccountType.CLIENTE,
                        title = "Cliente",
                        description = "Contratar servi√ßos e comprar produtos",
                        isSelected = selectedAccountType == AccountType.CLIENTE,
                        onClick = { selectedAccountType = AccountType.CLIENTE }
                    )
                    
                    AccountTypeOption(
                        accountType = AccountType.PARCEIRO,
                        title = "Parceiro",
                        description = "Oferecer servi√ßos e vender produtos",
                        isSelected = selectedAccountType == AccountType.PARCEIRO,
                        onClick = { selectedAccountType = AccountType.PARCEIRO }
                    )
                }
                
                Spacer(modifier = Modifier.height(8.dp))
                
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    OutlinedButton(
                        onClick = onDismiss,
                        modifier = Modifier.weight(1f),
                        colors = ButtonDefaults.outlinedButtonColors(
                            contentColor = TaskGoTextBlack
                        ),
                        border = BorderStroke(1.dp, TaskGoTextGray)
                    ) {
                        Text("Cancelar")
                    }
                    
                    Button(
                        onClick = { onAccountTypeSelected(selectedAccountType) },
                        modifier = Modifier.weight(1f),
                        colors = ButtonDefaults.buttonColors(
                            containerColor = TaskGoGreen
                        )
                    ) {
                        Text("Continuar", color = androidx.compose.ui.graphics.Color.White)
                    }
                }
            }
        }
    }
}

@Composable
private fun AccountTypeOption(
    accountType: AccountType,
    title: String,
    description: String,
    isSelected: Boolean,
    onClick: () -> Unit
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .clickable { onClick() },
        colors = CardDefaults.cardColors(
            containerColor = if (isSelected) TaskGoGreen.copy(alpha = 0.1f) else TaskGoSurface
        ),
        border = if (isSelected) BorderStroke(2.dp, TaskGoGreen) else null
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            RadioButton(
                selected = isSelected,
                onClick = onClick,
                colors = RadioButtonDefaults.colors(
                    selectedColor = TaskGoGreen
                )
            )
            Spacer(modifier = Modifier.width(12.dp))
            Column(modifier = Modifier.weight(1f)) {
                Text(
                    text = title,
                    style = MaterialTheme.typography.bodyLarge,
                    color = TaskGoTextBlack,
                    fontWeight = FontWeight.Medium
                )
                Text(
                    text = description,
                    style = MaterialTheme.typography.bodySmall,
                    color = TaskGoTextGray
                )
            }
        }
    }
}


```

## [FRONTEND]: core/design/AppBottomBar.kt

```kotlin
package com.taskgoapp.taskgo.core.design

import androidx.compose.material3.NavigationBar
import androidx.compose.material3.NavigationBarItem
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.res.stringResource
import com.taskgoapp.taskgo.R
import com.taskgoapp.taskgo.core.design.TGIcon
import com.taskgoapp.taskgo.core.design.TGIcons
import com.taskgoapp.taskgo.core.theme.*

data class BottomBarItem(
    val route: String,
    val titleResId: Int,
    val iconResId: Int
)

val bottomBarItems = listOf(
    BottomBarItem(
        route = "home",
        titleResId = R.string.nav_home,
        iconResId = R.drawable.ic_home // Usando novo √≠cone PNG
    ),
    BottomBarItem(
        route = "services",
        titleResId = R.string.nav_services,
        iconResId = R.drawable.ic_servicos // Corrigido para ic_servicos
    ),
    BottomBarItem(
        route = "products",
        titleResId = R.string.nav_products,
        iconResId = R.drawable.ic_produtos // Usando novo √≠cone PNG
    ),
    BottomBarItem(
        route = "feed",
        titleResId = R.string.nav_feed,
        iconResId = R.drawable.ic_feed
    ),
    BottomBarItem(
        route = "profile",
        titleResId = R.string.nav_profile,
        iconResId = R.drawable.ic_perfil // Usando novo √≠cone PNG
    )
)

@Composable
fun AppBottomBar(
    currentRoute: String,
    onTabSelected: (String) -> Unit,
    modifier: Modifier = Modifier
) {
    NavigationBar(
        modifier = modifier,
        containerColor = TaskGoBackgroundWhite,
    ) {
        bottomBarItems.forEach { item ->
            val selected = currentRoute == item.route
            NavigationBarItem(
                selected = selected,
                onClick = { onTabSelected(item.route) },
                icon = {
                    TGIcon(
                        iconRes = item.iconResId,
                        contentDescription = stringResource(id = item.titleResId),
                        size = TGIcons.Sizes.Navigation,
                        tint = if (selected) TaskGoNavActive else TaskGoNavInactive
                    )
                },
                label = {
                    Text(
                        text = stringResource(id = item.titleResId),
                        style = FigmaNavLabel,
                        color = if (selected) TaskGoNavActive else TaskGoNavInactive
                    )
                },
                colors = androidx.compose.material3.NavigationBarItemDefaults.colors(
                    selectedIconColor = TaskGoNavActive,
                    selectedTextColor = TaskGoNavActive,
                    indicatorColor = TaskGoNavActive.copy(alpha = 0.12f),
                    unselectedIconColor = TaskGoNavInactive,
                    unselectedTextColor = TaskGoNavInactive
                )
            )
        }
    }
}

```

## [FRONTEND]: core/design/AppTopBar.kt

```kotlin
package com.taskgoapp.taskgo.core.design

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape

import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.core.design.TGIcon
import com.taskgoapp.taskgo.core.design.TGIcons

@Composable
fun AppTopBar(
    title: String,
    onBackClick: (() -> Unit)? = null,
    backgroundColor: Color = MaterialTheme.colorScheme.primary,
    titleColor: Color = MaterialTheme.colorScheme.onPrimary,
    backIconColor: Color = MaterialTheme.colorScheme.onPrimary,
    subtitle: String? = null,
    subtitleColor: Color? = null,
    actions: @Composable (() -> Unit)? = null
) {
    Box(
        modifier = Modifier
            .fillMaxWidth()
            .background(backgroundColor)
            .padding(16.dp)
            .then(
                if (subtitle != null) {
                    Modifier.height(110.dp)
                } else {
                    Modifier.height(95.dp)
                }
            )
    ) {
        Row(
            modifier = Modifier.fillMaxWidth(),
            verticalAlignment = Alignment.Top
        ) {
            if (onBackClick != null) {
                Box(
                    modifier = Modifier
                        .size(40.dp)
                        .clip(CircleShape)
                        .clickable { onBackClick() }
                        .background(Color.White.copy(alpha = 0.2f)),
                    contentAlignment = Alignment.Center
                ) {
                    TGIcon(
                        iconRes = TGIcons.Back,
                        contentDescription = "Voltar",
                        size = TGIcons.Sizes.Medium,
                        tint = backIconColor
                    )
                }
                Spacer(modifier = Modifier.width(16.dp))
            }
            
            Column(
                modifier = Modifier.weight(1f)
            ) {
                // Linha com t√≠tulo e a√ß√µes (√≠cones) alinhados horizontalmente
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.SpaceBetween
                ) {
                    Text(
                        text = title,
                        style = MaterialTheme.typography.titleLarge,
                        fontWeight = FontWeight.Bold,
                        color = titleColor,
                        modifier = Modifier.weight(1f, fill = false)
                    )
                    
                    // √çcones de a√ß√µes alinhados horizontalmente com o t√≠tulo
                    actions?.invoke()
                }
                
                // Subt√≠tulo abaixo do t√≠tulo e √≠cones
                if (subtitle != null) {
                    Spacer(modifier = Modifier.height(8.dp))
                    Text(
                        text = subtitle,
                        style = MaterialTheme.typography.bodyMedium,
                        color = subtitleColor ?: Color.White
                    )
                }
            }
        }
    }
}

```

## [FRONTEND]: core/design/CircularImageCropper.kt

```kotlin
package com.taskgoapp.taskgo.core.design

import android.net.Uri
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.PickVisualMediaRequest
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.clickable
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.unit.dp
import coil.compose.AsyncImage
import com.canhub.cropper.CropImageContract
import com.canhub.cropper.CropImageContractOptions
import com.taskgoapp.taskgo.core.design.TGIcons
import com.taskgoapp.taskgo.core.permissions.PermissionHandler
import com.taskgoapp.taskgo.core.permissions.rememberImageReadPermissionLauncher

/**
 * Componente para sele√ß√£o e edi√ß√£o de foto de perfil com corte circular
 * Permite:
 * - Sele√ß√£o de imagem da galeria
 * - Corte circular usando ImageCropper (com propor√ß√£o 1:1)
 * - O ImageCropper nativo j√° suporta movimento/pan e zoom/pinch
 */
@Composable
fun CircularImageCropper(
    currentImageUri: String?,
    onImageCropped: (Uri) -> Unit,
    modifier: Modifier = Modifier,
    size: androidx.compose.ui.unit.Dp = 100.dp
) {
    val context = LocalContext.current
    var selectedImageUri by remember { mutableStateOf<Uri?>(null) }
    var pendingGalleryAction by remember { mutableStateOf(false) }
    
    val hasImagePermission = remember {
        PermissionHandler.hasImageReadPermission(context)
    }
    
    // Launcher para ImageCropper com formato circular (propor√ß√£o 1:1)
    val cropImageLauncher = rememberLauncherForActivityResult(
        contract = CropImageContract()
    ) { result ->
        if (result.isSuccessful) {
            result.uriContent?.let { croppedUri ->
                onImageCropped(croppedUri)
            }
        }
    }
    
    // Launcher para sele√ß√£o de imagem da galeria
    val galleryLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.PickVisualMedia()
    ) { uri ->
        if (uri != null) {
            selectedImageUri = uri
        }
    }
    
    // Launcher para permiss√£o de imagem
    val imagePermissionLauncher = rememberImageReadPermissionLauncher(
        onPermissionGranted = {
            pendingGalleryAction = true
        },
        onPermissionDenied = {
            // Permiss√£o negada
        }
    )
    
    // Executar a√ß√£o da galeria quando permiss√£o for concedida
    LaunchedEffect(pendingGalleryAction) {
        if (pendingGalleryAction && PermissionHandler.hasImageReadPermission(context)) {
            galleryLauncher.launch(PickVisualMediaRequest(ActivityResultContracts.PickVisualMedia.ImageOnly))
            pendingGalleryAction = false
        }
    }
    
    // Iniciar cropper quando imagem for selecionada
    LaunchedEffect(selectedImageUri) {
        selectedImageUri?.let { uri ->
            val cropOptions = CropImageContractOptions(
                uri = uri,
                cropImageOptions = CropImageConfig.createCircularOptions()
            )
            cropImageLauncher.launch(cropOptions)
            selectedImageUri = null // Limpar ap√≥s iniciar
        }
    }
    
    Box(
        modifier = modifier.size(size),
        contentAlignment = Alignment.Center
    ) {
        // Exibir imagem atual ou placeholder
        if (!currentImageUri.isNullOrBlank()) {
            AsyncImage(
                model = currentImageUri,
                contentDescription = "Foto de perfil",
                modifier = Modifier
                    .fillMaxSize()
                    .clip(CircleShape),
                contentScale = ContentScale.Crop
            )
        } else {
            Surface(
                modifier = Modifier.fillMaxSize(),
                shape = CircleShape,
                color = MaterialTheme.colorScheme.surfaceVariant
            ) {
                Icon(
                    painter = painterResource(TGIcons.Profile),
                    contentDescription = "Adicionar foto",
                    modifier = Modifier
                        .fillMaxSize(0.6f)
                        .align(Alignment.Center),
                    tint = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
        }
        
        // Overlay para indicar que √© clic√°vel
        Surface(
            modifier = Modifier
                .fillMaxSize()
                .clip(CircleShape)
                .clickable(
                    indication = null,
                    interactionSource = remember { MutableInteractionSource() }
                ) {
                    if (hasImagePermission) {
                        galleryLauncher.launch(PickVisualMediaRequest(ActivityResultContracts.PickVisualMedia.ImageOnly))
                    } else {
                        imagePermissionLauncher.launch(PermissionHandler.getImageReadPermission())
                    }
                },
            color = androidx.compose.ui.graphics.Color.Transparent
        ) {}
    }
}


```

## [FRONTEND]: core/design/Components.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.core.design

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.foundation.BorderStroke
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.SolidColor
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.Text
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.semantics.contentDescription
import androidx.compose.ui.semantics.semantics
import androidx.compose.material.icons.automirrored.filled.Send
import com.taskgoapp.taskgo.R
import com.taskgoapp.taskgo.core.accessibility.AccessibilityStrings
import com.taskgoapp.taskgo.core.theme.*

// AppTopBar e AppBottomBar foram movidos para arquivos separados
// AppTopBar.kt e AppBottomBar.kt

// SearchBar
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun SearchBar(
    query: String,
    onQueryChange: (String) -> Unit,
    placeholder: String = "Buscar...",
    modifier: Modifier = Modifier
) {
    OutlinedTextField(
        value = query,
        onValueChange = onQueryChange,
        modifier = modifier.fillMaxWidth(),
        placeholder = { Text(placeholder) },
        singleLine = true,
        shape = RoundedCornerShape(16.dp),
        colors = OutlinedTextFieldDefaults.colors(
            focusedBorderColor = MaterialTheme.colorScheme.primary,
            unfocusedBorderColor = MaterialTheme.colorScheme.outline,
            cursorColor = MaterialTheme.colorScheme.primary
        )
    )
}

// Buttons
@Composable
fun PrimaryButton(
    text: String,
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true
) {
    Button(
        onClick = onClick,
        enabled = enabled,
        modifier = modifier
            .height(52.dp),
        shape = RoundedCornerShape(8.dp),
        colors = ButtonDefaults.buttonColors(
            containerColor = TaskGoGreen,
            contentColor = TaskGoBackgroundWhite,
            disabledContainerColor = TaskGoGreen.copy(alpha = 0.3f),
            disabledContentColor = TaskGoBackgroundWhite.copy(alpha = 0.6f)
        ),
        contentPadding = PaddingValues(horizontal = 24.dp)
    ) {
        Text(
            text = text, 
            style = FigmaButtonText,
            color = TaskGoBackgroundWhite
        )
    }
}

@Composable
fun SecondaryButton(
    text: String,
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true
) {
    OutlinedButton(
        onClick = onClick,
        enabled = enabled,
        modifier = modifier
            .height(52.dp),
        shape = RoundedCornerShape(8.dp),
        colors = ButtonDefaults.outlinedButtonColors(
            contentColor = TaskGoGreen,
            disabledContentColor = TaskGoGreen.copy(alpha = 0.5f)
        ),
        border = BorderStroke(
            width = 1.dp,
            brush = SolidColor(if (enabled) TaskGoGreen else TaskGoGreen.copy(alpha = 0.5f))
        ),
        contentPadding = PaddingValues(horizontal = 24.dp)
    ) {
        Text(
            text = text, 
            style = FigmaButtonText,
            color = TaskGoGreen
        )
    }
}

@Composable
fun TextButton(
    text: String,
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true
) {
    Text(
        text = text,
        style = MaterialTheme.typography.labelLarge,
        color = if (enabled) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.primary.copy(alpha = 0.5f),
        modifier = modifier
            .clickable(enabled = enabled) { onClick() }
            .padding(horizontal = 16.dp, vertical = 8.dp)
    )
}

// Cards
@Composable
fun ServiceCard(
    title: String,
    provider: String,
    rating: Float,
    reviewsCount: Int,
    onClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier
            .fillMaxWidth()
            .clickable { onClick() },
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                text = title,
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.Bold
            )
            Spacer(modifier = Modifier.height(8.dp))
            Text(
                text = provider,
                style = MaterialTheme.typography.bodyMedium,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
            Spacer(modifier = Modifier.height(8.dp))
            Row(
                verticalAlignment = Alignment.CenterVertically
            ) {
                RatingBar(rating = rating, showCount = false)
                Spacer(modifier = Modifier.width(8.dp))
                Text(
                    text = "($reviewsCount)",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
        }
    }
}

@Composable
fun ProductCard(
    title: String,
    price: Double,
    imageRes: Int? = null,
    onClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier
            .fillMaxWidth()
            .clickable { onClick() },
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
    ) {
        Column {
            Box(
                modifier = Modifier
                    .fillMaxWidth()
                    .height(120.dp)
                    .background(MaterialTheme.colorScheme.surfaceVariant)
                    .clip(RoundedCornerShape(topStart = 12.dp, topEnd = 12.dp)),
                contentAlignment = Alignment.Center
            ) {
                if (imageRes != null) {
                    // TODO: Implementar carregamento de imagem com Coil
                    Icon(
                        imageVector = Icons.Default.Image,
                        contentDescription = "Imagem do produto",
                        modifier = Modifier.size(48.dp),
                        tint = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                } else {
                    Icon(
                        imageVector = Icons.Default.Image,
                        contentDescription = "Imagem do produto",
                        modifier = Modifier.size(48.dp),
                        tint = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
            }
            Column(
                modifier = Modifier.padding(16.dp)
            ) {
                Text(
                    text = title,
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold
                )
                Spacer(modifier = Modifier.height(8.dp))
                PriceTag(value = price)
            }
        }
    }
}

@Composable
fun ProposalCard(
    title: String,
    requester: String,
    date: String,
    budget: Double,
    status: String,
    onClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier
            .fillMaxWidth()
            .clickable { onClick() },
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                text = title,
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.Bold
            )
            Spacer(modifier = Modifier.height(8.dp))
            Text(
                text = "Solicitante: $requester",
                style = MaterialTheme.typography.bodyMedium
            )
            Text(
                text = "Data: $date",
                style = MaterialTheme.typography.bodyMedium
            )
            Text(
                text = "Or√ßamento: R$ %.2f".format(budget),
                style = MaterialTheme.typography.bodyMedium,
                fontWeight = FontWeight.Bold
            )
            Spacer(modifier = Modifier.height(8.dp))
            AssistChip(
                onClick = { },
                label = { Text(status) },
                colors = AssistChipDefaults.assistChipColors(
                    containerColor = when (status) {
                        "Pendente" -> MaterialTheme.colorScheme.tertiaryContainer
                        "Aceita" -> MaterialTheme.colorScheme.secondaryContainer
                        else -> MaterialTheme.colorScheme.surfaceVariant
                    }
                )
            )
        }
    }
}

// RatingBar
@Composable
fun RatingBar(
    rating: Float,
    count: Int? = null,
    modifier: Modifier = Modifier,
    showCount: Boolean = true
) {
    Row(
        verticalAlignment = Alignment.CenterVertically,
        modifier = modifier
    ) {
        repeat(5) { index ->
            Icon(
                imageVector = if (index < rating) Icons.Filled.Star else Icons.Filled.StarBorder,
                contentDescription = "Estrela ${index + 1}",
                tint = if (index < rating) Color(0xFFFFD700) else MaterialTheme.colorScheme.onSurfaceVariant,
                modifier = Modifier.size(16.dp)
            )
        }
        if (showCount && count != null) {
            Spacer(modifier = Modifier.width(4.dp))
            Text(
                text = "($count)",
                style = MaterialTheme.typography.bodySmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }
    }
}

// PriceTag
@Composable
fun PriceTag(
    value: Double,
    modifier: Modifier = Modifier
) {
    Surface(
        modifier = modifier,
        color = MaterialTheme.colorScheme.primaryContainer,
        shape = RoundedCornerShape(8.dp)
    ) {
        Text(
            text = "R$ %.2f".format(value),
            style = MaterialTheme.typography.titleMedium,
            color = MaterialTheme.colorScheme.onPrimaryContainer,
            fontWeight = FontWeight.Bold,
            modifier = Modifier.padding(horizontal = 12.dp, vertical = 6.dp)
        )
    }
}

// EmptyState
@Composable
fun EmptyState(
    icon: ImageVector,
    title: String,
    message: String,
    action: @Composable (() -> Unit)? = null,
    modifier: Modifier = Modifier
) {
    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        modifier = modifier.padding(32.dp)
    ) {
        Icon(
            imageVector = icon,
            contentDescription = null,
            modifier = Modifier.size(64.dp),
            tint = MaterialTheme.colorScheme.onSurfaceVariant
        )
        Spacer(modifier = Modifier.height(16.dp))
        Text(
            text = title,
            style = MaterialTheme.typography.headlineSmall,
            textAlign = TextAlign.Center
        )
        Spacer(modifier = Modifier.height(8.dp))
        Text(
            text = message,
            style = MaterialTheme.typography.bodyMedium,
            textAlign = TextAlign.Center,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )
        if (action != null) {
            Spacer(modifier = Modifier.height(16.dp))
            action()
        }
    }
}

// ChatBubble
@Composable
fun ChatBubble(
    message: String,
    isMine: Boolean,
    time: String,
    modifier: Modifier = Modifier
) {
    Column(
        modifier = modifier.fillMaxWidth(),
        horizontalAlignment = if (isMine) Alignment.End else Alignment.Start
    ) {
        Surface(
            color = if (isMine) Color(0xFFA4FFB6) else Color(0xFFD9D9D9),
            shape = RoundedCornerShape(
                topStart = 16.dp,
                topEnd = 16.dp,
                bottomStart = if (isMine) 16.dp else 4.dp,
                bottomEnd = if (isMine) 4.dp else 16.dp
            ),
            modifier = Modifier.widthIn(max = 280.dp)
        ) {
            Text(
                text = message,
                style = MaterialTheme.typography.bodyMedium,
                color = MaterialTheme.colorScheme.onSurface,
                modifier = Modifier.padding(12.dp)
            )
        }
        Spacer(modifier = Modifier.height(4.dp))
        Text(
            text = time,
            style = MaterialTheme.typography.bodySmall,
            color = MaterialTheme.colorScheme.onSurfaceVariant,
            modifier = Modifier.padding(horizontal = 4.dp)
        )
    }
}

// InputMessage
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun InputMessage(
    message: String,
    onMessageChange: (String) -> Unit,
    onSend: () -> Unit,
    modifier: Modifier = Modifier
) {
    Row(
        modifier = modifier.fillMaxWidth(),
        verticalAlignment = Alignment.Bottom
    ) {
        OutlinedTextField(
            value = message,
            onValueChange = onMessageChange,
            placeholder = { Text("Digite sua mensagem...") },
            maxLines = 4,
            singleLine = false,
            shape = RoundedCornerShape(16.dp),
            colors = OutlinedTextFieldDefaults.colors(
                focusedBorderColor = MaterialTheme.colorScheme.primary,
                unfocusedBorderColor = MaterialTheme.colorScheme.outline,
                cursorColor = MaterialTheme.colorScheme.primary
            ),
            modifier = Modifier.weight(1f)
        )
        Spacer(modifier = Modifier.width(8.dp))
        FloatingActionButton(
            onClick = onSend,
            containerColor = MaterialTheme.colorScheme.primary
        ) {
            Icon(
                imageVector = Icons.AutoMirrored.Filled.Send,
                contentDescription = "Enviar",
                tint = MaterialTheme.colorScheme.onPrimary
            )
        }
    }
}

// Timeline
@Composable
fun Timeline(
    events: List<TimelineEvent>,
    modifier: Modifier = Modifier
) {
    Column(modifier = modifier) {
        events.forEachIndexed { index, event ->
            Row(
                modifier = Modifier.fillMaxWidth()
            ) {
                Column(
                    horizontalAlignment = Alignment.CenterHorizontally,
                    modifier = Modifier.width(24.dp)
                ) {
                    if (index == 0) {
                        Icon(
                            imageVector = Icons.Filled.RadioButtonChecked,
                            contentDescription = null,
                            tint = MaterialTheme.colorScheme.primary,
                            modifier = Modifier.size(16.dp)
                        )
                    } else {
                        Icon(
                            imageVector = Icons.Filled.RadioButtonUnchecked,
                            contentDescription = null,
                            tint = MaterialTheme.colorScheme.onSurfaceVariant,
                            modifier = Modifier.size(16.dp)
                        )
                    }
                    if (index < events.size - 1) {
                        Box(
                            modifier = Modifier
                                .width(2.dp)
                                .height(32.dp)
                                .background(MaterialTheme.colorScheme.outlineVariant)
                        )
                    }
                }
                Spacer(modifier = Modifier.width(16.dp))
                Column(
                    modifier = Modifier.weight(1f)
                ) {
                    Text(
                        text = event.title,
                        style = MaterialTheme.typography.titleSmall,
                        fontWeight = FontWeight.Bold
                    )
                    Text(
                        text = event.description,
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                    Text(
                        text = event.time,
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
            }
            if (index < events.size - 1) {
                Spacer(modifier = Modifier.height(16.dp))
            }
        }
    }
}

data class TimelineEvent(
    val title: String,
    val description: String,
    val time: String
)

// Loading State Component
@Composable
fun LoadingState(
    modifier: Modifier = Modifier,
    message: String? = null
) {
    Box(
        modifier = modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Column(
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center
        ) {
            CircularProgressIndicator(
                modifier = Modifier.semantics {
                    contentDescription = AccessibilityStrings.loadingState()
                }
            )
            if (message != null) {
                Spacer(modifier = Modifier.height(16.dp))
                Text(
                    text = message,
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
        }
    }
}

// Error State Component
@Composable
fun ErrorState(
    error: String,
    onRetry: (() -> Unit)? = null,
    onDismiss: (() -> Unit)? = null,
    modifier: Modifier = Modifier
) {
    Column(
        modifier = modifier
            .fillMaxSize()
            .padding(16.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        Icon(
            imageVector = Icons.Default.Error,
            contentDescription = null,
            modifier = Modifier.size(64.dp),
            tint = MaterialTheme.colorScheme.error
        )
        Spacer(modifier = Modifier.height(16.dp))
        Text(
            text = stringResource(R.string.ui_error),
            style = MaterialTheme.typography.headlineSmall,
            color = MaterialTheme.colorScheme.error,
            textAlign = TextAlign.Center
        )
        Spacer(modifier = Modifier.height(8.dp))
        Text(
            text = error,
            style = MaterialTheme.typography.bodyMedium,
            color = MaterialTheme.colorScheme.onSurfaceVariant,
            textAlign = TextAlign.Center
        )
        if (onRetry != null || onDismiss != null) {
            Spacer(modifier = Modifier.height(24.dp))
            Row(
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                if (onRetry != null) {
                    Button(
                        onClick = onRetry,
                        colors = ButtonDefaults.buttonColors(
                            containerColor = TaskGoGreen
                        )
                    ) {
                        Text(stringResource(R.string.ui_retry))
                    }
                }
                if (onDismiss != null) {
                    OutlinedButton(onClick = onDismiss) {
                        Text(stringResource(R.string.ui_ok))
                    }
                }
            }
        }
    }
}

// Chip Component
@Composable
fun TGChip(
    text: String,
    selected: Boolean = false,
    onClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    FilterChip(
        selected = selected,
        onClick = onClick,
        label = { Text(text) },
        modifier = modifier,
        colors = FilterChipDefaults.filterChipColors(
            selectedContainerColor = com.taskgoapp.taskgo.core.theme.TaskGoBackgroundGray,
            selectedLabelColor = com.taskgoapp.taskgo.core.theme.TaskGoGreen
        )
    )
}

```

## [FRONTEND]: core/design/CropImageConfig.kt

```kotlin
package com.taskgoapp.taskgo.core.design

import android.graphics.Bitmap
import com.canhub.cropper.CropImageOptions
import com.canhub.cropper.CropImageView

/**
 * Configura√ß√µes padr√£o para o corte de imagem
 */
object CropImageConfig {
    
    /**
     * Cria as op√ß√µes padr√£o para corte de imagem
     */
    fun createDefaultOptions(): CropImageOptions {
        return CropImageOptions()
    }
    
    /**
     * Cria op√ß√µes para corte de imagem com propor√ß√£o fixa
     */
    fun createFixedAspectRatioOptions(
        aspectRatioX: Int = 1,
        aspectRatioY: Int = 1
    ): CropImageOptions {
        return CropImageOptions()
    }
    
    /**
     * Cria op√ß√µes para corte de imagem quadrada
     */
    fun createSquareOptions(): CropImageOptions {
        return CropImageOptions()
    }
    
    /**
     * Cria op√ß√µes para corte de imagem retangular (16:9)
     */
    fun createWideOptions(): CropImageOptions {
        return CropImageOptions()
    }
    
    /**
     * Cria op√ß√µes para corte circular de imagem (perfil)
     */
    fun createCircularOptions(): CropImageOptions {
        return CropImageOptions().apply {
            // A biblioteca ImageCropper j√° suporta corte circular atrav√©s do cropShape
            // Mas como estamos usando CropImageContract, as op√ß√µes podem ser limitadas
            // O corte circular ser√° feito visualmente atrav√©s do ImageCropper nativo
            fixAspectRatio = true
            aspectRatioX = 1
            aspectRatioY = 1
            guidelines = CropImageView.Guidelines.ON
            outputCompressFormat = android.graphics.Bitmap.CompressFormat.PNG
            outputCompressQuality = 90
        }
    }
}


```

## [FRONTEND]: core/design/ExpandingFAB.kt

```kotlin
package com.taskgoapp.taskgo.core.design

import androidx.compose.animation.*
import androidx.compose.animation.core.*
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.IconButton
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.rotate
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.core.theme.TaskGoGreen

/**
 * Bot√£o flutuante expans√≠vel que exibe a√ß√µes r√°pidas
 * Quando fechado: c√≠rculo verde
 * Quando aberto: ret√¢ngulo verde vertical com √≠cones de a√ß√µes
 */
@Composable
fun ExpandingFAB(
    onMessagesClick: () -> Unit,
    onSearchClick: () -> Unit,
    onCartClick: () -> Unit,
    onNotificationsClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    var isExpanded by remember { mutableStateOf(false) }
    
    // Anima√ß√µes
    val rotation by animateFloatAsState(
        targetValue = if (isExpanded) 45f else 0f,
        animationSpec = spring(
            dampingRatio = Spring.DampingRatioMediumBouncy,
            stiffness = Spring.StiffnessLow
        ),
        label = "rotation"
    )
    
    val scale by animateFloatAsState(
        targetValue = if (isExpanded) 0.8f else 1f,
        animationSpec = spring(
            dampingRatio = Spring.DampingRatioMediumBouncy,
            stiffness = Spring.StiffnessLow
        ),
        label = "scale"
    )
    
    Box(
        modifier = modifier
            .padding(16.dp),
        contentAlignment = Alignment.CenterEnd
    ) {
        // Bot√£o expandido (ret√¢ngulo vertical com √≠cones)
        AnimatedVisibility(
            visible = isExpanded,
            enter = expandVertically(
                animationSpec = spring(
                    dampingRatio = Spring.DampingRatioMediumBouncy,
                    stiffness = Spring.StiffnessLow
                )
            ) + fadeIn(),
            exit = shrinkVertically(
                animationSpec = spring(
                    dampingRatio = Spring.DampingRatioMediumBouncy,
                    stiffness = Spring.StiffnessLow
                )
            ) + fadeOut()
        ) {
            Column(
                modifier = Modifier
                    .clip(RoundedCornerShape(16.dp))
                    .background(TaskGoGreen)
                    .padding(vertical = 8.dp),
                horizontalAlignment = Alignment.CenterHorizontally,
                verticalArrangement = Arrangement.spacedBy(4.dp)
            ) {
                // Mensagens (topo)
                IconButton(
                    onClick = {
                        isExpanded = false
                        onMessagesClick()
                    },
                    modifier = Modifier.size(48.dp)
                ) {
                    TGIcon(
                        iconRes = TGIcons.Messages,
                        contentDescription = "Mensagens",
                        size = TGIcons.Sizes.Medium,
                        tint = Color.White
                    )
                }
                
                // Busca
                IconButton(
                    onClick = {
                        isExpanded = false
                        onSearchClick()
                    },
                    modifier = Modifier.size(48.dp)
                ) {
                    TGIcon(
                        iconRes = TGIcons.Search,
                        contentDescription = "Busca",
                        size = TGIcons.Sizes.Medium,
                        tint = Color.White
                    )
                }
                
                // Carrinho
                IconButton(
                    onClick = {
                        isExpanded = false
                        onCartClick()
                    },
                    modifier = Modifier.size(48.dp)
                ) {
                    TGIcon(
                        iconRes = TGIcons.Cart,
                        contentDescription = "Carrinho",
                        size = TGIcons.Sizes.Medium,
                        tint = Color.White
                    )
                }
                
                // Notifica√ß√µes (base)
                IconButton(
                    onClick = {
                        isExpanded = false
                        onNotificationsClick()
                    },
                    modifier = Modifier.size(48.dp)
                ) {
                    TGIcon(
                        iconRes = TGIcons.Bell,
                        contentDescription = "Notifica√ß√µes",
                        size = TGIcons.Sizes.Medium,
                        tint = Color.White
                    )
                }
            }
        }
        
        // Bot√£o principal (c√≠rculo verde) - aparece quando fechado
        AnimatedVisibility(
            visible = !isExpanded,
            enter = fadeIn() + scaleIn(),
            exit = fadeOut() + scaleOut()
        ) {
            Box(
                modifier = Modifier
                    .size(56.dp)
                    .clip(CircleShape)
                    .background(TaskGoGreen)
                    .clickable { isExpanded = true }
            )
        }
    }
}


```

## [FRONTEND]: core/design/FilterComponents.kt

```kotlin
package com.taskgoapp.taskgo.core.design

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.horizontalScroll
import androidx.compose.foundation.verticalScroll
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.taskgoapp.taskgo.core.theme.*

/**
 * Modelo de dados para filtros
 */
data class FilterState(
    val selectedCategories: Set<String> = emptySet(),
    val priceRange: PriceRange? = null,
    val location: LocationFilter? = null,
    val sortBy: SortOption = SortOption.RELEVANCE,
    val searchQuery: String = "",
    val minRating: Double? = null,
    val useLocationRadius: Boolean = false
)

data class PriceRange(
    val min: Double? = null,
    val max: Double? = null
)

data class LocationFilter(
    val city: String? = null,
    val state: String? = null,
    val radiusKm: Int? = null // Raio em km
)

enum class SortOption(val label: String) {
    RELEVANCE("Relev√¢ncia"),
    PRICE_LOW_TO_HIGH("Menor pre√ßo"),
    PRICE_HIGH_TO_LOW("Maior pre√ßo"),
    NEWEST("Mais recentes"),
    RATING("Melhor avaliados")
}

/**
 * Barra de filtros horizontal scroll√°vel
 */
@Composable
fun FilterBar(
    categories: List<String>,
    selectedCategories: Set<String>,
    onCategorySelected: (String) -> Unit,
    onFilterClick: () -> Unit,
    showSortButtons: Boolean = false,
    sortBy: SortOption? = null,
    onSortByRating: (() -> Unit)? = null,
    onSortByNewest: (() -> Unit)? = null,
    modifier: Modifier = Modifier
) {
    Row(
        modifier = modifier
            .fillMaxWidth()
            .horizontalScroll(rememberScrollState()),
        horizontalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        // Bot√£o de filtros avan√ßados
        FilterChip(
            selected = false,
            onClick = onFilterClick,
            label = {
                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.spacedBy(4.dp)
                ) {
                    Icon(
                        imageVector = Icons.Default.Tune,
                        contentDescription = null,
                        modifier = Modifier.size(16.dp)
                    )
                    Text("Filtros")
                }
            },
            colors = FilterChipDefaults.filterChipColors(
                containerColor = TaskGoSurfaceGray,
                labelColor = TaskGoTextBlack
            )
        )
        
        // Chips de categorias
        categories.forEach { category ->
            FilterChip(
                selected = selectedCategories.contains(category),
                onClick = { onCategorySelected(category) },
                label = { Text(category) },
                colors = FilterChipDefaults.filterChipColors(
                    selectedContainerColor = TaskGoGreen,
                    selectedLabelColor = TaskGoBackgroundWhite,
                    containerColor = TaskGoSurfaceGray,
                    labelColor = TaskGoTextBlack
                )
            )
        }
        
        // Bot√µes de ordena√ß√£o r√°pida (se solicitados)
        if (showSortButtons) {
            FilterChip(
                selected = sortBy == SortOption.RATING,
                onClick = { onSortByRating?.invoke() },
                label = { Text("‚≠ê", fontSize = 12.sp) },
                colors = FilterChipDefaults.filterChipColors(
                    selectedContainerColor = TaskGoGreen,
                    selectedLabelColor = Color.White,
                    containerColor = TaskGoSurfaceGray,
                    labelColor = TaskGoTextBlack
                )
            )
            FilterChip(
                selected = sortBy == SortOption.NEWEST,
                onClick = { onSortByNewest?.invoke() },
                label = { Text("Novos", fontSize = 11.sp) },
                colors = FilterChipDefaults.filterChipColors(
                    selectedContainerColor = TaskGoGreen,
                    selectedLabelColor = Color.White,
                    containerColor = TaskGoSurfaceGray,
                    labelColor = TaskGoTextBlack
                )
            )
        }
    }
}

/**
 * Bottom sheet de filtros avan√ßados
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun FilterBottomSheet(
    isOpen: Boolean,
    onDismiss: () -> Unit,
    filterState: FilterState,
    onFilterStateChange: (FilterState) -> Unit,
    priceRanges: List<PriceRangeOption> = defaultPriceRanges,
    cities: List<String> = emptyList(),
    states: List<String> = defaultBrazilianStates,
    showPriceFilter: Boolean = true,
    modifier: Modifier = Modifier
) {
    if (isOpen) {
        val sheetState = rememberModalBottomSheetState(
            skipPartiallyExpanded = true
        )
        
        LaunchedEffect(Unit) {
            sheetState.expand()
        }
        
        ModalBottomSheet(
            onDismissRequest = onDismiss,
            sheetState = sheetState,
            modifier = modifier
        ) {
            val scrollState = rememberScrollState()
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .verticalScroll(scrollState)
                    .padding(24.dp),
                verticalArrangement = Arrangement.spacedBy(24.dp)
            ) {
                // T√≠tulo
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Text(
                        text = "Filtros",
                        style = MaterialTheme.typography.titleLarge,
                        fontWeight = FontWeight.Bold,
                        color = TaskGoTextBlack
                    )
                    TextButton(onClick = {
                        onFilterStateChange(FilterState())
                    }) {
                        Text("Limpar tudo", color = TaskGoGreen)
                    }
                }
                
                // Filtro de Pre√ßo (apenas se showPriceFilter for true)
                if (showPriceFilter) {
                    Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {
                        Text(
                            text = "Faixa de Pre√ßo",
                            style = MaterialTheme.typography.titleMedium,
                            fontWeight = FontWeight.Bold,
                            color = TaskGoTextBlack
                        )
                        
                        priceRanges.forEach { range ->
                            Row(
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .clickable {
                                        onFilterStateChange(
                                            filterState.copy(priceRange = range.range)
                                        )
                                    },
                                verticalAlignment = Alignment.CenterVertically
                            ) {
                                RadioButton(
                                    selected = filterState.priceRange == range.range,
                                    onClick = {
                                        onFilterStateChange(
                                            filterState.copy(priceRange = range.range)
                                        )
                                    }
                                )
                                Spacer(modifier = Modifier.width(8.dp))
                                Text(
                                    text = range.label,
                                    style = MaterialTheme.typography.bodyLarge,
                                    color = TaskGoTextBlack
                                )
                            }
                        }
                    }
                    
                    HorizontalDivider()
                }
                
                // Filtro de Localiza√ß√£o
                Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {
                    Text(
                        text = "Localiza√ß√£o",
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold,
                        color = TaskGoTextBlack
                    )
                    
                    // Estado - Dropdown
                    var selectedState by remember(filterState.location?.state) {
                        mutableStateOf(filterState.location?.state ?: "")
                    }
                    var expandedState by remember { mutableStateOf(false) }
                    
                    ExposedDropdownMenuBox(
                        expanded = expandedState,
                        onExpandedChange = { expandedState = !expandedState }
                    ) {
                        OutlinedTextField(
                            value = selectedState,
                            onValueChange = {},
                            readOnly = true,
                            label = { Text("Estado (UF)") },
                            modifier = Modifier
                                .fillMaxWidth()
                                .menuAnchor(MenuAnchorType.PrimaryNotEditable),
                            trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = expandedState) },
                            placeholder = { Text("Selecione o estado") }
                        )
                        ExposedDropdownMenu(
                            expanded = expandedState,
                            onDismissRequest = { expandedState = false }
                        ) {
                            com.taskgoapp.taskgo.core.data.BrazilianCities.allStates.forEach { state ->
                                DropdownMenuItem(
                                    text = { Text(state) },
                                    onClick = {
                                        selectedState = state
                                        expandedState = false
                                        onFilterStateChange(
                                            filterState.copy(
                                                location = filterState.location?.copy(state = state, city = null) 
                                                    ?: LocationFilter(state = state)
                                            )
                                        )
                                    }
                                )
                            }
                        }
                    }
                    
                    Spacer(modifier = Modifier.height(8.dp))
                    
                    // Cidade - Dropdown (carrega baseado no estado selecionado)
                    var selectedCity by remember(filterState.location?.city, selectedState) {
                        mutableStateOf(filterState.location?.city ?: "")
                    }
                    var expandedCity by remember { mutableStateOf(false) }
                    val availableCities = remember(selectedState) {
                        if (selectedState.isNotEmpty()) {
                            com.taskgoapp.taskgo.core.data.BrazilianCities.getCitiesForState(selectedState)
                        } else {
                            emptyList()
                        }
                    }
                    
                    ExposedDropdownMenuBox(
                        expanded = expandedCity,
                        onExpandedChange = { expandedCity = !expandedCity }
                    ) {
                        OutlinedTextField(
                            value = selectedCity,
                            onValueChange = {},
                            readOnly = true,
                            label = { Text("Cidade") },
                            modifier = Modifier
                                .fillMaxWidth()
                                .menuAnchor(MenuAnchorType.PrimaryNotEditable),
                            trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = expandedCity) },
                            placeholder = { Text(if (selectedState.isEmpty()) "Selecione primeiro o estado" else "Selecione a cidade") },
                            enabled = selectedState.isNotEmpty()
                        )
                        ExposedDropdownMenu(
                            expanded = expandedCity,
                            onDismissRequest = { expandedCity = false }
                        ) {
                            availableCities.forEach { city ->
                                DropdownMenuItem(
                                    text = { Text(city) },
                                    onClick = {
                                        selectedCity = city
                                        expandedCity = false
                                        onFilterStateChange(
                                            filterState.copy(
                                                location = filterState.location?.copy(city = city)
                                                    ?: LocationFilter(state = selectedState, city = city)
                                            )
                                        )
                                    }
                                )
                            }
                        }
                    }
                    
                    Spacer(modifier = Modifier.height(8.dp))
                    
                    // Checkbox para usar localiza√ß√£o atual
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .clickable {
                                onFilterStateChange(
                                    filterState.copy(
                                        useLocationRadius = !filterState.useLocationRadius
                                    )
                                )
                            },
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Checkbox(
                            checked = filterState.useLocationRadius,
                            onCheckedChange = { checked ->
                                onFilterStateChange(
                                    filterState.copy(useLocationRadius = checked)
                                )
                            }
                        )
                        Spacer(modifier = Modifier.width(8.dp))
                        Text(
                            text = "Usar minha localiza√ß√£o atual",
                            style = MaterialTheme.typography.bodyLarge,
                            color = TaskGoTextBlack
                        )
                    }
                    
                    Spacer(modifier = Modifier.height(8.dp))
                    
                    // Raio - Slider (habilitado apenas se usar localiza√ß√£o)
                    if (filterState.useLocationRadius) {
                        var sliderValue by remember(filterState.location?.radiusKm, filterState.useLocationRadius) {
                            mutableStateOf((filterState.location?.radiusKm?.takeIf { it in 10..100 } ?: 10).toFloat())
                        }
                        
                        Column(
                            modifier = Modifier.fillMaxWidth(),
                            verticalArrangement = Arrangement.spacedBy(8.dp)
                        ) {
                            Text(
                                text = "Raio: ${sliderValue.toInt()} km",
                                style = MaterialTheme.typography.titleMedium,
                                fontWeight = FontWeight.Bold,
                                color = TaskGoTextBlack
                            )
                            
                            Slider(
                                value = sliderValue,
                                onValueChange = { newValue ->
                                    sliderValue = newValue
                                    val radiusKm = newValue.toInt()
                                    onFilterStateChange(
                                        filterState.copy(
                                            location = filterState.location?.copy(radiusKm = radiusKm)
                                                ?: LocationFilter(radiusKm = radiusKm)
                                        )
                                    )
                                },
                                valueRange = 10f..100f,
                                steps = 8, // Incrementos de 10km (10, 20, 30, ..., 100)
                                colors = SliderDefaults.colors(
                                    thumbColor = TaskGoGreen,
                                    activeTrackColor = TaskGoGreen,
                                    inactiveTrackColor = Color(0xFFE0E0E0)
                                )
                            )
                            
                            Row(
                                modifier = Modifier.fillMaxWidth(),
                                horizontalArrangement = Arrangement.SpaceBetween
                            ) {
                                Text(
                                    text = "10 km",
                                    style = MaterialTheme.typography.bodySmall,
                                    color = TaskGoTextGray
                                )
                                Text(
                                    text = "100 km",
                                    style = MaterialTheme.typography.bodySmall,
                                    color = TaskGoTextGray
                                )
                            }
                        }
                    }
                    
                }
                
                HorizontalDivider()
                
                // Filtro de Avalia√ß√£o
                Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {
                    Text(
                        text = "Avalia√ß√£o M√≠nima",
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold,
                        color = TaskGoTextBlack
                    )
                    
                    val ratingOptions = listOf(
                        "Todas" to null,
                        "4+ estrelas" to 4.0,
                        "3+ estrelas" to 3.0,
                        "2+ estrelas" to 2.0,
                        "1+ estrelas" to 1.0
                    )
                    
                    ratingOptions.forEach { (label, rating) ->
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .clickable {
                                    onFilterStateChange(
                                        filterState.copy(minRating = rating)
                                    )
                                },
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            RadioButton(
                                selected = filterState.minRating == rating,
                                onClick = {
                                    onFilterStateChange(
                                        filterState.copy(minRating = rating)
                                    )
                                }
                            )
                            Spacer(modifier = Modifier.width(8.dp))
                            Text(
                                text = label,
                                style = MaterialTheme.typography.bodyLarge,
                                color = TaskGoTextBlack
                            )
                        }
                    }
                }
                
                HorizontalDivider()
                
                // Ordena√ß√£o
                Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {
                    Text(
                        text = "Ordenar por",
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold,
                        color = TaskGoTextBlack
                    )
                    
                    SortOption.values().forEach { option ->
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .clickable {
                                    onFilterStateChange(filterState.copy(sortBy = option))
                                },
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            RadioButton(
                                selected = filterState.sortBy == option,
                                onClick = {
                                    onFilterStateChange(filterState.copy(sortBy = option))
                                }
                            )
                            Spacer(modifier = Modifier.width(8.dp))
                            Text(
                                text = option.label,
                                style = MaterialTheme.typography.bodyLarge,
                                color = TaskGoTextBlack
                            )
                        }
                    }
                }
                
                Spacer(modifier = Modifier.height(16.dp))
                
                // Bot√£o Confirmar
                Button(
                    onClick = onDismiss,
                    modifier = Modifier.fillMaxWidth(),
                    colors = ButtonDefaults.buttonColors(
                        containerColor = TaskGoGreen
                    ),
                    shape = RoundedCornerShape(12.dp)
                ) {
                    Text(
                        "Confirmar",
                        color = TaskGoBackgroundWhite,
                        fontWeight = FontWeight.Bold,
                        modifier = Modifier.padding(vertical = 8.dp)
                    )
                }
            }
        }
    }
}

data class PriceRangeOption(
    val label: String,
    val range: PriceRange
)

val defaultPriceRanges = listOf(
    PriceRangeOption("At√© R$ 50", PriceRange(max = 50.0)),
    PriceRangeOption("R$ 50 - R$ 100", PriceRange(min = 50.0, max = 100.0)),
    PriceRangeOption("R$ 100 - R$ 250", PriceRange(min = 100.0, max = 250.0)),
    PriceRangeOption("R$ 250 - R$ 500", PriceRange(min = 250.0, max = 500.0)),
    PriceRangeOption("R$ 500 - R$ 1000", PriceRange(min = 500.0, max = 1000.0)),
    PriceRangeOption("Acima de R$ 1000", PriceRange(min = 1000.0))
)

val defaultBrazilianStates = listOf(
    "AC", "AL", "AP", "AM", "BA", "CE", "DF", "ES", "GO", "MA",
    "MT", "MS", "MG", "PA", "PB", "PR", "PE", "PI", "RJ", "RN",
    "RS", "RO", "RR", "SC", "SP", "SE", "TO"
)


```

## [FRONTEND]: core/design/FullScreenVideoPlayer.kt

```kotlin
package com.taskgoapp.taskgo.core.design

import android.view.ViewGroup
import android.widget.FrameLayout
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Close
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.compose.ui.viewinterop.AndroidView
import androidx.compose.ui.window.Dialog
import androidx.compose.ui.window.DialogProperties
import androidx.media3.common.MediaItem
import androidx.media3.common.Player
import androidx.media3.exoplayer.ExoPlayer
import androidx.media3.ui.PlayerView

/**
 * Player de v√≠deo em tela cheia
 */
@Composable
fun FullScreenVideoPlayer(
    videoUrl: String,
    onDismiss: () -> Unit,
    modifier: Modifier = Modifier
) {
    val context = LocalContext.current
    
    val exoPlayer = remember {
        ExoPlayer.Builder(context).build().apply {
            val mediaItem = MediaItem.fromUri(videoUrl)
            setMediaItem(mediaItem)
            prepare()
            playWhenReady = true
            repeatMode = Player.REPEAT_MODE_OFF
        }
    }
    
    DisposableEffect(exoPlayer) {
        onDispose {
            exoPlayer.release()
        }
    }
    
    Dialog(
        onDismissRequest = onDismiss,
        properties = DialogProperties(
            usePlatformDefaultWidth = false,
            decorFitsSystemWindows = false
        )
    ) {
        Box(
            modifier = modifier
                .fillMaxSize()
                .background(Color.Black)
        ) {
            AndroidView(
                factory = { ctx ->
                    PlayerView(ctx).apply {
                        player = exoPlayer
                        layoutParams = FrameLayout.LayoutParams(
                            ViewGroup.LayoutParams.MATCH_PARENT,
                            ViewGroup.LayoutParams.MATCH_PARENT
                        )
                        useController = true
                    }
                },
                modifier = Modifier.fillMaxSize()
            )
            
            // Bot√£o de fechar
            IconButton(
                onClick = onDismiss,
                modifier = Modifier
                    .align(Alignment.TopEnd)
                    .padding(16.dp)
            ) {
                Icon(
                    imageVector = Icons.Default.Close,
                    contentDescription = "Fechar",
                    tint = Color.White
                )
            }
        }
    }
}


```

## [FRONTEND]: core/design/Icons.kt

```kotlin
package com.taskgoapp.taskgo.core.design

import androidx.annotation.DrawableRes
import androidx.compose.foundation.layout.size
import androidx.compose.material3.Icon
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.R

object TGIcons {
    // Mapeamento usando os √≠cones PNG criados
    @DrawableRes val Home = R.drawable.ic_home
    @DrawableRes val Services = R.drawable.ic_servicos // Corrigido para usar ic_servicos
    @DrawableRes val Products = R.drawable.ic_produtos
    @DrawableRes val Messages = R.drawable.ic_messages
    @DrawableRes val Feed = R.drawable.ic_feed
    @DrawableRes val Profile = R.drawable.ic_perfil
    @DrawableRes val Search = R.drawable.ic_search
    @DrawableRes val Cart = R.drawable.ic_carrinho
    @DrawableRes val Bell = R.drawable.ic_notification // Agora usando o √≠cone correto de notifica√ß√£o
    @DrawableRes val Back = R.drawable.ic_back
    @DrawableRes val Edit = R.drawable.ic_edit // Agora usando o √≠cone correto de editar
    @DrawableRes val Delete = R.drawable.ic_delete // Usando √≠cone correto de deletar
    @DrawableRes val Add = R.drawable.ic_add // Agora usando o √≠cone correto de adicionar
    @DrawableRes val Send = R.drawable.ic_add // Usando √≠cone de adicionar como enviar
    @DrawableRes val Star = R.drawable.ic_star // Agora usando o √≠cone correto de estrela
    @DrawableRes val Check = R.drawable.ic_check
    @DrawableRes val Close = R.drawable.ic_delete // Usando √≠cone de deletar como close
    @DrawableRes val Language = R.drawable.idioma
    @DrawableRes val Privacy = R.drawable.ic_privacidade
    @DrawableRes val Support = R.drawable.ic_suporte
    @DrawableRes val Info = R.drawable.ic_ajuda
    @DrawableRes val Phone = R.drawable.ic_telefone
    @DrawableRes val Pix = R.drawable.ic_pix
    @DrawableRes val PropostaAceita = R.drawable.ic_proposta_aceita
    @DrawableRes val Anuncios = R.drawable.ic_anuncios
    
    // Novos √≠cones adicionados
    @DrawableRes val Time = R.drawable.ic_time // √çcone de tempo para "Tempo no TaskGo"
    @DrawableRes val ManageProposals = R.drawable.ic_gerenciar_proposta // √çcone para "Gerenciar Propostas"
    @DrawableRes val MyOrders = R.drawable.ic_meus_pedidos // √çcone para "Meus Pedidos"
    @DrawableRes val Arrow = R.drawable.ic_arrow // √çcone de seta para "Menu do Perfil"
    
    // Logos principais - j√° existem!
    @DrawableRes val TaskGoLogoVertical = R.drawable.ic_taskgo_logo_vertical
    @DrawableRes val TaskGoLogoHorizontal = R.drawable.ic_taskgo_logo_horizontal
    
    // √çcones de sistema e configura√ß√µes
    @DrawableRes val Settings = R.drawable.ic_configuracoes
    @DrawableRes val Update = R.drawable.ic_atualizacao
    @DrawableRes val Account = R.drawable.ic_conta
    @DrawableRes val MyData = R.drawable.ic_meus_dados
    @DrawableRes val CreditCard = R.drawable.ic_cartao_de_credito
    @DrawableRes val DebitCard = R.drawable.ic_cartao_de_debito
    @DrawableRes val AlterarSenha = R.drawable.alterar_senha
    @DrawableRes val Package = R.drawable.ic_produtos // Using products icon for package
    @DrawableRes val Google = R.drawable.ic_google_logo // Google logo para login
    
    // Banners promocionais
    @DrawableRes val BannerLocalProviders = R.drawable.banner_prestadores_locais // Banner de prestadores locais
    @DrawableRes val BannerDiscountedProducts = R.drawable.banner_produtos_descontos // Banner de produtos com descontos
    @DrawableRes val BannerServiceOrders = R.drawable.banner_ordens_servico // Banner de ordens de servi√ßo
    
    // Tamanhos padr√£o para √≠cones
    object Sizes {
        val Small = 18.dp      // Para √≠cones pequenos em listas
        val Medium = 24.dp     // Tamanho padr√£o (mais usado)
        val Large = 28.dp      // Para √≠cones em top bars
        val ExtraLarge = 32.dp // Para √≠cones grandes
        val Navigation = 24.dp // Para bottom navigation
    }
}

/**
 * Componente helper para √≠cones padronizados com tamanho consistente
 * Garante que todos os √≠cones tenham o mesmo tamanho visual independente do tamanho do arquivo WebP
 */
@Composable
fun TGIcon(
    @DrawableRes iconRes: Int,
    contentDescription: String?,
    modifier: Modifier = Modifier,
    size: Dp = TGIcons.Sizes.Medium,
    tint: Color = Color.Unspecified
) {
    Icon(
        painter = painterResource(id = iconRes),
        contentDescription = contentDescription,
        modifier = modifier.size(size),
        tint = tint
    )
}

```

## [FRONTEND]: core/design/ImageEditor.kt

```kotlin
package com.taskgoapp.taskgo.core.design

import android.net.Uri
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.PickVisualMediaRequest
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.lazy.itemsIndexed
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Close
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import coil.compose.AsyncImage
import com.taskgoapp.taskgo.core.permissions.PermissionHandler
import com.taskgoapp.taskgo.core.permissions.rememberImageReadPermissionLauncher

/**
 * Componente para sele√ß√£o m√∫ltipla de imagens da galeria
 * Remove funcionalidade de corte - apenas sele√ß√£o m√∫ltipla
 */
@Composable
fun ImageEditor(
    selectedImageUris: List<Uri>,
    onImagesChanged: (List<Uri>) -> Unit,
    modifier: Modifier = Modifier,
    maxImages: Int = 5,
    placeholderText: String = "Adicione fotos"
) {
    val context = LocalContext.current
    var pendingGalleryAction by remember { mutableStateOf(false) }
    
    // Verificar permiss√£o de imagem
    val hasImagePermission = remember {
        PermissionHandler.hasImageReadPermission(context)
    }

    // Launcher para galeria m√∫ltipla
    val galleryLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.PickMultipleVisualMedia(maxItems = maxImages)
    ) { uris: List<Uri> ->
        val currentImages = selectedImageUris.toMutableList()
        val availableSlots = maxImages - currentImages.size
        
        // Adicionar novas imagens respeitando o limite
        val newImages = currentImages + uris.take(availableSlots)
        onImagesChanged(newImages.take(maxImages))
    }
    
    // Launcher para permiss√£o de imagem
    val imagePermissionLauncher = rememberImageReadPermissionLauncher(
        onPermissionGranted = {
            pendingGalleryAction = true
        },
        onPermissionDenied = {
            // Permiss√£o negada, n√£o fazer nada
        }
    )
    
    // Executar a√ß√£o da galeria quando permiss√£o for concedida
    LaunchedEffect(pendingGalleryAction) {
        if (pendingGalleryAction && PermissionHandler.hasImageReadPermission(context)) {
            galleryLauncher.launch(PickVisualMediaRequest(ActivityResultContracts.PickVisualMedia.ImageOnly))
            pendingGalleryAction = false
        }
    }

    Column(
        modifier = modifier.fillMaxWidth(),
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        // Grid de imagens selecionadas
        if (selectedImageUris.isNotEmpty()) {
            LazyRow(
                horizontalArrangement = Arrangement.spacedBy(12.dp),
                modifier = Modifier.fillMaxWidth()
            ) {
                itemsIndexed(selectedImageUris) { index, uri ->
                    Box(
                        modifier = Modifier
                            .size(100.dp)
                            .clip(RoundedCornerShape(8.dp))
                    ) {
                        AsyncImage(
                            model = uri,
                            contentDescription = "Imagem selecionada $index",
                            modifier = Modifier.fillMaxSize(),
                            contentScale = ContentScale.Crop
                        )
                        
                        // Bot√£o remover
                        IconButton(
                            onClick = {
                                val newImages = selectedImageUris.toMutableList()
                                newImages.removeAt(index)
                                onImagesChanged(newImages)
                            },
                            modifier = Modifier
                                .align(Alignment.TopEnd)
                                .size(32.dp)
                        ) {
                            Icon(
                                imageVector = androidx.compose.material.icons.Icons.Default.Close,
                                contentDescription = "Remover imagem",
                                tint = MaterialTheme.colorScheme.error,
                                modifier = Modifier.size(20.dp)
                            )
                        }
                    }
                }
            }
        }
        
        // Bot√£o adicionar fotos (se ainda h√° espa√ßo)
        if (selectedImageUris.size < maxImages) {
            OutlinedButton(
                onClick = {
                    if (hasImagePermission) {
                        galleryLauncher.launch(PickVisualMediaRequest(ActivityResultContracts.PickVisualMedia.ImageOnly))
                    } else {
                        imagePermissionLauncher.launch(PermissionHandler.getImageReadPermission())
                    }
                },
                modifier = Modifier.fillMaxWidth()
            ) {
                Icon(
                    imageVector = androidx.compose.material.icons.Icons.Default.Add,
                    contentDescription = null,
                    modifier = Modifier.size(20.dp)
                )
                Spacer(modifier = Modifier.width(8.dp))
                Text(
                    text = if (selectedImageUris.isEmpty()) {
                        placeholderText
                    } else {
                        "Adicionar mais fotos (${selectedImageUris.size}/$maxImages)"
                    }
                )
            }
        } else {
            // Mostrar mensagem quando limite atingido
            Text(
                text = "Limite de $maxImages imagens atingido",
                style = MaterialTheme.typography.bodySmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant,
                modifier = Modifier.fillMaxWidth()
            )
        }
    }
}

```

## [FRONTEND]: core/design/ImageLoaderConfig.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.core.design

import android.content.Context
import coil.ImageLoader
import coil.request.CachePolicy
import coil.util.DebugLogger
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object ImageLoaderConfig {

    @Provides
    @Singleton
    fun provideImageLoader(@ApplicationContext context: Context): ImageLoader {
        return ImageLoader.Builder(context)
            .memoryCachePolicy(CachePolicy.ENABLED)
            .diskCachePolicy(CachePolicy.ENABLED)
            .respectCacheHeaders(false)
            .logger(DebugLogger())
            .build()
    }
}

```

## [FRONTEND]: core/design/ImagePicker.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.core.design

import android.Manifest
import android.content.Context
import android.net.Uri
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import coil.compose.AsyncImage
import coil.request.ImageRequest
import com.taskgoapp.taskgo.core.permissions.PermissionHandler
import com.taskgoapp.taskgo.core.permissions.rememberCameraPermissionLauncher
import com.taskgoapp.taskgo.core.permissions.rememberImageReadPermissionLauncher
import java.io.File

@Composable
fun ImagePicker(
    selectedImageUri: Uri?,
    onImageSelected: (Uri?) -> Unit,
    modifier: Modifier = Modifier,
    placeholderText: String = "Adicione fotos"
) {
    val context = LocalContext.current
    var showImageSourceDialog by remember { mutableStateOf(false) }
    var showPermissionRationale by remember { mutableStateOf(false) }
    var permissionRationaleMessage by remember { mutableStateOf("") }
    
    // URI tempor√°ria para foto da c√¢mera
    var cameraImageUri by remember { mutableStateOf<Uri?>(null) }
    var pendingCameraAction by remember { mutableStateOf(false) }
    
    // Verificar permiss√µes
    val hasCameraPermission = remember {
        PermissionHandler.hasCameraPermission(context)
    }
    val hasImagePermission = remember {
        PermissionHandler.hasImageReadPermission(context)
    }
    
    // Launcher para galeria
    val galleryLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.GetContent()
    ) { uri: Uri? ->
        onImageSelected(uri)
    }

    // Launcher para c√¢mera
    val cameraLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.TakePicture()
    ) { success ->
        if (success) {
            cameraImageUri?.let { onImageSelected(it) }
        }
    }
    
    // Launcher para permiss√£o de c√¢mera
    val cameraPermissionLauncher = rememberCameraPermissionLauncher(
        onPermissionGranted = {
            pendingCameraAction = true
        },
        onPermissionDenied = {
            showPermissionRationale = true
            permissionRationaleMessage = "A permiss√£o da c√¢mera √© necess√°ria para tirar fotos"
        }
    )
    
    // Launcher para permiss√£o de galeria
    val imagePermissionLauncher = rememberImageReadPermissionLauncher(
        onPermissionGranted = {
            galleryLauncher.launch("image/*")
        },
        onPermissionDenied = {
            showPermissionRationale = true
            permissionRationaleMessage = "A permiss√£o de acesso √† galeria √© necess√°ria para selecionar imagens"
        }
    )
    
    // Executar a√ß√£o da c√¢mera quando permiss√£o for concedida
    LaunchedEffect(pendingCameraAction) {
        if (pendingCameraAction && PermissionHandler.hasCameraPermission(context)) {
            val imageFile = File(context.cacheDir, "camera_${System.currentTimeMillis()}.jpg")
            cameraImageUri = Uri.fromFile(imageFile)
            cameraLauncher.launch(cameraImageUri!!)
            pendingCameraAction = false
        }
    }

    Column(
        modifier = modifier.fillMaxWidth(),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text(
            text = placeholderText,
            style = MaterialTheme.typography.bodyMedium,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )
        Spacer(modifier = Modifier.height(8.dp))
        
        Box(
            modifier = Modifier
                .fillMaxWidth()
                .height(160.dp)
                .background(
                    MaterialTheme.colorScheme.surfaceVariant,
                    RoundedCornerShape(12.dp)
                )
                .clickable { showImageSourceDialog = true },
            contentAlignment = Alignment.Center
        ) {
            if (selectedImageUri != null) {
                // Mostrar imagem selecionada
                AsyncImage(
                    model = ImageRequest.Builder(context)
                        .data(selectedImageUri)
                        .crossfade(true)
                        .build(),
                    contentDescription = "Imagem do produto",
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(8.dp),
                    contentScale = ContentScale.Crop
                )
            } else {
                // Mostrar placeholder
                Surface(
                    color = Color.White,
                    shape = RoundedCornerShape(12.dp),
                    tonalElevation = 1.dp
                ) {
                    Box(
                        modifier = Modifier.size(56.dp),
                        contentAlignment = Alignment.Center
                    ) {
                        Text(
                            text = "+",
                            style = MaterialTheme.typography.headlineSmall,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                }
            }
        }
    }

    // Di√°logo para escolher fonte da imagem
    if (showImageSourceDialog) {
        AlertDialog(
            onDismissRequest = { showImageSourceDialog = false },
            title = { Text("Selecionar imagem") },
            text = { Text("Escolha de onde deseja obter a imagem") },
            confirmButton = {
                TextButton(
                    onClick = {
                        showImageSourceDialog = false
                        if (hasImagePermission) {
                            galleryLauncher.launch("image/*")
                        } else {
                            imagePermissionLauncher.launch(PermissionHandler.getImageReadPermission())
                        }
                    }
                ) {
                    Text("Galeria")
                }
            },
            dismissButton = {
                TextButton(
                    onClick = {
                        showImageSourceDialog = false
                        if (hasCameraPermission) {
                            val imageFile = File(context.cacheDir, "camera_${System.currentTimeMillis()}.jpg")
                            cameraImageUri = Uri.fromFile(imageFile)
                            cameraLauncher.launch(cameraImageUri!!)
                        } else {
                            cameraPermissionLauncher.launch(Manifest.permission.CAMERA)
                        }
                    }
                ) {
                    Text("C√¢mera")
                }
            }
        )
    }
    
    // Di√°logo de explica√ß√£o de permiss√£o
    if (showPermissionRationale) {
        AlertDialog(
            onDismissRequest = { showPermissionRationale = false },
            title = { Text("Permiss√£o Necess√°ria") },
            text = { Text(permissionRationaleMessage) },
            confirmButton = {
                TextButton(
                    onClick = { showPermissionRationale = false }
                ) {
                    Text("Entendi")
                }
            }
        )
    }
}

```

## [FRONTEND]: core/design/PasswordStrengthIndicator.kt

```kotlin
package com.taskgoapp.taskgo.core.design

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.LinearProgressIndicator
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.taskgoapp.taskgo.core.theme.TaskGoTextGray
import com.taskgoapp.taskgo.core.validation.PasswordStrength
import com.taskgoapp.taskgo.core.validation.PasswordValidator

/**
 * Componente visual para indicar a for√ßa da senha
 * Exibe uma barra de progresso colorida e texto descritivo
 */
@Composable
fun PasswordStrengthIndicator(
    password: String,
    modifier: Modifier = Modifier
) {
    val validator = PasswordValidator()
    val strength = validator.calculateStrength(password)
    
    if (password.isEmpty()) {
        return // N√£o exibir nada se a senha estiver vazia
    }
    
    Column(
        modifier = modifier.fillMaxWidth(),
        verticalArrangement = Arrangement.spacedBy(4.dp)
    ) {
        // Barra de progresso
        LinearProgressIndicator(
            progress = { getStrengthProgress(strength) },
            modifier = Modifier
                .fillMaxWidth()
                .height(4.dp)
                .clip(RoundedCornerShape(2.dp)),
            color = getStrengthColor(strength),
            trackColor = Color(0xFFE0E0E0)
        )
        
        // Texto descritivo
        Text(
            text = getStrengthText(strength),
            color = getStrengthColor(strength),
            fontSize = 12.sp,
            fontWeight = FontWeight.Medium
        )
    }
}

/**
 * Obt√©m a cor baseada na for√ßa da senha
 */
private fun getStrengthColor(strength: PasswordStrength): Color {
    return when (strength) {
        PasswordStrength.MUITO_FRACA -> Color(0xFFBD0000) // Vermelho (TaskGoError)
        PasswordStrength.FRACA -> Color(0xFFFF9800) // Laranja
        PasswordStrength.MEDIA -> Color(0xFFFFEE00) // Amarelo (TaskGoWarning)
        PasswordStrength.FORTE -> Color(0xFF49E985) // Verde claro (TaskGoGreenLight)
        PasswordStrength.MUITO_FORTE -> Color(0xFF00BD48) // Verde (TaskGoGreen)
    }
}

/**
 * Obt√©m o progresso (0.0 a 1.0) baseado na for√ßa da senha
 */
private fun getStrengthProgress(strength: PasswordStrength): Float {
    return when (strength) {
        PasswordStrength.MUITO_FRACA -> 0.2f
        PasswordStrength.FRACA -> 0.4f
        PasswordStrength.MEDIA -> 0.6f
        PasswordStrength.FORTE -> 0.8f
        PasswordStrength.MUITO_FORTE -> 1.0f
    }
}

/**
 * Obt√©m o texto descritivo baseado na for√ßa da senha
 */
private fun getStrengthText(strength: PasswordStrength): String {
    return when (strength) {
        PasswordStrength.MUITO_FRACA -> "Senha muito fraca"
        PasswordStrength.FRACA -> "Senha fraca"
        PasswordStrength.MEDIA -> "Senha m√©dia"
        PasswordStrength.FORTE -> "Senha forte"
        PasswordStrength.MUITO_FORTE -> "Senha muito forte"
    }
}


```

## [FRONTEND]: core/design/review/DesignReviewScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.core.design.review

import androidx.compose.foundation.ExperimentalFoundationApi
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.alpha
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.R

data class RouteSpec(
    val name: String,
    val route: String,
    val drawableRes: Int
)

@OptIn(ExperimentalFoundationApi::class, ExperimentalMaterial3Api::class)
@Composable
fun DesignReviewScreen(
    onNavigateToRoute: (String) -> Unit,
    onBackPressed: () -> Unit
) {
    var selectedScreenshot by remember { mutableStateOf(screenshots.first()) }
    var overlayEnabled by remember { mutableStateOf(DesignReviewState.overlayEnabled) }
    var overlayAlpha by remember { mutableStateOf(DesignReviewState.overlayAlpha) }
    var gridEnabled by remember { mutableStateOf(DesignReviewState.gridEnabled) }
    
    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Design Review") },
                navigationIcon = {
                    IconButton(onClick = onBackPressed) {
                        Icon(
                            painter = painterResource(R.drawable.ic_back),
                            contentDescription = "Voltar"
                        )
                    }
                }
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp)
        ) {
            // Controls
            Card(
                modifier = Modifier.fillMaxWidth(),
                colors = CardDefaults.cardColors(
                    containerColor = MaterialTheme.colorScheme.surfaceContainer
                )
            ) {
                Column(
                    modifier = Modifier.padding(16.dp),
                    verticalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    Text(
                        text = "Selecionar Screenshot",
                        style = MaterialTheme.typography.titleMedium
                    )
                    // Overlay toggles
                    Row(verticalAlignment = Alignment.CenterVertically) {
                        Checkbox(checked = overlayEnabled, onCheckedChange = {
                            overlayEnabled = it
                            DesignReviewState.overlayEnabled = it
                            if (it) DesignReviewState.overlayScreenshotRes = selectedScreenshot.drawableRes
                        })
                        Spacer(Modifier.width(8.dp))
                        Text("Ativar overlay global")
                    }
                    Row(verticalAlignment = Alignment.CenterVertically) {
                        Checkbox(checked = gridEnabled, onCheckedChange = {
                            gridEnabled = it
                            DesignReviewState.gridEnabled = it
                        })
                        Spacer(Modifier.width(8.dp))
                        Text("Mostrar grade de 8dp")
                    }
                    
                    // Alpha Slider
                    if (overlayEnabled) {
                        Column {
                            Text(
                                text = "Opacidade: ${(overlayAlpha * 100).toInt()}%",
                                style = MaterialTheme.typography.bodyMedium
                            )
                            Slider(
                                value = overlayAlpha,
                                onValueChange = { overlayAlpha = it },
                                valueRange = 0f..1f,
                                modifier = Modifier.fillMaxWidth()
                            )
                            // Persist state globally
                            LaunchedEffect(overlayAlpha) {
                                DesignReviewState.overlayAlpha = overlayAlpha
                            }
                        }
                    }
                    
                    // Navigation Button
                    Button(
                        onClick = { onNavigateToRoute(selectedScreenshot.route) },
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Text("Abrir UI Alvo: ${selectedScreenshot.name}")
                    }
                }
            }
            
            Spacer(modifier = Modifier.height(16.dp))
            
            // Screenshot List
            Text(
                text = "Screenshots Dispon√≠veis",
                style = MaterialTheme.typography.titleMedium
            )
            
            Spacer(modifier = Modifier.height(8.dp))
            
            LazyColumn(
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                items(screenshots) { screenshot ->
                    ScreenshotItem(
                        screenshot = screenshot,
                        isSelected = selectedScreenshot == screenshot,
                        onClick = {
                            selectedScreenshot = screenshot
                            if (overlayEnabled) {
                                DesignReviewState.overlayScreenshotRes = screenshot.drawableRes
                            }
                        }
                    )
                }
            }
        }
    }
}

@Composable
fun ScreenshotItem(
    screenshot: RouteSpec,
    isSelected: Boolean,
    onClick: () -> Unit
) {
    Card(
        onClick = onClick,
        modifier = Modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(
            containerColor = if (isSelected) 
                MaterialTheme.colorScheme.primaryContainer 
            else 
                MaterialTheme.colorScheme.surface
        )
    ) {
        Row(
            modifier = Modifier.padding(12.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Image(
                painter = painterResource(screenshot.drawableRes),
                contentDescription = screenshot.name,
                modifier = Modifier
                    .size(60.dp)
                    .background(Color.LightGray),
                contentScale = ContentScale.Crop
            )
            
            Spacer(modifier = Modifier.width(12.dp))
            
            Column {
                Text(
                    text = screenshot.name,
                    style = MaterialTheme.typography.titleSmall
                )
                Text(
                    text = screenshot.route,
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
        }
    }
}

@Composable
fun OverlayCompare(
    ui: @Composable () -> Unit,
    screenshotRes: Int,
    alpha: Float
) {
    Box(modifier = Modifier.fillMaxSize()) {
        ui()
        Image(
            painter = painterResource(screenshotRes),
            contentDescription = "Screenshot overlay",
            modifier = Modifier
                .fillMaxSize()
                .alpha(alpha),
            contentScale = ContentScale.FillBounds
        )
    }
}

val screenshots = listOf(
    RouteSpec("In√≠cio", "home", R.drawable.inicio),
    RouteSpec("Servi√ßos", "services", R.drawable.criar_ordem_de_servico),
    RouteSpec("Produtos", "products", R.drawable.gerencie_seus_produtos),
    RouteSpec("Mensagens", "messages", R.drawable.mensagens),
    RouteSpec("Perfil", "profile", R.drawable.meus_dados),
    RouteSpec("Configura√ß√µes", "settings", R.drawable.configuracoes),
    RouteSpec("Carrinho", "cart", R.drawable.carrinho_1),
    RouteSpec("Finalizar Pedido", "checkout", R.drawable.finalizar_pedido),
    RouteSpec("Detalhes do Produto", "productDetail", R.drawable.detalhes_do_produto_1),
    RouteSpec("Detalhes da Proposta", "proposalDetail", R.drawable.detalhes_da_proposta_1),
    RouteSpec("Meus Pedidos", "myOrders", R.drawable.meus_pedidos_em_andamento),
    RouteSpec("Notifica√ß√µes", "notifications", R.drawable.notificacoes),
    RouteSpec("Cadastro", "signup", R.drawable.cadastro),
    RouteSpec("Login Loja", "loginStore", R.drawable.login_loja),
    RouteSpec("An√∫ncios", "ads", R.drawable.anuncios),
    RouteSpec("Cart√£o de Cr√©dito", "paymentMethod", R.drawable.cartao_de_credito),
    RouteSpec("Confirmar Proposta", "confirmProposal", R.drawable.confirmar_proposta_1),
    RouteSpec("Confirmar Pix", "confirmPix", R.drawable.confirmacao_pix),
    RouteSpec("Cadastrar Endere√ßo", "addressBook", R.drawable.cadastrar_endereco),
    RouteSpec("Idioma", "language", R.drawable.idioma),
    RouteSpec("Conta", "account", R.drawable.conta),
    RouteSpec("Minhas Avalia√ß√µes", "myReviews", R.drawable.minhas_avaliacoes),
    RouteSpec("Hist√≥rico de Servi√ßos", "serviceHistory", R.drawable.historico_de_servicos),
    RouteSpec("Alterar Senha", "changePassword", R.drawable.alterar_senha),
    RouteSpec("Avaliar Prestador", "rateProvider", R.drawable.avaliar_prestador)
)

```

## [FRONTEND]: core/design/review/DesignReviewState.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.core.design.review

import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.setValue

object DesignReviewState {
    var overlayEnabled by mutableStateOf(false)
    var overlayAlpha by mutableStateOf(0.5f)
    var overlayScreenshotRes by mutableStateOf<Int?>(null)
    var gridEnabled by mutableStateOf(false)
}





```

## [FRONTEND]: core/design/reviews/ReviewComponents.kt

```kotlin
package com.taskgoapp.taskgo.core.design.reviews

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Star
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.core.theme.*

/**
 * Componente de estrelas de avalia√ß√£o interativo
 */
@Composable
fun RatingStars(
    rating: Int,
    onRatingChange: (Int) -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    starSize: androidx.compose.ui.unit.Dp = 32.dp
) {
    Row(
        modifier = modifier,
        horizontalArrangement = Arrangement.spacedBy(4.dp)
    ) {
        (1..5).forEach { index ->
            Icon(
                imageVector = Icons.Default.Star,
                contentDescription = "Estrela $index",
                modifier = Modifier
                    .size(starSize)
                    .then(
                        if (enabled) {
                            Modifier.clickable { onRatingChange(index) }
                        } else {
                            Modifier
                        }
                    ),
                tint = if (index <= rating) Color(0xFFFFD700) else Color.Gray.copy(alpha = 0.3f)
            )
        }
    }
}

/**
 * Componente de estrelas de avalia√ß√£o apenas para exibi√ß√£o
 */
@Composable
fun RatingStarsDisplay(
    rating: Double,
    modifier: Modifier = Modifier,
    starSize: androidx.compose.ui.unit.Dp = 16.dp,
    showRating: Boolean = true
) {
    Row(
        modifier = modifier,
        horizontalArrangement = Arrangement.spacedBy(2.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        val fullStars = rating.toInt()
        val hasHalfStar = rating - fullStars >= 0.5
        
        (1..5).forEach { index ->
            Icon(
                imageVector = Icons.Default.Star,
                contentDescription = null,
                modifier = Modifier.size(starSize),
                tint = when {
                    index <= fullStars -> Color(0xFFFFD700)
                    index == fullStars + 1 && hasHalfStar -> Color(0xFFFFD700).copy(alpha = 0.5f)
                    else -> Color.Gray.copy(alpha = 0.3f)
                }
            )
        }
        
        if (showRating) {
            Spacer(modifier = Modifier.width(4.dp))
            Text(
                text = String.format("%.1f", rating),
                style = MaterialTheme.typography.bodyMedium,
                color = TaskGoTextGray,
                fontWeight = FontWeight.Medium
            )
        }
    }
}

/**
 * Card de avalia√ß√£o individual
 */
@Composable
fun ReviewCard(
    review: com.taskgoapp.taskgo.core.model.Review,
    onHelpfulClick: (() -> Unit)? = null,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(defaultElevation = 1.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            // Header: Avatar, nome, data e verifica√ß√£o
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Row(
                    horizontalArrangement = Arrangement.spacedBy(12.dp),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    // Avatar
                    Box(
                        modifier = Modifier
                            .size(40.dp)
                            .clip(CircleShape)
                            .background(TaskGoSurfaceGray),
                        contentAlignment = Alignment.Center
                    ) {
                        Text(
                            text = review.reviewerName.take(1).uppercase(),
                            style = MaterialTheme.typography.titleMedium,
                            color = TaskGoTextGray
                        )
                    }
                    
                    Column {
                        Row(
                            verticalAlignment = Alignment.CenterVertically,
                            horizontalArrangement = Arrangement.spacedBy(4.dp)
                        ) {
                            Text(
                                text = review.reviewerName,
                                style = MaterialTheme.typography.bodyLarge,
                                fontWeight = FontWeight.Bold,
                                color = TaskGoTextBlack
                            )
                            if (review.verifiedPurchase) {
                                Badge(
                                    containerColor = TaskGoGreen.copy(alpha = 0.2f),
                                    contentColor = TaskGoGreen
                                ) {
                                    Text(
                                        text = "Compra verificada",
                                        style = MaterialTheme.typography.labelSmall
                                    )
                                }
                            }
                        }
                        Text(
                            text = formatDate(review.createdAt),
                            style = MaterialTheme.typography.bodySmall,
                            color = TaskGoTextGray
                        )
                    }
                }
                
                // Rating
                RatingStarsDisplay(
                    rating = review.rating.toDouble(),
                    starSize = 16.dp,
                    showRating = false
                )
            }
            
            // Coment√°rio
            review.comment?.let { comment ->
                Text(
                    text = comment,
                    style = MaterialTheme.typography.bodyMedium,
                    color = TaskGoTextBlack
                )
            }
            
            // Fotos (se houver)
            if (review.photoUrls.isNotEmpty()) {
                Row(
                    horizontalArrangement = Arrangement.spacedBy(8.dp),
                    modifier = Modifier.fillMaxWidth()
                ) {
                    review.photoUrls.take(3).forEach { photoUrl ->
                        // Placeholder para imagem - em produ√ß√£o, usar AsyncImage
                        Box(
                            modifier = Modifier
                                .size(80.dp)
                                .clip(MaterialTheme.shapes.small)
                                .background(TaskGoSurfaceGray)
                        )
                    }
                }
            }
            
            // Footer: √ötil
            if (onHelpfulClick != null) {
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    TextButton(onClick = onHelpfulClick) {
                        Text(
                            text = "√ötil (${review.helpfulCount})",
                            style = MaterialTheme.typography.bodySmall,
                            color = TaskGoTextGray
                        )
                    }
                }
            }
        }
    }
}

/**
 * Resumo de avalia√ß√µes com distribui√ß√£o
 */
@Composable
fun ReviewSummaryCard(
    summary: com.taskgoapp.taskgo.core.model.ReviewSummary,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // M√©dia e total
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Column {
                    Text(
                        text = String.format("%.1f", summary.averageRating),
                        style = MaterialTheme.typography.displaySmall,
                        fontWeight = FontWeight.Bold,
                        color = TaskGoTextBlack
                    )
                    RatingStarsDisplay(
                        rating = summary.averageRating,
                        starSize = 20.dp,
                        showRating = false
                    )
                }
                Text(
                    text = "${summary.totalReviews} avalia√ß√µes",
                    style = MaterialTheme.typography.bodyLarge,
                    color = TaskGoTextGray
                )
            }
            
            // Distribui√ß√£o de avalia√ß√µes
            if (summary.ratingDistribution.isNotEmpty()) {
                Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
                    (5 downTo 1).forEach { stars ->
                        val count = summary.ratingDistribution[stars] ?: 0
                        val percentage = if (summary.totalReviews > 0) {
                            (count.toFloat() / summary.totalReviews.toFloat()) * 100f
                        } else 0f
                        
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            verticalAlignment = Alignment.CenterVertically,
                            horizontalArrangement = Arrangement.spacedBy(8.dp)
                        ) {
                            Text(
                                text = "$stars",
                                style = MaterialTheme.typography.bodySmall,
                                color = TaskGoTextGray,
                                modifier = Modifier.width(16.dp)
                            )
                            Icon(
                                imageVector = Icons.Default.Star,
                                contentDescription = null,
                                tint = Color(0xFFFFD700),
                                modifier = Modifier.size(12.dp)
                            )
                            LinearProgressIndicator(
                                progress = { percentage / 100f },
                                modifier = Modifier
                                    .weight(1f)
                                    .height(8.dp),
                                color = Color(0xFFFFD700),
                                trackColor = Color.Gray.copy(alpha = 0.2f)
                            )
                            Text(
                                text = "$count",
                                style = MaterialTheme.typography.bodySmall,
                                color = TaskGoTextGray,
                                modifier = Modifier.width(24.dp)
                            )
                        }
                    }
                }
            }
        }
    }
}

private fun formatDate(timestamp: Long): String {
    val now = System.currentTimeMillis()
    val diff = now - timestamp
    
    return when {
        diff < 60_000 -> "Agora"
        diff < 3_600_000 -> "${diff / 60_000} min atr√°s"
        diff < 86_400_000 -> "${diff / 3_600_000} h atr√°s"
        diff < 2_592_000_000 -> "${diff / 86_400_000} dias atr√°s"
        else -> {
            val date = java.util.Date(timestamp)
            val format = java.text.SimpleDateFormat("dd/MM/yyyy", java.util.Locale("pt", "BR"))
            format.format(date)
        }
    }
}


```

## [FRONTEND]: core/design/reviews/ReviewsSectionCompact.kt

```kotlin
package com.taskgoapp.taskgo.core.design.reviews

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowForward
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.collectAsState
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.taskgoapp.taskgo.core.model.ReviewType
import com.taskgoapp.taskgo.core.theme.*
import com.taskgoapp.taskgo.feature.reviews.presentation.ReviewsViewModel

/**
 * Componente compacto de avalia√ß√µes para telas de detalhes
 */
@Composable
fun ReviewsSectionCompact(
    targetId: String,
    type: ReviewType,
    onNavigateToReviews: () -> Unit,
    modifier: Modifier = Modifier
) {
    val viewModel: ReviewsViewModel = hiltViewModel()
    val uiState by viewModel.uiState.collectAsState()
    
    LaunchedEffect(targetId, type) {
        viewModel.loadReviews(targetId, type)
    }
    
    Card(
        modifier = modifier
            .fillMaxWidth()
            .clickable { onNavigateToReviews() },
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Column {
                    Text(
                        text = "Avalia√ß√µes",
                        style = FigmaProductName,
                        color = TaskGoTextBlack,
                        fontWeight = FontWeight.Bold
                    )
                    if (uiState.summary.totalReviews > 0) {
                        Row(
                            verticalAlignment = Alignment.CenterVertically,
                            horizontalArrangement = Arrangement.spacedBy(8.dp)
                        ) {
                            RatingStarsDisplay(
                                rating = uiState.summary.averageRating,
                                starSize = 16.dp,
                                showRating = true
                            )
                            Text(
                                text = "(${uiState.summary.totalReviews})",
                                style = FigmaProductDescription,
                                color = TaskGoTextGray
                            )
                        }
                    } else {
                        Text(
                            text = "Nenhuma avalia√ß√£o ainda",
                            style = FigmaProductDescription,
                            color = TaskGoTextGray
                        )
                    }
                }
                
                Icon(
                    imageVector = Icons.AutoMirrored.Filled.ArrowForward,
                    contentDescription = "Ver todas as avalia√ß√µes",
                    tint = TaskGoTextGray
                )
            }
            
            // Mostrar algumas avalia√ß√µes recentes
            if (uiState.reviews.isNotEmpty()) {
                Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
                    uiState.reviews.take(2).forEach { review ->
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.SpaceBetween,
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Column(modifier = Modifier.weight(1f)) {
                                Text(
                                    text = review.reviewerName,
                                    style = FigmaStatusText,
                                    color = TaskGoTextBlack,
                                    fontWeight = FontWeight.Medium
                                )
                                review.comment?.let { comment ->
                                    Text(
                                        text = comment.take(80) + if (comment.length > 80) "..." else "",
                                        style = FigmaProductDescription,
                                        color = TaskGoTextGray,
                                        maxLines = 2
                                    )
                                }
                            }
                            RatingStarsDisplay(
                                rating = review.rating.toDouble(),
                                starSize = 12.dp,
                                showRating = false
                            )
                        }
                        if (review != uiState.reviews.take(2).last()) {
                            HorizontalDivider(color = TaskGoDivider)
                        }
                    }
                }
            }
        }
    }
}


```

## [FRONTEND]: core/design/SearchBar.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.core.design

import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.text.KeyboardActions
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Search
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.OutlinedTextFieldDefaults
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.R
import com.taskgoapp.taskgo.core.theme.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun SearchBar(
    query: String,
    onQueryChange: (String) -> Unit,
    placeholder: String = stringResource(R.string.action_search),
    modifier: Modifier = Modifier,
    onSearch: (() -> Unit)? = null
) {
    OutlinedTextField(
        value = query,
        onValueChange = onQueryChange,
        placeholder = { 
            Text(
                text = placeholder,
                style = FigmaPlaceholder,
                color = TaskGoTextGrayPlaceholder
            ) 
        },
        leadingIcon = {
            Icon(
                imageVector = Icons.Default.Search,
                contentDescription = stringResource(R.string.action_search),
                tint = TaskGoTextGray
            )
        },
        keyboardOptions = KeyboardOptions(
            imeAction = ImeAction.Search
        ),
        keyboardActions = KeyboardActions(
            onSearch = { onSearch?.invoke() }
        ),
        singleLine = true,
        colors = OutlinedTextFieldDefaults.colors(
            focusedBorderColor = TaskGoGreen,
            unfocusedBorderColor = TaskGoBorder,
            focusedTextColor = TaskGoTextBlack,
            unfocusedTextColor = TaskGoTextBlack,
            focusedPlaceholderColor = TaskGoTextGrayPlaceholder,
            unfocusedPlaceholderColor = TaskGoTextGrayPlaceholder
        ),
        modifier = modifier
            .fillMaxWidth()
            .padding(16.dp)
    )
}

```

## [FRONTEND]: core/design/SimpleImageCropper.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.core.design

import android.net.Uri
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import com.canhub.cropper.CropImageContract
import com.canhub.cropper.CropImageContractOptions
import com.taskgoapp.taskgo.core.permissions.PermissionHandler
import com.taskgoapp.taskgo.core.permissions.rememberImageReadPermissionLauncher

@Composable
fun SimpleImageCropper(
    onImageCropped: (Uri) -> Unit,
    onCancel: () -> Unit = {},
    modifier: Modifier = Modifier
) {
    val context = LocalContext.current
    var pendingImagePickerAction by remember { mutableStateOf(false) }
    
    val hasImagePermission = remember {
        PermissionHandler.hasImageReadPermission(context)
    }
    
    val cropImageLauncher = rememberLauncherForActivityResult(
        contract = CropImageContract()
    ) { result ->
        if (result.isSuccessful) {
            result.uriContent?.let { croppedUri ->
                onImageCropped(croppedUri)
            }
        } else {
            onCancel()
        }
    }
    
    val imagePicker = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.GetContent()
    ) { uri: Uri? ->
        uri?.let { 
            // Abrir diretamente o cropper com a imagem selecionada
            cropImageLauncher.launch(
                CropImageContractOptions(
                    uri = it,
                    cropImageOptions = CropImageConfig.createDefaultOptions()
                )
            )
        } ?: run {
            onCancel()
        }
    }
    
    val imagePermissionLauncher = rememberImageReadPermissionLauncher(
        onPermissionGranted = {
            pendingImagePickerAction = true
        },
        onPermissionDenied = {
            onCancel()
        }
    )
    
    // Executar a√ß√£o do imagePicker quando permiss√£o for concedida
    LaunchedEffect(pendingImagePickerAction) {
        if (pendingImagePickerAction && PermissionHandler.hasImageReadPermission(context)) {
            imagePicker.launch("image/*")
            pendingImagePickerAction = false
        }
    }

    // Abrir galeria automaticamente quando o composable for criado
    LaunchedEffect(Unit) {
        if (hasImagePermission) {
            imagePicker.launch("image/*")
        } else {
            imagePermissionLauncher.launch(PermissionHandler.getImageReadPermission())
        }
    }
}

```

## [FRONTEND]: core/design/TextFieldHelper.kt

```kotlin
package com.taskgoapp.taskgo.core.design

import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.text.BasicTextField
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.OutlinedTextFieldDefaults
import androidx.compose.material3.TextFieldColors
import androidx.compose.material3.TextFieldDefaults
import androidx.compose.runtime.Composable
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Shape
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.input.TextFieldValue
import androidx.compose.ui.text.input.VisualTransformation
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.core.theme.TaskGoGreen
import com.taskgoapp.taskgo.core.theme.TaskGoTextGray

@Composable
private fun OutlinedTextFieldString(
    value: String,
    onValueChange: (String) -> Unit,
    modifier: Modifier,
    label: @Composable (() -> Unit)?,
    placeholder: @Composable (() -> Unit)?,
    singleLine: Boolean,
    enabled: Boolean,
    readOnly: Boolean,
    keyboardOptions: KeyboardOptions?,
    maxLines: Int,
    minLines: Int,
    isError: Boolean,
    supportingText: @Composable (() -> Unit)?,
    visualTransformation: VisualTransformation,
    trailingIcon: @Composable (() -> Unit)?,
    colors: TextFieldColors,
    shape: Shape,
    @Suppress("UNUSED_PARAMETER") contentPadding: PaddingValues
) {
    val interactionSource = remember { MutableInteractionSource() }
    OutlinedTextField(
        value = value,
        onValueChange = onValueChange,
        modifier = modifier,
        enabled = enabled,
        readOnly = readOnly,
        label = label,
        placeholder = placeholder,
        trailingIcon = trailingIcon,
        supportingText = supportingText,
        isError = isError,
        visualTransformation = visualTransformation,
        keyboardOptions = keyboardOptions ?: KeyboardOptions.Default,
        interactionSource = interactionSource,
        singleLine = singleLine,
        maxLines = maxLines,
        minLines = minLines,
        shape = shape,
        colors = colors
    )
}

@Composable
private fun OutlinedTextFieldValue(
    value: TextFieldValue,
    onValueChange: (TextFieldValue) -> Unit,
    modifier: Modifier,
    label: @Composable (() -> Unit)?,
    placeholder: @Composable (() -> Unit)?,
    singleLine: Boolean,
    enabled: Boolean,
    readOnly: Boolean,
    keyboardOptions: KeyboardOptions?,
    maxLines: Int,
    minLines: Int,
    isError: Boolean,
    supportingText: @Composable (() -> Unit)?,
    trailingIcon: @Composable (() -> Unit)?,
    colors: TextFieldColors,
    shape: Shape,
    @Suppress("UNUSED_PARAMETER") contentPadding: PaddingValues
) {
    val interactionSource = remember { MutableInteractionSource() }
    OutlinedTextField(
        value = value,
        onValueChange = onValueChange,
        modifier = modifier,
        enabled = enabled,
        readOnly = readOnly,
        label = label,
        placeholder = placeholder,
        trailingIcon = trailingIcon,
        supportingText = supportingText,
        isError = isError,
        visualTransformation = VisualTransformation.None,
        keyboardOptions = keyboardOptions ?: KeyboardOptions.Default,
        interactionSource = interactionSource,
        singleLine = singleLine,
        maxLines = maxLines,
        minLines = minLines,
        shape = shape,
        colors = colors
    )
}

/**
 * Helper para criar OutlinedTextField com √°rea de texto aumentada
 * Aumenta o contentPadding interno para que o texto n√£o apare√ßa cortado
 */
@Composable
fun EnhancedOutlinedTextField(
    value: String,
    onValueChange: (String) -> Unit,
    modifier: Modifier = Modifier,
    label: @Composable (() -> Unit)? = null,
    placeholder: @Composable (() -> Unit)? = null,
    singleLine: Boolean = false,
    enabled: Boolean = true,
    readOnly: Boolean = false,
    keyboardType: KeyboardType = KeyboardType.Text,
    keyboardOptions: KeyboardOptions? = null,
    maxLines: Int = if (singleLine) 1 else Int.MAX_VALUE,
    minLines: Int = if (singleLine) 1 else 1,
    isError: Boolean = false,
    supportingText: @Composable (() -> Unit)? = null,
    visualTransformation: VisualTransformation = VisualTransformation.None,
    trailingIcon: @Composable (() -> Unit)? = null
) {
    OutlinedTextFieldString(
        value = value,
        onValueChange = onValueChange,
        modifier = modifier,
        label = label,
        placeholder = placeholder,
        singleLine = singleLine,
        enabled = enabled,
        readOnly = readOnly,
        keyboardOptions = keyboardOptions ?: KeyboardOptions(keyboardType = keyboardType),
        maxLines = maxLines,
        minLines = minLines,
        isError = isError,
        supportingText = supportingText,
        visualTransformation = visualTransformation,
        trailingIcon = trailingIcon,
        colors = OutlinedTextFieldDefaults.colors(
            focusedBorderColor = if (isError) MaterialTheme.colorScheme.error else TaskGoGreen,
            unfocusedBorderColor = if (isError) MaterialTheme.colorScheme.error else TaskGoTextGray,
            focusedLabelColor = TaskGoTextGray,
            unfocusedLabelColor = TaskGoTextGray,
            cursorColor = TaskGoGreen
        ),
        shape = RoundedCornerShape(8.dp),
        contentPadding = PaddingValues(horizontal = 16.dp, vertical = 20.dp)
    )
}

/**
 * Helper para criar OutlinedTextField com TextFieldValue (para campos formatados)
 */
@Composable
fun OutlinedTextFieldWithValue(
    value: TextFieldValue,
    onValueChange: (TextFieldValue) -> Unit,
    modifier: Modifier = Modifier,
    label: @Composable (() -> Unit)? = null,
    placeholder: @Composable (() -> Unit)? = null,
    singleLine: Boolean = false,
    enabled: Boolean = true,
    readOnly: Boolean = false,
    keyboardOptions: KeyboardOptions? = null,
    maxLines: Int = if (singleLine) 1 else Int.MAX_VALUE,
    minLines: Int = if (singleLine) 1 else 1,
    isError: Boolean = false,
    supportingText: @Composable (() -> Unit)? = null,
    trailingIcon: @Composable (() -> Unit)? = null,
    shape: Shape = RoundedCornerShape(8.dp),
    colors: TextFieldColors? = null,
    contentPadding: PaddingValues = PaddingValues(horizontal = 16.dp, vertical = 20.dp)
) {
    OutlinedTextFieldValue(
        value = value,
        onValueChange = onValueChange,
        modifier = modifier,
        label = label,
        placeholder = placeholder,
        singleLine = singleLine,
        enabled = enabled,
        readOnly = readOnly,
        keyboardOptions = keyboardOptions,
        maxLines = maxLines,
        minLines = minLines,
        isError = isError,
        supportingText = supportingText,
        trailingIcon = trailingIcon,
        colors = colors ?: OutlinedTextFieldDefaults.colors(
            focusedBorderColor = if (isError) MaterialTheme.colorScheme.error else TaskGoGreen,
            unfocusedBorderColor = if (isError) MaterialTheme.colorScheme.error else TaskGoTextGray,
            focusedLabelColor = TaskGoTextGray,
            unfocusedLabelColor = TaskGoTextGray,
            cursorColor = TaskGoGreen
        ),
        shape = shape,
        contentPadding = contentPadding
    )
}

```

## [FRONTEND]: core/design/UserAvatarName.kt

```kotlin
package com.taskgoapp.taskgo.core.design

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Person
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import coil.compose.AsyncImage
import coil.request.ImageRequest
import com.taskgoapp.taskgo.core.theme.TaskGoTextBlack
import com.taskgoapp.taskgo.core.theme.TaskGoTextGray

/**
 * Componente reutiliz√°vel para exibir avatar e nome do usu√°rio
 * Recebe userName e userPhotoUrl como par√¢metros (carregamento deve ser feito pelo caller)
 */
@Composable
fun UserAvatarName(
    userName: String? = null,
    userPhotoUrl: String? = null,
    onUserClick: (() -> Unit)? = null,
    modifier: Modifier = Modifier,
    avatarSize: androidx.compose.ui.unit.Dp = 40.dp,
    showName: Boolean = true
) {
    Row(
        modifier = modifier
            .then(if (onUserClick != null) Modifier.clickable { onUserClick() } else Modifier),
        verticalAlignment = Alignment.CenterVertically,
        horizontalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        // Avatar
        if (!userPhotoUrl.isNullOrBlank()) {
            AsyncImage(
                model = ImageRequest.Builder(LocalContext.current)
                    .data(userPhotoUrl)
                    .crossfade(true)
                    .build(),
                contentDescription = "Avatar do usu√°rio",
                modifier = Modifier
                    .size(avatarSize)
                    .clip(CircleShape),
                contentScale = ContentScale.Crop
            )
        } else {
            Box(
                modifier = Modifier
                    .size(avatarSize)
                    .clip(CircleShape)
                    .background(Color.Gray.copy(alpha = 0.2f)),
                contentAlignment = Alignment.Center
            ) {
                Icon(
                    imageVector = Icons.Default.Person,
                    contentDescription = "Avatar do usu√°rio",
                    modifier = Modifier.size(avatarSize * 0.6f),
                    tint = Color.Gray
                )
            }
        }
        
        // Nome (se habilitado)
        if (showName && userName != null) {
            Text(
                text = userName,
                style = MaterialTheme.typography.bodyMedium,
                fontWeight = FontWeight.Medium,
                color = TaskGoTextBlack,
                maxLines = 1
            )
        }
    }
}



```

## [FRONTEND]: core/design/UserAvatarNameLoader.kt

```kotlin
package com.taskgoapp.taskgo.core.design

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import coil.compose.AsyncImage
import coil.request.ImageRequest
import com.taskgoapp.taskgo.core.theme.TaskGoTextBlack
import com.taskgoapp.taskgo.data.repository.FirestoreUserRepository
import com.google.firebase.firestore.FirebaseFirestore
import kotlinx.coroutines.launch

/**
 * Componente reutiliz√°vel para exibir avatar e nome do usu√°rio
 * Carrega automaticamente os dados do usu√°rio pelo userId usando FirestoreUserRepository
 */
@Composable
fun UserAvatarNameLoader(
    userId: String?,
    onUserClick: (() -> Unit)? = null,
    modifier: Modifier = Modifier,
    avatarSize: androidx.compose.ui.unit.Dp = 40.dp,
    showName: Boolean = true
) {
    val userRepository = remember {
        FirestoreUserRepository(com.taskgoapp.taskgo.core.firebase.FirestoreHelper.getInstance())
    }
    
    var userName by remember { mutableStateOf<String?>(null) }
    var userPhotoUrl by remember { mutableStateOf<String?>(null) }
    val scope = rememberCoroutineScope()
    
    LaunchedEffect(userId) {
        if (userId != null && userId.isNotBlank()) {
            scope.launch {
                try {
                    var user = userRepository.getUser(userId)
                    // Se n√£o encontrou, tentar novamente ap√≥s um delay (pode ser que a Cloud Function ainda n√£o tenha criado)
                    if (user == null) {
                        kotlinx.coroutines.delay(1000)
                        user = userRepository.getUser(userId)
                    }
                    userName = user?.displayName
                    userPhotoUrl = user?.photoURL
                    android.util.Log.d("UserAvatarNameLoader", "Usu√°rio carregado: ${user?.displayName}, foto: ${user?.photoURL != null}")
                } catch (e: Exception) {
                    android.util.Log.e("UserAvatarNameLoader", "Erro ao carregar usu√°rio: ${e.message}", e)
                }
            }
        }
    }
    
    UserAvatarName(
        userName = userName,
        userPhotoUrl = userPhotoUrl,
        onUserClick = onUserClick,
        modifier = modifier,
        avatarSize = avatarSize,
        showName = showName
    )
}



```

# Core - error


## [FRONTEND]: core/error/FirestoreExceptionHandler.kt

```kotlin
package com.taskgoapp.taskgo.core.error

import android.util.Log
import com.google.firebase.firestore.FirebaseFirestoreException
import kotlinx.coroutines.CoroutineExceptionHandler

object FirestoreExceptionHandler {
    private const val TAG = "FirestoreExceptionHandler"
    const val DEFAULT_TAG = "FirestoreExceptionHandler"
    
    /**
     * Handler global para exce√ß√µes do Firestore em corrotinas
     * Previne crashes quando h√° erros de permiss√£o ou outros erros do Firestore
     */
    val coroutineExceptionHandler = CoroutineExceptionHandler { context, exception ->
        when (exception) {
            is FirebaseFirestoreException -> {
                when (exception.code) {
                    FirebaseFirestoreException.Code.PERMISSION_DENIED -> {
                        Log.w(TAG, "Permiss√£o negada no Firestore: ${exception.message}")
                        // N√£o crashar o app, apenas logar
                    }
                    FirebaseFirestoreException.Code.UNAVAILABLE -> {
                        Log.w(TAG, "Firestore temporariamente indispon√≠vel: ${exception.message}")
                    }
                    FirebaseFirestoreException.Code.UNAUTHENTICATED -> {
                        Log.w(TAG, "Usu√°rio n√£o autenticado: ${exception.message}")
                    }
                    else -> {
                        Log.e(TAG, "Erro do Firestore: ${exception.message}", exception)
                    }
                }
            }
            else -> {
                Log.e(TAG, "Exce√ß√£o n√£o tratada: ${exception.message}", exception)
            }
        }
    }
    
    /**
     * Trata exce√ß√µes do Firestore de forma segura, retornando um valor padr√£o
     */
    inline fun <T> handleFirestoreException(
        defaultValue: T,
        tag: String = DEFAULT_TAG,
        action: () -> T
    ): T {
        return try {
            action()
        } catch (e: FirebaseFirestoreException) {
            when (e.code) {
                FirebaseFirestoreException.Code.PERMISSION_DENIED -> {
                    Log.w(tag, "Permiss√£o negada: ${e.message}")
                }
                else -> {
                    Log.e(tag, "Erro do Firestore: ${e.message}", e)
                }
            }
            defaultValue
        } catch (e: Exception) {
            Log.e(tag, "Erro inesperado: ${e.message}", e)
            defaultValue
        }
    }
}


```

# Core - firebase


## [FRONTEND]: core/firebase/FirebaseConfigValidator.kt

```kotlin
package com.taskgoapp.taskgo.core.firebase

import android.content.Context
import android.util.Log
import com.google.firebase.FirebaseApp

object FirebaseConfigValidator {
    private const val TAG = "FirebaseConfigValidator"
    
    /**
     * Valida as configura√ß√µes do Firebase
     */
    fun validate(context: Context): ValidationResult {
        Log.d(TAG, "=== VALIDA√á√ÉO DAS CONFIGURA√á√ïES DO FIREBASE ===")
        
        val result = ValidationResult()
        
        // Validar Firebase App inicializado
        try {
            val firebaseApp = FirebaseApp.getInstance()
            result.firebaseInitialized = true
            Log.d(TAG, "‚úÖ Firebase App inicializado")
            
            // Validar API Key
            val apiKey = firebaseApp.options.apiKey
            result.apiKey = apiKey
            Log.d(TAG, "API Key: $apiKey")
            if (apiKey.isNotEmpty()) {
                result.apiKeyValid = true
                Log.d(TAG, "‚úÖ API Key presente")
            } else {
                result.apiKeyValid = false
                Log.e(TAG, "‚ùå API Key vazia")
            }
            
            // Validar Project ID
            val projectId = firebaseApp.options.projectId ?: ""
            result.projectId = projectId
            Log.d(TAG, "Project ID: $projectId")
            if (projectId == "task-go-ee85f") {
                result.projectIdValid = true
                Log.d(TAG, "‚úÖ Project ID correto")
            } else {
                result.projectIdValid = false
                Log.e(TAG, "‚ùå Project ID incorreto. Esperado: task-go-ee85f, Encontrado: $projectId")
            }
            
            // Validar Application ID
            val applicationId = firebaseApp.options.applicationId
            result.applicationId = applicationId
            Log.d(TAG, "Application ID: $applicationId")
            if (applicationId.isNotEmpty()) {
                result.applicationIdValid = true
                Log.d(TAG, "‚úÖ Application ID presente")
            } else {
                result.applicationIdValid = false
                Log.e(TAG, "‚ùå Application ID vazio")
            }
            
            // Validar Storage Bucket
            val storageBucket = firebaseApp.options.storageBucket
            result.storageBucket = storageBucket
            Log.d(TAG, "Storage Bucket: $storageBucket")
            if (storageBucket != null && storageBucket.isNotEmpty()) {
                result.storageBucketValid = true
                Log.d(TAG, "‚úÖ Storage Bucket presente")
            } else {
                result.storageBucketValid = false
                Log.w(TAG, "‚ö†Ô∏è Storage Bucket vazio")
            }
            
        } catch (e: Exception) {
            result.firebaseInitialized = false
            Log.e(TAG, "‚ùå Firebase App n√£o inicializado: ${e.message}", e)
        }
        
        // Validar google-services.json
        try {
            val googleServicesJson = validateGoogleServicesJson(context)
            result.googleServicesJsonValid = googleServicesJson.isValid
            result.packageName = googleServicesJson.packageName
            result.googleServicesApiKey = googleServicesJson.apiKey
            
            if (googleServicesJson.isValid) {
                Log.d(TAG, "‚úÖ google-services.json v√°lido")
                Log.d(TAG, "Package Name no google-services.json: ${googleServicesJson.packageName}")
                Log.d(TAG, "API Key no google-services.json: ${googleServicesJson.apiKey}")
                
                // Verificar se o package name est√° correto
                if (googleServicesJson.packageName == "com.taskgoapp.taskgo") {
                    result.packageNameValid = true
                    Log.d(TAG, "‚úÖ Package Name correto")
                } else {
                    result.packageNameValid = false
                    Log.e(TAG, "‚ùå Package Name incorreto. Esperado: com.taskgoapp.taskgo, Encontrado: ${googleServicesJson.packageName}")
                }
                
                // Verificar se a API Key do google-services.json bate com a do Firebase
                val firebaseApiKey = try {
                    FirebaseApp.getInstance().options.apiKey
                } catch (e: Exception) {
                    ""
                }
                if (googleServicesJson.apiKey == firebaseApiKey) {
                    result.apiKeyMatches = true
                    Log.d(TAG, "‚úÖ API Key do google-services.json bate com a do Firebase")
                } else {
                    result.apiKeyMatches = false
                    Log.e(TAG, "‚ùå API Key do google-services.json N√ÉO bate com a do Firebase")
                    Log.e(TAG, "   google-services.json: ${googleServicesJson.apiKey}")
                    Log.e(TAG, "   Firebase: $firebaseApiKey")
                }
            } else {
                Log.e(TAG, "‚ùå google-services.json inv√°lido ou n√£o encontrado")
            }
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Erro ao validar google-services.json: ${e.message}", e)
        }
        
        // Resultado final
        result.isValid = result.firebaseInitialized && 
                        result.apiKeyValid && 
                        result.projectIdValid && 
                        result.applicationIdValid &&
                        result.googleServicesJsonValid &&
                        result.packageNameValid &&
                        result.apiKeyMatches
        
        Log.d(TAG, "=== RESULTADO DA VALIDA√á√ÉO ===")
        Log.d(TAG, "V√°lido: ${result.isValid}")
        Log.d(TAG, "Firebase inicializado: ${result.firebaseInitialized}")
        Log.d(TAG, "API Key v√°lida: ${result.apiKeyValid}")
        Log.d(TAG, "Project ID v√°lido: ${result.projectIdValid}")
        Log.d(TAG, "Package Name v√°lido: ${result.packageNameValid}")
        Log.d(TAG, "API Keys correspondem: ${result.apiKeyMatches}")
        
        if (!result.isValid) {
            Log.e(TAG, "‚ö†Ô∏è CONFIGURA√á√ïES DO FIREBASE INV√ÅLIDAS!")
            Log.e(TAG, "Consulte VERIFICACAO_FIREBASE_CONFIG.md para resolver")
        } else {
            Log.d(TAG, "‚úÖ Todas as configura√ß√µes do Firebase est√£o v√°lidas")
        }
        
        return result
    }
    
    private fun validateGoogleServicesJson(context: Context): GoogleServicesJsonResult {
        return try {
            // O google-services.json √© processado pelo plugin do Google Services
            // N√£o podemos l√™-lo diretamente, ent√£o validamos apenas as informa√ß√µes do Firebase
            // que j√° foram inicializadas
            GoogleServicesJsonResult(
                isValid = true,
                packageName = context.packageName,
                apiKey = try {
                    FirebaseApp.getInstance().options.apiKey
                } catch (e: Exception) {
                    ""
                },
                projectId = try {
                    FirebaseApp.getInstance().options.projectId ?: ""
                } catch (e: Exception) {
                    ""
                },
                projectNumber = try {
                    FirebaseApp.getInstance().options.projectId ?: ""
                } catch (e: Exception) {
                    ""
                }
            )
        } catch (e: Exception) {
            Log.e(TAG, "Erro ao validar google-services.json: ${e.message}", e)
            GoogleServicesJsonResult(isValid = false, packageName = "", apiKey = "", projectId = "", projectNumber = "")
        }
    }
    
    data class ValidationResult(
        var isValid: Boolean = false,
        var firebaseInitialized: Boolean = false,
        var apiKey: String = "",
        var apiKeyValid: Boolean = false,
        var projectId: String = "",
        var projectIdValid: Boolean = false,
        var applicationId: String = "",
        var applicationIdValid: Boolean = false,
        var storageBucket: String? = null,
        var storageBucketValid: Boolean = false,
        var googleServicesJsonValid: Boolean = false,
        var packageName: String = "",
        var packageNameValid: Boolean = false,
        var googleServicesApiKey: String = "",
        var apiKeyMatches: Boolean = false
    )
    
    private data class GoogleServicesJsonResult(
        val isValid: Boolean,
        val packageName: String,
        val apiKey: String,
        val projectId: String,
        val projectNumber: String
    )
}


```

## [FRONTEND]: core/firebase/FirestoreHelper.kt

```kotlin
package com.taskgoapp.taskgo.core.firebase

import com.google.firebase.FirebaseApp
import com.google.firebase.firestore.FirebaseFirestore
import android.util.Log

/**
 * Helper para obter inst√¢ncia do Firestore configurada para o database padr√£o '(default)'
 * O Firestore usa o database '(default)' por padr√£o quando nenhum nome √© especificado
 */
object FirestoreHelper {
    private const val TAG = "FirestoreHelper"
    
    /**
     * Obt√©m inst√¢ncia do Firestore para o database padr√£o '(default)'
     */
    @JvmStatic
    fun getInstance(): FirebaseFirestore {
        return try {
            Log.d(TAG, "Acessando Firestore database padrao (default)...")
            // Usar database padr√£o '(default)' - n√£o especificar nome usa o default automaticamente
            val firestore = FirebaseFirestore.getInstance()
            Log.d(TAG, "Database Firestore acessado com sucesso")
            firestore
        } catch (e: Exception) {
            Log.e(TAG, "ERRO CRITICO: Nao foi possivel acessar o database Firestore", e)
            Log.e(TAG, "   Exception type: ${e.javaClass.simpleName}")
            Log.e(TAG, "   Exception message: ${e.message}")
            e.printStackTrace()
            throw IllegalStateException(
                "FALHA CRITICA: Database Firestore nao esta disponivel. " +
                "Verifique se o Firebase esta configurado corretamente.",
                e
            )
        }
    }
}

```

## [FRONTEND]: core/firebase/LocationHelper.kt

```kotlin
package com.taskgoapp.taskgo.core.firebase

import com.google.firebase.firestore.FirebaseFirestore
import android.util.Log
import kotlinx.coroutines.flow.first

/**
 * Helper para organiza√ß√£o de dados por localiza√ß√£o
 * Dados p√∫blicos s√£o salvos em cole√ß√µes organizadas por cidade/estado
 * Estrutura: locations/{city}_{state}/{collection}/{documentId}
 */
object LocationHelper {
    private const val TAG = "LocationHelper"
    
    /**
     * Normaliza cidade e estado para criar ID v√°lido para cole√ß√£o
     * Remove espa√ßos, caracteres especiais e converte para lowercase
     * Exemplo: "Osasco" + "SP" -> "osasco_sp"
     */
    fun normalizeLocationId(city: String, state: String): String {
        val normalize = { str: String ->
            java.text.Normalizer.normalize(str.lowercase().trim(), java.text.Normalizer.Form.NFD)
                .replace(Regex("[\\u0300-\\u036F]"), "") // Remove acentos
                .replace(Regex("[^a-z0-9]"), "_") // Substitui caracteres especiais por underscore
                .replace(Regex("_+"), "_") // Remove underscores duplicados
                .replace(Regex("^_|_\$"), "") // Remove underscores no in√≠cio e fim
        }
        
        val normalizedCity = normalize(city)
        val normalizedState = normalize(state)
        
        val locationId = if (normalizedCity.isEmpty() && normalizedState.isEmpty()) {
            "unknown"
        } else if (normalizedCity.isEmpty()) {
            normalizedState
        } else if (normalizedState.isEmpty()) {
            normalizedCity
        } else {
            "${normalizedCity}_${normalizedState}"
        }
        
        // üìç LOCATION TRACE OBRIGAT√ìRIO - Rastreamento de normaliza√ß√£o (Frontend)
        Log.d("LocationTrace", """
            üìç FRONTEND LOCATION TRACE
            Function: normalizeLocationId
            RawCity: $city
            RawState: $state
            NormalizedCity: $normalizedCity
            NormalizedState: $normalizedState
            LocationId: $locationId
            Timestamp: ${java.util.Date()}
        """.trimIndent())
        
        return locationId
    }
    
    /**
     * Extrai cidade e estado de uma string de localiza√ß√£o
     * Formatos suportados:
     * - "Cidade, Estado"
     * - "Endere√ßo, Cidade, Estado"
     * - "Cidade"
     */
    fun parseLocation(location: String): Pair<String, String> {
        if (location.isBlank()) {
            return "" to ""
        }
        
        val parts = location.split(",").map { it.trim() }.filter { it.isNotEmpty() }
        
        if (parts.isEmpty()) {
            return "" to ""
        }
        
        if (parts.size == 1) {
            // Apenas cidade fornecida
            return parts[0] to ""
        }
        
        // Assumir que os √∫ltimos dois elementos s√£o cidade e estado
        val state = parts[parts.size - 1]
        val city = parts[parts.size - 2]
        
        return city to state
    }
    
    /**
     * Obt√©m refer√™ncia da cole√ß√£o por localiza√ß√£o
     * @param firestore Inst√¢ncia do Firestore
     * @param collection Nome da cole√ß√£o (orders, products, stories, posts)
     * @param city Cidade
     * @param state Estado
     */
    fun getLocationCollection(
        firestore: FirebaseFirestore,
        collection: String,
        city: String,
        state: String
    ): com.google.firebase.firestore.CollectionReference {
        val locationId = normalizeLocationId(city, state)
        val firestorePath = "locations/$locationId/$collection"
        
        // üìç LOCATION TRACE OBRIGAT√ìRIO - Rastreamento de cole√ß√£o (Frontend)
        Log.d("LocationTrace", """
            üìç FRONTEND LOCATION TRACE
            Function: getLocationCollection
            City: $city
            State: $state
            LocationId: $locationId
            Firestore Path: $firestorePath
            Collection: $collection
            Timestamp: ${java.util.Date()}
        """.trimIndent())
        
        return firestore.collection("locations").document(locationId).collection(collection)
    }
    
    /**
     * Obt√©m cidade e estado do usu√°rio a partir do UserRepository
     * Retorna Pair(city, state)
     * CR√çTICO: UserProfile agora tem state diretamente (adicionado na vers√£o 88)
     */
    suspend fun getUserLocation(
        userRepository: com.taskgoapp.taskgo.domain.repository.UserRepository
    ): Pair<String, String> {
        return try {
            val user = userRepository.observeCurrentUser().first()
            val city = user?.city?.takeIf { it.isNotBlank() } ?: ""
            val state = user?.state?.takeIf { it.isNotBlank() } ?: ""
            
            val locationId = normalizeLocationId(city, state)
            
            // üìç LOCATION TRACE OBRIGAT√ìRIO - Rastreamento de localiza√ß√£o do usu√°rio (Frontend)
            Log.d("LocationTrace", """
                üìç FRONTEND LOCATION TRACE
                Function: getUserLocation
                RawCity: ${user?.city ?: "null"}
                RawState: ${user?.state ?: "null"}
                City: $city
                State: $state
                LocationId: $locationId
                Timestamp: ${java.util.Date()}
            """.trimIndent())
            
            city to state
        } catch (e: Exception) {
            Log.e(TAG, "Erro ao obter localizacao do usuario: ${e.message}", e)
            // üìç LOCATION TRACE: Erro ao obter localiza√ß√£o
            Log.w("LocationTrace", """
                üìç FRONTEND LOCATION TRACE
                Function: getUserLocation
                Error: ${e.message}
                Timestamp: ${java.util.Date()}
            """.trimIndent())
            "" to ""
        }
    }
}

```

# Core - locale


## [FRONTEND]: core/locale/LocaleHelper.kt

```kotlin
package com.taskgoapp.taskgo.core.locale

import android.content.Context
import android.content.res.Configuration
import android.content.res.Resources
import android.os.Build
import androidx.compose.runtime.Composable
import androidx.compose.runtime.CompositionLocalProvider
import androidx.compose.runtime.compositionLocalOf
import androidx.compose.runtime.remember
import androidx.compose.ui.platform.LocalConfiguration
import androidx.compose.ui.platform.LocalContext
import java.util.Locale

val LocalAppLanguage = compositionLocalOf<String> { "pt" }

@Composable
fun ProvideAppLanguage(
    languageCode: String,
    content: @Composable () -> Unit
) {
    val context = LocalContext.current
    val configuration = LocalConfiguration.current
    
    val updatedContext = remember(languageCode) {
        updateLocale(context, languageCode)
    }
    
    val updatedConfiguration = remember(languageCode, configuration) {
        Configuration(configuration).apply {
            setLocale(LocaleManager.getLocale(languageCode))
        }
    }
    
    CompositionLocalProvider(
        LocalAppLanguage provides languageCode
    ) {
        content()
    }
}

private fun updateLocale(context: Context, languageCode: String): Context {
    val locale = LocaleManager.getLocale(languageCode)
    Locale.setDefault(locale)
    
    val resources: Resources = context.resources
    val configuration: Configuration = resources.configuration
    
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
        configuration.setLocale(locale)
        return context.createConfigurationContext(configuration)
    } else {
        @Suppress("DEPRECATION")
        configuration.locale = locale
        @Suppress("DEPRECATION")
        resources.updateConfiguration(configuration, resources.displayMetrics)
        return context
    }
}


```

## [FRONTEND]: core/locale/LocaleManager.kt

```kotlin
package com.taskgoapp.taskgo.core.locale

import android.content.Context
import android.content.res.Configuration
import android.content.res.Resources
import android.os.Build
import java.util.Locale

object LocaleManager {
    
    fun getLocale(languageCode: String): Locale {
        return when (languageCode) {
            "en" -> Locale.ENGLISH
            "es" -> Locale("es", "ES")
            "fr" -> Locale.FRENCH
            "it" -> Locale.ITALIAN
            "de" -> Locale.GERMAN
            else -> Locale("pt", "BR")
        }
    }
    
    fun updateConfiguration(context: Context, languageCode: String): Context {
        val locale = getLocale(languageCode)
        Locale.setDefault(locale)
        
        val resources: Resources = context.resources
        val configuration: Configuration = resources.configuration
        
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
            configuration.setLocale(locale)
            return context.createConfigurationContext(configuration)
        } else {
            @Suppress("DEPRECATION")
            configuration.locale = locale
            @Suppress("DEPRECATION")
            resources.updateConfiguration(configuration, resources.displayMetrics)
            return context
        }
    }
    
    fun getLanguageCode(locale: Locale): String {
        return when (locale.language) {
            "en" -> "en"
            "es" -> "es"
            "fr" -> "fr"
            "it" -> "it"
            "de" -> "de"
            else -> "pt"
        }
    }
}


```

# Core - location


## [FRONTEND]: core/location/GeocodingService.kt

```kotlin
package com.taskgoapp.taskgo.core.location

import android.util.Log
import com.taskgoapp.taskgo.core.model.Address
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.json.JSONObject
import java.net.HttpURLConnection
import java.net.URL
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Servi√ßo de geocoding para converter endere√ßos em coordenadas
 * Utiliza Google Maps Geocoding API
 */
@Singleton
class GeocodingService @Inject constructor() {
    
    companion object {
        private const val TAG = "GeocodingService"
        private const val GEOCODING_API = "https://maps.googleapis.com/maps/api/geocode/json"
        private const val API_KEY = "REDACTED_GOOGLE_MAPS_API_KEY"
    }
    
    /**
     * Converte um endere√ßo em coordenadas (latitude, longitude)
     */
    suspend fun geocodeAddress(address: Address): GeocodingResult = withContext(Dispatchers.IO) {
        try {
            // Construir endere√ßo completo para geocoding
            val fullAddress = buildString {
                if (address.street.isNotEmpty()) append(address.street)
                if (address.number.isNotEmpty()) append(", ${address.number}")
                if (address.neighborhood.isNotEmpty()) append(", ${address.neighborhood}")
                if (address.city.isNotEmpty()) append(", ${address.city}")
                if (address.state.isNotEmpty()) append(", ${address.state}")
                if (address.zipCode.isNotEmpty()) append(" ${address.zipCode}")
                append(", Brasil")
            }
            
            // Se tiver CEP, usar CEP para geocoding (mais preciso)
            val query = if (address.zipCode.isNotEmpty() || address.cep.isNotEmpty()) {
                val cep = address.zipCode.ifEmpty { address.cep }
                "$cep, Brasil"
            } else {
                fullAddress
            }
            
            val encodedQuery = java.net.URLEncoder.encode(query, "UTF-8")
            val url = URL("$GEOCODING_API?address=$encodedQuery&key=$API_KEY")
            
            val connection = url.openConnection() as HttpURLConnection
            connection.requestMethod = "GET"
            connection.connectTimeout = 5000
            connection.readTimeout = 5000
            
            val responseCode = connection.responseCode
            
            if (responseCode == HttpURLConnection.HTTP_OK) {
                val response = connection.inputStream.bufferedReader().use { it.readText() }
                val json = JSONObject(response)
                
                val status = json.getString("status")
                
                if (status == "OK") {
                    val results = json.getJSONArray("results")
                    if (results.length() > 0) {
                        val firstResult = results.getJSONObject(0)
                        val geometry = firstResult.getJSONObject("geometry")
                        val location = geometry.getJSONObject("location")
                        
                        val latitude = location.getDouble("lat")
                        val longitude = location.getDouble("lng")
                        
                        Log.d(TAG, "Geocoding bem-sucedido: $query -> ($latitude, $longitude)")
                        return@withContext GeocodingResult.Success(
                            latitude = latitude,
                            longitude = longitude,
                            formattedAddress = firstResult.getString("formatted_address")
                        )
                    }
                } else {
                    Log.w(TAG, "Geocoding falhou: status=$status para endere√ßo=$query")
                    return@withContext GeocodingResult.Error("Status: $status")
                }
            } else {
                Log.e(TAG, "Erro HTTP ao fazer geocoding: $responseCode")
                return@withContext GeocodingResult.Error("Erro HTTP: $responseCode")
            }
            
            GeocodingResult.Error("Nenhum resultado encontrado")
        } catch (e: Exception) {
            Log.e(TAG, "Erro ao fazer geocoding: ${e.message}", e)
            GeocodingResult.Error("Erro: ${e.message}")
        }
    }
    
    /**
     * Converte CEP em coordenadas
     */
    suspend fun geocodeCep(cep: String): GeocodingResult = withContext(Dispatchers.IO) {
        try {
            val cleanCep = cep.replace(Regex("[^0-9]"), "")
            if (cleanCep.length != 8) {
                return@withContext GeocodingResult.Error("CEP inv√°lido")
            }
            
            val encodedCep = java.net.URLEncoder.encode("$cleanCep, Brasil", "UTF-8")
            val url = URL("$GEOCODING_API?address=$encodedCep&key=$API_KEY")
            
            val connection = url.openConnection() as HttpURLConnection
            connection.requestMethod = "GET"
            connection.connectTimeout = 5000
            connection.readTimeout = 5000
            
            val responseCode = connection.responseCode
            
            if (responseCode == HttpURLConnection.HTTP_OK) {
                val response = connection.inputStream.bufferedReader().use { it.readText() }
                val json = JSONObject(response)
                
                val status = json.getString("status")
                
                if (status == "OK") {
                    val results = json.getJSONArray("results")
                    if (results.length() > 0) {
                        val firstResult = results.getJSONObject(0)
                        val geometry = firstResult.getJSONObject("geometry")
                        val location = geometry.getJSONObject("location")
                        
                        val latitude = location.getDouble("lat")
                        val longitude = location.getDouble("lng")
                        
                        return@withContext GeocodingResult.Success(
                            latitude = latitude,
                            longitude = longitude,
                            formattedAddress = firstResult.getString("formatted_address")
                        )
                    }
                }
            }
            
            GeocodingResult.Error("CEP n√£o encontrado")
        } catch (e: Exception) {
            Log.e(TAG, "Erro ao fazer geocoding do CEP: ${e.message}", e)
            GeocodingResult.Error("Erro: ${e.message}")
        }
    }
}

/**
 * Resultado do geocoding
 */
sealed class GeocodingResult {
    data class Success(
        val latitude: Double,
        val longitude: Double,
        val formattedAddress: String
    ) : GeocodingResult()
    
    data class Error(val message: String) : GeocodingResult()
}


```

## [FRONTEND]: core/location/LocationManager.kt

```kotlin
package com.taskgoapp.taskgo.core.location

import android.Manifest
import android.content.Context
import android.location.Address
import android.location.Geocoder
import android.location.Location
import android.os.Build
import androidx.annotation.RequiresPermission
import com.google.android.gms.location.*
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.suspendCancellableCoroutine
import java.util.Locale
import javax.inject.Inject
import javax.inject.Singleton
import kotlin.coroutines.resume

@Singleton
class LocationManager @Inject constructor(
    private val context: Context
) {
    private val fusedLocationClient: FusedLocationProviderClient =
        LocationServices.getFusedLocationProviderClient(context)
    
    private val geocoder: Geocoder? = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
        Geocoder(context, Locale.getDefault())
    } else {
        @Suppress("DEPRECATION")
        Geocoder(context, Locale.getDefault())
    }
    
    /**
     * Obt√©m a localiza√ß√£o atual do usu√°rio
     * Requer permiss√µes ACCESS_FINE_LOCATION ou ACCESS_COARSE_LOCATION
     */
    @RequiresPermission(anyOf = [Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION])
    suspend fun getCurrentLocation(): Location? = suspendCancellableCoroutine { continuation ->
        var isResumed = false // Flag para garantir que s√≥ resuma uma vez
        
        val locationRequest = LocationRequest.Builder(
            Priority.PRIORITY_HIGH_ACCURACY,
            10000L // 10 segundos
        ).apply {
            setMaxUpdateDelayMillis(5000L)
        }.build()
        
        val locationCallback = object : LocationCallback() {
            override fun onLocationResult(locationResult: LocationResult) {
                if (!isResumed) {
                    isResumed = true
                    fusedLocationClient.removeLocationUpdates(this)
                    val location = locationResult.lastLocation
                    continuation.resume(location)
                }
            }
        }
        
        try {
            fusedLocationClient.requestLocationUpdates(
                locationRequest,
                locationCallback,
                context.mainLooper
            )
            
            continuation.invokeOnCancellation {
                if (!isResumed) {
                    isResumed = true
                    fusedLocationClient.removeLocationUpdates(locationCallback)
                }
            }
        } catch (e: SecurityException) {
            if (!isResumed) {
                isResumed = true
                continuation.resume(null)
            }
        }
    }
    
    /**
     * Obt√©m o endere√ßo a partir das coordenadas
     */
    suspend fun getAddressFromLocation(latitude: Double, longitude: Double): Address? {
        return try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                geocoder?.getFromLocation(latitude, longitude, 1)?.firstOrNull()
            } else {
                @Suppress("DEPRECATION")
                geocoder?.getFromLocation(latitude, longitude, 1)?.firstOrNull()
            }
        } catch (e: Exception) {
            null
        }
    }
    
    /**
     * Obt√©m o endere√ßo completo a partir da localiza√ß√£o atual
     */
    @RequiresPermission(anyOf = [Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION])
    suspend fun getCurrentAddress(): Address? {
        val location = getCurrentLocation() ?: return null
        return getAddressFromLocation(location.latitude, location.longitude)
    }
    
    /**
     * Observa mudan√ßas de localiza√ß√£o
     */
    @RequiresPermission(anyOf = [Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION])
    fun observeLocation(): Flow<Location> = callbackFlow {
        val locationRequest = LocationRequest.Builder(
            Priority.PRIORITY_HIGH_ACCURACY,
            10000L
        ).build()
        
        val locationCallback = object : LocationCallback() {
            override fun onLocationResult(locationResult: LocationResult) {
                locationResult.lastLocation?.let { location ->
                    trySend(location)
                }
            }
        }
        
        try {
            fusedLocationClient.requestLocationUpdates(
                locationRequest,
                locationCallback,
                context.mainLooper
            )
        } catch (e: SecurityException) {
            close(e)
        }
        
        awaitClose {
            fusedLocationClient.removeLocationUpdates(locationCallback)
        }
    }
}


```

## [FRONTEND]: core/location/LocationState.kt

```kotlin
package com.taskgoapp.taskgo.core.location

/**
 * Estado global de localiza√ß√£o do usu√°rio
 * Fonte √∫nica de verdade para city, state e locationId
 * 
 * ‚úÖ Ready: Localiza√ß√£o est√° pronta e v√°lida
 * ‚è≥ Loading: Localiza√ß√£o ainda n√£o est√° dispon√≠vel
 * ‚ùå Error: Erro ao obter localiza√ß√£o
 */
sealed class LocationState {
    /**
     * Localiza√ß√£o ainda n√£o est√° dispon√≠vel
     * Nenhuma query Firestore por localiza√ß√£o deve ocorrer
     */
    object Loading : LocationState()
    
    /**
     * Localiza√ß√£o est√° pronta e v√°lida
     * Todos os valores (city, state, locationId) est√£o resolvidos
     */
    data class Ready(
        val city: String,
        val state: String,
        val locationId: String
    ) : LocationState() {
        init {
            require(city.isNotBlank()) { "City cannot be blank in LocationState.Ready" }
            require(state.isNotBlank()) { "State cannot be blank in LocationState.Ready" }
            require(locationId.isNotBlank() && locationId != "unknown") { 
                "LocationId cannot be blank or 'unknown' in LocationState.Ready" 
            }
        }
    }
    
    /**
     * Erro ao obter localiza√ß√£o
     * Nenhuma query Firestore por localiza√ß√£o deve ocorrer
     */
    data class Error(val reason: String) : LocationState()
}

```

## [FRONTEND]: core/location/LocationStateManager.kt

```kotlin
package com.taskgoapp.taskgo.core.location

import android.util.Log
import com.taskgoapp.taskgo.core.firebase.LocationHelper
import com.taskgoapp.taskgo.domain.repository.UserRepository
import kotlinx.coroutines.flow.*
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Gerenciador de estado global de localiza√ß√£o
 * Singleton respons√°vel por:
 * - Observar usu√°rio logado
 * - Extrair city/state
 * - Normalizar locationId
 * - Emitir LocationState.Ready SOMENTE quando os 3 valores estiverem v√°lidos
 * 
 * ‚ö†Ô∏è FONTE √öNICA DE VERDADE DA LOCALIZA√á√ÉO NO FRONTEND
 */
@Singleton
class LocationStateManager @Inject constructor(
    private val userRepository: UserRepository
) {
    private val TAG = "LocationStateManager"
    
    /**
     * Estado atual de localiza√ß√£o
     * Observe este Flow para saber quando a localiza√ß√£o est√° pronta
     */
    val locationState: Flow<LocationState> = userRepository.observeCurrentUser()
        .map { user ->
            when {
                user == null -> {
                    Log.w(TAG, "üìç User is null, location state: Loading")
                    LocationState.Loading
                }
                else -> {
                    val city = user.city?.takeIf { it.isNotBlank() } ?: ""
                    val state = user.state?.takeIf { it.isNotBlank() } ?: ""
                    
                    when {
                        city.isBlank() || state.isBlank() -> {
                            Log.w(TAG, """
                                üìç Location not ready:
                                UserId: ${user.id}
                                City: ${user.city ?: "null"}
                                State: ${user.state ?: "null"}
                            """.trimIndent())
                            LocationState.Loading
                        }
                        else -> {
                            val locationId = LocationHelper.normalizeLocationId(city, state)
                            
                            // üö® PROTE√á√ÉO: Nunca permitir "unknown" como locationId v√°lido
                            if (locationId == "unknown" || locationId.isBlank()) {
                                Log.e(TAG, """
                                    üìç FATAL_LOCATION: Attempted to create LocationState.Ready with invalid locationId
                                    City: $city
                                    State: $state
                                    LocationId: $locationId
                                """.trimIndent())
                                LocationState.Error("Invalid locationId: $locationId")
                            } else {
                                Log.d(TAG, """
                                    üìç Location ready:
                                    City: $city
                                    State: $state
                                    LocationId: $locationId
                                """.trimIndent())
                                LocationState.Ready(
                                    city = city,
                                    state = state,
                                    locationId = locationId
                                )
                            }
                        }
                    }
                }
            }
        }
        .catch { exception ->
            Log.e(TAG, "üìç Error observing user location: ${exception.message}", exception)
            emit(LocationState.Error("Failed to get user location: ${exception.message}"))
        }
        .distinctUntilChanged()
        .shareIn(
            scope = kotlinx.coroutines.CoroutineScope(kotlinx.coroutines.Dispatchers.IO),
            started = kotlinx.coroutines.flow.SharingStarted.WhileSubscribed(5000L),
            replay = 1
        )
    
    /**
     * Obt√©m o estado atual de localiza√ß√£o (one-shot)
     */
    suspend fun getCurrentLocationState(): LocationState {
        return locationState.first()
    }
    
    /**
     * Verifica se a localiza√ß√£o est√° pronta
     */
    suspend fun isLocationReady(): Boolean {
        return getCurrentLocationState() is LocationState.Ready
    }
}

```

## [FRONTEND]: core/location/LocationUtils.kt

```kotlin
package com.taskgoapp.taskgo.core.location

import android.location.Location
import kotlin.math.*

/**
 * Calcula a dist√¢ncia entre duas coordenadas usando a f√≥rmula de Haversine
 * @return Dist√¢ncia em quil√¥metros
 */
fun calculateDistance(
    lat1: Double,
    lon1: Double,
    lat2: Double,
    lon2: Double
): Double {
    val earthRadiusKm = 6371.0
    
    val dLat = Math.toRadians(lat2 - lat1)
    val dLon = Math.toRadians(lon2 - lon1)
    
    val a = sin(dLat / 2) * sin(dLat / 2) +
            cos(Math.toRadians(lat1)) * cos(Math.toRadians(lat2)) *
            sin(dLon / 2) * sin(dLon / 2)
    
    val c = 2 * atan2(sqrt(a), sqrt(1 - a))
    
    return earthRadiusKm * c
}

/**
 * Verifica se uma localiza√ß√£o est√° dentro do raio especificado
 */
fun isWithinRadius(
    centerLat: Double,
    centerLon: Double,
    targetLat: Double,
    targetLon: Double,
    radiusKm: Double
): Boolean {
    val distance = calculateDistance(centerLat, centerLon, targetLat, targetLon)
    return distance <= radiusKm
}

/**
 * Extens√£o para Location para facilitar c√°lculos
 */
fun Location.distanceToKm(otherLat: Double, otherLon: Double): Double {
    return calculateDistance(this.latitude, this.longitude, otherLat, otherLon)
}


```

# Core - maps


## [FRONTEND]: core/maps/ProvidersMapView.kt

```kotlin
package com.taskgoapp.taskgo.core.maps

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import com.google.android.gms.maps.CameraUpdateFactory
import com.google.android.gms.maps.model.BitmapDescriptorFactory
import com.google.android.gms.maps.model.CameraPosition
import com.google.android.gms.maps.model.LatLng
import com.google.maps.android.compose.*
import android.location.Location
import com.taskgoapp.taskgo.core.theme.TaskGoGreen

/**
 * Componente de mapa que exibe localiza√ß√£o do usu√°rio e lojas em tempo real
 * Utiliza Google Maps SDK com atualiza√ß√£o em tempo real de localiza√ß√µes
 */
@Composable
fun ProvidersMapView(
    userLocation: Location?,
    stores: List<StoreLocation>,
    onStoreClick: (String) -> Unit = {},
    modifier: Modifier = Modifier
) {
    // Posi√ß√£o inicial do mapa (centro do Brasil ou localiza√ß√£o do usu√°rio)
    val initialPosition = remember {
        userLocation?.let {
            LatLng(it.latitude, it.longitude)
        } ?: LatLng(-14.2350, -51.9253) // Centro do Brasil
    }
    
    var cameraPositionState by remember {
        mutableStateOf(
            CameraPositionState(
                position = CameraPosition.fromLatLngZoom(initialPosition, 12f)
            )
        )
    }
    
    // Atualizar c√¢mera quando localiza√ß√£o do usu√°rio mudar
    LaunchedEffect(userLocation) {
        userLocation?.let { location ->
            val newPosition = LatLng(location.latitude, location.longitude)
            cameraPositionState.animate(
                CameraUpdateFactory.newCameraPosition(
                    CameraPosition.fromLatLngZoom(newPosition, 13f)
                )
            )
        }
    }
    
    Box(modifier = modifier.fillMaxSize()) {
        GoogleMap(
            modifier = Modifier
                .fillMaxSize()
                .clip(RoundedCornerShape(16.dp)),
            cameraPositionState = cameraPositionState,
            properties = MapProperties(
                mapType = MapType.NORMAL,
                isMyLocationEnabled = userLocation != null,
                isTrafficEnabled = false
            ),
            uiSettings = MapUiSettings(
                zoomControlsEnabled = true,
                myLocationButtonEnabled = true,
                compassEnabled = true,
                zoomGesturesEnabled = true,
                scrollGesturesEnabled = true,
                tiltGesturesEnabled = false,
                rotationGesturesEnabled = true
            )
        ) {
            // Marcador da localiza√ß√£o do usu√°rio (se dispon√≠vel)
            userLocation?.let { location ->
                Marker(
                    state = MarkerState(position = LatLng(location.latitude, location.longitude)),
                    title = "Sua localiza√ß√£o",
                    snippet = "Voc√™ est√° aqui"
                )
            }
            
            // Marcadores de lojas
            stores.forEach { store ->
                Marker(
                    state = MarkerState(
                        position = LatLng(store.latitude, store.longitude)
                    ),
                    title = store.name,
                    snippet = store.type,
                    icon = BitmapDescriptorFactory.defaultMarker(BitmapDescriptorFactory.HUE_BLUE),
                    onClick = {
                        onStoreClick(store.id)
                        true
                    }
                )
            }
        }
        
        // Legenda do mapa
        Card(
            modifier = Modifier
                .align(androidx.compose.ui.Alignment.TopEnd)
                .padding(16.dp),
            colors = CardDefaults.cardColors(
                containerColor = Color.White.copy(alpha = 0.9f)
            )
        ) {
            Column(
                modifier = Modifier.padding(12.dp),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                MapLegendItem(
                    color = Color(0xFF2196F3),
                    label = "Lojas"
                )
                if (userLocation != null) {
                    MapLegendItem(
                        color = Color.Red,
                        label = "Voc√™"
                    )
                }
            }
        }
    }
}

@Composable
private fun MapLegendItem(
    color: Color,
    label: String
) {
    Row(
        horizontalArrangement = Arrangement.spacedBy(8.dp),
        verticalAlignment = androidx.compose.ui.Alignment.CenterVertically
    ) {
        Box(
            modifier = Modifier
                .size(16.dp)
                .background(color, androidx.compose.foundation.shape.CircleShape)
        )
        Text(
            text = label,
            style = MaterialTheme.typography.bodySmall,
            color = Color.Black
        )
    }
}

// Modelos de dados
data class ProviderLocation(
    val id: String,
    val name: String,
    val category: String,
    val latitude: Double,
    val longitude: Double,
    val rating: Float? = null,
    val isOnline: Boolean = true
)

data class StoreLocation(
    val id: String,
    val name: String,
    val type: String,
    val latitude: Double,
    val longitude: Double,
    val rating: Float? = null,
    val isOpen: Boolean = true
)


```

# Core - model


## [FRONTEND]: core/model/BlockedUser.kt

```kotlin
package com.taskgoapp.taskgo.core.model

import java.util.Date

/**
 * Modelo de usu√°rio bloqueado
 */
data class BlockedUser(
    val id: String,
    val blockerId: String, // ID do usu√°rio que bloqueou
    val blockedId: String, // ID do usu√°rio bloqueado
    val blockedName: String?,
    val blockedAvatarUrl: String?,
    val createdAt: Date
)

```

## [FRONTEND]: core/model/HomeBanner.kt

```kotlin
package com.taskgoapp.taskgo.core.model

data class HomeBanner(
    val id: String,
    val title: String,
    val subtitle: String,
    val actionLabel: String,
    val imageUrl: String? = null,
    val audience: Audience = Audience.TODOS,
    val actionRoute: String? = null,
    val priority: Int = 0
) {
    enum class Audience {
        CLIENTE,
        PRESTADOR,
        TODOS
    }
}


```

## [FRONTEND]: core/model/Models.kt

```kotlin
package com.taskgoapp.taskgo.core.model

// User Models
enum class UserType {
    CLIENT,     // Cliente que contrata servi√ßos
    PROVIDER    // Prestador de servi√ßos
}

enum class AccountType { 
    /**
     * @deprecated Use PARCEIRO instead. Mantido apenas para compatibilidade durante migra√ß√£o.
     */
    @Deprecated("Use PARCEIRO instead", ReplaceWith("PARCEIRO"))
    PRESTADOR,
    
    /**
     * @deprecated Use PARCEIRO instead. Mantido apenas para compatibilidade durante migra√ß√£o.
     */
    @Deprecated("Use PARCEIRO instead", ReplaceWith("PARCEIRO"))
    VENDEDOR,
    
    PARCEIRO, // Unifica√ß√£o de PRESTADOR e VENDEDOR - pode oferecer servi√ßos e produtos
    
    CLIENTE 
}

data class UserProfile(
    val id: String,
    val name: String,
    val email: String,
    val phone: String?,
    val city: String?,
    val state: String? = null, // Estado (UF) - adicionado para suporte a arquitetura regional
    val profession: String?, // ex: "Montador de M√≥veis"
    val accountType: AccountType,
    val rating: Double?, // mostra em "Meus dados"
    val avatarUri: String?, // persistir URI (MediaStore) local
    val profileImages: List<String>? = null // m√∫ltiplas imagens de perfil
)

data class Product(
    val id: String,
    val title: String,
    val price: Double,
    val description: String?,
    val sellerId: String? = null, // ID do vendedor
    val sellerName: String?,
    val imageUris: List<String>, // 1..n imagens
    val category: String? = null, // Categoria do produto
    val rating: Double? = null, // Avalia√ß√£o m√©dia do produto/vendedor
    val latitude: Double? = null, // Latitude da localiza√ß√£o do produto
    val longitude: Double? = null, // Longitude da localiza√ß√£o do produto
    val featured: Boolean? = false, // Produto em destaque/promocional
    val discountPercentage: Double? = null, // Percentual de desconto para destaque/promo√ß√µes
    val active: Boolean = true // Controle de soft-delete
)

data class ServiceOrder(
    val id: String,
    val category: String,
    val description: String,
    val date: Long, // epoch millis
    val addressLine: String,
    val city: String,
    val state: String,
    val rating: Double? = null, // Avalia√ß√£o m√©dia do prestador de servi√ßo
    val latitude: Double? = null, // Latitude da localiza√ß√£o do servi√ßo
    val longitude: Double? = null, // Longitude da localiza√ß√£o do servi√ßo
    val featured: Boolean? = false // Servi√ßo em destaque
)

data class Proposal(
    val id: String,
    val orderId: String,
    val providerName: String,
    val rating: Double,
    val amount: Double,
    val message: String,
    val scheduledDate: Long,
    val address: String,
    val accepted: Boolean = false
)

data class CartItem(
    val productId: String, 
    val qty: Int
)

data class OrderItem(
    val productId: String,
    val productTitle: String? = null,
    val quantity: Int,
    val price: Double
)

enum class OrderStatus { 
    EM_ANDAMENTO, 
    CONCLUIDO, 
    CANCELADO 
}


data class PurchaseOrder(
    val id: String,
    val orderNumber: String,
    val createdAt: Long,
    val total: Double,
    val subtotal: Double,
    val deliveryFee: Double,
    val status: OrderStatus,
    val items: List<OrderItem>,
    val paymentMethod: String, // "Pix" | "Cr√©dito" | "D√©bito"
    val trackingCode: String? = null,
    val deliveryAddress: String? = null
)

data class TrackingEvent(
    val label: String, 
    val date: Long, 
    val done: Boolean
)

data class MessageThread(
    val id: String,
    val title: String, // ex: "Pedro Amaral"
    val lastMessage: String,
    val lastTime: Long
)

data class ChatMessage(
    val id: String,
    val threadId: String,
    val senderMe: Boolean,
    val text: String,
    val time: Long
)

data class Address(
    val id: String = "",
    val name: String = "",
    val phone: String = "",
    val cep: String = "",
    val street: String = "",
    val district: String = "",
    val city: String = "",
    val state: String = "",
    val number: String = "",
    val complement: String? = null,
    val neighborhood: String = "",
    val zipCode: String = "",
    val country: String = "Brasil"
) {
    fun getFullAddress(): String {
        return buildString {
            append(street)
            if (number.isNotEmpty()) append(", $number")
            complement?.let { append(" - $it") }
            append("\n${neighborhood.ifEmpty { district }}")
            append("\n$city - $state")
            append("\n${zipCode.ifEmpty { cep }}")
            if (country.isNotEmpty()) append("\n$country")
        }
    }
    
    fun isValid(): Boolean {
        return street.isNotEmpty() &&
               (number.isNotEmpty() || id.isNotEmpty()) &&
               (neighborhood.isNotEmpty() || district.isNotEmpty()) &&
               city.isNotEmpty() &&
               state.isNotEmpty() &&
               (zipCode.isNotEmpty() || cep.isNotEmpty())
    }
}

data class Card(
    val id: String,
    val holder: String,
    val numberMasked: String, // "**** **** **** 1234"
    val brand: String, // heur√≠stica
    val expMonth: Int,
    val expYear: Int,
    val type: String // "Cr√©dito" | "D√©bito"
)

data class PaymentMethod(
    val id: Long,
    val type: PaymentType,
    val lastFourDigits: String,
    val cardholderName: String,
    val expiryDate: String,
    val isDefault: Boolean = false
)

enum class PaymentType {
    CREDIT_CARD, DEBIT_CARD, PIX
}

// Notification Models
data class NotificationItem(
    val id: String,
    val type: NotificationType,
    val title: String,
    val message: String,
    val date: Long,
    val isRead: Boolean = false,
    val actionRoute: String? = null
)

enum class NotificationType {
    ORDER_SHIPPED, PROPOSAL_APPROVED, NEW_MESSAGE, UPDATE_AVAILABLE, ORDER_PUBLISHED
}

// Review/Rating Models
enum class ReviewType {
    PRODUCT,      // Avalia√ß√£o de produto
    SERVICE,      // Avalia√ß√£o de servi√ßo
    PROVIDER      // Avalia√ß√£o de prestador de servi√ßo
}

data class Review(
    val id: String,
    val type: ReviewType,
    val targetId: String, // ID do produto, servi√ßo ou prestador
    val reviewerId: String,
    val reviewerName: String,
    val reviewerAvatarUri: String? = null,
    val rating: Int, // 1-5 estrelas
    val comment: String? = null,
    val photoUrls: List<String> = emptyList(),
    val createdAt: Long, // epoch millis
    val updatedAt: Long? = null,
    val orderId: String? = null, // ID do pedido relacionado (se aplic√°vel)
    val helpfulCount: Int = 0, // Quantidade de "√∫til" recebidos
    val verifiedPurchase: Boolean = false // Se foi uma compra verificada
)

data class ReviewSummary(
    val averageRating: Double,
    val totalReviews: Int,
    val ratingDistribution: Map<Int, Int> = emptyMap() // 1->count, 2->count, etc.
)

// Result wrapper for error handling
sealed class Result<out T> {
    data class Success<T>(val data: T) : Result<T>()
    data class Error(val exception: Throwable) : Result<Nothing>()
    object Loading : Result<Nothing>()
}

```

## [FRONTEND]: core/model/Order.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.core.model

import java.time.Instant

data class Order(
    val id: Long,
    val items: List<com.taskgoapp.taskgo.core.model.OrderItem>,
    val total: Double,
    val status: String,
    val createdAt: Instant
)


```

## [FRONTEND]: core/model/Post.kt

```kotlin
package com.taskgoapp.taskgo.core.model

import java.util.Date

/**
 * Model de dom√≠nio para Post
 */
data class Post(
    val id: String,
    val userId: String,
    val userName: String,
    val userAvatarUrl: String?,
    val text: String,
    val mediaUrls: List<String>,
    val mediaTypes: List<String>, // "image" ou "video"
    val location: PostLocation?,
    val createdAt: Date?,
    val updatedAt: Date?,
    val likesCount: Int,
    val commentsCount: Int,
    val isLiked: Boolean, // Se o usu√°rio atual curtiu o post
    val tags: List<String>?
)

/**
 * Localiza√ß√£o do post
 */
data class PostLocation(
    val city: String,
    val state: String,
    val latitude: Double,
    val longitude: Double
) {
    /**
     * Calcula a dist√¢ncia em km entre duas localiza√ß√µes usando a f√≥rmula de Haversine
     */
    fun distanceTo(other: PostLocation): Double {
        val earthRadius = 6371.0 // Raio da Terra em km
        
        val lat1Rad = Math.toRadians(latitude)
        val lat2Rad = Math.toRadians(other.latitude)
        val deltaLat = Math.toRadians(other.latitude - latitude)
        val deltaLon = Math.toRadians(other.longitude - longitude)
        
        val a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
                Math.cos(lat1Rad) * Math.cos(lat2Rad) *
                Math.sin(deltaLon / 2) * Math.sin(deltaLon / 2)
        
        val c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))
        
        return earthRadius * c
    }
}

```

## [FRONTEND]: core/model/PostInterest.kt

```kotlin
package com.taskgoapp.taskgo.core.model

import java.util.Date

/**
 * Modelo de interesse do usu√°rio em um post
 */
data class PostInterest(
    val id: String,
    val userId: String,
    val postId: String,
    val isInterested: Boolean, // true = tem interesse, false = n√£o tem interesse
    val createdAt: Date
)

```

## [FRONTEND]: core/model/PostRating.kt

```kotlin
package com.taskgoapp.taskgo.core.model

import java.util.Date

/**
 * Modelo de avalia√ß√£o de um post
 */
data class PostRating(
    val id: String,
    val postId: String,
    val userId: String,
    val userName: String?,
    val userAvatarUrl: String?,
    val rating: Int, // 1-5 estrelas
    val comment: String?,
    val createdAt: Date
)

```

## [FRONTEND]: core/model/Story.kt

```kotlin
package com.taskgoapp.taskgo.core.model

import java.util.Date

/**
 * Model de dom√≠nio para Story (similar ao Instagram)
 * Stories expiram ap√≥s 24 horas
 */
data class Story(
    val id: String,
    val userId: String,
    val userName: String,
    val userAvatarUrl: String?,
    val mediaUrl: String,
    val mediaType: String, // "image" ou "video"
    val thumbnailUrl: String? = null, // Para v√≠deos
    val caption: String? = null, // Texto opcional sobre a story
    val createdAt: Date,
    val expiresAt: Date, // Data de expira√ß√£o (criado + 24 horas)
    val viewsCount: Int = 0,
    val isViewed: Boolean = false, // Se o usu√°rio atual j√° viu esta story
    val location: StoryLocation? = null // Localiza√ß√£o opcional
)

/**
 * Localiza√ß√£o da Story
 */
data class StoryLocation(
    val city: String,
    val state: String,
    val latitude: Double,
    val longitude: Double
)


```

## [FRONTEND]: core/model/StoryAnalytics.kt

```kotlin
package com.taskgoapp.taskgo.core.model

import java.util.Date

/**
 * Model de dom√≠nio para Analytics de Story (similar ao Instagram)
 * Cont√©m todas as m√©tricas e visualiza√ß√µes de uma story
 */
data class StoryAnalytics(
    val storyId: String,
    val userId: String,
    val views: List<StoryView> = emptyList(),
    val accountsReached: Int = 0,
    val impressions: Int = 0,
    val followers: Int = 0,
    val navigation: Int = 0, // Navega√ß√£o para o perfil
    val back: Int = 0, // Voltar (swipe down ou tap esquerdo)
    val alignments: Int = 0, // Swipe para cima (abrir analytics)
    val interactions: StoryInteractions = StoryInteractions()
)

/**
 * Model de visualiza√ß√£o de Story
 */
data class StoryView(
    val userId: String,
    val userName: String,
    val userAvatarUrl: String? = null,
    val viewedAt: Date,
    val isFollower: Boolean = false // Se o usu√°rio que visualizou √© seguidor
)

/**
 * Model de intera√ß√µes com Story
 */
data class StoryInteractions(
    val profileVisits: Int = 0, // Visitas ao perfil a partir da story
    val linkClicks: Int = 0 // Cliques em links (para futuras implementa√ß√µes)
)

```

# Core - navigation


## [FRONTEND]: core/navigation/AuthNavigationHelper.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.core.navigation

import androidx.navigation.NavController
import com.taskgoapp.taskgo.data.repository.FirebaseAuthRepository

/**
 * Helper para prote√ß√£o de rotas baseado em autentica√ß√£o
 */
object AuthNavigationHelper {
    
    /**
     * Rotas que requerem autentica√ß√£o
     */
    private val protectedRoutes = setOf(
        "home",
        "profile",
        "messages",
        "services",
        "products",
        "notifications",
        "settings",
        "configuracoes",
        "meus_pedidos",
        "meus_servicos",
        "meus_produtos",
        "cart",
        "checkout",
        "orders",
        "chat"
    )
    
    /**
     * Rotas p√∫blicas (n√£o requerem autentica√ß√£o)
     */
    private val publicRoutes = setOf(
        "splash",
        "login_person",
        "login_store",
        "signup",
        "signup_success",
        "forgot_password"
    )
    
    /**
     * Verifica se uma rota requer autentica√ß√£o
     */
    fun isProtectedRoute(route: String): Boolean {
        return protectedRoutes.any { route.startsWith(it) } ||
               route.contains("/") && protectedRoutes.any { route.startsWith("$it/") }
    }
    
    /**
     * Verifica se uma rota √© p√∫blica
     */
    fun isPublicRoute(route: String): Boolean {
        return publicRoutes.contains(route) || 
               route.startsWith("login") || 
               route.startsWith("signup")
    }
    
    /**
     * Navega para uma rota protegida, redirecionando para login se n√£o autenticado
     */
    fun navigateToProtectedRoute(
        navController: NavController,
        authRepository: FirebaseAuthRepository,
        route: String
    ) {
        if (isProtectedRoute(route)) {
            if (!authRepository.isLoggedIn()) {
                // Redirecionar para login se n√£o autenticado
                navController.navigate("login_person") {
                    popUpTo(navController.graph.startDestinationId) { inclusive = false }
                    launchSingleTop = true
                }
            } else {
                // Navegar normalmente se autenticado
                navController.navigate(route) {
                    launchSingleTop = true
                }
            }
        } else {
            // Navegar normalmente para rotas p√∫blicas
            navController.navigate(route) {
                launchSingleTop = true
            }
        }
    }
}


```

## [FRONTEND]: core/navigation/BottomNavigationBar.kt

```kotlin
package com.taskgoapp.taskgo.core.navigation

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.taskgoapp.taskgo.core.theme.TaskGoGreen
import com.taskgoapp.taskgo.core.theme.TaskGoTextGrayPlaceholder
import com.taskgoapp.taskgo.core.design.TGIcons

/**
 * Barra de navega√ß√£o inferior baseada no prot√≥tipo Figma
 * Cores extra√≠das: ativa #00BD48, inativa #BBBBBB
 */
@Composable
fun BottomNavigationBar(
    currentRoute: String,
    onNavigate: (String) -> Unit,
    accountType: com.taskgoapp.taskgo.core.model.AccountType? = null, // Par√¢metro opcional para accountType
    modifier: Modifier = Modifier
) {
    // Determinar label da aba Produtos: "Loja" para Cliente e Parceiro, "Produtos" para outros
    val productsLabel = when (accountType) {
        com.taskgoapp.taskgo.core.model.AccountType.CLIENTE,
        com.taskgoapp.taskgo.core.model.AccountType.PARCEIRO,
        com.taskgoapp.taskgo.core.model.AccountType.PRESTADOR,
        com.taskgoapp.taskgo.core.model.AccountType.VENDEDOR -> "Loja"
        else -> "Produtos"
    }
    
    val bottomNavItems = listOf(
        BottomNavItem(
            route = "home",
            label = "In√≠cio",
            iconRes = TGIcons.Home
        ),
        BottomNavItem(
            route = "services",
            label = "Servi√ßos", 
            iconRes = TGIcons.Services
        ),
        BottomNavItem(
            route = "products",
            label = productsLabel, // Din√¢mico baseado em accountType
            iconRes = TGIcons.Products
        ),
        BottomNavItem(
            route = "feed",
            label = "Feed",
            iconRes = TGIcons.Feed
        ),
        BottomNavItem(
            route = "profile",
            label = "Perfil",
            iconRes = TGIcons.Profile
        )
    )

    Surface(
        modifier = modifier.fillMaxWidth(),
        color = Color.White,
        shadowElevation = 8.dp
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 8.dp, vertical = 8.dp),
            horizontalArrangement = Arrangement.SpaceEvenly,
            verticalAlignment = Alignment.CenterVertically
        ) {
            bottomNavItems.forEach { item ->
                BottomNavItem(
                    item = item,
                    isSelected = currentRoute == item.route,
                    onClick = { onNavigate(item.route) }
                )
            }
        }
    }
}

@Composable
private fun BottomNavItem(
    item: BottomNavItem,
    isSelected: Boolean,
    onClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    val backgroundColor = if (isSelected) TaskGoGreen.copy(alpha = 0.1f) else Color.Transparent
    val textColor = if (isSelected) TaskGoGreen else TaskGoTextGrayPlaceholder
    val iconColor = if (isSelected) TaskGoGreen else TaskGoTextGrayPlaceholder

    Column(
        modifier = modifier
            .clip(RoundedCornerShape(12.dp))
            .background(backgroundColor)
            .clickable { onClick() }
            .padding(horizontal = 12.dp, vertical = 8.dp),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Icon(
            painter = painterResource(item.iconRes),
            contentDescription = item.label,
            tint = iconColor,
            modifier = Modifier.size(24.dp)
        )
        
        Spacer(modifier = Modifier.height(4.dp))
        
        Text(
            text = item.label,
            color = textColor,
            fontSize = 12.sp,
            fontWeight = if (isSelected) FontWeight.SemiBold else FontWeight.Normal
        )
    }
}

data class BottomNavItem(
    val route: String,
    val label: String,
    val iconRes: Int
)

```

## [FRONTEND]: core/navigation/TaskGoDestinations.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.core.navigation

object TaskGoDestinations {
    // Auth routes
    const val FORGOT_PASSWORD_ROUTE = "forgot_password"
    
    // Main tabs
    const val HOME_ROUTE = "home"
    const val SERVICES_ROUTE = "services"
    const val PRODUCTS_ROUTE = "products"
    const val MESSAGES_ROUTE = "messages"
    const val PROFILE_ROUTE = "profile"

    // Services
    const val SERVICE_DETAIL_ROUTE = "service_detail"
    const val CREATE_WORK_ORDER_ROUTE = "create_work_order"
    const val PROPOSALS_INBOX_ROUTE = "proposals_inbox"
    const val PROPOSAL_DETAIL_ROUTE = "proposal_detail"
    const val CONFIRMAR_PROPOSTA_ROUTE = "confirmar_proposta"
    const val DETALHES_PROPOSTA_ROUTE = "detalhes_proposta"
    const val AVALIAR_PRESTADOR_ROUTE = "avaliar_prestador"
    const val HISTORICO_SERVICOS_ROUTE = "historico_servicos"
    const val MEUS_SERVICOS_ROUTE = "meus_servicos"
    const val GERENCIAR_PROPOSTAS_ROUTE = "gerenciar_propostas"

    // Products
    const val PRODUCT_DETAIL_ROUTE = "product_detail"
    const val CART_ROUTE = "cart"
    const val FORMA_PAGAMENTO_ROUTE = "forma_pagamento"
    const val CARTAO_CREDITO_ROUTE = "cartao_credito"
    const val CARTAO_DEBITO_ROUTE = "cartao_debito"
    const val FINALIZAR_PEDIDO_ROUTE = "finalizar_pedido"
    const val CONFIRMACAO_PIX_ROUTE = "confirmacao_pix"
    const val MEUS_PEDIDOS_ROUTE = "meus_pedidos"
    const val ORDER_TRACKING_ROUTE = "order_tracking"
    const val DETALHES_PEDIDO_ROUTE = "detalhes_pedido"
    const val RASTREAMENTO_PEDIDO_ROUTE = "rastreamento_pedido"
    const val RESUMO_PEDIDO_ROUTE = "resumo_pedido"
    const val MEUS_PRODUTOS_ROUTE = "meus_produtos"
    const val GERENCIAR_PRODUTOS_ROUTE = "gerenciar_produtos"
    const val EDITAR_PRODUTO_ROUTE = "editar_produto"
    const val CRIAR_PRODUTO_ROUTE = "criar_produto"

    // Messages
    const val CHAT_ROUTE = "chat"

    // Profile
    const val CONTA_ROUTE = "conta"
    const val MEUS_DADOS_ROUTE = "meus_dados"
    const val MINHAS_AVALIACOES_ROUTE = "minhas_avaliacoes"
    const val CONFIGURACOES_ROUTE = "configuracoes"
    const val ALTERAR_SENHA_ROUTE = "alterar_senha"
    const val PRIVACIDADE_ROUTE = "privacidade"
    const val SUPORTE_ROUTE = "suporte"
    const val SOBRE_ROUTE = "sobre"
    const val NOTIFICATIONS_ROUTE = "notifications"
    const val NOTIFICATION_DETAIL_ROUTE = "notification_detail"
    // Settings detail routes
    const val ACCOUNT_SETTINGS_ROUTE = "account_settings"
    const val PREFERENCES_SETTINGS_ROUTE = "preferences_settings"
    const val NOTIFICATIONS_SETTINGS_ROUTE = "notifications_settings"
    const val LANGUAGE_SETTINGS_ROUTE = "language_settings"

    // AI support
    const val AI_SUPPORT_ROUTE = "ai_support"

    // Auth
    const val LOGIN_ROUTE = "login"
    const val SIGNUP_ROUTE = "signup"
    const val CADASTRO_ROUTE = "cadastro"
    const val CADASTRO_FINALIZADO_ROUTE = "cadastro_finalizado"

    // Checkout
    const val CADASTRAR_ENDERECO_ROUTE = "cadastrar_endereco"

    // Reviews
    const val REVIEWS_ROUTE = "reviews"

    // Ads
    const val ANUNCIOS_ROUTE = "anuncios"
}

```

# Core - network


## [FRONTEND]: core/network/NetworkDiagnostic.kt

```kotlin
package com.taskgoapp.taskgo.core.network

import android.content.Context
import android.net.ConnectivityManager
import android.net.NetworkCapabilities
import android.os.Build
import android.util.Log
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.net.HttpURLConnection
import java.net.URL

object NetworkDiagnostic {
    private const val TAG = "NetworkDiagnostic"
    
    /**
     * Verifica se h√° conex√£o com a internet
     */
    fun hasInternetConnection(context: Context): Boolean {
        val connectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
        
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            val network = connectivityManager.activeNetwork ?: return false
            val capabilities = connectivityManager.getNetworkCapabilities(network) ?: return false
            
            capabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET) &&
            capabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED)
        } else {
            @Suppress("DEPRECATION")
            val networkInfo = connectivityManager.activeNetworkInfo
            networkInfo?.isConnected == true
        }
    }
    
    /**
     * Verifica se √© poss√≠vel conectar ao Firebase
     */
    suspend fun canReachFirebase(): Boolean = withContext(Dispatchers.IO) {
        try {
            val url = URL("https://firebase.googleapis.com")
            val connection = url.openConnection() as HttpURLConnection
            connection.connectTimeout = 5000
            connection.readTimeout = 5000
            connection.requestMethod = "HEAD"
            val responseCode = connection.responseCode
            connection.disconnect()
            
            // Firebase retorna 404 para HEAD requests na raiz, mas isso indica que o servi√ßo est√° respondendo
            // Considerar reachable para c√≥digos que indicam que o servidor est√° respondendo
            val canReach = when (responseCode) {
                in 200..399 -> true
                HttpURLConnection.HTTP_NOT_FOUND -> {
                    // 404 na raiz do Firebase √© esperado (servidor est√° respondendo, mas endpoint n√£o existe)
                    Log.d(TAG, "Firebase endpoint retornou 404 (esperado para HEAD na raiz), mas servidor est√° respondendo")
                    true
                }
                HttpURLConnection.HTTP_FORBIDDEN,
                HttpURLConnection.HTTP_UNAUTHORIZED,
                HttpURLConnection.HTTP_BAD_METHOD -> true
                else -> false
            }
            Log.d(TAG, "Firebase reachable: $canReach (response code: $responseCode)")
            canReach
        } catch (e: Exception) {
            Log.e(TAG, "Cannot reach Firebase: ${e.message}", e)
            false
        }
    }
    
    /**
     * Verifica se √© poss√≠vel conectar ao Google
     */
    suspend fun canReachGoogle(): Boolean = withContext(Dispatchers.IO) {
        try {
            val url = URL("https://www.google.com")
            val connection = url.openConnection() as HttpURLConnection
            connection.connectTimeout = 5000
            connection.readTimeout = 5000
            connection.requestMethod = "HEAD"
            val responseCode = connection.responseCode
            connection.disconnect()
            
            val canReach = responseCode in 200..399
            Log.d(TAG, "Google reachable: $canReach (response code: $responseCode)")
            canReach
        } catch (e: Exception) {
            Log.e(TAG, "Cannot reach Google: ${e.message}", e)
            false
        }
    }
    
    /**
     * Verifica se √© poss√≠vel conectar ao reCAPTCHA
     */
    suspend fun canReachRecaptcha(): Boolean = withContext(Dispatchers.IO) {
        try {
            val url = URL("https://www.google.com/recaptcha/api.js")
            val connection = url.openConnection() as HttpURLConnection
            connection.connectTimeout = 5000
            connection.readTimeout = 5000
            connection.requestMethod = "HEAD"
            val responseCode = connection.responseCode
            connection.disconnect()
            
            val canReach = responseCode in 200..399
            Log.d(TAG, "reCAPTCHA reachable: $canReach (response code: $responseCode)")
            canReach
        } catch (e: Exception) {
            Log.e(TAG, "Cannot reach reCAPTCHA: ${e.message}", e)
            false
        }
    }
    
    /**
     * Executa diagn√≥stico completo de rede
     */
    suspend fun diagnose(context: Context): NetworkDiagnosticResult {
        Log.d(TAG, "=== INICIANDO DIAGN√ìSTICO DE REDE ===")
        
        val hasConnection = hasInternetConnection(context)
        Log.d(TAG, "Conex√£o de internet dispon√≠vel: $hasConnection")
        
        if (!hasConnection) {
            return NetworkDiagnosticResult(
                hasInternet = false,
                canReachFirebase = false,
                canReachGoogle = false,
                canReachRecaptcha = false,
                error = "Sem conex√£o de internet"
            )
        }
        
        val canReachGoogle = canReachGoogle()
        val canReachFirebase = canReachFirebase()
        val canReachRecaptcha = canReachRecaptcha()
        
        val result = NetworkDiagnosticResult(
            hasInternet = true,
            canReachFirebase = canReachFirebase,
            canReachGoogle = canReachGoogle,
            canReachRecaptcha = canReachRecaptcha,
            error = if (!canReachFirebase) "N√£o √© poss√≠vel conectar ao Firebase" else null
        )
        
        Log.d(TAG, "=== DIAGN√ìSTICO CONCLU√çDO ===")
        Log.d(TAG, "Resultado: $result")
        
        return result
    }
}

data class NetworkDiagnosticResult(
    val hasInternet: Boolean,
    val canReachFirebase: Boolean,
    val canReachGoogle: Boolean,
    val canReachRecaptcha: Boolean,
    val error: String? = null
) {
    val isHealthy: Boolean
        get() = hasInternet && canReachFirebase && canReachGoogle && canReachRecaptcha
}


```

# Core - notifications


## [FRONTEND]: core/notifications/NotificationManager.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.core.notifications

import android.app.NotificationChannel
import android.content.Context
import android.os.Build
import androidx.core.app.NotificationCompat
import androidx.core.app.NotificationManagerCompat
import com.taskgoapp.taskgo.R
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class NotificationManager @Inject constructor(
    private val context: Context
) {
    
    companion object {
        const val CHANNEL_ID = "taskgo.default"
        const val CHANNEL_NAME = "TaskGo"
        const val CHANNEL_DESCRIPTION = "Notifica√ß√µes do TaskGo"
    }
    
    init {
        createNotificationChannel()
    }
    
    private fun createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(
                CHANNEL_ID,
                CHANNEL_NAME,
                android.app.NotificationManager.IMPORTANCE_DEFAULT
            ).apply {
                description = CHANNEL_DESCRIPTION
            }
            
            val notificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as android.app.NotificationManager
            notificationManager.createNotificationChannel(channel)
        }
    }
    
    fun showNotification(
        id: Int,
        title: String,
        message: String,
        actionText: String? = null
    ) {
        val builder = NotificationCompat.Builder(context, CHANNEL_ID)
            .setSmallIcon(R.drawable.ic_launcher_foreground)
            .setContentTitle(title)
            .setContentText(message)
            .setPriority(NotificationCompat.PRIORITY_DEFAULT)
            .setAutoCancel(true)
        
        if (actionText != null) {
            builder.addAction(
                R.drawable.ic_launcher_foreground,
                actionText,
                null // PendingIntent would go here
            )
        }
        
        with(NotificationManagerCompat.from(context)) {
            if (areNotificationsEnabled()) {
                notify(id, builder.build())
            }
        }
    }
    
    fun showOrderShippedNotification(orderId: String) {
        showNotification(
            id = orderId.hashCode(),
            title = "Pedido Enviado",
            message = "Seu pedido foi despachado e est√° a caminho!",
            actionText = "Acompanhar"
        )
    }
    
    fun showProposalApprovedNotification(proposalId: String) {
        showNotification(
            id = proposalId.hashCode(),
            title = "Proposta Aprovada",
            message = "Sua proposta foi aceita pelo cliente!",
            actionText = "Ver Detalhes"
        )
    }
    
    fun showNewMessageNotification(threadId: String, senderName: String) {
        showNotification(
            id = threadId.hashCode(),
            title = "Nova Mensagem",
            message = "$senderName enviou uma mensagem",
            actionText = "Responder"
        )
    }
    
    fun showUpdateAvailableNotification() {
        showNotification(
            id = "update".hashCode(),
            title = "Atualiza√ß√£o Dispon√≠vel",
            message = "Uma nova vers√£o do TaskGo est√° dispon√≠vel",
            actionText = "Atualizar"
        )
    }
    
    fun showServiceOrderPublishedNotification(orderId: String) {
        showNotification(
            id = orderId.hashCode(),
            title = "Ordem de Servi√ßo Publicada",
            message = "Sua ordem foi publicada e j√° recebeu propostas!",
            actionText = "Ver Propostas"
        )
    }
}

```

# Core - payment


## [FRONTEND]: core/payment/GooglePayManager.kt

```kotlin
package com.taskgoapp.taskgo.core.payment

import android.app.Activity
import android.content.Context
import com.google.android.gms.common.api.ApiException
import com.google.android.gms.tasks.Task
import com.google.android.gms.wallet.*
import org.json.JSONArray
import org.json.JSONException
import org.json.JSONObject

class GooglePayManager(private val context: Context) {

    private val paymentsClient: PaymentsClient = Wallet.getPaymentsClient(
        context,
        Wallet.WalletOptions.Builder()
            .setEnvironment(WalletConstants.ENVIRONMENT_TEST) // Mude para PRODUCTION em produ√ß√£o
            .build()
    )

    /**
     * Verifica se o Google Pay est√° dispon√≠vel no dispositivo
     */
    fun isReadyToPay(): Task<Boolean> {
        val request = IsReadyToPayRequest.fromJson(createIsReadyToPayRequest().toString())
        return paymentsClient.isReadyToPay(request)
    }

    /**
     * Cria uma solicita√ß√£o de pagamento
     */
    fun createPaymentRequest(
        price: String,
        currencyCode: String = "BRL",
        priceStatus: String = "FINAL"
    ): PaymentDataRequest {
        val request = createPaymentDataRequest(price, currencyCode, priceStatus)
        return PaymentDataRequest.fromJson(request.toString())
    }

    /**
     * Inicia o fluxo de pagamento
     */
    fun loadPaymentData(
        activity: Activity,
        price: String,
        currencyCode: String = "BRL",
        onSuccess: (PaymentData) -> Unit,
        onError: (Exception) -> Unit
    ) {
        isReadyToPay().addOnCompleteListener { task ->
            if (task.isSuccessful && task.result == true) {
                val request = createPaymentRequest(price, currencyCode)
                val taskPayment = paymentsClient.loadPaymentData(request)
                taskPayment.addOnCompleteListener { paymentTask ->
                    if (paymentTask.isSuccessful) {
                        onSuccess(paymentTask.result)
                    } else {
                        val exception = paymentTask.exception
                        if (exception is ApiException) {
                            when (exception.statusCode) {
                                WalletConstants.RESULT_ERROR -> {
                                    // Erro desconhecido
                                    onError(exception)
                                }
                                16 -> { // RESULT_CANCELED
                                    // Usu√°rio cancelou
                                    onError(Exception("Pagamento cancelado pelo usu√°rio"))
                                }
                                else -> {
                                    onError(exception)
                                }
                            }
                        } else {
                            onError(exception ?: Exception("Erro desconhecido"))
                        }
                    }
                }
            } else {
                onError(Exception("Google Pay n√£o est√° dispon√≠vel neste dispositivo"))
            }
        }
    }

    private fun createIsReadyToPayRequest(): JSONObject {
        return JSONObject().apply {
            put("apiVersion", 2)
            put("apiVersionMinor", 0)
            put("allowedPaymentMethods", JSONArray().apply {
                put(JSONObject().apply {
                    put("type", "CARD")
                    put("parameters", JSONObject().apply {
                        put("allowedAuthMethods", JSONArray().apply {
                            put("PAN_ONLY")
                            put("CRYPTOGRAM_3DS")
                        })
                        put("allowedCardNetworks", JSONArray().apply {
                            put("AMEX")
                            put("DISCOVER")
                            put("JCB")
                            put("MASTERCARD")
                            put("VISA")
                        })
                    })
                    put("tokenizationSpecification", JSONObject().apply {
                        put("type", "PAYMENT_GATEWAY")
                        put("parameters", JSONObject().apply {
                            put("gateway", "stripe")
                            // Stripe gateway merchant ID - deve ser configurado via vari√°vel de ambiente
                            // Para produ√ß√£o, use o merchant ID do Stripe obtido do dashboard
                            put("gatewayMerchantId", "stripe")
                        })
                    })
                })
            })
        }
    }

    private fun createPaymentDataRequest(
        price: String,
        currencyCode: String,
        priceStatus: String
    ): JSONObject {
        val paymentDataRequest = JSONObject().apply {
            put("apiVersion", 2)
            put("apiVersionMinor", 0)
            put("merchantInfo", JSONObject().apply {
                put("merchantName", "TaskGo")
                // Merchant ID do Google Pay - deve ser configurado no Google Pay Console
                // Para produ√ß√£o, use o merchant ID real obtido do Google Pay Business Console
                put("merchantId", "01234567890123456789")
            })
            put("allowedPaymentMethods", JSONArray().apply {
                put(JSONObject().apply {
                    put("type", "CARD")
                    put("parameters", JSONObject().apply {
                        put("allowedAuthMethods", JSONArray().apply {
                            put("PAN_ONLY")
                            put("CRYPTOGRAM_3DS")
                        })
                        put("allowedCardNetworks", JSONArray().apply {
                            put("AMEX")
                            put("DISCOVER")
                            put("JCB")
                            put("MASTERCARD")
                            put("VISA")
                        })
                        put("billingAddressRequired", true)
                        put("billingAddressParameters", JSONObject().apply {
                            put("format", "FULL")
                        })
                    })
                    put("tokenizationSpecification", JSONObject().apply {
                        put("type", "PAYMENT_GATEWAY")
                        put("parameters", JSONObject().apply {
                            put("gateway", "stripe")
                            // Stripe gateway merchant ID - deve ser configurado via vari√°vel de ambiente
                            // Para produ√ß√£o, use o merchant ID do Stripe obtido do dashboard
                            put("gatewayMerchantId", "stripe")
                        })
                    })
                })
            })
            put("transactionInfo", JSONObject().apply {
                put("totalPriceStatus", priceStatus)
                put("totalPrice", price)
                put("totalPriceLabel", "Total")
                put("currencyCode", currencyCode)
            })
            put("shippingAddressRequired", false)
            put("emailRequired", true)
        }

        return paymentDataRequest
    }

    /**
     * Extrai informa√ß√µes do pagamento do PaymentData
     */
    fun extractPaymentInfo(paymentData: PaymentData): PaymentInfo {
        val paymentInfoJson = paymentData.toJson()
        return try {
            val paymentDataJson = JSONObject(paymentInfoJson)
            val paymentMethodData = paymentDataJson.getJSONObject("paymentMethodData")
            val tokenizationData = paymentMethodData.getJSONObject("tokenizationData")
            val token = tokenizationData.getString("token")
            
            PaymentInfo(
                token = token,
                email = paymentDataJson.optString("email"),
                billingAddress = paymentDataJson.optJSONObject("billingAddress")?.toString()
            )
        } catch (e: JSONException) {
            throw Exception("Erro ao processar dados do pagamento", e)
        }
    }
}

data class PaymentInfo(
    val token: String,
    val email: String?,
    val billingAddress: String?
)


```

## [FRONTEND]: core/payment/PaymentGateway.kt

```kotlin
package com.taskgoapp.taskgo.core.payment

import com.taskgoapp.taskgo.core.model.PaymentType
import com.taskgoapp.taskgo.core.tracking.TrackingCodeGenerator
import com.taskgoapp.taskgo.data.firebase.FirebaseFunctionsService
import com.taskgoapp.taskgo.domain.usecase.CheckoutUseCase
import com.taskgoapp.taskgo.domain.repository.TrackingRepository
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class PaymentGateway @Inject constructor(
    private val checkoutUseCase: CheckoutUseCase,
    private val functionsService: FirebaseFunctionsService,
    private val trackingRepository: TrackingRepository
) {

    suspend fun process(request: PaymentGatewayRequest): Result<PaymentGatewayResult> {
        return try {
            // Criar pedido primeiro
            // Mapear PaymentType para string leg√≠vel
            val paymentMethodString = when (request.paymentType) {
                PaymentType.CREDIT_CARD -> "Cr√©dito"
                PaymentType.DEBIT_CARD -> "D√©bito"
                PaymentType.PIX -> "Pix"
            }
            val orderResult = checkoutUseCase.invoke(
                paymentMethod = paymentMethodString,
                addressId = request.addressId
            )
            val orderId = orderResult.getOrThrow()

            // Se for PIX, criar pagamento PIX
            if (request.paymentType == PaymentType.PIX) {
                val pixData = functionsService.createPixPayment(orderId).getOrElse { throw it }
                val pixKey = pixData["pixKey"] as? String ?: ""
                val qrCodeData = pixData["qrCodeData"] as? String ?: ""
                
                // Para PIX, o pagamento fica pendente at√© confirma√ß√£o
                // N√£o confirmamos automaticamente como nos cart√µes
                
                return Result.success(
                    PaymentGatewayResult(
                        orderId = orderId,
                        paymentIntentId = pixKey, // Usar chave PIX como ID
                        clientSecret = qrCodeData, // Usar QR code data como secret
                        trackingCode = TrackingCodeGenerator.generate(orderId),
                        paymentType = request.paymentType
                    )
                )
            }

            // Para produtos, usar createProductPaymentIntent (com split payment e comiss√£o)
            // Para servi√ßos, usar createPaymentIntent (pagamento de servi√ßos)
            val intentData = if (isProductOrder(orderId)) {
                // Usar novo sistema de pagamento de produtos com Stripe Connect
                functionsService.createProductPaymentIntent(orderId).getOrElse { throw it }
            } else {
                // Usar sistema de pagamento de servi√ßos
                functionsService.createPaymentIntent(orderId).getOrElse { throw it }
            }
            
            val paymentIntentId = intentData["paymentIntentId"] as? String
                ?: intentData["id"] as? String
                ?: throw IllegalStateException("paymentIntentId n√£o retornado pelo backend")
            val clientSecret = intentData["clientSecret"] as? String
                ?: throw IllegalStateException("clientSecret n√£o retornado pelo backend")

            // N√ÉO confirmar pagamento aqui - o PaymentSheet vai processar o pagamento
            // O webhook do Stripe vai confirmar automaticamente quando o pagamento for bem-sucedido
            // Retornar o clientSecret para que o app possa apresentar o PaymentSheet
            
            Result.success(
                PaymentGatewayResult(
                    orderId = orderId,
                    paymentIntentId = paymentIntentId,
                    clientSecret = clientSecret,
                    trackingCode = TrackingCodeGenerator.generate(orderId),
                    paymentType = request.paymentType
                )
            )
        } catch (error: Exception) {
            Result.failure(error)
        }
    }
    
    // Verifica se √© um pedido de produto (purchase_order) ou servi√ßo (order)
    private suspend fun isProductOrder(orderId: String): Boolean {
        // Por padr√£o, assumimos que pedidos criados via checkout s√£o de produtos
        // Isso pode ser melhorado verificando a cole√ß√£o no Firestore
        return true // Por enquanto, sempre produtos
    }
}

data class PaymentGatewayRequest(
    val paymentType: PaymentType,
    val addressId: String
)

data class PaymentGatewayResult(
    val orderId: String,
    val paymentIntentId: String,
    val clientSecret: String?,
    val trackingCode: String,
    val paymentType: PaymentType
)


```

## [FRONTEND]: core/payment/StripePaymentManager.kt

```kotlin
package com.taskgoapp.taskgo.core.payment

import android.app.Activity
import androidx.activity.ComponentActivity
import com.stripe.android.PaymentConfiguration
import com.stripe.android.paymentsheet.PaymentSheet
import com.stripe.android.paymentsheet.PaymentSheetResult
import kotlinx.coroutines.suspendCancellableCoroutine
import javax.inject.Inject
import javax.inject.Singleton
import kotlin.coroutines.resume

@Singleton
class StripePaymentManager @Inject constructor() {
    
    private var isStripeInitialized = false
    
    /**
     * Initialize Stripe with publishable key
     */
    fun initialize(activity: Activity, publishableKey: String) {
        PaymentConfiguration.init(activity.application, publishableKey)
        isStripeInitialized = true
    }
    
    /**
     * Present PaymentSheet to user and process payment
     * Returns PaymentSheetResult indicating success or failure
     */
    suspend fun presentPaymentSheet(
        activity: Activity,
        clientSecret: String,
        customerId: String? = null,
        customerEphemeralKeySecret: String? = null
    ): Result<PaymentSheetResult> = suspendCancellableCoroutine { continuation ->
        try {
            if (!isStripeInitialized) {
                throw IllegalStateException("Stripe not initialized. Call initialize() first.")
            }
            
            val componentActivity = activity as? ComponentActivity
                ?: throw IllegalArgumentException("Activity must be a ComponentActivity")
            
            val paymentSheet = PaymentSheet(componentActivity) { result: PaymentSheetResult ->
                when (result) {
                    is PaymentSheetResult.Completed -> {
                        continuation.resume(Result.success(result))
                    }
                    is PaymentSheetResult.Canceled -> {
                        continuation.resume(Result.failure(Exception("Payment canceled by user")))
                    }
                    is PaymentSheetResult.Failed -> {
                        continuation.resume(Result.failure(result.error))
                    }
                }
            }
            
            val paymentSheetConfiguration = PaymentSheet.Configuration.Builder("TaskGo")
                .apply {
                    customerId?.let { customer ->
                        customerEphemeralKeySecret?.let { ephemeralKey ->
                            customer(
                                PaymentSheet.CustomerConfiguration(
                                    id = customer,
                                    ephemeralKeySecret = ephemeralKey
                                )
                            )
                        }
                    }
                }
                .build()
            
            paymentSheet.presentWithPaymentIntent(
                paymentIntentClientSecret = clientSecret,
                configuration = paymentSheetConfiguration
            )
        } catch (e: Exception) {
            continuation.resume(Result.failure(e))
        }
    }
    
    /**
     * Check if Stripe is initialized
     */
    fun isInitialized(): Boolean {
        return isStripeInitialized
    }
}


```

# Core - permissions


## [FRONTEND]: core/permissions/PermissionHandler.kt

```kotlin
package com.taskgoapp.taskgo.core.permissions

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.os.Build
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.runtime.Composable
import androidx.compose.runtime.remember
import androidx.compose.ui.platform.LocalContext
import androidx.core.content.ContextCompat

/**
 * Handler para solicitar permiss√µes em runtime usando Compose
 */
object PermissionHandler {
    
    /**
     * Verifica se uma permiss√£o foi concedida
     */
    fun hasPermission(context: Context, permission: String): Boolean {
        return ContextCompat.checkSelfPermission(
            context,
            permission
        ) == PackageManager.PERMISSION_GRANTED
    }
    
    /**
     * Verifica se a permiss√£o de c√¢mera foi concedida
     */
    fun hasCameraPermission(context: Context): Boolean {
        return hasPermission(context, Manifest.permission.CAMERA)
    }
    
    /**
     * Verifica se a permiss√£o de leitura de imagens foi concedida
     * (compat√≠vel com Android 13+ e vers√µes anteriores)
     */
    fun hasImageReadPermission(context: Context): Boolean {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            hasPermission(context, Manifest.permission.READ_MEDIA_IMAGES)
        } else {
            hasPermission(context, Manifest.permission.READ_EXTERNAL_STORAGE)
        }
    }
    
    /**
     * Verifica se a permiss√£o de notifica√ß√µes foi concedida
     */
    fun hasNotificationPermission(context: Context): Boolean {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            hasPermission(context, Manifest.permission.POST_NOTIFICATIONS)
        } else {
            true // N√£o necess√°rio em vers√µes anteriores
        }
    }
    
    /**
     * Verifica se a permiss√£o de localiza√ß√£o foi concedida
     */
    fun hasLocationPermission(context: Context): Boolean {
        val fineLocation = hasPermission(context, Manifest.permission.ACCESS_FINE_LOCATION)
        val coarseLocation = hasPermission(context, Manifest.permission.ACCESS_COARSE_LOCATION)
        return fineLocation || coarseLocation
    }
    
    /**
     * Retorna a permiss√£o de leitura de imagens apropriada para a vers√£o do Android
     */
    fun getImageReadPermission(): String {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            Manifest.permission.READ_MEDIA_IMAGES
        } else {
            Manifest.permission.READ_EXTERNAL_STORAGE
        }
    }
}

/**
 * Composable para criar um launcher de permiss√£o de c√¢mera
 */
@Composable
fun rememberCameraPermissionLauncher(
    onPermissionGranted: () -> Unit,
    onPermissionDenied: () -> Unit = {}
): androidx.activity.result.ActivityResultLauncher<String> {
    val context = LocalContext.current
    
    return rememberLauncherForActivityResult(
        contract = ActivityResultContracts.RequestPermission()
    ) { isGranted: Boolean ->
        if (isGranted) {
            onPermissionGranted()
        } else {
            onPermissionDenied()
        }
    }
}

/**
 * Composable para criar um launcher de permiss√£o de leitura de imagens
 */
@Composable
fun rememberImageReadPermissionLauncher(
    onPermissionGranted: () -> Unit,
    onPermissionDenied: () -> Unit = {}
): androidx.activity.result.ActivityResultLauncher<String> {
    val context = LocalContext.current
    
    return rememberLauncherForActivityResult(
        contract = ActivityResultContracts.RequestPermission()
    ) { isGranted: Boolean ->
        if (isGranted) {
            onPermissionGranted()
        } else {
            onPermissionDenied()
        }
    }
}

/**
 * Composable para criar um launcher de permiss√£o de notifica√ß√µes
 */
@Composable
fun rememberNotificationPermissionLauncher(
    onPermissionGranted: () -> Unit,
    onPermissionDenied: () -> Unit = {}
): androidx.activity.result.ActivityResultLauncher<String>? {
    val context = LocalContext.current
    
    return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
        rememberLauncherForActivityResult(
            contract = ActivityResultContracts.RequestPermission()
        ) { isGranted: Boolean ->
            if (isGranted) {
                onPermissionGranted()
            } else {
                onPermissionDenied()
            }
        }
    } else {
        // Permiss√£o n√£o necess√°ria em vers√µes anteriores
        null
    }
}

/**
 * Composable para criar um launcher de m√∫ltiplas permiss√µes
 */
@Composable
fun rememberMultiplePermissionsLauncher(
    onAllPermissionsGranted: () -> Unit,
    onPermissionDenied: () -> Unit = {}
): androidx.activity.result.ActivityResultLauncher<Array<String>> {
    return rememberLauncherForActivityResult(
        contract = ActivityResultContracts.RequestMultiplePermissions()
    ) { permissions: Map<String, Boolean> ->
        val allGranted = permissions.values.all { it }
        if (allGranted) {
            onAllPermissionsGranted()
        } else {
            onPermissionDenied()
        }
    }
}


```

## [FRONTEND]: core/permissions/PermissionManager.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.core.permissions

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.os.Build
import androidx.core.content.ContextCompat
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class PermissionManager @Inject constructor(
    private val context: Context
) {
    
    fun hasNotificationPermission(): Boolean {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            ContextCompat.checkSelfPermission(
                context,
                Manifest.permission.POST_NOTIFICATIONS
            ) == PackageManager.PERMISSION_GRANTED
        } else {
            true // Permission not required for older versions
        }
    }
    
    fun hasImagePermission(): Boolean {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            ContextCompat.checkSelfPermission(
                context,
                Manifest.permission.READ_MEDIA_IMAGES
            ) == PackageManager.PERMISSION_GRANTED
        } else {
            ContextCompat.checkSelfPermission(
                context,
                Manifest.permission.READ_EXTERNAL_STORAGE
            ) == PackageManager.PERMISSION_GRANTED
        }
    }
    
    fun hasCameraPermission(): Boolean {
        return ContextCompat.checkSelfPermission(
            context,
            Manifest.permission.CAMERA
        ) == PackageManager.PERMISSION_GRANTED
    }
    
    fun hasLocationPermission(): Boolean {
        val fineLocation = ContextCompat.checkSelfPermission(
            context,
            Manifest.permission.ACCESS_FINE_LOCATION
        ) == PackageManager.PERMISSION_GRANTED
        
        val coarseLocation = ContextCompat.checkSelfPermission(
            context,
            Manifest.permission.ACCESS_COARSE_LOCATION
        ) == PackageManager.PERMISSION_GRANTED
        
        return fineLocation || coarseLocation
    }
    
    fun getRequiredPermissions(): List<String> {
        val permissions = mutableListOf<String>()
        
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            permissions.add(Manifest.permission.POST_NOTIFICATIONS)
            permissions.add(Manifest.permission.READ_MEDIA_IMAGES)
        } else {
            permissions.add(Manifest.permission.READ_EXTERNAL_STORAGE)
        }
        
        permissions.add(Manifest.permission.CAMERA)
        permissions.add(Manifest.permission.ACCESS_COARSE_LOCATION)
        permissions.add(Manifest.permission.ACCESS_FINE_LOCATION)
        
        return permissions
    }
}


```

# Core - photo


## [FRONTEND]: core/photo/ImageRepository.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.core.photo

import android.content.ContentResolver
import android.net.Uri
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class ImageRepository @Inject constructor(
    private val photoPickerManager: PhotoPickerManager
) {
    
    suspend fun saveImageUri(contentResolver: ContentResolver, uri: Uri): String {
        // Take persistable URI permission
        photoPickerManager.takePersistableUriPermission(contentResolver, uri)
        
        // Return the URI string for storage in Room
        return uri.toString()
    }
    
    fun getImageUri(uriString: String): Uri? {
        return try {
            Uri.parse(uriString)
        } catch (e: Exception) {
            null
        }
    }
}

```

## [FRONTEND]: core/photo/PhotoPickerManager.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.core.photo

import android.content.ContentResolver
import android.content.Context
import android.content.Intent
import android.net.Uri
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class PhotoPickerManager @Inject constructor(
    private val context: Context
) {
    
    fun takePersistableUriPermission(contentResolver: ContentResolver, uri: Uri) {
        try {
            contentResolver.takePersistableUriPermission(
                uri,
                Intent.FLAG_GRANT_READ_URI_PERMISSION
            )
        } catch (e: SecurityException) {
            // Handle permission error
        }
    }
}

```

# Core - recommendation


## [FRONTEND]: core/recommendation/PersonalizedRecommendationEngine.kt

```kotlin
package com.taskgoapp.taskgo.core.recommendation

import android.util.Log
import com.taskgoapp.taskgo.core.model.Product
import com.taskgoapp.taskgo.core.model.ServiceOrder
import com.taskgoapp.taskgo.data.firestore.models.ReviewFirestore
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import javax.inject.Inject
import javax.inject.Singleton
import kotlin.math.*

/**
 * Motor de recomenda√ß√£o personalizado avan√ßado
 * Analisa padr√µes de compra, avalia√ß√µes, promo√ß√µes e comportamento do usu√°rio
 * para criar recomenda√ß√µes altamente personalizadas que aumentam reten√ß√£o
 */
@Singleton
class PersonalizedRecommendationEngine @Inject constructor() {
    
    companion object {
        private const val TAG = "RecommendationEngine"
        
        // Pesos para diferentes fatores de recomenda√ß√£o
        private const val WEIGHT_PURCHASE_HISTORY = 0.35f
        private const val WEIGHT_REVIEWS = 0.25f
        private const val WEIGHT_PROMOTIONS = 0.15f
        private const val WEIGHT_CATEGORY_PREFERENCE = 0.15f
        private const val WEIGHT_LOCATION = 0.10f
        
        // Fatores de decaimento temporal (quanto mais recente, mais relevante)
        private const val TIME_DECAY_FACTOR = 0.1f
    }
    
    /**
     * Calcula score de recomenda√ß√£o para um produto
     */
    suspend fun calculateProductScore(
        product: Product,
        userPurchaseHistory: List<UserPurchase>,
        userReviews: List<ReviewFirestore>,
        userLocation: UserLocation?,
        currentPromotions: List<Promotion>,
        userCategoryPreferences: Map<String, Float>
    ): Float {
        var totalScore = 0f
        
        // 1. Hist√≥rico de compras (35%)
        val purchaseScore = calculatePurchaseHistoryScore(
            product = product,
            purchaseHistory = userPurchaseHistory
        )
        totalScore += purchaseScore * WEIGHT_PURCHASE_HISTORY
        
        // 2. Avalia√ß√µes (25%)
        val reviewScore = calculateReviewScore(
            product = product,
            userReviews = userReviews,
            allProductReviews = emptyList() // Ser√° passado do reposit√≥rio
        )
        totalScore += reviewScore * WEIGHT_REVIEWS
        
        // 3. Promo√ß√µes (15%)
        val promotionScore = calculatePromotionScore(
            product = product,
            promotions = currentPromotions
        )
        totalScore += promotionScore * WEIGHT_PROMOTIONS
        
        // 4. Prefer√™ncias de categoria (15%)
        val categoryScore = calculateCategoryPreferenceScore(
            product = product,
            categoryPreferences = userCategoryPreferences
        )
        totalScore += categoryScore * WEIGHT_CATEGORY_PREFERENCE
        
        // 5. Localiza√ß√£o (10%)
        val locationScore = calculateLocationScore(
            product = product,
            userLocation = userLocation
        )
        totalScore += locationScore * WEIGHT_LOCATION
        
        return totalScore.coerceIn(0f, 1f)
    }
    
    /**
     * Calcula score baseado no hist√≥rico de compras
     */
    private fun calculatePurchaseHistoryScore(
        product: Product,
        purchaseHistory: List<UserPurchase>
    ): Float {
        if (purchaseHistory.isEmpty()) return 0.5f // Score neutro se n√£o houver hist√≥rico
        
        // Busca compras similares
        // Como Product n√£o tem category nem brand, comparamos apenas por pre√ßo similar
        val productPrice = product.price.toFloat()
        val similarPurchases = purchaseHistory.filter { purchase ->
            // Compara se o pre√ßo est√° em uma faixa similar (¬±30%)
            val priceDiff = kotlin.math.abs(purchase.price - productPrice) / productPrice
            priceDiff <= 0.3f
        }
        
        if (similarPurchases.isEmpty()) return 0.3f
        
        // Calcula score baseado em frequ√™ncia e rec√™ncia
        var score = 0f
        val now = System.currentTimeMillis()
        
        similarPurchases.forEach { purchase ->
            val timeDecay = exp(-TIME_DECAY_FACTOR * (now - purchase.timestamp) / (1000 * 60 * 60 * 24)) // Decaimento di√°rio
            val frequencyBonus = min(similarPurchases.size / 10f, 1f) // B√¥nus por frequ√™ncia
            score += (0.5f + frequencyBonus * 0.5f) * timeDecay.toFloat()
        }
        
        return (score / similarPurchases.size).coerceIn(0f, 1f)
    }
    
    /**
     * Calcula score baseado em avalia√ß√µes
     */
    private fun calculateReviewScore(
        product: Product,
        userReviews: List<ReviewFirestore>,
        allProductReviews: List<ReviewFirestore>
    ): Float {
        // Avalia√ß√µes do pr√≥prio usu√°rio para produtos similares
        val similarReviews = userReviews.filter { review ->
            review.type == "PRODUCT" && review.targetId == product.id.toString()
        }
        
        var score = 0.5f // Score base
        
        if (similarReviews.isNotEmpty()) {
            val avgRating = similarReviews.map { it.rating }.average().toFloat()
            score = (avgRating / 5f) // Normaliza para 0-1
        }
        
        // Considera avalia√ß√µes gerais do produto (se dispon√≠veis)
        val productReviews = allProductReviews.filter { it.targetId == product.id.toString() }
        if (productReviews.isNotEmpty()) {
            val avgProductRating = productReviews.map { it.rating }.average().toFloat()
            val generalScore = avgProductRating / 5f
            // Combina avalia√ß√£o pessoal (70%) com geral (30%)
            score = score * 0.7f + generalScore * 0.3f
        }
        
        return score.coerceIn(0f, 1f)
    }
    
    /**
     * Calcula score baseado em promo√ß√µes ativas
     */
    private fun calculatePromotionScore(
        product: Product,
        promotions: List<Promotion>
    ): Float {
        val activePromotion = promotions.find { it.productId == product.id.toString() }
        
        if (activePromotion == null) return 0.5f
        
        // Score baseado no desconto
        val discountPercent = activePromotion.discountPercent
        val score = when {
            discountPercent >= 50 -> 1.0f
            discountPercent >= 30 -> 0.8f
            discountPercent >= 20 -> 0.6f
            discountPercent >= 10 -> 0.4f
            else -> 0.2f
        }
        
        // B√¥nus por urg√™ncia (promo√ß√£o acabando)
        if (activePromotion.isUrgent) {
            return min(1.0f, score * 1.2f)
        }
        
        return score
    }
    
    /**
     * Calcula score baseado em prefer√™ncias de categoria
     */
    private fun calculateCategoryPreferenceScore(
        product: Product,
        categoryPreferences: Map<String, Float>
    ): Float {
        // Product n√£o tem category, ent√£o retornamos score neutro
        // Em uma implementa√ß√£o futura, poderia extrair categoria do t√≠tulo ou descri√ß√£o
        return 0.5f
    }
    
    /**
     * Calcula score baseado em localiza√ß√£o
     */
    private fun calculateLocationScore(
        product: Product,
        userLocation: UserLocation?
    ): Float {
        if (userLocation == null || product.latitude == null || product.longitude == null) {
            return 0.5f
        }
        
        // Calcula dist√¢ncia
        val distance = calculateDistance(
            lat1 = userLocation.latitude,
            lon1 = userLocation.longitude,
            lat2 = product.latitude.toDouble(),
            lon2 = product.longitude.toDouble()
        )
        
        // Score baseado na dist√¢ncia (quanto mais perto, maior o score)
        return when {
            distance < 5 -> 1.0f      // Menos de 5km
            distance < 10 -> 0.8f     // Menos de 10km
            distance < 25 -> 0.6f     // Menos de 25km
            distance < 50 -> 0.4f     // Menos de 50km
            else -> 0.2f              // Mais de 50km
        }
    }
    
    /**
     * Calcula dist√¢ncia entre duas coordenadas (Haversine)
     */
    private fun calculateDistance(lat1: Double, lon1: Double, lat2: Double, lon2: Double): Double {
        val R = 6371.0 // Raio da Terra em km
        val dLat = Math.toRadians(lat2 - lat1)
        val dLon = Math.toRadians(lon2 - lon1)
        val a = sin(dLat / 2) * sin(dLat / 2) +
                cos(Math.toRadians(lat1)) * cos(Math.toRadians(lat2)) *
                sin(dLon / 2) * sin(dLon / 2)
        val c = 2 * atan2(sqrt(a), sqrt(1 - a))
        return R * c
    }
    
    /**
     * Analisa padr√µes de comportamento do usu√°rio
     */
    fun analyzeUserPatterns(
        purchaseHistory: List<UserPurchase>,
        reviews: List<ReviewFirestore>,
        searchHistory: List<String>
    ): UserBehaviorPattern {
        // Categorias mais compradas
        val categoryFrequency = purchaseHistory.groupingBy { it.category }.eachCount()
        val topCategories = categoryFrequency.toList()
            .sortedByDescending { it.second }
            .take(5)
            .map { it.first }
        
        // Faixa de pre√ßo preferida
        val prices = purchaseHistory.map { it.price }
        val avgPrice = prices.average().toFloat()
        val priceRange = PriceRange(
            min = prices.minOrNull() ?: 0f,
            max = prices.maxOrNull() ?: Float.MAX_VALUE,
            average = avgPrice
        )
        
        // Hor√°rios de compra mais frequentes
        val purchaseHours = purchaseHistory.map { purchase ->
            java.util.Calendar.getInstance().apply {
                timeInMillis = purchase.timestamp
            }.get(java.util.Calendar.HOUR_OF_DAY)
        }
        val mostActiveHour = purchaseHours.groupingBy { it }.eachCount()
            .maxByOrNull { it.value }?.key ?: 12
        
        // Padr√µes de busca
        val searchTerms = searchHistory.flatMap { it.split(" ") }
        val topSearchTerms = searchTerms.groupingBy { it.lowercase() }.eachCount()
            .toList()
            .sortedByDescending { it.second }
            .take(10)
            .map { it.first }
        
        return UserBehaviorPattern(
            topCategories = topCategories,
            preferredPriceRange = priceRange,
            mostActiveHour = mostActiveHour,
            topSearchTerms = topSearchTerms,
            averageRatingGiven = reviews.map { it.rating }.average().toFloat(),
            totalPurchases = purchaseHistory.size,
            totalReviews = reviews.size
        )
    }
    
    /**
     * Gera recomenda√ß√µes personalizadas para o usu√°rio
     */
    suspend fun generatePersonalizedRecommendations(
        availableProducts: List<Product>,
        userContext: UserContext
    ): Flow<List<RecommendedItem>> = flow {
        val recommendations = availableProducts.map { product ->
            val score = calculateProductScore(
                product = product,
                userPurchaseHistory = userContext.purchaseHistory,
                userReviews = userContext.reviews,
                userLocation = userContext.location,
                currentPromotions = userContext.activePromotions,
                userCategoryPreferences = userContext.categoryPreferences
            )
            
            RecommendedItem(
                product = product,
                score = score,
                reasons = generateRecommendationReasons(product, userContext, score)
            )
        }
        .sortedByDescending { it.score }
        .take(20) // Top 20 recomenda√ß√µes
        
        emit(recommendations)
    }
    
    /**
     * Gera raz√µes para a recomenda√ß√£o (aumenta transpar√™ncia e confian√ßa)
     */
    private fun generateRecommendationReasons(
        product: Product,
        userContext: UserContext,
        score: Float
    ): List<String> {
        val reasons = mutableListOf<String>()
        
        // Raz√£o baseada em compras similares (por pre√ßo)
        val productPrice = product.price.toFloat()
        val similarPurchases = userContext.purchaseHistory.count { purchase ->
            val priceDiff = kotlin.math.abs(purchase.price - productPrice) / productPrice
            priceDiff <= 0.3f
        }
        if (similarPurchases > 0) {
            reasons.add("Voc√™ j√° comprou $similarPurchases ${if (similarPurchases == 1) "item similar" else "itens similares"}")
        }
        
        // Raz√£o baseada em promo√ß√£o
        val promotion = userContext.activePromotions.find { it.productId == product.id.toString() }
        if (promotion != null) {
            reasons.add("${promotion.discountPercent}% de desconto dispon√≠vel")
        }
        
        // Raz√£o baseada em localiza√ß√£o
        if (userContext.location != null && product.latitude != null && product.longitude != null) {
            val distance = calculateDistance(
                userContext.location.latitude,
                userContext.location.longitude,
                product.latitude,
                product.longitude
            )
            if (distance < 10) {
                reasons.add("Pr√≥ximo da sua localiza√ß√£o (${distance.toInt()}km)")
            }
        }
        
        // Raz√£o baseada em avalia√ß√µes
        val productReviews = userContext.reviews.filter { it.targetId == product.id.toString() }
        if (productReviews.isNotEmpty()) {
            val avgRating = productReviews.map { it.rating }.average()
            if (avgRating >= 4.0) {
                reasons.add("Bem avaliado (${String.format("%.1f", avgRating)}/5.0)")
            }
        }
        
        return reasons.ifEmpty { listOf("Recomendado para voc√™") }
    }
}

// Modelos de dados para o motor de recomenda√ß√£o
data class UserPurchase(
    val productId: String,
    val category: String,
    val price: Float,
    val brand: String?,
    val timestamp: Long,
    val rating: Float? = null
)

data class UserLocation(
    val latitude: Double,
    val longitude: Double
)

data class Promotion(
    val productId: String,
    val discountPercent: Int,
    val isUrgent: Boolean = false,
    val endDate: Long? = null
)

data class PriceRange(
    val min: Float,
    val max: Float,
    val average: Float
) {
    fun overlaps(price: Float): Boolean = price in min..max
}

data class UserBehaviorPattern(
    val topCategories: List<String>,
    val preferredPriceRange: PriceRange,
    val mostActiveHour: Int,
    val topSearchTerms: List<String>,
    val averageRatingGiven: Float,
    val totalPurchases: Int,
    val totalReviews: Int
)

data class UserContext(
    val purchaseHistory: List<UserPurchase>,
    val reviews: List<ReviewFirestore>,
    val location: UserLocation?,
    val activePromotions: List<Promotion>,
    val categoryPreferences: Map<String, Float>
)

data class RecommendedItem(
    val product: Product,
    val score: Float,
    val reasons: List<String>
)


```

# Core - security


## [FRONTEND]: core/security/DocumentVerificationBlock.kt

```kotlin
package com.taskgoapp.taskgo.core.security

import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Lock
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.taskgoapp.taskgo.core.theme.*

/**
 * Composable que bloqueia funcionalidades at√© documentos serem cadastrados
 */
@Composable
fun DocumentVerificationBlock(
    isVerified: Boolean,
    onVerifyClick: () -> Unit,
    content: @Composable () -> Unit
) {
    if (isVerified) {
        content()
    } else {
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(32.dp),
            contentAlignment = Alignment.Center
        ) {
            Column(
                horizontalAlignment = Alignment.CenterHorizontally,
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                Icon(
                    imageVector = Icons.Default.Lock,
                    contentDescription = null,
                    modifier = Modifier.size(64.dp),
                    tint = TaskGoGreen
                )
                
                Text(
                    text = "Verifica√ß√£o Necess√°ria",
                    style = MaterialTheme.typography.headlineSmall,
                    fontWeight = FontWeight.Bold,
                    color = TaskGoTextBlack,
                    textAlign = TextAlign.Center
                )
                
                Text(
                    text = "Para criar produtos e servi√ßos, voc√™ precisa completar a verifica√ß√£o de identidade enviando seus documentos.",
                    style = MaterialTheme.typography.bodyMedium,
                    color = TaskGoTextGray,
                    textAlign = TextAlign.Center
                )
                
                Spacer(modifier = Modifier.height(8.dp))
                
                Button(
                    onClick = onVerifyClick,
                    colors = ButtonDefaults.buttonColors(
                        containerColor = TaskGoGreen
                    ),
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Text(
                        text = "Verificar Identidade",
                        style = MaterialTheme.typography.bodyLarge,
                        fontWeight = FontWeight.Bold
                    )
                }
            }
        }
    }
}


```

## [FRONTEND]: core/security/DocumentVerificationManager.kt

```kotlin
package com.taskgoapp.taskgo.core.security

import android.content.Context
import android.util.Log
import com.google.firebase.auth.FirebaseAuth
import com.taskgoapp.taskgo.core.model.Result
import com.taskgoapp.taskgo.data.repository.FirestoreUserRepository
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.tasks.await
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Gerenciador de verifica√ß√£o de documentos e bloqueio de funcionalidades
 */
@Singleton
class DocumentVerificationManager @Inject constructor(
    private val firestoreUserRepository: FirestoreUserRepository,
    private val auth: FirebaseAuth
) {
    
    /**
     * Verifica se o usu√°rio tem documentos cadastrados
     */
    suspend fun hasDocumentsVerified(): Boolean {
        // DESATIVADO TEMPORARIAMENTE PARA TESTES: liberar cria√ß√£o de produtos/servi√ßos
        return true
    }
    
    /**
     * Observa o status de verifica√ß√£o de documentos
     */
    fun observeVerificationStatus(): Flow<Boolean> = flow {
        while (true) {
            emit(hasDocumentsVerified())
            kotlinx.coroutines.delay(5000) // Verificar a cada 5 segundos
        }
    }
    
    /**
     * Verifica se o usu√°rio pode criar produtos/servi√ßos
     */
    suspend fun canCreateContent(): Boolean {
        // DESATIVADO TEMPORARIAMENTE PARA TESTES
        return true
    }
    
    /**
     * Cria notifica√ß√£o para lembrar cadastro de documentos
     */
    suspend fun createDocumentReminderNotification(): Result<String> {
        val currentUser = auth.currentUser ?: return Result.Error(Exception("Usu√°rio n√£o autenticado"))
        
        return try {
            val notificationRepository = com.taskgoapp.taskgo.data.repository.FirestoreNotificationRepository(
                com.taskgoapp.taskgo.core.firebase.FirestoreHelper.getInstance(),
                auth
            )
            
            notificationRepository.createNotification(
                type = "document_verification",
                title = "Complete seu cadastro",
                message = "Para criar produtos e servi√ßos, voc√™ precisa enviar seus documentos de identifica√ß√£o.",
                data = mapOf("action" to "verify_identity")
            )
        } catch (e: Exception) {
            Log.e("DocumentVerificationManager", "Erro ao criar notifica√ß√£o: ${e.message}", e)
            Result.Error(e)
        }
    }
}


```

## [FRONTEND]: core/security/FaceVerificationManager.kt

```kotlin
package com.taskgoapp.taskgo.core.security

import android.content.Context
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.net.Uri
import android.util.Log
import com.google.mlkit.vision.common.InputImage
import com.google.mlkit.vision.face.Face
import com.google.mlkit.vision.face.FaceDetection
import com.google.mlkit.vision.face.FaceDetector
import com.google.mlkit.vision.face.FaceDetectorOptions
import kotlinx.coroutines.suspendCancellableCoroutine
import java.io.InputStream
import kotlin.coroutines.resume
import kotlin.coroutines.resumeWithException

/**
 * Gerenciador de verifica√ß√£o facial usando ML Kit
 * Compara uma selfie com a foto do documento para verificar identidade
 */
class FaceVerificationManager(private val context: Context) {

    private val faceDetector: FaceDetector = FaceDetection.getClient(
        FaceDetectorOptions.Builder()
            .setPerformanceMode(FaceDetectorOptions.PERFORMANCE_MODE_ACCURATE) // Mudado para ACCURATE para melhor detec√ß√£o
            .setLandmarkMode(FaceDetectorOptions.LANDMARK_MODE_ALL) // CR√çTICO: Mudado para ALL para obter landmarks necess√°rios para compara√ß√£o
            .setClassificationMode(FaceDetectorOptions.CLASSIFICATION_MODE_ALL) // Habilitar classifica√ß√£o para melhor precis√£o
            .enableTracking()
            .build()
    )

    /**
     * Detecta faces em uma imagem
     */
    suspend fun detectFaces(imageUri: Uri): List<Face> = suspendCancellableCoroutine { continuation ->
        try {
            // Usa BitmapUtils para carregar e redimensionar a imagem
            val bitmap = com.taskgoapp.taskgo.core.utils.BitmapUtils.loadAndResizeBitmap(
                context,
                imageUri,
                maxDimension = 1024 // Limita a 1024px para detec√ß√£o facial
            )

            if (bitmap == null) {
                continuation.resumeWithException(Exception("N√£o foi poss√≠vel carregar a imagem"))
                return@suspendCancellableCoroutine
            }

            val image = InputImage.fromBitmap(bitmap, 0)
            
            faceDetector.process(image)
                .addOnSuccessListener { faces ->
                    Log.d(TAG, "Faces detectadas: ${faces.size}")
                    continuation.resume(faces)
                }
                .addOnFailureListener { e ->
                    Log.e(TAG, "Erro ao detectar faces: ${e.message}", e)
                    continuation.resumeWithException(e)
                }
        } catch (e: Exception) {
            Log.e(TAG, "Erro ao processar imagem: ${e.message}", e)
            continuation.resumeWithException(e)
        }
    }

    /**
     * Verifica se h√° uma face na imagem
     */
    suspend fun hasFace(imageUri: Uri): Boolean {
        return try {
            val faces = detectFaces(imageUri)
            faces.isNotEmpty()
        } catch (e: Exception) {
            Log.e(TAG, "Erro ao verificar face: ${e.message}", e)
            false
        }
    }

    /**
     * Compara duas imagens para verificar se s√£o da mesma pessoa
     * Retorna um score de similaridade (0.0 a 1.0)
     * 
     * Nota: Esta √© uma implementa√ß√£o b√°sica. Para produ√ß√£o, considere usar
     * Firebase ML Face Recognition ou um servi√ßo de terceiros mais robusto
     */
    suspend fun compareFaces(selfieUri: Uri, documentUri: Uri): FaceComparisonResult {
        return try {
            val selfieFaces = detectFaces(selfieUri)
            val documentFaces = detectFaces(documentUri)

            if (selfieFaces.isEmpty()) {
                return FaceComparisonResult(
                    success = false,
                    score = 0.0,
                    message = "Nenhuma face detectada na selfie"
                )
            }

            if (documentFaces.isEmpty()) {
                return FaceComparisonResult(
                    success = false,
                    score = 0.0,
                    message = "Nenhuma face detectada no documento"
                )
            }

            // Compara√ß√£o usando geometria + marcos faciais (embedding simplificado)
            val selfieFace = selfieFaces[0]
            val documentFace = documentFaces[0]

            val geomScore = calculateSimilarityScore(selfieFace, documentFace)
            val embSelfie = computeEmbedding(selfieFace)
            val embDoc = computeEmbedding(documentFace)
            val cosine = if (embSelfie.isNotEmpty() && embDoc.isNotEmpty()) cosineSimilarity(embSelfie, embDoc) else 0.0

            // Combina√ß√£o ponderada: 40% geometria + 60% embedding
            val score = (geomScore * 0.4 + cosine * 0.6)

            // Threshold ajustado: 0.40 para permitir mais varia√ß√µes
            // Selfies podem ter ilumina√ß√£o/√¢ngulo/express√£o diferentes do documento
            // Este threshold foi reduzido para ser mais tolerante, mas ainda seguro
            val success = score >= 0.40
            
            Log.d(TAG, "Compara√ß√£o facial: score=$score (${(score * 100).toInt()}%), threshold=0.40, success=$success")

            FaceComparisonResult(
                success = success,
                score = score,
                message = if (success) {
                    "Faces correspondem (${(score * 100).toInt()}% de similaridade)"
                } else {
                    "Faces n√£o correspondem suficientemente (${(score * 100).toInt()}% de similaridade)"
                }
            )
        } catch (e: Exception) {
            Log.e(TAG, "Erro ao comparar faces: ${e.message}", e)
            FaceComparisonResult(
                success = false,
                score = 0.0,
                message = "Erro ao comparar faces: ${e.message}"
            )
        }
    }

    /**
     * Gera um embedding 2D simples baseado em dist√¢ncias/raz√µes entre marcos (contours/landmarks)
     */
    private fun computeEmbedding(face: Face): DoubleArray {
        val bb = face.boundingBox
        val w = bb.width().coerceAtLeast(1)
        val h = bb.height().coerceAtLeast(1)

        fun p(type: Int): android.graphics.PointF? = face.getLandmark(type)?.position
        val lEye = p(com.google.mlkit.vision.face.FaceLandmark.LEFT_EYE)
        val rEye = p(com.google.mlkit.vision.face.FaceLandmark.RIGHT_EYE)
        val nose = p(com.google.mlkit.vision.face.FaceLandmark.NOSE_BASE)
        val mouth = p(com.google.mlkit.vision.face.FaceLandmark.MOUTH_BOTTOM)
        val lEar = p(com.google.mlkit.vision.face.FaceLandmark.LEFT_EAR)
        val rEar = p(com.google.mlkit.vision.face.FaceLandmark.RIGHT_EAR)

        val pts = listOf(lEye, rEye, nose, mouth, lEar, rEar).mapNotNull { it }
        if (pts.size < 4) return DoubleArray(0)

        fun nd(ax: Float, ay: Float, bx: Float, by: Float): Double {
            val dx = (ax - bx) / w
            val dy = (ay - by) / h
            return kotlin.math.sqrt((dx * dx + dy * dy).toDouble())
        }

        // Dist√¢ncias normalizadas principais
        val dEye = if (lEye != null && rEye != null) nd(lEye.x, lEye.y, rEye.x, rEye.y) else 0.0
        val dEyeNoseL = if (lEye != null && nose != null) nd(lEye.x, lEye.y, nose.x, nose.y) else 0.0
        val dEyeNoseR = if (rEye != null && nose != null) nd(rEye.x, rEye.y, nose.x, nose.y) else 0.0
        val dNoseMouth = if (nose != null && mouth != null) nd(nose.x, nose.y, mouth.x, mouth.y) else 0.0
        val dMouthEyeL = if (mouth != null && lEye != null) nd(mouth.x, mouth.y, lEye.x, lEye.y) else 0.0
        val dMouthEyeR = if (mouth != null && rEye != null) nd(mouth.x, mouth.y, rEye.x, rEye.y) else 0.0
        val dEarWidth = if (lEar != null && rEar != null) nd(lEar.x, lEar.y, rEar.x, rEar.y) else 0.0

        // Raz√µes est√°veis
        val r1 = if (dEye > 0) dNoseMouth / dEye else 0.0
        val r2 = if (dEye > 0) (dEyeNoseL + dEyeNoseR) / (2 * dEye) else 0.0
        val r3 = if (dEarWidth > 0) dEye / dEarWidth else 0.0

        return doubleArrayOf(dEye, dEyeNoseL, dEyeNoseR, dNoseMouth, dMouthEyeL, dMouthEyeR, dEarWidth, r1, r2, r3)
    }

    private fun cosineSimilarity(a: DoubleArray, b: DoubleArray): Double {
        if (a.size != b.size || a.isEmpty()) return 0.0
        var dot = 0.0
        var na = 0.0
        var nb = 0.0
        for (i in a.indices) {
            dot += a[i] * b[i]
            na += a[i] * a[i]
            nb += b[i] * b[i]
        }
        if (na == 0.0 || nb == 0.0) return 0.0
        return (dot / (kotlin.math.sqrt(na) * kotlin.math.sqrt(nb))).coerceIn(-1.0, 1.0)
    }

    /**
     * Calcula score de similaridade entre duas faces
     * Combina bounding box + propor√ß√µes + marcos faciais normalizados
     */
    private fun calculateSimilarityScore(face1: Face, face2: Face): Double {
        val boundingBox1 = face1.boundingBox
        val boundingBox2 = face2.boundingBox

        // Comparar tamanho relativo (0..1)
        val size1 = boundingBox1.width() * boundingBox1.height()
        val size2 = boundingBox2.width() * boundingBox2.height()
        val sizeRatio = minOf(size1, size2).toDouble() / maxOf(size1, size2).toDouble()

        // Comparar propor√ß√£o (largura/altura) (0..1)
        val aspectRatio1 = boundingBox1.width().toDouble() / boundingBox1.height()
        val aspectRatio2 = boundingBox2.width().toDouble() / boundingBox2.height()
        val aspectRatioDiff = 1.0 - kotlin.math.abs(aspectRatio1 - aspectRatio2) / maxOf(aspectRatio1, aspectRatio2)

        // Comparar marcos faciais (se dispon√≠veis) - normalizados pelo tamanho da caixa
        fun norm(dx: Float, dy: Float, w: Int, h: Int): Double {
            val nx = dx / w
            val ny = dy / h
            return kotlin.math.sqrt((nx * nx + ny * ny).toDouble())
        }

        fun getPoint(face: Face, type: Int): android.graphics.PointF? =
            face.getLandmark(type)?.position

        // Pontos de interesse: olhos, nariz, boca
        val f1LeftEye = getPoint(face1, com.google.mlkit.vision.face.FaceLandmark.LEFT_EYE)
        val f1RightEye = getPoint(face1, com.google.mlkit.vision.face.FaceLandmark.RIGHT_EYE)
        val f1Nose = getPoint(face1, com.google.mlkit.vision.face.FaceLandmark.NOSE_BASE)
        val f1Mouth = getPoint(face1, com.google.mlkit.vision.face.FaceLandmark.MOUTH_BOTTOM)

        val f2LeftEye = getPoint(face2, com.google.mlkit.vision.face.FaceLandmark.LEFT_EYE)
        val f2RightEye = getPoint(face2, com.google.mlkit.vision.face.FaceLandmark.RIGHT_EYE)
        val f2Nose = getPoint(face2, com.google.mlkit.vision.face.FaceLandmark.NOSE_BASE)
        val f2Mouth = getPoint(face2, com.google.mlkit.vision.face.FaceLandmark.MOUTH_BOTTOM)

        var landmarksScore = 0.0
        var pairs = 0

        if (f1LeftEye != null && f1RightEye != null && f2LeftEye != null && f2RightEye != null) {
            // Dist√¢ncia entre olhos
            val d1 = norm(
                f1RightEye.x - f1LeftEye.x,
                f1RightEye.y - f1LeftEye.y,
                boundingBox1.width(),
                boundingBox1.height()
            )
            val d2 = norm(
                f2RightEye.x - f2LeftEye.x,
                f2RightEye.y - f2LeftEye.y,
                boundingBox2.width(),
                boundingBox2.height()
            )
            landmarksScore += 1.0 - kotlin.math.abs(d1 - d2) / maxOf(d1, d2)
            pairs++
        }

        if (f1LeftEye != null && f1Mouth != null && f2LeftEye != null && f2Mouth != null) {
            // Dist√¢ncia olho esquerdo - boca
            val d1 = norm(
                f1Mouth.x - f1LeftEye.x,
                f1Mouth.y - f1LeftEye.y,
                boundingBox1.width(),
                boundingBox1.height()
            )
            val d2 = norm(
                f2Mouth.x - f2LeftEye.x,
                f2Mouth.y - f2LeftEye.y,
                boundingBox2.width(),
                boundingBox2.height()
            )
            landmarksScore += 1.0 - kotlin.math.abs(d1 - d2) / maxOf(d1, d2)
            pairs++
        }

        if (f1RightEye != null && f1Mouth != null && f2RightEye != null && f2Mouth != null) {
            // Dist√¢ncia olho direito - boca
            val d1 = norm(
                f1Mouth.x - f1RightEye.x,
                f1Mouth.y - f1RightEye.y,
                boundingBox1.width(),
                boundingBox1.height()
            )
            val d2 = norm(
                f2Mouth.x - f2RightEye.x,
                f2Mouth.y - f2RightEye.y,
                boundingBox2.width(),
                boundingBox2.height()
            )
            landmarksScore += 1.0 - kotlin.math.abs(d1 - d2) / maxOf(d1, d2)
            pairs++
        }

        if (f1Nose != null && f1Mouth != null && f2Nose != null && f2Mouth != null) {
            // Dist√¢ncia nariz - boca
            val d1 = norm(
                f1Mouth.x - f1Nose.x,
                f1Mouth.y - f1Nose.y,
                boundingBox1.width(),
                boundingBox1.height()
            )
            val d2 = norm(
                f2Mouth.x - f2Nose.x,
                f2Mouth.y - f2Nose.y,
                boundingBox2.width(),
                boundingBox2.height()
            )
            landmarksScore += 1.0 - kotlin.math.abs(d1 - d2) / maxOf(d1, d2)
            pairs++
        }

        val landmarksFinal = if (pairs > 0) (landmarksScore / pairs) else 0.0

        // Score combinado (pesos)
        val score = (sizeRatio * 0.2 + aspectRatioDiff * 0.2 + landmarksFinal * 0.6)

        return score.coerceIn(0.0, 1.0)
    }

    /**
     * Libera recursos
     */
    fun release() {
        faceDetector.close()
    }

    companion object {
        private const val TAG = "FaceVerificationManager"
    }
}

data class FaceComparisonResult(
    val success: Boolean,
    val score: Double,
    val message: String
)


```

## [FRONTEND]: core/security/LGPDComplianceManager.kt

```kotlin
package com.taskgoapp.taskgo.core.security

import android.content.Context
import android.util.Log
import com.google.firebase.firestore.FirebaseFirestore
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.tasks.await
import kotlinx.coroutines.withContext
import java.util.*
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Gerenciador de conformidade com LGPD (Lei Geral de Prote√ß√£o de Dados)
 * Implementa todos os protocolos necess√°rios para publica√ß√£o na Google Play Store
 * 
 * Funcionalidades:
 * - Consentimento expl√≠cito do usu√°rio
 * - Direito ao esquecimento (exclus√£o de dados)
 * - Portabilidade de dados
 * - Transpar√™ncia no uso de dados
 * - Seguran√ßa e criptografia
 * - Auditoria de acesso
 */
@Singleton
class LGPDComplianceManager @Inject constructor(
    private val context: Context,
    private val firestore: FirebaseFirestore
) {
    
    companion object {
        private const val TAG = "LGPDCompliance"
        private const val CONSENT_COLLECTION = "user_consents"
        private const val DATA_ACCESS_LOG = "data_access_logs"
        private const val PRIVACY_POLICY_VERSION = "1.0"
    }
    
    /**
     * Registra consentimento do usu√°rio para coleta de dados
     */
    suspend fun registerConsent(
        userId: String,
        consentType: ConsentType,
        granted: Boolean,
        purpose: String
    ): Result<Unit> = withContext(Dispatchers.IO) {
        try {
            val consentData = mapOf(
                "userId" to userId,
                "consentType" to consentType.name,
                "granted" to granted,
                "purpose" to purpose,
                "timestamp" to System.currentTimeMillis(),
                "ipAddress" to getDeviceInfo().ipAddress,
                "deviceId" to getDeviceInfo().deviceId,
                "privacyPolicyVersion" to PRIVACY_POLICY_VERSION
            )
            
            firestore.collection(CONSENT_COLLECTION)
                .document("${userId}_${consentType.name}_${System.currentTimeMillis()}")
                .set(consentData)
                .await()
            
            Log.d(TAG, "Consentimento registrado: $consentType para usu√°rio $userId")
            Result.success(Unit)
        } catch (e: Exception) {
            Log.e(TAG, "Erro ao registrar consentimento: ${e.message}", e)
            Result.failure(e)
        }
    }
    
    /**
     * Verifica se o usu√°rio deu consentimento para um tipo espec√≠fico
     */
    suspend fun hasConsent(userId: String, consentType: ConsentType): Boolean = withContext(Dispatchers.IO) {
        try {
            val snapshot = firestore.collection(CONSENT_COLLECTION)
                .whereEqualTo("userId", userId)
                .whereEqualTo("consentType", consentType.name)
                .orderBy("timestamp", com.google.firebase.firestore.Query.Direction.DESCENDING)
                .limit(1)
                .get()
                .await()
            
            if (snapshot.isEmpty) return@withContext false
            
            val latestConsent = snapshot.documents.first()
            return@withContext latestConsent.getBoolean("granted") ?: false
        } catch (e: Exception) {
            Log.e(TAG, "Erro ao verificar consentimento: ${e.message}", e)
            false
        }
    }
    
    /**
     * Implementa direito ao esquecimento (exclus√£o de dados pessoais)
     */
    suspend fun requestDataDeletion(userId: String): Result<DeletionReport> = withContext(Dispatchers.IO) {
        try {
            val report = DeletionReport(userId = userId)
            
            // 1. Excluir dados do Firestore
            val collectionsToClean = listOf(
                "users",
                "orders",
                "reviews",
                "notifications",
                "chat_sessions"
            )
            
            collectionsToClean.forEach { collectionName ->
                try {
                    val snapshot = firestore.collection(collectionName)
                        .whereEqualTo("userId", userId)
                        .get()
                        .await()
                    
                    snapshot.documents.forEach { doc ->
                        doc.reference.delete().await()
                        report.deletedDocuments++
                    }
                } catch (e: Exception) {
                    Log.e(TAG, "Erro ao excluir da cole√ß√£o $collectionName: ${e.message}")
                    report.errors.add("Erro ao excluir $collectionName: ${e.message}")
                }
            }
            
            // 2. Excluir dados de consentimento (manter log por 5 anos conforme LGPD)
            // Nota: Logs de consentimento devem ser mantidos por per√≠odo legal
            
            // 3. Anonimizar dados de analytics (manter dados agregados)
            report.anonymizedData = true
            
            // 4. Registrar solicita√ß√£o de exclus√£o
            firestore.collection("data_deletion_requests")
                .document(userId)
                .set(mapOf(
                    "userId" to userId,
                    "requestedAt" to System.currentTimeMillis(),
                    "status" to "completed",
                    "deletedDocuments" to report.deletedDocuments
                ))
                .await()
            
            Log.d(TAG, "Exclus√£o de dados conclu√≠da para usu√°rio $userId")
            Result.success(report)
        } catch (e: Exception) {
            Log.e(TAG, "Erro ao excluir dados: ${e.message}", e)
            Result.failure(e)
        }
    }
    
    /**
     * Implementa direito √† portabilidade de dados
     */
    suspend fun exportUserData(userId: String): Result<UserDataExport> = withContext(Dispatchers.IO) {
        try {
            val export = UserDataExport(userId = userId, exportDate = Date())
            
            // Coletar todos os dados do usu√°rio
            val userData = mutableMapOf<String, Any>()
            
            // Dados do perfil
            val userDoc = firestore.collection("users").document(userId).get().await()
            if (userDoc.exists()) {
                userData["profile"] = userDoc.data ?: emptyMap<String, Any>()
            }
            
            // Dados de pedidos (service orders)
            val serviceOrders = firestore.collection("orders")
                .whereEqualTo("clientId", userId)
                .get()
                .await()
            userData["service_orders"] = serviceOrders.documents.map { it.data }
            
            // Dados de pedidos de produtos
            val productOrders = firestore.collection("purchase_orders")
                .whereEqualTo("clientId", userId)
                .get()
                .await()
            userData["product_orders"] = productOrders.documents.map { it.data }
            
            // Dados de avalia√ß√µes (como reviewer)
            val reviewsAsReviewer = firestore.collection("reviews")
                .whereEqualTo("reviewerId", userId)
                .get()
                .await()
            userData["reviews_as_reviewer"] = reviewsAsReviewer.documents.map { it.data }
            
            // Dados de avalia√ß√µes (como target)
            val reviewsAsTarget = firestore.collection("reviews")
                .whereEqualTo("targetId", userId)
                .get()
                .await()
            userData["reviews_as_target"] = reviewsAsTarget.documents.map { it.data }
            
            // Dados de notifica√ß√µes
            val notifications = firestore.collection("notifications")
                .whereEqualTo("userId", userId)
                .get()
                .await()
            userData["notifications"] = notifications.documents.map { it.data }
            
            export.data = userData
            export.format = "JSON"
            export.sizeBytes = userData.toString().length.toLong()
            
            // Registrar exporta√ß√£o
            firestore.collection("data_exports")
                .document("${userId}_${System.currentTimeMillis()}")
                .set(mapOf(
                    "userId" to userId,
                    "exportDate" to System.currentTimeMillis(),
                    "format" to export.format,
                    "sizeBytes" to export.sizeBytes
                ))
                .await()
            
            Log.d(TAG, "Exporta√ß√£o de dados conclu√≠da para usu√°rio $userId")
            Result.success(export)
        } catch (e: Exception) {
            Log.e(TAG, "Erro ao exportar dados: ${e.message}", e)
            Result.failure(e)
        }
    }
    
    /**
     * Registra acesso a dados pessoais (auditoria)
     */
    suspend fun logDataAccess(
        userId: String,
        dataType: DataType,
        accessReason: String,
        accessedBy: String = "system"
    ) {
        try {
            val logEntry = mapOf(
                "userId" to userId,
                "dataType" to dataType.name,
                "accessReason" to accessReason,
                "accessedBy" to accessedBy,
                "timestamp" to System.currentTimeMillis(),
                "ipAddress" to getDeviceInfo().ipAddress,
                "deviceInfo" to getDeviceInfo().deviceModel
            )
            
            firestore.collection(DATA_ACCESS_LOG)
                .add(logEntry)
                .await()
        } catch (e: Exception) {
            Log.e(TAG, "Erro ao registrar acesso: ${e.message}", e)
        }
    }
    
    /**
     * Criptografa dados sens√≠veis antes de armazenar
     */
    fun encryptSensitiveData(data: String): String {
        // Implementa√ß√£o de criptografia (usar AES-256 em produ√ß√£o)
        // Por enquanto, retorna hash (em produ√ß√£o, usar biblioteca de criptografia)
        return data.hashCode().toString()
    }
    
    /**
     * Verifica se os dados est√£o criptografados
     */
    fun isDataEncrypted(data: String): Boolean {
        // L√≥gica para verificar se dados est√£o criptografados
        return false // Implementar conforme necess√°rio
    }
    
    /**
     * Obt√©m informa√ß√µes do dispositivo para auditoria
     */
    private fun getDeviceInfo(): DeviceInfo {
        return DeviceInfo(
            deviceId = android.provider.Settings.Secure.getString(
                context.contentResolver,
                android.provider.Settings.Secure.ANDROID_ID
            ) ?: "unknown",
            deviceModel = android.os.Build.MODEL,
            osVersion = android.os.Build.VERSION.RELEASE,
            ipAddress = "0.0.0.0" // Ser√° obtido via API em produ√ß√£o
        )
    }
    
    /**
     * Gera relat√≥rio de conformidade LGPD
     */
    suspend fun generateComplianceReport(userId: String): Flow<ComplianceReport> = flow {
        val report = ComplianceReport(
            userId = userId,
            generatedAt = Date(),
            consents = emptyList(),
            dataAccessLogs = emptyList(),
            dataRetentionPeriod = "Conforme LGPD",
            securityMeasures = listOf(
                "Criptografia de dados sens√≠veis",
                "Logs de auditoria",
                "Controle de acesso",
                "Backup seguro"
            )
        )
        
        // Buscar consentimentos
        try {
            val consents = firestore.collection(CONSENT_COLLECTION)
                .whereEqualTo("userId", userId)
                .get()
                .await()
            
            report.consents = consents.documents.map { doc ->
                ConsentRecord(
                    type = ConsentType.valueOf(doc.getString("consentType") ?: "ANALYTICS"),
                    granted = doc.getBoolean("granted") ?: false,
                    timestamp = doc.getLong("timestamp") ?: 0L
                )
            }
        } catch (e: Exception) {
            Log.e(TAG, "Erro ao buscar consentimentos: ${e.message}")
        }
        
        // Buscar logs de acesso
        try {
            val logs = firestore.collection(DATA_ACCESS_LOG)
                .whereEqualTo("userId", userId)
                .orderBy("timestamp", com.google.firebase.firestore.Query.Direction.DESCENDING)
                .limit(100)
                .get()
                .await()
            
            report.dataAccessLogs = logs.documents.map { doc ->
                DataAccessLog(
                    dataType = DataType.valueOf(doc.getString("dataType") ?: "PROFILE"),
                    accessReason = doc.getString("accessReason") ?: "",
                    timestamp = doc.getLong("timestamp") ?: 0L
                )
            }
        } catch (e: Exception) {
            Log.e(TAG, "Erro ao buscar logs: ${e.message}")
        }
        
        emit(report)
    }
    
    /**
     * Obt√©m hist√≥rico de consentimentos do usu√°rio
     */
    suspend fun getConsentHistory(userId: String): Result<List<ConsentRecord>> = withContext(Dispatchers.IO) {
        try {
            // Buscar sem orderBy primeiro para evitar erro de √≠ndice
            val snapshot = firestore.collection(CONSENT_COLLECTION)
                .whereEqualTo("userId", userId)
                .get()
                .await()
            
            val consents = snapshot.documents.mapNotNull { doc ->
                try {
                    ConsentRecord(
                        type = ConsentType.valueOf(doc.getString("consentType") ?: "ANALYTICS"),
                        granted = doc.getBoolean("granted") ?: false,
                        timestamp = doc.getLong("timestamp") ?: 0L,
                        purpose = doc.getString("purpose") ?: ""
                    )
                } catch (e: Exception) {
                    Log.w(TAG, "Erro ao processar consentimento: ${e.message}")
                    null
                }
            }.sortedByDescending { it.timestamp } // Ordenar localmente
            
            Log.d(TAG, "Hist√≥rico de consentimentos carregado: ${consents.size} registros")
            Result.success(consents)
        } catch (e: Exception) {
            Log.e(TAG, "Erro ao buscar hist√≥rico de consentimentos: ${e.message}", e)
            // Retornar lista vazia em caso de erro ao inv√©s de falhar completamente
            Result.success(emptyList())
        }
    }
}

// Modelos de dados para LGPD
enum class ConsentType {
    ANALYTICS,
    MARKETING,
    PERSONALIZATION,
    LOCATION,
    CAMERA,
    CONTACTS,
    STORAGE
}

enum class DataType {
    PROFILE,
    LOCATION,
    PAYMENT,
    CONTACTS,
    MESSAGES,
    PURCHASE_HISTORY,
    REVIEWS
}

data class ConsentRecord(
    val type: ConsentType,
    val granted: Boolean,
    val timestamp: Long,
    val purpose: String = ""
)

data class DataAccessLog(
    val dataType: DataType,
    val accessReason: String,
    val timestamp: Long
)

data class DeletionReport(
    val userId: String,
    var deletedDocuments: Int = 0,
    var anonymizedData: Boolean = false,
    val errors: MutableList<String> = mutableListOf()
)

data class UserDataExport(
    val userId: String,
    val exportDate: Date,
    var data: Map<String, Any> = emptyMap(),
    var format: String = "JSON",
    var sizeBytes: Long = 0
)

data class ComplianceReport(
    val userId: String,
    val generatedAt: Date,
    var consents: List<ConsentRecord>,
    var dataAccessLogs: List<DataAccessLog>,
    val dataRetentionPeriod: String,
    val securityMeasures: List<String>
)

data class DeviceInfo(
    val deviceId: String,
    val deviceModel: String,
    val osVersion: String,
    val ipAddress: String
)


```

## [FRONTEND]: core/security/PDFExporter.kt

```kotlin
package com.taskgoapp.taskgo.core.security

import android.content.Context
import android.os.Build
import android.os.Environment
import android.util.Log
import com.itextpdf.kernel.colors.ColorConstants
import com.itextpdf.kernel.pdf.PdfDocument
import com.itextpdf.kernel.pdf.PdfWriter
import com.itextpdf.layout.Document
import com.itextpdf.layout.element.Paragraph
import com.itextpdf.layout.element.Table
import com.itextpdf.layout.properties.TextAlignment
import com.itextpdf.layout.properties.UnitValue
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.io.File
import java.io.FileOutputStream
import java.text.SimpleDateFormat
import java.util.*
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class PDFExporter @Inject constructor(
    private val context: Context
) {
    companion object {
        private const val TAG = "PDFExporter"
    }
    
    /**
     * Exporta dados do usu√°rio em formato PDF e salva no dispositivo
     */
    suspend fun exportUserDataToPDF(
        userId: String,
        userData: Map<String, Any>
    ): Result<File> = withContext(Dispatchers.IO) {
        try {
            // Criar diret√≥rio para downloads
            val downloadsDir = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                context.getExternalFilesDir(Environment.DIRECTORY_DOWNLOADS)
            } else {
                File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS), "TaskGo")
            }
            
            downloadsDir?.mkdirs()
            
            val dateFormat = SimpleDateFormat("yyyyMMdd_HHmmss", Locale.getDefault())
            val fileName = "TaskGo_Dados_${userId}_${dateFormat.format(Date())}.pdf"
            val file = File(downloadsDir, fileName)
            
            // Criar PDF
            val writer = PdfWriter(FileOutputStream(file))
            val pdfDocument = PdfDocument(writer)
            val document = Document(pdfDocument)
            
            // T√≠tulo
            document.add(
                Paragraph("Relat√≥rio de Dados do Usu√°rio - TaskGo")
                    .setFontSize(20f)
                    .setBold()
                    .setTextAlignment(TextAlignment.CENTER)
                    .setMarginBottom(20f)
            )
            
            document.add(
                Paragraph("Data de Exporta√ß√£o: ${SimpleDateFormat("dd/MM/yyyy HH:mm:ss", Locale.getDefault()).format(Date())}")
                    .setFontSize(12f)
                    .setTextAlignment(TextAlignment.CENTER)
                    .setMarginBottom(30f)
            )
            
            // Dados do Perfil
            val profileData = userData["profile"] as? Map<*, *>
            if (profileData != null) {
                document.add(
                    Paragraph("Dados do Perfil")
                        .setFontSize(16f)
                        .setBold()
                        .setMarginTop(20f)
                        .setMarginBottom(10f)
                )
                
                val profileTable = Table(UnitValue.createPercentArray(floatArrayOf(30f, 70f)))
                profileTable.setWidth(UnitValue.createPercentValue(100f))
                
                profileData.forEach { (key, value) ->
                    if (value != null && value.toString().isNotBlank()) {
                        profileTable.addCell(Paragraph(key.toString()).setBold())
                        profileTable.addCell(Paragraph(value.toString()))
                    }
                }
                
                document.add(profileTable)
            }
            
            // Pedidos
            val orders = userData["orders"] as? List<*>
            if (orders != null && orders.isNotEmpty()) {
                document.add(
                    Paragraph("Pedidos (${orders.size})")
                        .setFontSize(16f)
                        .setBold()
                        .setMarginTop(20f)
                        .setMarginBottom(10f)
                )
                
                orders.forEachIndexed { index, order ->
                    val orderMap = order as? Map<*, *>
                    if (orderMap != null) {
                        document.add(
                            Paragraph("Pedido ${index + 1}")
                                .setFontSize(14f)
                                .setBold()
                                .setMarginTop(10f)
                        )
                        
                        val orderTable = Table(UnitValue.createPercentArray(floatArrayOf(30f, 70f)))
                        orderTable.setWidth(UnitValue.createPercentValue(100f))
                        
                        orderMap.forEach { (key, value) ->
                            if (value != null && value.toString().isNotBlank()) {
                                orderTable.addCell(Paragraph(key.toString()).setBold())
                                orderTable.addCell(Paragraph(value.toString()))
                            }
                        }
                        
                        document.add(orderTable)
                    }
                }
            }
            
            // Avalia√ß√µes
            val reviews = userData["reviews"] as? List<*>
            if (reviews != null && reviews.isNotEmpty()) {
                document.add(
                    Paragraph("Avalia√ß√µes (${reviews.size})")
                        .setFontSize(16f)
                        .setBold()
                        .setMarginTop(20f)
                        .setMarginBottom(10f)
                )
                
                reviews.forEachIndexed { index, review ->
                    val reviewMap = review as? Map<*, *>
                    if (reviewMap != null) {
                        document.add(
                            Paragraph("Avalia√ß√£o ${index + 1}")
                                .setFontSize(14f)
                                .setBold()
                                .setMarginTop(10f)
                        )
                        
                        val reviewTable = Table(UnitValue.createPercentArray(floatArrayOf(30f, 70f)))
                        reviewTable.setWidth(UnitValue.createPercentValue(100f))
                        
                        reviewMap.forEach { (key, value) ->
                            if (value != null && value.toString().isNotBlank()) {
                                reviewTable.addCell(Paragraph(key.toString()).setBold())
                                reviewTable.addCell(Paragraph(value.toString()))
                            }
                        }
                        
                        document.add(reviewTable)
                    }
                }
            }
            
            // Notifica√ß√µes
            val notifications = userData["notifications"] as? List<*>
            if (notifications != null && notifications.isNotEmpty()) {
                document.add(
                    Paragraph("Notifica√ß√µes (${notifications.size})")
                        .setFontSize(16f)
                        .setBold()
                        .setMarginTop(20f)
                        .setMarginBottom(10f)
                )
                
                notifications.take(50).forEachIndexed { index, notification ->
                    val notifMap = notification as? Map<*, *>
                    if (notifMap != null) {
                        document.add(
                            Paragraph("Notifica√ß√£o ${index + 1}")
                                .setFontSize(14f)
                                .setBold()
                                .setMarginTop(10f)
                        )
                        
                        val notifTable = Table(UnitValue.createPercentArray(floatArrayOf(30f, 70f)))
                        notifTable.setWidth(UnitValue.createPercentValue(100f))
                        
                        notifMap.forEach { (key, value) ->
                            if (value != null && value.toString().isNotBlank()) {
                                notifTable.addCell(Paragraph(key.toString()).setBold())
                                notifTable.addCell(Paragraph(value.toString()))
                            }
                        }
                        
                        document.add(notifTable)
                    }
                }
            }
            
            // Rodap√©
            document.add(
                Paragraph("\n\nEste documento cont√©m todos os dados pessoais associados √† sua conta no TaskGo.")
                    .setFontSize(10f)
                    .setTextAlignment(TextAlignment.CENTER)
                    .setMarginTop(30f)
            )
            
            document.close()
            
            Log.d(TAG, "PDF exportado com sucesso: ${file.absolutePath}")
            Result.success(file)
        } catch (e: Exception) {
            Log.e(TAG, "Erro ao exportar PDF: ${e.message}", e)
            Result.failure(e)
        }
    }
}


```

## [FRONTEND]: core/security/RealTimeFaceAnalyzer.kt

```kotlin
package com.taskgoapp.taskgo.core.security

import android.util.Log
import androidx.camera.core.ImageAnalysis
import androidx.camera.core.ImageProxy
import com.google.mlkit.vision.common.InputImage
import com.google.mlkit.vision.face.Face
import com.google.mlkit.vision.face.FaceDetection
import com.google.mlkit.vision.face.FaceDetector
import com.google.mlkit.vision.face.FaceDetectorOptions

/**
 * Analisador de face em tempo real usando ML Kit e CameraX ImageAnalysis
 * Processa frames da c√¢mera em tempo real para detectar e validar faces
 */
class RealTimeFaceAnalyzer(
    private val onFaceDetected: (FaceDetectionResult) -> Unit
) : ImageAnalysis.Analyzer {
    
    private val faceDetector: FaceDetector = FaceDetection.getClient(
        FaceDetectorOptions.Builder()
            .setPerformanceMode(FaceDetectorOptions.PERFORMANCE_MODE_FAST)
            .setLandmarkMode(FaceDetectorOptions.LANDMARK_MODE_ALL)
            .setClassificationMode(FaceDetectorOptions.CLASSIFICATION_MODE_ALL)
            .setContourMode(FaceDetectorOptions.CONTOUR_MODE_ALL)
            .enableTracking()
            .setMinFaceSize(0.15f) // Face deve ocupar pelo menos 15% da imagem
            .build()
    )
    
    private var isProcessing = false
    private var frameSkipCount = 0
    private val FRAME_SKIP = 2 // Processa 1 frame a cada 3 (reduz carga)
    
    // Estados de vivacidade
    private var lastEyesOpen: Pair<Float?, Float?> = 1.0f to 1.0f
    private var blinkInProgress = false
    private var blinkDetectedInternal = false
    private var lastBlinkTimeMs = 0L
    private val blinkMinCloseProb = 0.3f
    private val blinkOpenProb = 0.6f
    private val blinkTimeoutMs = 2500L
    private var lookLeftDetectedInternal = false
    private var lookRightDetectedInternal = false
    private var lookLeftStartMs = 0L
    private var lookRightStartMs = 0L
    private val lookHoldMs = 400L
    private val lookYawLeft = -18f
    private val lookYawRight = 18f
    
    override fun analyze(imageProxy: ImageProxy) {
        // Pular frames para reduzir carga de processamento
        if (frameSkipCount < FRAME_SKIP) {
            frameSkipCount++
            imageProxy.close()
            return
        }
        frameSkipCount = 0
        
        // Evitar processar m√∫ltiplos frames simultaneamente
        if (isProcessing) {
            imageProxy.close()
            return
        }
        
        isProcessing = true
        
        try {
            val mediaImage = imageProxy.image
            if (mediaImage == null) {
                imageProxy.close()
                isProcessing = false
                return
            }
            
            val image = InputImage.fromMediaImage(
                mediaImage,
                imageProxy.imageInfo.rotationDegrees
            )
            
            faceDetector.process(image)
                .addOnSuccessListener { faces ->
                    val result = analyzeFaces(faces, imageProxy.width, imageProxy.height)
                    onFaceDetected(result)
                    imageProxy.close()
                    isProcessing = false
                }
                .addOnFailureListener { e ->
                    Log.e(TAG, "Erro ao processar face: ${e.message}", e)
                    onFaceDetected(FaceDetectionResult.noFace())
                    imageProxy.close()
                    isProcessing = false
                }
        } catch (e: Exception) {
            Log.e(TAG, "Erro ao analisar frame: ${e.message}", e)
            imageProxy.close()
            isProcessing = false
        }
    }
    
    /**
     * Analisa as faces detectadas e retorna resultado detalhado
     */
    private fun analyzeFaces(faces: List<Face>, imageWidth: Int, imageHeight: Int): FaceDetectionResult {
        if (faces.isEmpty()) {
            return FaceDetectionResult.noFace()
        }
        
        // Usar apenas a primeira face detectada (mais pr√≥xima/central)
        val face = faces[0]
        val boundingBox = face.boundingBox
        
        // Calcular posi√ß√£o relativa da face na imagem
        val faceCenterX = boundingBox.centerX().toFloat() / imageWidth
        val faceCenterY = boundingBox.centerY().toFloat() / imageHeight
        
        // Calcular tamanho relativo da face
        val faceWidth = boundingBox.width().toFloat() / imageWidth
        val faceHeight = boundingBox.height().toFloat() / imageHeight
        val faceSize = (faceWidth + faceHeight) / 2f
        
        // Verificar se a face est√° centralizada (dentro de 40% do centro)
        val isCentered = faceCenterX in 0.3f..0.7f && faceCenterY in 0.3f..0.7f
        
        // Verificar tamanho da face (ideal: 30-50% da imagem)
        val isGoodSize = faceSize in 0.25f..0.55f
        
        // Verificar se olhos est√£o abertos (se dispon√≠vel)
        val leftEyeOpen = face.leftEyeOpenProbability
        val rightEyeOpen = face.rightEyeOpenProbability
        val eyesOpen = if (leftEyeOpen != null && rightEyeOpen != null) {
            leftEyeOpen > 0.5f && rightEyeOpen > 0.5f
        } else {
            true // Se n√£o dispon√≠vel, assumir OK
        }
        
        // Verificar se est√° sorrindo (opcional - pode indicar pose natural)
        val smiling = face.smilingProbability
        val isNaturalPose = smiling == null || smiling in 0.2f..0.8f
        
        // Verificar se est√° olhando para a c√¢mera (head euler angles)
        val headEulerY = face.headEulerAngleY // Rota√ß√£o horizontal (-30 a +30 √© bom)
        val headEulerZ = face.headEulerAngleZ // Inclina√ß√£o (-15 a +15 √© bom)
        val isLookingAtCamera = Math.abs(headEulerY) < 25f && Math.abs(headEulerZ) < 15f
        
        // Vivacidade: detec√ß√£o de piscar e olhar lateral sustentado
        val now = System.currentTimeMillis()
        if (leftEyeOpen != null && rightEyeOpen != null) {
            val wasOpen = (lastEyesOpen.first ?: 1.0f) > blinkOpenProb && (lastEyesOpen.second ?: 1.0f) > blinkOpenProb
            val nowClosed = leftEyeOpen < blinkMinCloseProb && rightEyeOpen < blinkMinCloseProb
            val nowOpen = leftEyeOpen > blinkOpenProb && rightEyeOpen > blinkOpenProb
            if (!blinkInProgress && wasOpen && nowClosed) {
                blinkInProgress = true
            } else if (blinkInProgress && nowOpen) {
                blinkDetectedInternal = true
                lastBlinkTimeMs = now
                blinkInProgress = false
            } else if (blinkInProgress && (now - lastBlinkTimeMs) > blinkTimeoutMs) {
                blinkInProgress = false
            }
            lastEyesOpen = leftEyeOpen to rightEyeOpen
        }
        if (headEulerY <= lookYawLeft) {
            if (lookLeftStartMs == 0L) lookLeftStartMs = now
            if (!lookLeftDetectedInternal && (now - lookLeftStartMs) >= lookHoldMs) {
                lookLeftDetectedInternal = true
            }
        } else {
            lookLeftStartMs = 0L
        }
        if (headEulerY >= lookYawRight) {
            if (lookRightStartMs == 0L) lookRightStartMs = now
            if (!lookRightDetectedInternal && (now - lookRightStartMs) >= lookHoldMs) {
                lookRightDetectedInternal = true
            }
        } else {
            lookRightStartMs = 0L
        }
        
        // Calcular score geral de qualidade
        var qualityScore = 0.0f
        
        if (isCentered) qualityScore += 0.3f
        if (isGoodSize) qualityScore += 0.3f
        if (eyesOpen) qualityScore += 0.2f
        if (isLookingAtCamera) qualityScore += 0.2f
        
        val isGoodQuality = qualityScore >= 0.7f && isCentered && isGoodSize && eyesOpen && isLookingAtCamera
        
        return FaceDetectionResult(
            hasFace = true,
            isCentered = isCentered,
            isGoodSize = isGoodSize,
            eyesOpen = eyesOpen,
            isLookingAtCamera = isLookingAtCamera,
            qualityScore = qualityScore,
            isGoodQuality = isGoodQuality,
            faceSize = faceSize,
            faceCenterX = faceCenterX,
            faceCenterY = faceCenterY,
            headEulerY = headEulerY,
            headEulerZ = headEulerZ,
            leftEyeOpen = leftEyeOpen,
            rightEyeOpen = rightEyeOpen,
            smiling = smiling,
            blinkDetected = blinkDetectedInternal,
            lookLeft = lookLeftDetectedInternal,
            lookRight = lookRightDetectedInternal
        )
    }
    
    fun release() {
        faceDetector.close()
    }
    
    companion object {
        private const val TAG = "RealTimeFaceAnalyzer"
    }
}

/**
 * Resultado da detec√ß√£o facial em tempo real
 */
data class FaceDetectionResult(
    val hasFace: Boolean,
    val isCentered: Boolean = false,
    val isGoodSize: Boolean = false,
    val eyesOpen: Boolean = false,
    val isLookingAtCamera: Boolean = false,
    val qualityScore: Float = 0f,
    val isGoodQuality: Boolean = false,
    val faceSize: Float = 0f,
    val faceCenterX: Float = 0.5f,
    val faceCenterY: Float = 0.5f,
    val headEulerY: Float = 0f,
    val headEulerZ: Float = 0f,
    val leftEyeOpen: Float? = null,
    val rightEyeOpen: Float? = null,
    val smiling: Float? = null,
    val blinkDetected: Boolean = false,
    val lookLeft: Boolean = false,
    val lookRight: Boolean = false
) {
    companion object {
        fun noFace() = FaceDetectionResult(hasFace = false)
    }
}


```

# Core - sync


## [FRONTEND]: core/sync/InitialDataSyncManager.kt

```kotlin
package com.taskgoapp.taskgo.core.sync

import android.util.Log
import com.google.firebase.auth.FirebaseAuth
import com.taskgoapp.taskgo.data.local.dao.*
import com.taskgoapp.taskgo.data.repository.*
import com.taskgoapp.taskgo.domain.repository.*
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.withContext
import kotlinx.coroutines.flow.first
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Gerenciador de sincroniza√ß√£o inicial de dados
 * 
 * No primeiro acesso do usu√°rio ap√≥s login, baixa todos os dados do Firebase
 * para o cache local para melhorar performance e permitir uso offline
 */
@Singleton
class InitialDataSyncManager @Inject constructor(
    private val firebaseAuth: FirebaseAuth,
    private val productsRepository: ProductsRepository,
    private val ordersRepository: OrdersRepository,
    private val addressRepository: AddressRepository,
    private val cardRepository: CardRepository,
    private val userRepository: UserRepository,
    private val firestoreUserRepository: com.taskgoapp.taskgo.data.repository.FirestoreUserRepository,
    private val productDao: ProductDao,
    private val purchaseOrderDao: PurchaseOrderDao,
    private val addressDao: AddressDao,
    private val cardDao: CardDao,
    private val userProfileDao: UserProfileDao
) {
    
    private val TAG = "InitialDataSyncManager"
    
    /**
     * Sincroniza todos os dados do usu√°rio do Firebase para o cache local
     * 
     * @return true se a sincroniza√ß√£o foi bem-sucedida, false caso contr√°rio
     */
    suspend fun syncAllUserData(): Boolean = withContext(Dispatchers.IO) {
        val userId = firebaseAuth.currentUser?.uid
        if (userId == null) {
            Log.w(TAG, "Usu√°rio n√£o autenticado, n√£o √© poss√≠vel sincronizar dados")
            return@withContext false
        }
        
        Log.d(TAG, "=== Iniciando sincroniza√ß√£o inicial de dados para usu√°rio: $userId ===")
        
        try {
            // Executar todas as sincroniza√ß√µes em paralelo para melhor performance
            val results = awaitAll(
                async { syncUserProfile(userId) },
                async { syncProducts(userId) },
                async { syncOrders(userId) },
                async { syncAddresses(userId) },
                async { syncCards(userId) }
            )
            
            val allSuccess = results.all { it }
            
            if (allSuccess) {
                Log.d(TAG, "=== Sincroniza√ß√£o inicial conclu√≠da com sucesso ===")
            } else {
                Log.w(TAG, "=== Sincroniza√ß√£o inicial conclu√≠da com alguns erros ===")
            }
            
            allSuccess
        } catch (e: Exception) {
            Log.e(TAG, "Erro durante sincroniza√ß√£o inicial: ${e.message}", e)
            false
        }
    }
    
    /**
     * Sincroniza o perfil do usu√°rio
     */
    private suspend fun syncUserProfile(userId: String): Boolean {
        return try {
            Log.d(TAG, "Sincronizando perfil do usu√°rio...")
            
            // Carregar do Firestore e salvar no banco local
            val userFirestore = firestoreUserRepository.getUser(userId)
            
            if (userFirestore != null) {
                val accountType = when (userFirestore.role?.lowercase()) {
                    "partner" -> com.taskgoapp.taskgo.core.model.AccountType.PARCEIRO
                    "provider" -> com.taskgoapp.taskgo.core.model.AccountType.PARCEIRO // Legacy - migrar para PARCEIRO
                    "seller" -> com.taskgoapp.taskgo.core.model.AccountType.PARCEIRO // Legacy - migrar para PARCEIRO
                    "client" -> com.taskgoapp.taskgo.core.model.AccountType.CLIENTE
                    else -> com.taskgoapp.taskgo.core.model.AccountType.CLIENTE
                }
                
                val user = com.taskgoapp.taskgo.core.model.UserProfile(
                    id = userId,
                    name = userFirestore.displayName ?: "",
                    email = userFirestore.email,
                    phone = userFirestore.phone,
                    city = userFirestore.address?.city,
                    state = userFirestore.address?.state,
                    profession = null,
                    accountType = accountType,
                    rating = userFirestore.rating,
                    avatarUri = userFirestore.photoURL,
                    profileImages = null
                )
                
                // Salvar no banco local
                userRepository.updateUser(user)
                Log.d(TAG, "Perfil do usu√°rio sincronizado: ${user.name}, accountType: ${user.accountType}")
            } else {
                Log.d(TAG, "Perfil do usu√°rio n√£o encontrado no Firestore")
            }
            true
        } catch (e: Exception) {
            Log.e(TAG, "Erro ao sincronizar perfil: ${e.message}", e)
            false
        }
    }
    
    /**
     * Sincroniza produtos do usu√°rio (se for vendedor)
     */
    private suspend fun syncProducts(userId: String): Boolean {
        return try {
            Log.d(TAG, "Sincronizando produtos do usu√°rio...")
            // Dispara busca que j√° atualiza o cache no reposit√≥rio
            productsRepository.getMyProducts()
            true
        } catch (e: Exception) {
            Log.e(TAG, "Erro ao sincronizar produtos: ${e.message}", e)
            false
        }
    }
    
    /**
     * Sincroniza pedidos do usu√°rio
     */
    private suspend fun syncOrders(userId: String): Boolean {
        return try {
            Log.d(TAG, "Sincronizando pedidos do usu√°rio...")
            // Dispara observa√ß√£o que puxa do Firestore e atualiza o cache
            ordersRepository.observeOrders().first()
            true
        } catch (e: Exception) {
            Log.e(TAG, "Erro ao sincronizar pedidos: ${e.message}", e)
            false
        }
    }
    
    /**
     * Sincroniza endere√ßos do usu√°rio
     */
    private suspend fun syncAddresses(userId: String): Boolean {
        return try {
            Log.d(TAG, "Sincronizando endere√ßos do usu√°rio...")
            addressRepository.observeAddresses().first()
            true
        } catch (e: Exception) {
            Log.e(TAG, "Erro ao sincronizar endere√ßos: ${e.message}", e)
            false
        }
    }
    
    /**
     * Sincroniza cart√µes do usu√°rio
     */
    private suspend fun syncCards(userId: String): Boolean {
        return try {
            Log.d(TAG, "Sincronizando cart√µes do usu√°rio...")
            cardRepository.observeCards().first()
            true
        } catch (e: Exception) {
            Log.e(TAG, "Erro ao sincronizar cart√µes: ${e.message}", e)
            false
        }
    }
}


```

## [FRONTEND]: core/sync/SyncManager.kt

```kotlin
package com.taskgoapp.taskgo.core.sync

import android.util.Log
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.SetOptions
import com.google.gson.Gson
import kotlinx.coroutines.tasks.await
import com.taskgoapp.taskgo.data.local.dao.SyncQueueDao
import com.taskgoapp.taskgo.data.local.entity.SyncQueueEntity
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Gerenciador de sincroniza√ß√£o local -> Firebase
 * 
 * L√≥gica:
 * 1. Dados s√£o salvos localmente primeiro (instant√¢neo)
 * 2. Ap√≥s 1 minuto, sincroniza com Firebase
 * 3. Dados permanecem locais para melhorar carregamento
 * 4. Dados s√≥ s√£o apagados quando reescritos pelo usu√°rio
 */
@Singleton
class SyncManager @Inject constructor(
    private val syncQueueDao: SyncQueueDao,
    private val firestore: FirebaseFirestore,
    private val gson: Gson
) {
    private val TAG = "SyncManager"
    private val syncScope = CoroutineScope(SupervisorJob() + Dispatchers.IO)
    private var syncJob: Job? = null
    
    companion object {
        private const val SYNC_DELAY_MS = 60_000L // 1 minuto
        private const val MAX_RETRIES = 3
    }
    
    /**
     * Agenda uma opera√ß√£o para sincroniza√ß√£o ap√≥s 1 minuto
     * Se j√° existe uma pend√™ncia para o mesmo tipo e ID, atualiza em vez de criar nova
     */
    suspend fun scheduleSync(
        syncType: String,
        entityId: String,
        operation: String,
        data: Any
    ) {
        try {
            val dataJson = gson.toJson(data)
            val syncAt = System.currentTimeMillis() + SYNC_DELAY_MS
            
            val syncEntity = SyncQueueEntity(
                syncType = syncType,
                entityId = entityId,
                operation = operation,
                data = dataJson,
                syncAt = syncAt,
                status = "pending"
            )
            
            syncQueueDao.upsert(syncEntity)
            Log.d(TAG, "Sincroniza√ß√£o agendada: $syncType/$entityId ($operation) para ${syncAt}")
        } catch (e: Exception) {
            Log.e(TAG, "Erro ao agendar sincroniza√ß√£o: ${e.message}", e)
        }
    }
    
    /**
     * Inicia o processo de sincroniza√ß√£o cont√≠nua
     */
    fun startSync() {
        if (syncJob?.isActive == true) {
            Log.d(TAG, "Sincroniza√ß√£o j√° est√° em execu√ß√£o")
            return
        }
        
        syncJob = syncScope.launch {
            while (true) {
                try {
                    syncPendingItems()
                    delay(30_000) // Verifica a cada 30 segundos
                } catch (e: Exception) {
                    Log.e(TAG, "Erro no loop de sincroniza√ß√£o: ${e.message}", e)
                    delay(60_000) // Em caso de erro, espera 1 minuto
                }
            }
        }
        
        Log.d(TAG, "Sincroniza√ß√£o iniciada")
    }
    
    /**
     * Para o processo de sincroniza√ß√£o
     */
    fun stopSync() {
        syncJob?.cancel()
        syncJob = null
        Log.d(TAG, "Sincroniza√ß√£o parada")
    }
    
    /**
     * Sincroniza itens pendentes que j√° passaram do tempo de espera
     */
    private suspend fun syncPendingItems() {
        val pendingSyncs = syncQueueDao.getPendingSyncs()
        
        if (pendingSyncs.isEmpty()) {
            return
        }
        
        Log.d(TAG, "Sincronizando ${pendingSyncs.size} itens pendentes...")
        
        pendingSyncs.forEach { sync ->
            try {
                syncQueueDao.markAsSyncing(sync.id)
                val success = performSync(sync)
                
                if (success) {
                    syncQueueDao.markAsCompleted(sync.id)
                    Log.d(TAG, "Sincroniza√ß√£o conclu√≠da: ${sync.syncType}/${sync.entityId}")
                } else {
                    if (sync.retryCount < MAX_RETRIES) {
                        syncQueueDao.reschedule(sync.id)
                        Log.d(TAG, "Sincroniza√ß√£o reagendada (tentativa ${sync.retryCount + 1}): ${sync.syncType}/${sync.entityId}")
                    } else {
                        syncQueueDao.markAsFailed(sync.id, "M√°ximo de tentativas atingido")
                        Log.e(TAG, "Sincroniza√ß√£o falhou ap√≥s $MAX_RETRIES tentativas: ${sync.syncType}/${sync.entityId}")
                    }
                }
            } catch (e: Exception) {
                Log.e(TAG, "Erro ao sincronizar ${sync.syncType}/${sync.entityId}: ${e.message}", e)
                
                if (sync.retryCount < MAX_RETRIES) {
                    syncQueueDao.reschedule(sync.id)
                } else {
                    syncQueueDao.markAsFailed(sync.id, e.message ?: "Erro desconhecido")
                }
            }
        }
        
        // Limpa sincroniza√ß√µes conclu√≠das e falhas ap√≥s muitas tentativas
        syncQueueDao.cleanupCompletedAndFailed()
    }
    
    /**
     * Executa um ciclo √∫nico de sincroniza√ß√£o (exposto para Workers)
     */
    suspend fun runOneSyncCycle() {
        syncPendingItems()
    }
    
    /**
     * Executa a sincroniza√ß√£o real com Firebase
     */
    private suspend fun performSync(sync: SyncQueueEntity): Boolean = withContext(Dispatchers.IO) {
        return@withContext try {
            when (sync.syncType) {
                "product" -> syncProduct(sync)
                "service" -> syncService(sync)
                "user_profile" -> syncUserProfile(sync)
                "settings" -> syncSettings(sync)
                "order" -> syncOrder(sync)
                "address" -> syncAddress(sync)
                "card" -> syncCard(sync)
                else -> {
                    Log.w(TAG, "Tipo de sincroniza√ß√£o n√£o suportado: ${sync.syncType}")
                    false
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Erro ao executar sincroniza√ß√£o: ${e.message}", e)
            false
        }
    }
    
    private suspend fun syncProduct(sync: SyncQueueEntity): Boolean {
        return try {
            val productData = gson.fromJson(sync.data, Map::class.java) as Map<String, Any>
            val collection = firestore.collection("products")
            
            when (sync.operation) {
                "create", "update" -> {
                    val docRef = if (sync.entityId.isNotEmpty()) {
                        collection.document(sync.entityId)
                    } else {
                        collection.document()
                    }
                    docRef.set(productData).await()
                    true
                }
                "delete" -> {
                    collection.document(sync.entityId).update("active", false).await()
                    true
                }
                else -> false
            }
        } catch (e: Exception) {
            Log.e(TAG, "Erro ao sincronizar produto: ${e.message}", e)
            false
        }
    }
    
    private suspend fun syncService(sync: SyncQueueEntity): Boolean {
        return try {
            val serviceData = gson.fromJson(sync.data, Map::class.java) as Map<String, Any>
            val collection = firestore.collection("services")
            
            when (sync.operation) {
                "create", "update" -> {
                    val docRef = if (sync.entityId.isNotEmpty()) {
                        collection.document(sync.entityId)
                    } else {
                        collection.document()
                    }
                    docRef.set(serviceData).await()
                    true
                }
                "delete" -> {
                    collection.document(sync.entityId).delete().await()
                    true
                }
                else -> false
            }
        } catch (e: Exception) {
            Log.e(TAG, "Erro ao sincronizar servi√ßo: ${e.message}", e)
            false
        }
    }
    
    private suspend fun syncUserProfile(sync: SyncQueueEntity): Boolean {
        return try {
            val userData = gson.fromJson(sync.data, Map::class.java) as Map<String, Any>
            val collection = firestore.collection("users")
            
            when (sync.operation) {
                "create", "update" -> {
                    collection.document(sync.entityId).set(userData, SetOptions.merge()).await()
                    true
                }
                else -> false
            }
        } catch (e: Exception) {
            Log.e(TAG, "Erro ao sincronizar perfil: ${e.message}", e)
            false
        }
    }
    
    private suspend fun syncSettings(sync: SyncQueueEntity): Boolean {
        return try {
            val settingsData = gson.fromJson(sync.data, Map::class.java) as Map<String, Any>
            val collection = firestore.collection("users")
            
            // Settings s√£o salvos no documento do usu√°rio
            val userId = sync.entityId
            collection.document(userId).update(settingsData).await()
            true
        } catch (e: Exception) {
            Log.e(TAG, "Erro ao sincronizar configura√ß√µes: ${e.message}", e)
            false
        }
    }
    
    private suspend fun syncOrder(sync: SyncQueueEntity): Boolean {
        return try {
            val orderData = gson.fromJson(sync.data, Map::class.java) as Map<String, Any>
            val collection = firestore.collection("purchase_orders")
            
            when (sync.operation) {
                "create", "update" -> {
                    collection.document(sync.entityId).set(orderData).await()
                    true
                }
                else -> false
            }
        } catch (e: Exception) {
            Log.e(TAG, "Erro ao sincronizar pedido: ${e.message}", e)
            false
        }
    }
    
    private suspend fun syncAddress(sync: SyncQueueEntity): Boolean {
        return try {
            val addressData = gson.fromJson(sync.data, Map::class.java) as Map<String, Any>
            val collection = firestore.collection("addresses")
            
            when (sync.operation) {
                "create", "update" -> {
                    collection.document(sync.entityId).set(addressData).await()
                    true
                }
                "delete" -> {
                    collection.document(sync.entityId).delete().await()
                    true
                }
                else -> false
            }
        } catch (e: Exception) {
            Log.e(TAG, "Erro ao sincronizar endere√ßo: ${e.message}", e)
            false
        }
    }
    
    private suspend fun syncCard(sync: SyncQueueEntity): Boolean {
        return try {
            val cardData = gson.fromJson(sync.data, Map::class.java) as Map<String, Any>
            val collection = firestore.collection("cards")
            
            when (sync.operation) {
                "create", "update" -> {
                    collection.document(sync.entityId).set(cardData).await()
                    true
                }
                "delete" -> {
                    collection.document(sync.entityId).delete().await()
                    true
                }
                else -> false
            }
        } catch (e: Exception) {
            Log.e(TAG, "Erro ao sincronizar cart√£o: ${e.message}", e)
            false
        }
    }
    
    /**
     * For√ßa sincroniza√ß√£o imediata de um item espec√≠fico
     */
    suspend fun forceSync(syncType: String, entityId: String): Boolean {
        val sync = syncQueueDao.getPendingSync(syncType, entityId) ?: return false
        syncQueueDao.markAsSyncing(sync.id)
        val success = performSync(sync)
        
        if (success) {
            syncQueueDao.markAsCompleted(sync.id)
        } else {
            syncQueueDao.reschedule(sync.id)
        }
        
        return success
    }
    
    /**
     * Observa o n√∫mero de pend√™ncias de sincroniza√ß√£o
     */
    fun observePendingCount(): Flow<Int> = flow {
        while (true) {
            val count = syncQueueDao.countByStatus("pending")
            emit(count)
            delay(10_000) // Atualiza a cada 10 segundos
        }
    }
}


```

## [FRONTEND]: core/sync/SyncWorker.kt

```kotlin
package com.taskgoapp.taskgo.core.sync

import android.content.Context
import android.util.Log
import androidx.hilt.work.HiltWorker
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import com.taskgoapp.taskgo.data.local.dao.SyncQueueDao
import dagger.assisted.Assisted
import dagger.assisted.AssistedInject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import javax.inject.Inject

@HiltWorker
class SyncWorker @AssistedInject constructor(
    @Assisted appContext: Context,
    @Assisted workerParams: WorkerParameters,
    private val syncManager: SyncManager
) : CoroutineWorker(appContext, workerParams) {
    override suspend fun doWork(): Result = withContext(Dispatchers.IO) {
        return@withContext try {
            Log.d("SyncWorker", "Executando ciclo de sincroniza√ß√£o")
            syncManager.runOneSyncCycle()
            Result.success()
        } catch (e: Exception) {
            Log.e("SyncWorker", "Erro na sincroniza√ß√£o peri√≥dica: ${e.message}", e)
            Result.retry()
        }
    }
}



```

# Core - theme


## [FRONTEND]: core/theme/Colors.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.core.theme

import androidx.compose.ui.graphics.Color

/**
 * Cores extra√≠das diretamente do prot√≥tipo Figma
 * Fonte: https://www.figma.com/design/ESJvpooDWO2xZwFOyW0YzO/TaskGo
 * Baseado nos tokens extra√≠dos do arquivo colors.json
 */

// === CORES PRINCIPAIS ===
// Verde principal do TaskGo (splash, vector, produtos ativo, perfil ativo)
val TaskGoGreen = Color(0xFF00BD48)           // rgb(0, 189, 72) - splash/vector
val TaskGoGreenLight = Color(0xFF49E985)      // rgb(73, 233, 134) - ellipse_1 (sucesso)
val TaskGoGreenDark = Color(0xFF005224)       // rgb(0, 82, 36) - pre√ßos destacados

// === CORES DE FUNDO ===
val TaskGoBackgroundWhite = Color(0xFFFFFFFF)           // Branco principal
val TaskGoBackgroundGray = Color(0xFFF7F7F7)          // rgb(247, 247, 247) - rectangle_11
val TaskGoBackgroundGrayLight = Color(0xFFF9F9F9)     // rgb(249, 249, 249) - rectangle_14
val TaskGoBackgroundGrayBorder = Color(0xFFFCFCFC)     // rgb(252, 252, 252) - rectangle_28

// === CORES DE SUPERF√çCIE ===
val TaskGoSurface = Color(0xFFFFFFFF)                  // Superf√≠cies brancas
val TaskGoSurfaceGray = Color(0xFFF1F1F1)              // rgb(241, 241, 241) - rectangle_24,25,26,27
val TaskGoSurfaceGrayLight = Color(0xFFDBDBDB)         // rgb(219, 219, 219) - rectangle_39,41,42,etc

// === CORES DE TEXTO (baseadas no Figma) ===
val TaskGoTextBlack = Color(0xFF000000)                // rgb(0, 0, 0) - texto preto principal
val TaskGoTextDark = Color(0xFF383838)                // rgb(56, 56, 56) - texto escuro
val TaskGoTextGray = Color(0xFF6C6C6C)                // rgb(108, 108, 108) - texto cinza padr√£o
val TaskGoTextGrayMedium = Color(0xFF646464)           // rgb(100, 100, 100) - texto cinza m√©dio
val TaskGoTextGrayLight = Color(0xFF808080)            // rgb(128, 128, 128) - texto cinza claro
val TaskGoTextGrayPlaceholder = Color(0xFFBBBBBB)     // rgb(187, 187, 187) - inicio/mensagem inativo

// === CORES DE STATUS ===
val TaskGoSuccess = Color(0xFF00BD48)                  // Verde de sucesso
val TaskGoError = Color(0xFFBD0000)                    // rgb(189, 0, 0) - texto de erro
val TaskGoWarning = Color(0xFFFFEE00)                  // Estrelas - rgb(255, 238, 0)

// === CORES DE ELEMENTOS ===
val TaskGoBorder = Color(0xFFD9D9D9)                   // rgb(217, 217, 217) - rectangle_1
val TaskGoBorderLight = Color(0xFFD9D9D9)              // rgb(217, 217, 217) - rectangle_30,39,etc
val TaskGoDivider = Color(0xFFE0E0E0)                 // rgb(224, 224, 224) - rectangle_30

// === CORES DE DESTAQUE ===
val TaskGoPrimary = TaskGoGreen
val TaskGoSecondary = Color(0xFFFFEE00)                // Estrelas/Amarelo
val TaskGoAccent = TaskGoGreenDark

// === CORES NEUTRAS ===
val TaskGoNeutralDark = Color(0xFF3F3F3F)              // rgb(63, 63, 63) - _1,_2,_3,_4,_5
val TaskGoNeutral = Color(0xFFA9A9A9)                  // rgb(169, 169, 169) - "1"

// === CORES ESPEC√çFICAS DO FIGMA ===
// Cores dos bot√µes de navega√ß√£o
val TaskGoNavInactive = Color(0xFFBBBBBB)             // rgb(187, 187, 187) - inicio/mensagem inativo
val TaskGoNavActive = Color(0xFF00BD48)               // Verde ativo

// Cores de pre√ßos
val TaskGoPriceDark = Color(0xFF2C2C2C)               // rgb(44, 44, 44) - pre√ßos normais
val TaskGoPriceGreen = Color(0xFF005224)              // rgb(0, 82, 36) - pre√ßos destacados

// Cores de notifica√ß√µes
val TaskGoNotificationBg = Color(0xFFE0E0E0)          // rgb(224, 224, 224) - rectangle_30
val TaskGoNotificationIcon = Color(0xFFDBDBDB)        // rgb(219, 219, 219) - rectangle_39,41,42

// Cores de estrelas (avalia√ß√µes)
val TaskGoStarFilled = Color(0xFFFFEE00)              // rgb(255, 238, 0) - estrelas preenchidas
val TaskGoStarEmpty = Color(0xFF6C6C6C)               // rgb(108, 108, 108) - estrelas vazias

// === MAPEAMENTO PARA MATERIAL DESIGN ===
val TaskGoSuccessGreen = Color(0xFF4CAF50)              // Verde de sucesso Material
val TaskGoErrorRed = Color(0xFFCC0000)                 // Vermelho de erro
val TaskGoTextDarkGray = Color(0xFF333333)             // Texto escuro
val TaskGoTextMediumGray = Color(0xFF666666)          // Texto m√©dio
val TaskGoTextLightGray = Color(0xFF999999)           // Texto claro
val TaskGoStarYellow = Color(0xFFFFD700)              // Estrelas douradas
val TaskGoAmber = Color(0xFFFFC107)                   // Amarelo/√¢mbar
val TaskGoOrange = Color(0xFFFF9800)                  // Laranja
val TaskGoDividerLight = Color(0xFFE0E0E0)            // Divider claro
val TaskGoBackgroundLight = Color(0xFFF5F5F5)         // Background claro
val TaskGoSurfaceGrayBg = Color(0xFFE8F5E8)            // Background verde suave

```

## [FRONTEND]: core/theme/Shapes.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.core.theme

import androidx.compose.material3.Shapes
import androidx.compose.ui.unit.dp

/**
 * Formas baseadas no prot√≥tipo Figma
 * Baseado nos componentes de bordas arredondadas dos cards e bot√µes
 */
val TaskGoShapes = Shapes(
    extraSmall = androidx.compose.foundation.shape.RoundedCornerShape(8.dp),
    small = androidx.compose.foundation.shape.RoundedCornerShape(12.dp),
    medium = androidx.compose.foundation.shape.RoundedCornerShape(16.dp),
    large = androidx.compose.foundation.shape.RoundedCornerShape(20.dp),
    extraLarge = androidx.compose.foundation.shape.RoundedCornerShape(28.dp)
)

/**
 * Espa√ßamentos padr√£o extra√≠dos do Figma
 */
object TaskGoSpacing {
    val xs = 4.dp
    val sm = 8.dp
    val md = 16.dp
    val lg = 24.dp
    val xl = 32.dp
    val xxl = 48.dp
}

```

## [FRONTEND]: core/theme/Theme.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.core.theme

import android.app.Activity
import android.content.res.Configuration
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.runtime.CompositionLocalProvider
import androidx.compose.runtime.SideEffect
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.platform.LocalConfiguration
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalView
import androidx.core.view.WindowCompat
import com.taskgoapp.taskgo.core.locale.LocaleManager
import java.util.Locale

/**
 * Esquema de cores baseado no prot√≥tipo Figma
 * Cores extra√≠das diretamente do design
 */
private val LightColorScheme = lightColorScheme(
    primary = TaskGoGreen,                    // Verde principal #00BD48
    onPrimary = TaskGoBackgroundWhite,        // Branco sobre verde
    primaryContainer = TaskGoGreenLight,      // Verde claro
    onPrimaryContainer = TaskGoTextBlack,
    
    secondary = TaskGoGreenDark,              // Verde escuro
    onSecondary = TaskGoBackgroundWhite,
    secondaryContainer = TaskGoBackgroundGray,
    onSecondaryContainer = TaskGoTextBlack,
    
    tertiary = TaskGoSecondary,               // Amarelo das estrelas
    onTertiary = TaskGoBackgroundWhite,
    
    background = TaskGoBackgroundWhite,
    onBackground = TaskGoTextBlack,
    
    surface = TaskGoSurface,
    onSurface = TaskGoTextBlack,
    
    surfaceVariant = TaskGoBackgroundGray,
    onSurfaceVariant = TaskGoTextGray,
    
    error = TaskGoError,
    onError = TaskGoBackgroundWhite,
    errorContainer = TaskGoSurfaceGrayLight,
    onErrorContainer = TaskGoError,
    
    outline = TaskGoBorder,
    outlineVariant = TaskGoDivider,
    
    surfaceTint = TaskGoGreen,
    inverseSurface = TaskGoNeutralDark,
    inverseOnSurface = TaskGoBackgroundWhite,
    inversePrimary = TaskGoGreenLight
)

private val DarkColorScheme = darkColorScheme(
    primary = TaskGoGreenLight,
    onPrimary = TaskGoTextBlack,
    primaryContainer = TaskGoGreenDark,
    onPrimaryContainer = TaskGoBackgroundWhite,
    
    secondary = TaskGoGreen,
    onSecondary = TaskGoBackgroundWhite,
    secondaryContainer = TaskGoNeutralDark,
    onSecondaryContainer = TaskGoGreenLight,
    
    tertiary = TaskGoSecondary,
    onTertiary = TaskGoTextBlack,
    
    background = TaskGoTextBlack,
    onBackground = TaskGoBackgroundWhite,
    
    surface = TaskGoNeutralDark,
    onSurface = TaskGoBackgroundWhite,
    
    surfaceVariant = TaskGoNeutralDark,
    onSurfaceVariant = TaskGoTextGrayMedium,
    
    error = TaskGoError,
    onError = TaskGoBackgroundWhite,
    errorContainer = TaskGoError,
    onErrorContainer = TaskGoBackgroundWhite,
    
    outline = TaskGoBorder,
    outlineVariant = TaskGoBorderLight,
    
    surfaceTint = TaskGoGreen,
    inverseSurface = TaskGoBackgroundWhite,
    inverseOnSurface = TaskGoTextBlack,
    inversePrimary = TaskGoGreenDark
)

@Composable
fun TaskGoTheme(
    darkTheme: Boolean = false, // Sempre usar tema claro
    languageCode: String = "pt",
    content: @Composable () -> Unit
) {
    // Sempre usar tema claro - tema escuro desabilitado
    val colorScheme = LightColorScheme

    val view = LocalView.current
    val context = LocalContext.current
    val configuration = LocalConfiguration.current
    
    // Aplicar locale dinamicamente
    val locale = LocaleManager.getLocale(languageCode)
    Locale.setDefault(locale)
    
    val updatedConfiguration = Configuration(configuration).apply {
        setLocale(locale)
    }
    
    
    if (!view.isInEditMode) {
        SideEffect {
            val window = (view.context as Activity).window
            window.statusBarColor = colorScheme.primary.toArgb()
            WindowCompat.getInsetsController(window, view).isAppearanceLightStatusBars = !darkTheme
        }
    }

    // Prover configura√ß√£o atualizada para os composables filhos
    CompositionLocalProvider(
        LocalConfiguration provides updatedConfiguration
    ) {
        MaterialTheme(
            colorScheme = colorScheme,
            typography = TaskGoTypography,
            shapes = TaskGoShapes,
            content = content
        )
    }
}

```

## [FRONTEND]: core/theme/Typography.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.core.theme

import androidx.compose.material3.Typography
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp

/**
 * Tipografia baseada no prot√≥tipo Figma
 * Font: Open Sans (conforme arquivo OpenSans.ttf no projeto)
 * Baseado nos estilos extra√≠dos do Figma
 */

// === TIPOGRAFIA PRINCIPAL ===
val TaskGoTypography = Typography(
    // Display styles - para t√≠tulos principais
    displayLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontSize = 32.sp,
        fontWeight = FontWeight.Bold,
        lineHeight = 40.sp,
        letterSpacing = 0.sp
    ),
    displayMedium = TextStyle(
        fontFamily = FontFamily.Default,
        fontSize = 28.sp,
        fontWeight = FontWeight.Bold,
        lineHeight = 36.sp,
        letterSpacing = 0.sp
    ),
    displaySmall = TextStyle(
        fontFamily = FontFamily.Default,
        fontSize = 24.sp,
        fontWeight = FontWeight.Bold,
        lineHeight = 32.sp,
        letterSpacing = 0.sp
    ),
    
    // Headline styles - para t√≠tulos de se√ß√£o
    headlineLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontSize = 28.sp,
        fontWeight = FontWeight.SemiBold,
        lineHeight = 36.sp,
        letterSpacing = 0.sp
    ),
    headlineMedium = TextStyle(
        fontFamily = FontFamily.Default,
        fontSize = 24.sp,
        fontWeight = FontWeight.SemiBold,
        lineHeight = 32.sp,
        letterSpacing = 0.sp
    ),
    headlineSmall = TextStyle(
        fontFamily = FontFamily.Default,
        fontSize = 20.sp,
        fontWeight = FontWeight.SemiBold,
        lineHeight = 28.sp,
        letterSpacing = 0.sp
    ),
    
    // Title styles - para t√≠tulos de cards e elementos
    titleLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontSize = 22.sp,
        fontWeight = FontWeight.SemiBold,
        lineHeight = 28.sp,
        letterSpacing = 0.sp
    ),
    titleMedium = TextStyle(
        fontFamily = FontFamily.Default,
        fontSize = 18.sp,
        fontWeight = FontWeight.Medium,
        lineHeight = 24.sp,
        letterSpacing = 0.sp
    ),
    titleSmall = TextStyle(
        fontFamily = FontFamily.Default,
        fontSize = 16.sp,
        fontWeight = FontWeight.Medium,
        lineHeight = 22.sp,
        letterSpacing = 0.sp
    ),
    
    // Body styles - para texto principal
    bodyLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontSize = 16.sp,
        fontWeight = FontWeight.Normal,
        lineHeight = 24.sp,
        letterSpacing = 0.sp
    ),
    bodyMedium = TextStyle(
        fontFamily = FontFamily.Default,
        fontSize = 14.sp,
        fontWeight = FontWeight.Normal,
        lineHeight = 20.sp,
        letterSpacing = 0.sp
    ),
    bodySmall = TextStyle(
        fontFamily = FontFamily.Default,
        fontSize = 12.sp,
        fontWeight = FontWeight.Normal,
        lineHeight = 18.sp,
        letterSpacing = 0.sp
    ),
    
    // Label styles - para labels e bot√µes
    labelLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontSize = 14.sp,
        fontWeight = FontWeight.SemiBold,
        lineHeight = 20.sp,
        letterSpacing = 0.sp
    ),
    labelMedium = TextStyle(
        fontFamily = FontFamily.Default,
        fontSize = 12.sp,
        fontWeight = FontWeight.Medium,
        lineHeight = 18.sp,
        letterSpacing = 0.sp
    ),
    labelSmall = TextStyle(
        fontFamily = FontFamily.Default,
        fontSize = 11.sp,
        fontWeight = FontWeight.Medium,
        lineHeight = 16.sp,
        letterSpacing = 0.sp
    )
)

// === ESTILOS ESPEC√çFICOS DO FIGMA ===
// Baseados nos estilos extra√≠dos do prot√≥tipo

// T√≠tulos principais das telas
val FigmaTitleLarge = TextStyle(
    fontFamily = FontFamily.Default,
    fontSize = 24.sp,
    fontWeight = FontWeight.Bold,
    lineHeight = 32.sp,
    letterSpacing = 0.sp
)

// T√≠tulos de se√ß√£o (ex: "Produtos em Destaque")
val FigmaSectionTitle = TextStyle(
    fontFamily = FontFamily.Default,
    fontSize = 20.sp,
    fontWeight = FontWeight.SemiBold,
    lineHeight = 28.sp,
    letterSpacing = 0.sp
)

// Nomes de produtos/servi√ßos
val FigmaProductName = TextStyle(
    fontFamily = FontFamily.Default,
    fontSize = 16.sp,
    fontWeight = FontWeight.Medium,
    lineHeight = 22.sp,
    letterSpacing = 0.sp
)

// Descri√ß√µes de produtos
val FigmaProductDescription = TextStyle(
    fontFamily = FontFamily.Default,
    fontSize = 14.sp,
    fontWeight = FontWeight.Normal,
    lineHeight = 20.sp,
    letterSpacing = 0.sp
)

// Pre√ßos
val FigmaPrice = TextStyle(
    fontFamily = FontFamily.Default,
    fontSize = 16.sp,
    fontWeight = FontWeight.Bold,
    lineHeight = 22.sp,
    letterSpacing = 0.sp
)

// Texto de navega√ß√£o (bottom nav)
val FigmaNavLabel = TextStyle(
    fontFamily = FontFamily.Default,
    fontSize = 12.sp,
    fontWeight = FontWeight.Medium,
    lineHeight = 16.sp,
    letterSpacing = 0.sp
)

// Placeholders de input
val FigmaPlaceholder = TextStyle(
    fontFamily = FontFamily.Default,
    fontSize = 14.sp,
    fontWeight = FontWeight.Normal,
    lineHeight = 20.sp,
    letterSpacing = 0.sp
)

// Texto de bot√µes
val FigmaButtonText = TextStyle(
    fontFamily = FontFamily.Default,
    fontSize = 16.sp,
    fontWeight = FontWeight.SemiBold,
    lineHeight = 22.sp,
    letterSpacing = 0.sp
)

// Texto de status (ex: "Em andamento", "Conclu√≠do")
val FigmaStatusText = TextStyle(
    fontFamily = FontFamily.Default,
    fontSize = 12.sp,
    fontWeight = FontWeight.Medium,
    lineHeight = 16.sp,
    letterSpacing = 0.sp
)

// Texto de avalia√ß√£o/rating
val FigmaRatingText = TextStyle(
    fontFamily = FontFamily.Default,
    fontSize = 14.sp,
    fontWeight = FontWeight.Medium,
    lineHeight = 20.sp,
    letterSpacing = 0.sp
)

```

# Core - tracking


## [FRONTEND]: core/tracking/TrackingCodeGenerator.kt

```kotlin
package com.taskgoapp.taskgo.core.tracking

import kotlin.math.absoluteValue

object TrackingCodeGenerator {
    fun generate(orderId: String): String {
        val normalized = orderId.filter { it.isLetterOrDigit() }
        val hash = normalized.hashCode().absoluteValue % 1_000_000_000
        val middle = hash.toString().padStart(9, '0')
        return "TG${middle}BR"
    }
}


```

# Core - ui


## [FRONTEND]: core/ui/UiState.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.core.ui

/**
 * Sealed class representing UI state
 */
sealed class UiState<out T> {
    object Loading : UiState<Nothing>()
    data class Success<T>(val data: T) : UiState<T>()
    data class Error(val message: String) : UiState<Nothing>()
    
    /**
     * Check if state is loading
     */
    val isLoading: Boolean
        get() = this is Loading
    
    /**
     * Check if state is error
     */
    val isError: Boolean
        get() = this is Error
    
    /**
     * Check if state is success
     */
    val isSuccess: Boolean
        get() = this is Success
    
    /**
     * Get data if success, null otherwise
     */
    fun getDataOrNull(): T? = when (this) {
        is Success -> data
        else -> null
    }
    
    /**
     * Get error message if error, null otherwise
     */
    fun getErrorOrNull(): String? = when (this) {
        is Error -> message
        else -> null
    }
}



```

# Core - utils


## [FRONTEND]: core/utils/BitmapUtils.kt

```kotlin
package com.taskgoapp.taskgo.core.utils

import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.graphics.Matrix
import android.net.Uri
import android.content.Context
import androidx.exifinterface.media.ExifInterface
import java.io.InputStream
import kotlin.math.max
import kotlin.math.min

object BitmapUtils {
    private const val MAX_IMAGE_DIMENSION = 2048 // M√°ximo de 2048px em qualquer dimens√£o
    private const val MAX_BITMAP_SIZE = 10 * 1024 * 1024 // 10MB m√°ximo em mem√≥ria
    
    /**
     * Redimensiona um bitmap para um tamanho m√°ximo, mantendo a propor√ß√£o
     */
    fun resizeBitmap(bitmap: Bitmap, maxDimension: Int = MAX_IMAGE_DIMENSION): Bitmap {
        val width = bitmap.width
        val height = bitmap.height
        
        // Se j√° est√° dentro do limite, retorna o bitmap original
        if (width <= maxDimension && height <= maxDimension) {
            return bitmap
        }
        
        val scale = min(
            maxDimension.toFloat() / width,
            maxDimension.toFloat() / height
        )
        
        val newWidth = (width * scale).toInt()
        val newHeight = (height * scale).toInt()
        
        return Bitmap.createScaledBitmap(bitmap, newWidth, newHeight, true)
    }
    
    /**
     * Carrega e redimensiona um bitmap de uma URI, considerando a orienta√ß√£o EXIF
     */
    fun loadAndResizeBitmap(context: Context, uri: Uri, maxDimension: Int = MAX_IMAGE_DIMENSION): Bitmap? {
        return try {
            val inputStream: InputStream? = context.contentResolver.openInputStream(uri)
            if (inputStream == null) return null
            
            // Primeiro, decodifica apenas as dimens√µes
            val options = BitmapFactory.Options().apply {
                inJustDecodeBounds = true
            }
            BitmapFactory.decodeStream(inputStream, null, options)
            inputStream.close()
            
            // Calcula o sample size para reduzir mem√≥ria
            options.inSampleSize = calculateInSampleSize(options, maxDimension, maxDimension)
            options.inJustDecodeBounds = false
            
            // Decodifica o bitmap com o sample size
            val newInputStream = context.contentResolver.openInputStream(uri)
            val bitmap = BitmapFactory.decodeStream(newInputStream, null, options)
            newInputStream?.close()
            
            if (bitmap == null) return null
            
            // Corrige orienta√ß√£o EXIF se necess√°rio
            val orientedBitmap = fixOrientation(context, uri, bitmap)
            
            // Redimensiona se ainda estiver muito grande
            if (orientedBitmap.width > maxDimension || orientedBitmap.height > maxDimension) {
                resizeBitmap(orientedBitmap, maxDimension)
            } else {
                orientedBitmap
            }
        } catch (e: Exception) {
            null
        }
    }
    
    /**
     * Calcula o inSampleSize para reduzir o uso de mem√≥ria
     */
    private fun calculateInSampleSize(
        options: BitmapFactory.Options,
        reqWidth: Int,
        reqHeight: Int
    ): Int {
        val height = options.outHeight
        val width = options.outWidth
        var inSampleSize = 1
        
        if (height > reqHeight || width > reqWidth) {
            val halfHeight = height / 2
            val halfWidth = width / 2
            
            while ((halfHeight / inSampleSize) >= reqHeight &&
                (halfWidth / inSampleSize) >= reqWidth) {
                inSampleSize *= 2
            }
        }
        
        return inSampleSize
    }
    
    /**
     * Corrige a orienta√ß√£o da imagem baseado nos dados EXIF
     */
    private fun fixOrientation(context: Context, uri: Uri, bitmap: Bitmap): Bitmap {
        return try {
            val inputStream = context.contentResolver.openInputStream(uri) ?: return bitmap
            val exif = ExifInterface(inputStream)
            inputStream.close()
            
            val orientation = exif.getAttributeInt(
                ExifInterface.TAG_ORIENTATION,
                ExifInterface.ORIENTATION_NORMAL
            )
            
            if (orientation == ExifInterface.ORIENTATION_NORMAL) {
                return bitmap
            }
            
            val matrix = Matrix()
            when (orientation) {
                ExifInterface.ORIENTATION_ROTATE_90 -> matrix.postRotate(90f)
                ExifInterface.ORIENTATION_ROTATE_180 -> matrix.postRotate(180f)
                ExifInterface.ORIENTATION_ROTATE_270 -> matrix.postRotate(270f)
                ExifInterface.ORIENTATION_FLIP_HORIZONTAL -> matrix.postScale(-1f, 1f)
                ExifInterface.ORIENTATION_FLIP_VERTICAL -> matrix.postScale(1f, -1f)
                ExifInterface.ORIENTATION_TRANSPOSE -> {
                    matrix.postRotate(90f)
                    matrix.postScale(-1f, 1f)
                }
                ExifInterface.ORIENTATION_TRANSVERSE -> {
                    matrix.postRotate(270f)
                    matrix.postScale(-1f, 1f)
                }
                else -> return bitmap
            }
            
            val rotatedBitmap = Bitmap.createBitmap(bitmap, 0, 0, bitmap.width, bitmap.height, matrix, true)
            if (rotatedBitmap != bitmap) {
                bitmap.recycle()
            }
            rotatedBitmap
        } catch (e: Exception) {
            // Se houver erro ao ler EXIF, retorna o bitmap original
            bitmap
        }
    }
    
    /**
     * Verifica se um bitmap excede o tamanho m√°ximo permitido
     */
    fun isBitmapTooLarge(bitmap: Bitmap): Boolean {
        val byteCount = bitmap.allocationByteCount
        return byteCount > MAX_BITMAP_SIZE
    }
}


```

## [FRONTEND]: core/utils/ErrorHandler.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.core.utils

import android.util.Log
import com.taskgoapp.taskgo.utils.FirebaseErrorHandler
import com.google.firebase.FirebaseException
import java.net.UnknownHostException
import java.util.concurrent.TimeoutException

/**
 * Centralized error handler for the application
 */
object ErrorHandler {
    
    private const val TAG = "ErrorHandler"
    
    /**
     * Get user-friendly error message from exception
     */
    fun getErrorMessage(error: Throwable): String {
        return when (error) {
            is FirebaseException -> FirebaseErrorHandler.getErrorMessage(error)
            is UnknownHostException -> "Erro de conex√£o. Verifique sua internet."
            is TimeoutException -> "Tempo de espera excedido. Tente novamente."
            is NetworkException -> "Erro de conex√£o. Verifique sua internet."
            else -> {
                val message = error.message
                if (message.isNullOrBlank()) {
                    "Erro desconhecido. Tente novamente."
                } else {
                    message
                }
            }
        }
    }
    
    /**
     * Handle error and log it
     */
    fun handleError(
        error: Throwable,
        tag: String = TAG,
        onError: ((String) -> Unit)? = null
    ) {
        val message = getErrorMessage(error)
        Log.e(tag, "Error: $message", error)
        onError?.invoke(message)
    }
    
    /**
     * Log error without showing to user
     */
    fun logError(error: Throwable, tag: String = TAG) {
        Log.e(tag, "Error: ${error.message}", error)
    }
}

/**
 * Custom exception for network errors
 */
class NetworkException(message: String? = null, cause: Throwable? = null) : 
    Exception(message ?: "Network error", cause)



```

## [FRONTEND]: core/utils/KeyboardUtils.kt

```kotlin
package com.taskgoapp.taskgo.core.utils

import androidx.compose.foundation.clickable
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.foundation.layout.Box
import androidx.compose.runtime.Composable
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalFocusManager
import androidx.compose.ui.platform.LocalSoftwareKeyboardController

/**
 * Modifier extension para esconder o teclado ao clicar fora dos campos de texto
 * 
 * Uso:
 * ```
 * Box(modifier = Modifier
 *     .fillMaxSize()
 *     .hideKeyboardOnClickOutside()
 * ) {
 *     // Conte√∫do do formul√°rio
 * }
 * ```
 */
@Composable
fun Modifier.hideKeyboardOnClickOutside(): Modifier {
    val focusManager = LocalFocusManager.current
    val keyboardController = LocalSoftwareKeyboardController.current
    
    return this.then(
        Modifier.clickable(
            indication = null,
            interactionSource = remember { MutableInteractionSource() }
        ) {
            focusManager.clearFocus()
            keyboardController?.hide()
        }
    )
}


```

## [FRONTEND]: core/utils/TextFormatters.kt

```kotlin
package com.taskgoapp.taskgo.core.utils

import androidx.compose.ui.text.TextRange
import androidx.compose.ui.text.input.TextFieldValue

/**
 * Utilit√°rios para formata√ß√£o autom√°tica de campos de texto em formul√°rios
 * Com preserva√ß√£o de posi√ß√£o do cursor
 */
object TextFormatters {
    
    /**
     * Calcula a nova posi√ß√£o do cursor ap√≥s formata√ß√£o
     */
    private fun calculateNewCursorPosition(
        oldText: String,
        newText: String,
        oldCursorPosition: Int
    ): Int {
        // Conta quantos caracteres n√£o num√©ricos existem antes da posi√ß√£o do cursor no texto antigo
        val charsBeforeCursor = oldText.take(oldCursorPosition)
        val digitsBeforeCursor = charsBeforeCursor.count { it.isDigit() }
        
        // Encontra a posi√ß√£o no novo texto onde esse mesmo n√∫mero de d√≠gitos est√°
        var digitCount = 0
        for (i in newText.indices) {
            if (newText[i].isDigit()) {
                digitCount++
                if (digitCount >= digitsBeforeCursor) {
                    // Coloca o cursor ap√≥s o d√≠gito encontrado
                    return i + 1
                }
            }
        }
        
        // Se chegou aqui, cursor deve estar no final
        return newText.length
    }
    
    /**
     * Formata pre√ßo para exibi√ß√£o brasileira (1.234,56)
     * Aceita entrada como "1234.56" ou "1234,56" ou "123456"
     * N√ÉO adiciona ",00" automaticamente - apenas formata o que foi digitado
     */
    fun formatPrice(value: String): String {
        // Se vazio, retorna vazio
        if (value.isEmpty()) return ""
        
        // Remove caracteres n√£o num√©ricos exceto v√≠rgula
        val clean = value.replace(Regex("[^0-9,]"), "")
        
        if (clean.isEmpty()) return ""
        
        // Detecta se h√° v√≠rgula (separador decimal brasileiro)
        val hasComma = clean.contains(",")
        
        if (hasComma) {
            // H√° v√≠rgula: tudo antes da v√≠rgula √© parte inteira, tudo ap√≥s s√£o centavos (m√°ximo 2 d√≠gitos)
            val parts = clean.split(",")
            val integerPart = parts[0].replace(Regex("[^0-9]"), "")
            val decimalPart = parts.getOrNull(1)?.replace(Regex("[^0-9]"), "")?.take(2) ?: ""
            
            // Se parte inteira est√° vazia, retorna apenas centavos
            if (integerPart.isEmpty()) {
                return if (decimalPart.isNotEmpty()) "0,$decimalPart" else ""
            }
            
            // Formata parte inteira com separador de milhar (ponto)
            val formattedInteger = integerPart.reversed().chunked(3).joinToString(".").reversed()
            
            return if (decimalPart.isNotEmpty()) {
                "$formattedInteger,$decimalPart"
            } else {
                formattedInteger
            }
        } else {
            // N√£o h√° v√≠rgula: apenas formata parte inteira com separador de milhar
            // N√ÉO adiciona ",00" automaticamente - deixa o usu√°rio digitar
            val cleanDigits = clean.replace(Regex("[^0-9]"), "")
            if (cleanDigits.isEmpty()) return ""
            
            val formattedInteger = cleanDigits.reversed().chunked(3).joinToString(".").reversed()
            return formattedInteger
        }
    }
    
    /**
     * Remove formata√ß√£o de pre√ßo para obter valor num√©rico
     */
    fun unformatPrice(value: String): String {
        return value.replace(Regex("[^0-9]"), "")
    }
    
    /**
     * Formata telefone brasileiro (XX) XXXXX-XXXX ou (XX) XXXX-XXXX
     */
    fun formatPhone(value: String): String {
        val clean = value.replace(Regex("[^0-9]"), "")
        
        return when {
            clean.isEmpty() -> ""
            clean.length <= 2 -> "($clean"
            clean.length <= 6 -> {
                val ddd = clean.substring(0, 2)
                val rest = clean.substring(2)
                "($ddd) $rest"
            }
            clean.length <= 10 -> {
                // Telefone fixo (XX) XXXX-XXXX
                val ddd = clean.substring(0, 2)
                val part1 = clean.substring(2, 6)
                val part2 = clean.substring(6)
                "($ddd) $part1-$part2"
            }
            else -> {
                // Celular (XX) XXXXX-XXXX
                val ddd = clean.substring(0, 2)
                val part1 = clean.substring(2, 7)
                val part2 = clean.substring(7, 11)
                "($ddd) $part1-$part2"
            }
        }
    }
    
    /**
     * Formata telefone preservando posi√ß√£o do cursor
     */
    fun formatPhoneWithCursor(textFieldValue: TextFieldValue): TextFieldValue {
        val oldText = textFieldValue.text
        val oldCursor = textFieldValue.selection.start
        val newText = formatPhone(oldText)
        val newCursor = calculateNewCursorPosition(oldText, newText, oldCursor)
        return TextFieldValue(newText, TextRange(newCursor))
    }
    
    /**
     * Formata CPF (000.000.000-00) progressivamente
     */
    fun formatCpf(cpf: String): String {
        val clean = cpf.replace(Regex("[^0-9]"), "")
        if (clean.isEmpty()) return ""
        
        return when {
            clean.length <= 3 -> clean
            clean.length <= 6 -> "${clean.substring(0, 3)}.${clean.substring(3)}"
            clean.length <= 9 -> "${clean.substring(0, 3)}.${clean.substring(3, 6)}.${clean.substring(6)}"
            clean.length <= 11 -> "${clean.substring(0, 3)}.${clean.substring(3, 6)}.${clean.substring(6, 9)}-${clean.substring(9)}"
            else -> {
                // Se tiver mais de 11 d√≠gitos, limita a 11
                val limited = clean.substring(0, 11)
                "${limited.substring(0, 3)}.${limited.substring(3, 6)}.${limited.substring(6, 9)}-${limited.substring(9)}"
            }
        }
    }
    
    /**
     * Formata CPF preservando posi√ß√£o do cursor
     */
    fun formatCpfWithCursor(textFieldValue: TextFieldValue): TextFieldValue {
        val oldText = textFieldValue.text
        val oldCursor = textFieldValue.selection.start
        val newText = formatCpf(oldText)
        val newCursor = calculateNewCursorPosition(oldText, newText, oldCursor)
        return TextFieldValue(newText, TextRange(newCursor))
    }
    
    /**
     * Formata CNPJ (00.000.000/0000-00) progressivamente
     */
    fun formatCnpj(cnpj: String): String {
        val clean = cnpj.replace(Regex("[^0-9]"), "")
        if (clean.isEmpty()) return ""
        
        return when {
            clean.length <= 2 -> clean
            clean.length <= 5 -> "${clean.substring(0, 2)}.${clean.substring(2)}"
            clean.length <= 8 -> "${clean.substring(0, 2)}.${clean.substring(2, 5)}.${clean.substring(5)}"
            clean.length <= 12 -> "${clean.substring(0, 2)}.${clean.substring(2, 5)}.${clean.substring(5, 8)}/${clean.substring(8)}"
            clean.length <= 14 -> "${clean.substring(0, 2)}.${clean.substring(2, 5)}.${clean.substring(5, 8)}/${clean.substring(8, 12)}-${clean.substring(12)}"
            else -> {
                // Se tiver mais de 14 d√≠gitos, limita a 14
                val limited = clean.substring(0, 14)
                "${limited.substring(0, 2)}.${limited.substring(2, 5)}.${limited.substring(5, 8)}/${limited.substring(8, 12)}-${limited.substring(12)}"
            }
        }
    }
    
    /**
     * Formata CNPJ preservando posi√ß√£o do cursor
     */
    fun formatCnpjWithCursor(textFieldValue: TextFieldValue): TextFieldValue {
        val oldText = textFieldValue.text
        val oldCursor = textFieldValue.selection.start
        val newText = formatCnpj(oldText)
        val newCursor = calculateNewCursorPosition(oldText, newText, oldCursor)
        return TextFieldValue(newText, TextRange(newCursor))
    }
    
    /**
     * Formata data brasileira (DD/MM/AAAA)
     */
    fun formatDate(value: String): String {
        val clean = value.replace(Regex("[^0-9]"), "")
        
        return when {
            clean.isEmpty() -> ""
            clean.length <= 2 -> clean
            clean.length <= 4 -> {
                val day = clean.substring(0, 2)
                val month = clean.substring(2)
                "$day/$month"
            }
            else -> {
                val day = clean.substring(0, 2)
                val month = clean.substring(2, 4)
                val year = clean.substring(4, 8)
                "$day/$month/$year"
            }
        }
    }
    
    /**
     * Formata data preservando posi√ß√£o do cursor
     */
    fun formatDateWithCursor(textFieldValue: TextFieldValue): TextFieldValue {
        val oldText = textFieldValue.text
        val oldCursor = textFieldValue.selection.start
        val newText = formatDate(oldText)
        val newCursor = calculateNewCursorPosition(oldText, newText, oldCursor)
        return TextFieldValue(newText, TextRange(newCursor))
    }
    
    /**
     * Valida formato de data durante digita√ß√£o
     * Corrigido para evitar crash ao converter para int
     */
    fun isValidDateInput(value: String): Boolean {
        return try {
            val clean = value.replace(Regex("[^0-9]"), "")
            if (clean.isEmpty()) return true
            
            // Validar dia (01-31)
            if (clean.length >= 2) {
                val dayStr = clean.substring(0, 2)
                val day = dayStr.toIntOrNull()
                if (day == null || day < 1 || day > 31) return false
            }
            
            // Validar m√™s (01-12)
            if (clean.length >= 4) {
                val monthStr = clean.substring(2, 4)
                val month = monthStr.toIntOrNull()
                if (month == null || month < 1 || month > 12) return false
            }
            
            // Validar ano (1900-2099)
            if (clean.length >= 8) {
                val yearStr = clean.substring(4, 8)
                val yearValue = yearStr.toIntOrNull()
                if (yearValue == null || yearValue < 1900 || yearValue > 2099) return false
                
                // Valida√ß√£o adicional: verificar se a data √© v√°lida (ex: 31/02 n√£o existe)
                if (clean.length == 8) {
                    val dayValue = clean.substring(0, 2).toIntOrNull() ?: return false
                    val monthValue = clean.substring(2, 4).toIntOrNull() ?: return false
                    
                    // Validar se a data existe
                    val calendar = java.util.Calendar.getInstance()
                    calendar.set(java.util.Calendar.YEAR, yearValue)
                    calendar.set(java.util.Calendar.MONTH, monthValue - 1) // Calendar month is 0-based
                    calendar.set(java.util.Calendar.DAY_OF_MONTH, 1)
                    val maxDay = calendar.getActualMaximum(java.util.Calendar.DAY_OF_MONTH)
                    if (dayValue > maxDay) return false
                }
            }
            
            true
        } catch (e: Exception) {
            // Qualquer exce√ß√£o durante valida√ß√£o retorna false
            false
        }
    }
    
    /**
     * Formata CEP (00000-000)
     * Reutiliza fun√ß√£o do DocumentValidator
     */
    fun formatCep(cep: String): String {
        val clean = cep.replace(Regex("[^0-9]"), "")
        if (clean.isEmpty()) return ""
        if (clean.length <= 5) return clean
        if (clean.length <= 8) return "${clean.substring(0, 5)}-${clean.substring(5)}"
        return "${clean.substring(0, 5)}-${clean.substring(5, 8)}"
    }
    
    /**
     * Formata CEP preservando posi√ß√£o do cursor
     */
    fun formatCepWithCursor(textFieldValue: TextFieldValue): TextFieldValue {
        val oldText = textFieldValue.text
        val oldCursor = textFieldValue.selection.start
        val newText = formatCep(oldText)
        val newCursor = calculateNewCursorPosition(oldText, newText, oldCursor)
        return TextFieldValue(newText, TextRange(newCursor))
    }
    
    /**
     * Formata RG brasileiro (00.000.000-0 ou formato similar)
     * Formato padr√£o: XX.XXX.XXX-X (9 d√≠gitos)
     * Suporta at√© 12 d√≠gitos alfanum√©ricos para diferentes estados
     */
    fun formatRg(rg: String): String {
        val clean = rg.replace(Regex("[^0-9A-Za-z]"), "").uppercase()
        if (clean.isEmpty()) return ""
        
        // Limita a 12 d√≠gitos para compatibilidade com diferentes estados
        val limited = if (clean.length > 12) clean.substring(0, 12) else clean
        
        return when {
            limited.length <= 2 -> limited
            limited.length <= 5 -> "${limited.substring(0, 2)}.${limited.substring(2)}"
            limited.length <= 8 -> "${limited.substring(0, 2)}.${limited.substring(2, 5)}.${limited.substring(5)}"
            limited.length <= 9 -> {
                // Formato padr√£o: XX.XXX.XXX-X (9 d√≠gitos)
                "${limited.substring(0, 2)}.${limited.substring(2, 5)}.${limited.substring(5, 8)}-${limited.substring(8)}"
            }
            else -> {
                // Para RGs com mais de 9 d√≠gitos (at√© 12), formata como XX.XXX.XXX-XXX
                // Mant√©m os primeiros 8 d√≠gitos no padr√£o e adiciona o resto ap√≥s h√≠fen
                "${limited.substring(0, 2)}.${limited.substring(2, 5)}.${limited.substring(5, 8)}-${limited.substring(8)}"
            }
        }
    }
    
    /**
     * Formata RG preservando posi√ß√£o do cursor
     */
    fun formatRgWithCursor(textFieldValue: TextFieldValue): TextFieldValue {
        val oldText = textFieldValue.text
        val oldCursor = textFieldValue.selection.start
        val newText = formatRg(oldText)
        val newCursor = calculateNewCursorPosition(oldText, newText, oldCursor)
        return TextFieldValue(newText, TextRange(newCursor))
    }
    
    /**
     * Remove formata√ß√£o de qualquer campo
     */
    fun removeFormatting(value: String): String {
        return value.replace(Regex("[^0-9]"), "")
    }
}


```

## [FRONTEND]: core/utils/UserIdentifier.kt

```kotlin
package com.taskgoapp.taskgo.core.utils

import com.taskgoapp.taskgo.data.firestore.models.UserFirestore
import java.security.MessageDigest
import kotlin.math.round

/**
 * Sistema de ID √∫nico por usu√°rio baseado em:
 * - Modo de conta (role)
 * - Geolocaliza√ß√£o (cidade/estado ou latitude/longitude)
 * - Categorias de servi√ßos (preferredCategories)
 * 
 * Este ID √© usado para indexa√ß√£o e busca eficiente no Firestore,
 * permitindo filtrar usu√°rios por localiza√ß√£o, tipo de conta e categorias.
 */
object UserIdentifier {
    
    /**
     * Gera um ID √∫nico para o usu√°rio baseado em seus atributos
     * @param user Usu√°rio do Firestore
     * @return ID √∫nico calculado
     */
    fun generateUserId(user: UserFirestore): String {
        val components = mutableListOf<String>()
        
        // 1. Modo de conta (role)
        components.add("role:${user.role}")
        
        // 2. Geolocaliza√ß√£o (cidade/estado ou coordenadas)
        val locationId = generateLocationId(user)
        if (locationId.isNotEmpty()) {
            components.add("loc:$locationId")
        }
        
        // 3. Categorias de servi√ßos (apenas para parceiros)
        if (user.role == "partner" || user.role == "provider" || user.role == "seller") {
            val categoriesId = generateCategoriesId(user.preferredCategories)
            if (categoriesId.isNotEmpty()) {
                components.add("cats:$categoriesId")
            }
        }
        
        // Gerar hash MD5 do ID composto para garantir unicidade e tamanho fixo
        val compositeId = components.joinToString("|")
        return generateHash(compositeId)
    }
    
    /**
     * Gera ID de localiza√ß√£o baseado em cidade/estado ou coordenadas
     */
    private fun generateLocationId(user: UserFirestore): String {
        // Priorizar cidade/estado do endere√ßo
        val address = user.address
        if (address != null) {
            val city = address.city?.trim()?.lowercase() ?: ""
            val state = address.state?.trim()?.lowercase() ?: ""
            if (city.isNotEmpty() && state.isNotEmpty()) {
                return "${city}_${state}"
            }
        }
        
        // Se n√£o tiver endere√ßo, retornar vazio (n√£o usar coordenadas para ID de localiza√ß√£o)
        // Coordenadas s√£o muito espec√≠ficas e mudam frequentemente
        return ""
    }
    
    /**
     * Gera ID de categorias ordenadas e normalizadas
     */
    private fun generateCategoriesId(categories: List<String>?): String {
        if (categories.isNullOrEmpty()) {
            return ""
        }
        
        // Ordenar e normalizar categorias
        val normalized = categories
            .map { it.trim().lowercase() }
            .sorted()
            .joinToString(",")
        
        return generateHash(normalized).take(8) // Usar apenas 8 caracteres do hash
    }
    
    /**
     * Gera hash MD5 de uma string
     */
    private fun generateHash(input: String): String {
        val md = MessageDigest.getInstance("MD5")
        val hashBytes = md.digest(input.toByteArray())
        return hashBytes.joinToString("") { "%02x".format(it) }
    }
    
    /**
     * Gera ID de localiza√ß√£o baseado em coordenadas GPS (para busca por raio)
     * Usa geohash aproximado para agrupar coordenadas pr√≥ximas
     */
    fun generateGeohashId(latitude: Double, longitude: Double, precision: Int = 5): String {
        // Geohash simplificado: arredondar coordenadas para agrupar √°reas pr√≥ximas
        val latRounded = round(latitude * 100.0) / 100.0 // Precis√£o de ~1km
        val lngRounded = round(longitude * 100.0) / 100.0
        
        return "${latRounded}_${lngRounded}"
    }
    
    /**
     * Gera ID composto para busca eficiente de usu√°rios por:
     * - Localiza√ß√£o (geohash)
     * - Role
     * - Categorias
     */
    fun generateSearchId(
        role: String,
        latitude: Double?,
        longitude: Double?,
        city: String?,
        state: String?,
        categories: List<String>?
    ): String {
        val components = mutableListOf<String>()
        
        components.add("role:$role")
        
        // Priorizar cidade/estado, sen√£o usar geohash
        if (city != null && state != null && city.isNotEmpty() && state.isNotEmpty()) {
            components.add("loc:${city.lowercase()}_${state.lowercase()}")
        } else if (latitude != null && longitude != null) {
            components.add("geo:${generateGeohashId(latitude, longitude)}")
        }
        
        if (role == "partner" || role == "provider" || role == "seller") {
            val categoriesId = generateCategoriesId(categories)
            if (categoriesId.isNotEmpty()) {
                components.add("cats:$categoriesId")
            }
        }
        
        return components.joinToString("|")
    }
    
    /**
     * Extrai componentes do ID de busca para facilitar queries
     */
    data class SearchIdComponents(
        val role: String?,
        val location: String?,
        val geohash: String?,
        val categories: List<String>?
    )
    
    fun parseSearchId(searchId: String): SearchIdComponents {
        val parts = searchId.split("|")
        var role: String? = null
        var location: String? = null
        var geohash: String? = null
        var categories: List<String>? = null
        
        parts.forEach { part ->
            when {
                part.startsWith("role:") -> role = part.substringAfter("role:")
                part.startsWith("loc:") -> location = part.substringAfter("loc:")
                part.startsWith("geo:") -> geohash = part.substringAfter("geo:")
                part.startsWith("cats:") -> {
                    // Categories hash n√£o pode ser revertido, mas podemos usar para busca
                    // Em uma implementa√ß√£o futura, podemos manter um √≠ndice reverso
                }
            }
        }
        
        return SearchIdComponents(role, location, geohash, categories)
    }
}

```

# Core - validation


## [FRONTEND]: core/validation/CepService.kt

```kotlin
package com.taskgoapp.taskgo.core.validation

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.json.JSONObject
import java.net.HttpURLConnection
import java.net.URL

/**
 * Resultado da busca de CEP
 */
data class CepResult(
    val cep: String,
    val logradouro: String,
    val complemento: String?,
    val bairro: String,
    val localidade: String,
    val uf: String,
    val erro: Boolean = false
) {
    fun toAddress(): AddressData {
        return AddressData(
            street = logradouro,
            neighborhood = bairro,
            city = localidade,
            state = uf,
            zipCode = cep
        )
    }
}

/**
 * Dados de endere√ßo para preenchimento autom√°tico
 */
data class AddressData(
    val street: String,
    val neighborhood: String,
    val city: String,
    val state: String,
    val zipCode: String,
    val complement: String? = null
)

/**
 * Servi√ßo para buscar endere√ßo por CEP usando a API ViaCEP
 * API p√∫blica e gratuita dos Correios
 */
class CepService {
    
    companion object {
        private const val VIA_CEP_API = "https://viacep.com.br/ws/%s/json/"
    }
    
    /**
     * Busca endere√ßo por CEP
     * @param cep CEP no formato 00000000 ou 00000-000
     * @return CepResult com os dados do endere√ßo ou erro
     */
    suspend fun searchCep(cep: String): Result<CepResult> = withContext(Dispatchers.IO) {
        try {
            // Remove formata√ß√£o do CEP
            val cleanCep = cep.replace(Regex("[^0-9]"), "")
            
            // Valida formato do CEP
            if (cleanCep.length != 8) {
                return@withContext Result.failure(Exception("CEP deve conter 8 d√≠gitos"))
            }
            
            // Faz requisi√ß√£o √† API ViaCEP
            val url = URL(VIA_CEP_API.format(cleanCep))
            val connection = url.openConnection() as HttpURLConnection
            
            connection.requestMethod = "GET"
            connection.connectTimeout = 5000
            connection.readTimeout = 5000
            
            val responseCode = connection.responseCode
            
            if (responseCode == HttpURLConnection.HTTP_OK) {
                val response = connection.inputStream.bufferedReader().use { it.readText() }
                val json = JSONObject(response)
                
                // Verifica se h√° erro na resposta
                if (json.has("erro") && json.getBoolean("erro")) {
                    return@withContext Result.failure(Exception("CEP n√£o encontrado"))
                }
                
                val complementoValue = json.optString("complemento", "")
                val cepResult = CepResult(
                    cep = json.optString("cep", cleanCep),
                    logradouro = json.optString("logradouro", ""),
                    complemento = complementoValue.takeIf { it.isNotEmpty() },
                    bairro = json.optString("bairro", ""),
                    localidade = json.optString("localidade", ""),
                    uf = json.optString("uf", ""),
                    erro = false
                )
                
                Result.success(cepResult)
            } else {
                Result.failure(Exception("Erro ao buscar CEP. C√≥digo: $responseCode"))
            }
        } catch (e: Exception) {
            Result.failure(Exception("Erro ao buscar CEP: ${e.message}", e))
        }
    }
}


```

## [FRONTEND]: core/validation/DocumentValidator.kt

```kotlin
package com.taskgoapp.taskgo.core.validation

/**
 * Servi√ßo para valida√ß√£o de documentos brasileiros (CPF e RG)
 */
class DocumentValidator {
    
    companion object {
        // Estados brasileiros e seus formatos de RG
        private val RG_FORMATS = mapOf(
            "SP" to Regex("^\\d{9}(-\\d{1})?$"), // SP: 123456789 ou 123456789-0
            "RJ" to Regex("^\\d{7,8}(-\\d{1})?$"), // RJ: 1234567 ou 12345678-0
            "MG" to Regex("^[A-Z]{0,2}\\d{6,9}(-\\d{1})?$"), // MG: pode ter prefixo
            "RS" to Regex("^\\d{7,10}$"), // RS: 7 a 10 d√≠gitos
            "PR" to Regex("^\\d{8,10}(-\\d{1})?$"), // PR: 8 a 10 d√≠gitos
            "SC" to Regex("^\\d{6,9}$"), // SC: 6 a 9 d√≠gitos
            "BA" to Regex("^\\d{6,9}(-\\d{1})?$"), // BA: 6 a 9 d√≠gitos
            "GO" to Regex("^\\d{7,9}(-\\d{1})?$"), // GO: 7 a 9 d√≠gitos
            "PE" to Regex("^\\d{7,9}$"), // PE: 7 a 9 d√≠gitos
            "CE" to Regex("^\\d{7,9}(-\\d{1})?$"), // CE: 7 a 9 d√≠gitos
            "DF" to Regex("^\\d{6,9}(-\\d{1})?$"), // DF: 6 a 9 d√≠gitos
            "ES" to Regex("^\\d{7,9}(-\\d{1})?$"), // ES: 7 a 9 d√≠gitos
            "MT" to Regex("^\\d{7,9}(-\\d{1})?$"), // MT: 7 a 9 d√≠gitos
            "MS" to Regex("^\\d{7,9}(-\\d{1})?$"), // MS: 7 a 9 d√≠gitos
            "PA" to Regex("^\\d{7,9}(-\\d{1})?$"), // PA: 7 a 9 d√≠gitos
            "PB" to Regex("^\\d{7,9}(-\\d{1})?$"), // PB: 7 a 9 d√≠gitos
            "AM" to Regex("^\\d{7,9}(-\\d{1})?$"), // AM: 7 a 9 d√≠gitos
            "RN" to Regex("^\\d{7,9}(-\\d{1})?$"), // RN: 7 a 9 d√≠gitos
            "AL" to Regex("^\\d{7,9}(-\\d{1})?$"), // AL: 7 a 9 d√≠gitos
            "SE" to Regex("^\\d{7,9}(-\\d{1})?$"), // SE: 7 a 9 d√≠gitos
            "TO" to Regex("^\\d{7,9}(-\\d{1})?$"), // TO: 7 a 9 d√≠gitos
            "AC" to Regex("^\\d{7,9}(-\\d{1})?$"), // AC: 7 a 9 d√≠gitos
            "AP" to Regex("^\\d{7,9}(-\\d{1})?$"), // AP: 7 a 9 d√≠gitos
            "RO" to Regex("^\\d{7,9}(-\\d{1})?$"), // RO: 7 a 9 d√≠gitos
            "RR" to Regex("^\\d{7,9}(-\\d{1})?$"), // RR: 7 a 9 d√≠gitos
            "PI" to Regex("^\\d{7,9}(-\\d{1})?$"), // PI: 7 a 9 d√≠gitos
            "MA" to Regex("^\\d{7,9}(-\\d{1})?$")  // MA: 7 a 9 d√≠gitos
        )
    }
    
    /**
     * Valida CPF usando o algoritmo oficial brasileiro
     * @param cpf CPF no formato 00000000000 ou 000.000.000-00
     * @return ValidationResult com resultado da valida√ß√£o
     */
    fun validateCpf(cpf: String): ValidationResult {
        // Remove formata√ß√£o
        val cleanCpf = cpf.replace(Regex("[^0-9]"), "")
        
        // Verifica tamanho
        if (cleanCpf.length != 11) {
            return ValidationResult.Invalid("CPF deve conter 11 d√≠gitos")
        }
        
        // Verifica se todos os d√≠gitos s√£o iguais (CPFs inv√°lidos conhecidos)
        if (cleanCpf.all { it == cleanCpf[0] }) {
            return ValidationResult.Invalid("CPF inv√°lido")
        }
        
        // Valida primeiro d√≠gito verificador
        var sum = 0
        for (i in 0..8) {
            sum += Character.getNumericValue(cleanCpf[i]) * (10 - i)
        }
        var digit1 = 11 - (sum % 11)
        if (digit1 >= 10) digit1 = 0
        
        if (digit1 != Character.getNumericValue(cleanCpf[9])) {
            return ValidationResult.Invalid("CPF inv√°lido")
        }
        
        // Valida segundo d√≠gito verificador
        sum = 0
        for (i in 0..9) {
            sum += Character.getNumericValue(cleanCpf[i]) * (11 - i)
        }
        var digit2 = 11 - (sum % 11)
        if (digit2 >= 10) digit2 = 0
        
        if (digit2 != Character.getNumericValue(cleanCpf[10])) {
            return ValidationResult.Invalid("CPF inv√°lido")
        }
        
        return ValidationResult.Valid
    }
    
    /**
     * Valida RG baseado no estado
     * @param rg RG no formato do estado
     * @param state Estado brasileiro (UF) para valida√ß√£o espec√≠fica
     * @return ValidationResult com resultado da valida√ß√£o
     */
    fun validateRg(rg: String, state: String? = null): ValidationResult {
        // Remove espa√ßos extras
        val cleanRg = rg.trim()
        
        if (cleanRg.isEmpty()) {
            return ValidationResult.Valid // RG √© opcional
        }
        
        // Remove formata√ß√£o (pontos, h√≠fens) para contar d√≠gitos
        val digitsOnly = cleanRg.replace(Regex("[^0-9A-Za-z]"), "").uppercase()
        
        // Valida√ß√£o gen√©rica: 6 a 12 d√≠gitos alfanum√©ricos
        if (digitsOnly.length < 6 || digitsOnly.length > 12) {
            return ValidationResult.Invalid("RG inv√°lido. Formato incorreto.")
        }
        
        // Valida formato brasileiro padr√£o: XX.XXX.XXX-X (ex: 13.262.015-6)
        // Aceita formato com pontos e h√≠fen
        val formattedPattern = Regex("^\\d{2}\\.\\d{3}\\.\\d{3}-\\d{1}$") // Formato padr√£o: XX.XXX.XXX-X
        
        // Se tem pontos, valida formato formatado primeiro (mais comum)
        if (cleanRg.contains(".")) {
            // Verifica se segue o formato XX.XXX.XXX-X exatamente
            if (formattedPattern.matches(cleanRg)) {
                // Formato est√° correto! Valida por estado se especificado
                val mainDigitsOnly = cleanRg.split("-")[0].replace(Regex("[^0-9A-Za-z]"), "").uppercase()
                val mainDigitsCount = mainDigitsOnly.length
                
                // Valida por estado se especificado
                if (state != null && state.isNotEmpty()) {
                    val stateUpper = state.uppercase()
                    // PR aceita 8-10 d√≠gitos principais (formato padr√£o tem 8)
                    if (stateUpper == "PR" && mainDigitsCount >= 8 && mainDigitsCount <= 10) {
                        return ValidationResult.Valid
                    } else if (stateUpper != "PR") {
                        // Para outros estados, verifica se a quantidade est√° dentro do esperado
                        val format = RG_FORMATS[stateUpper]
                        if (format != null && format.matches(mainDigitsOnly)) {
                            return ValidationResult.Valid
                        }
                        return ValidationResult.Invalid("RG inv√°lido para o estado $stateUpper. Formato esperado: 00.000.000-0")
                    }
                } else {
                    // Se n√£o especificou estado, aceita formato padr√£o brasileiro (8-9 d√≠gitos principais + 1 verificador)
                    if (mainDigitsCount >= 8 && mainDigitsCount <= 9) {
                        return ValidationResult.Valid
                    }
                }
            } else {
                // Se n√£o passou na regex exata, verifica manualmente a estrutura (formato XX.XXX.XXX-X)
                val parts = cleanRg.split(".")
                if (parts.size == 3) {
                    val firstPart = parts[0]
                    val secondPart = parts[1]
                    val thirdWithDash = parts[2]
                    
                    // Verifica se cada parte tem a quantidade correta de d√≠gitos
                    if (firstPart.length == 2 && firstPart.all { it.isDigit() } &&
                        secondPart.length == 3 && secondPart.all { it.isDigit() } &&
                        thirdWithDash.contains("-")) {
                        
                        val lastParts = thirdWithDash.split("-")
                        if (lastParts.size == 2 &&
                            lastParts[0].length == 3 && lastParts[0].all { it.isDigit() } &&
                            lastParts[1].length >= 1 && lastParts[1].length <= 2 && lastParts[1].all { it.isDigit() }) {
                            // Formato v√°lido: XX.XXX.XXX-X ou XX.XXX.XXX-XX
                            // Valida por estado se especificado
                            val mainDigitsOnly = cleanRg.split("-")[0].replace(Regex("[^0-9A-Za-z]"), "").uppercase()
                            val mainDigitsCount = mainDigitsOnly.length
                            
                            if (state != null && state.isNotEmpty()) {
                                val stateUpper = state.uppercase()
                                if (stateUpper == "PR" && mainDigitsCount >= 8 && mainDigitsCount <= 10) {
                                    return ValidationResult.Valid
                                } else if (stateUpper != "PR") {
                                    val format = RG_FORMATS[stateUpper]
                                    if (format != null && format.matches(mainDigitsOnly)) {
                                        return ValidationResult.Valid
                                    }
                                    return ValidationResult.Invalid("RG inv√°lido para o estado $stateUpper. Formato esperado: 00.000.000-0")
                                }
                            }
                            // Se n√£o especificou estado ou passou na valida√ß√£o, aceita
                            return ValidationResult.Valid
                        }
                    }
                }
                return ValidationResult.Invalid("RG inv√°lido. Formato incorreto. Use o formato: 00.000.000-0")
            }
        }
        
        // Se especificar estado e n√£o tem pontos, valida formato espec√≠fico ap√≥s remover formata√ß√£o
        if (state != null && state.isNotEmpty()) {
            val stateUpper = state.uppercase()
            val format = RG_FORMATS[stateUpper]
            
            if (format != null) {
                // Para valida√ß√£o por estado sem formata√ß√£o, separa d√≠gitos principais do verificador
                val mainDigitsOnly = if (cleanRg.contains("-")) {
                    cleanRg.split("-")[0].replace(Regex("[^0-9A-Za-z]"), "").uppercase()
                } else {
                    // Se n√£o tem h√≠fen, assume que o √∫ltimo d√≠gito pode ser verificador
                    if (stateUpper == "PR" && digitsOnly.length >= 9) {
                        digitsOnly.substring(0, digitsOnly.length - 1)
                    } else if (stateUpper != "PR" && digitsOnly.length >= 8) {
                        digitsOnly.substring(0, digitsOnly.length - 1)
                    } else {
                        digitsOnly
                    }
                }
                
                // Valida formato espec√≠fico do estado usando apenas d√≠gitos principais
                if (stateUpper == "PR") {
                    val mainDigitsCount = mainDigitsOnly.length
                    if (mainDigitsCount >= 8 && mainDigitsCount <= 10) {
                        return ValidationResult.Valid
                    }
                } else {
                    if (format.matches(mainDigitsOnly) || format.matches(digitsOnly)) {
                        return ValidationResult.Valid
                    }
                }
                
                return ValidationResult.Invalid("RG inv√°lido para o estado $stateUpper. Formato esperado: 00.000.000-0")
            }
        }
        
        // Se n√£o tem pontos, valida formato simples (apenas d√≠gitos e h√≠fen opcional)
        val simplePattern = Regex("^\\d{6,12}(-\\d{1,2})?$")
        if (simplePattern.matches(cleanRg)) {
            return ValidationResult.Valid
        }
        
        // Valida apenas d√≠gitos alfanum√©ricos (6-12 caracteres)
        if (digitsOnly.all { it.isDigit() || it.isLetter() }) {
            return ValidationResult.Valid
        }
        
        return ValidationResult.Invalid("RG inv√°lido. Formato incorreto.")
    }
    
    /**
     * Formata CPF para exibi√ß√£o (000.000.000-00)
     */
    fun formatCpf(cpf: String): String {
        val cleanCpf = cpf.replace(Regex("[^0-9]"), "")
        if (cleanCpf.length != 11) return cpf
        
        return "${cleanCpf.substring(0, 3)}.${cleanCpf.substring(3, 6)}.${cleanCpf.substring(6, 9)}-${cleanCpf.substring(9)}"
    }
    
    /**
     * Formata CEP para exibi√ß√£o (00000-000)
     */
    fun formatCep(cep: String): String {
        val cleanCep = cep.replace(Regex("[^0-9]"), "")
        if (cleanCep.length != 8) return cep
        
        return "${cleanCep.substring(0, 5)}-${cleanCep.substring(5)}"
    }
    
    /**
     * Formata RG baseado no estado
     */
    fun formatRg(rg: String, @Suppress("UNUSED_PARAMETER") state: String? = null): String {
        val cleanRg = rg.replace(Regex("[^0-9A-Za-z]"), "").uppercase()
        
        // Formata√ß√£o b√°sica: adiciona h√≠fen antes do √∫ltimo d√≠gito se n√£o tiver
        if (cleanRg.length >= 7 && !cleanRg.contains("-")) {
            return "${cleanRg.substring(0, cleanRg.length - 1)}-${cleanRg.last()}"
        }
        
        return cleanRg
    }
    
    /**
     * Valida CNPJ usando o algoritmo oficial brasileiro
     * @param cnpj CNPJ no formato 00000000000000 ou 00.000.000/0000-00
     * @return ValidationResult com resultado da valida√ß√£o
     */
    fun validateCnpj(cnpj: String): ValidationResult {
        // Remove formata√ß√£o
        val cleanCnpj = cnpj.replace(Regex("[^0-9]"), "")
        
        // Verifica tamanho
        if (cleanCnpj.length != 14) {
            return ValidationResult.Invalid("CNPJ deve conter 14 d√≠gitos")
        }
        
        // Verifica se todos os d√≠gitos s√£o iguais (CNPJs inv√°lidos conhecidos)
        if (cleanCnpj.all { it == cleanCnpj[0] }) {
            return ValidationResult.Invalid("CNPJ inv√°lido")
        }
        
        // Valida primeiro d√≠gito verificador
        val weights1 = intArrayOf(5, 4, 3, 2, 9, 8, 7, 6, 5, 4, 3, 2)
        var sum = 0
        for (i in 0..11) {
            sum += Character.getNumericValue(cleanCnpj[i]) * weights1[i]
        }
        var digit1 = sum % 11
        digit1 = if (digit1 < 2) 0 else 11 - digit1
        
        if (digit1 != Character.getNumericValue(cleanCnpj[12])) {
            return ValidationResult.Invalid("CNPJ inv√°lido")
        }
        
        // Valida segundo d√≠gito verificador
        val weights2 = intArrayOf(6, 5, 4, 3, 2, 9, 8, 7, 6, 5, 4, 3, 2)
        sum = 0
        for (i in 0..12) {
            sum += Character.getNumericValue(cleanCnpj[i]) * weights2[i]
        }
        var digit2 = sum % 11
        digit2 = if (digit2 < 2) 0 else 11 - digit2
        
        if (digit2 != Character.getNumericValue(cleanCnpj[13])) {
            return ValidationResult.Invalid("CNPJ inv√°lido")
        }
        
        return ValidationResult.Valid
    }
    
    /**
     * Formata CNPJ para exibi√ß√£o (00.000.000/0000-00)
     */
    fun formatCnpj(cnpj: String): String {
        val cleanCnpj = cnpj.replace(Regex("[^0-9]"), "")
        if (cleanCnpj.length != 14) return cnpj
        
        return "${cleanCnpj.substring(0, 2)}.${cleanCnpj.substring(2, 5)}.${cleanCnpj.substring(5, 8)}/${cleanCnpj.substring(8, 12)}-${cleanCnpj.substring(12)}"
    }
    
    /**
     * Detecta se o documento √© CPF ou CNPJ e valida
     */
    fun validateCpfOrCnpj(document: String): ValidationResult {
        val cleanDoc = document.replace(Regex("[^0-9]"), "")
        return when (cleanDoc.length) {
            11 -> validateCpf(document)
            14 -> validateCnpj(document)
            else -> ValidationResult.Invalid("Documento deve ter 11 d√≠gitos (CPF) ou 14 d√≠gitos (CNPJ)")
        }
    }
}


```

## [FRONTEND]: core/validation/GovernmentDocumentValidator.kt

```kotlin
package com.taskgoapp.taskgo.core.validation

import android.util.Log
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.json.JSONObject
import java.net.HttpURLConnection
import java.net.URL
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Servi√ßo avan√ßado de valida√ß√£o de documentos brasileiros
 * Utiliza APIs p√∫blicas do governo quando dispon√≠veis
 * Implementa valida√ß√µes robustas seguindo padr√µes banc√°rios e governamentais
 */
@Singleton
class GovernmentDocumentValidator @Inject constructor() {
    
    companion object {
        private const val TAG = "GovDocumentValidator"
        // API p√∫blica para consulta de CPF (quando dispon√≠vel)
        // Nota: APIs p√∫blicas de valida√ß√£o de CPF s√£o limitadas por quest√µes de privacidade
        // Por isso, usamos valida√ß√£o algor√≠tmica robusta + verifica√ß√£o de padr√µes conhecidos
        private const val RECEITA_WS_API = "https://www.receitaws.com.br/v1/cnpj/%s"
    }
    
    /**
     * Valida CPF com verifica√ß√£o avan√ßada
     * Inclui verifica√ß√£o de CPFs bloqueados e padr√µes conhecidos
     */
    suspend fun validateCpfAdvanced(cpf: String): DocumentValidationResult = withContext(Dispatchers.IO) {
        try {
            val cleanCpf = cpf.replace(Regex("[^0-9]"), "")
            
            // Valida√ß√£o b√°sica
            if (cleanCpf.length != 11) {
                return@withContext DocumentValidationResult.Invalid("CPF deve conter exatamente 11 d√≠gitos")
            }
            
            // Verifica CPFs conhecidos como inv√°lidos (todos os d√≠gitos iguais)
            if (cleanCpf.all { it == cleanCpf[0] }) {
                return@withContext DocumentValidationResult.Invalid("CPF inv√°lido: todos os d√≠gitos s√£o iguais")
            }
            
            // Valida√ß√£o algor√≠tmica dos d√≠gitos verificadores
            val validator = DocumentValidator()
            val basicValidation = validator.validateCpf(cpf)
            
            if (basicValidation is ValidationResult.Invalid) {
                return@withContext DocumentValidationResult.Invalid(basicValidation.message)
            }
            
            // Verifica√ß√£o adicional: CPFs conhecidos como bloqueados pela Receita Federal
            // (Lista de CPFs bloqueados por quest√µes fiscais - exemplo)
            val blockedCpfs = listOf(
                "00000000000", "11111111111", "22222222222", "33333333333",
                "44444444444", "55555555555", "66666666666", "77777777777",
                "88888888888", "99999999999"
            )
            
            if (blockedCpfs.contains(cleanCpf)) {
                return@withContext DocumentValidationResult.Invalid("CPF bloqueado pela Receita Federal")
            }
            
            // Verifica√ß√£o de CPF suspeito (padr√µes que indicam poss√≠vel fraude)
            // Exemplo: sequ√™ncias muito regulares
            if (isSuspiciousPattern(cleanCpf)) {
                return@withContext DocumentValidationResult.Suspicious("CPF com padr√£o suspeito. Verifique os dados.")
            }
            
            DocumentValidationResult.Valid(cleanCpf)
        } catch (e: Exception) {
            Log.e(TAG, "Erro ao validar CPF: ${e.message}", e)
            DocumentValidationResult.Error("Erro ao validar CPF: ${e.message}")
        }
    }
    
    /**
     * Valida CNPJ com verifica√ß√£o avan√ßada e consulta √† API da ReceitaWS
     */
    suspend fun validateCnpjAdvanced(cnpj: String): DocumentValidationResult = withContext(Dispatchers.IO) {
        try {
            val cleanCnpj = cnpj.replace(Regex("[^0-9]"), "")
            
            // Valida√ß√£o b√°sica
            if (cleanCnpj.length != 14) {
                return@withContext DocumentValidationResult.Invalid("CNPJ deve conter exatamente 14 d√≠gitos")
            }
            
            // Verifica CNPJs conhecidos como inv√°lidos
            if (cleanCnpj.all { it == cleanCnpj[0] }) {
                return@withContext DocumentValidationResult.Invalid("CNPJ inv√°lido: todos os d√≠gitos s√£o iguais")
            }
            
            // Valida√ß√£o algor√≠tmica dos d√≠gitos verificadores
            val validator = DocumentValidator()
            val basicValidation = validator.validateCnpj(cnpj)
            
            if (basicValidation is ValidationResult.Invalid) {
                return@withContext DocumentValidationResult.Invalid(basicValidation.message)
            }
            
            // Consulta √† API da ReceitaWS para verificar se CNPJ existe e est√° ativo
            try {
                val url = URL(RECEITA_WS_API.format(cleanCnpj))
                val connection = url.openConnection() as HttpURLConnection
                connection.requestMethod = "GET"
                connection.connectTimeout = 5000
                connection.readTimeout = 5000
                connection.setRequestProperty("Accept", "application/json")
                
                val responseCode = connection.responseCode
                
                if (responseCode == HttpURLConnection.HTTP_OK) {
                    val response = connection.inputStream.bufferedReader().use { it.readText() }
                    val json = JSONObject(response)
                    
                    // Verifica se CNPJ est√° ativo
                    val status = json.optString("status", "")
                    if (status == "ERROR" || json.has("erro")) {
                        return@withContext DocumentValidationResult.Invalid("CNPJ n√£o encontrado na Receita Federal")
                    }
                    
                    // Verifica situa√ß√£o cadastral
                    val situacao = json.optString("situacao", "")
                    if (situacao.isNotEmpty() && situacao != "ATIVA") {
                        return@withContext DocumentValidationResult.Invalid("CNPJ com situa√ß√£o cadastral: $situacao")
                    }
                    
                    // Retorna CNPJ v√°lido com dados adicionais
                    val companyName = json.optString("nome", "")
                    val companyData = CnpjCompanyData(
                        cnpj = cleanCnpj,
                        companyName = companyName,
                        situation = situacao,
                        openingDate = json.optString("abertura", ""),
                        legalNature = json.optString("natureza_juridica", ""),
                        mainActivity = json.optString("atividade_principal", "")
                    )
                    
                    DocumentValidationResult.ValidWithData(cleanCnpj, companyData)
                } else {
                    // Se API n√£o responder, retorna valida√ß√£o algor√≠tmica
                    Log.w(TAG, "API ReceitaWS n√£o dispon√≠vel, usando valida√ß√£o algor√≠tmica")
                    DocumentValidationResult.Valid(cleanCnpj)
                }
            } catch (e: Exception) {
                // Se falhar a consulta √† API, usa apenas valida√ß√£o algor√≠tmica
                Log.w(TAG, "Erro ao consultar API ReceitaWS: ${e.message}")
                DocumentValidationResult.Valid(cleanCnpj)
            }
        } catch (e: Exception) {
            Log.e(TAG, "Erro ao validar CNPJ: ${e.message}", e)
            DocumentValidationResult.Error("Erro ao validar CNPJ: ${e.message}")
        }
    }
    
    /**
     * Valida RG com verifica√ß√£o avan√ßada baseada no estado
     */
    suspend fun validateRgAdvanced(rg: String, state: String?): DocumentValidationResult = withContext(Dispatchers.IO) {
        try {
            val validator = DocumentValidator()
            val basicValidation = validator.validateRg(rg, state)
            
            if (basicValidation is ValidationResult.Invalid) {
                return@withContext DocumentValidationResult.Invalid(basicValidation.message)
            }
            
            // Verifica√ß√µes adicionais de padr√µes suspeitos
            val cleanRg = rg.replace(Regex("[^0-9A-Za-z]"), "").uppercase()
            
            if (cleanRg.length < 6 || cleanRg.length > 12) {
                return@withContext DocumentValidationResult.Invalid("RG deve ter entre 6 e 12 caracteres")
            }
            
            // Verifica padr√µes suspeitos
            if (isSuspiciousPattern(cleanRg)) {
                return@withContext DocumentValidationResult.Suspicious("RG com padr√£o suspeito. Verifique os dados.")
            }
            
            DocumentValidationResult.Valid(cleanRg)
        } catch (e: Exception) {
            Log.e(TAG, "Erro ao validar RG: ${e.message}", e)
            DocumentValidationResult.Error("Erro ao validar RG: ${e.message}")
        }
    }
    
    /**
     * Verifica se um documento tem padr√£o suspeito
     */
    private fun isSuspiciousPattern(document: String): Boolean {
        // Verifica sequ√™ncias muito regulares (ex: 123456789, 111111111)
        if (document.length >= 6) {
            // Verifica se todos os d√≠gitos s√£o iguais
            if (document.all { it == document[0] }) {
                return true
            }
            
            // Verifica sequ√™ncias incrementais ou decrementais
            var isSequential = true
            var isReverseSequential = true
            
            for (i in 1 until document.length) {
                val current = document[i].code
                val previous = document[i - 1].code
                
                // Sequ√™ncia incremental
                if (current != previous + 1) {
                    isSequential = false
                }
                
                // Sequ√™ncia decremental
                if (current != previous - 1) {
                    isReverseSequential = false
                }
            }
            
            if (isSequential || isReverseSequential) {
                return true
            }
        }
        
        return false
    }
}

/**
 * Resultado avan√ßado de valida√ß√£o de documentos
 */
sealed class DocumentValidationResult {
    data class Valid(val document: String) : DocumentValidationResult()
    data class ValidWithData(val document: String, val companyData: CnpjCompanyData) : DocumentValidationResult()
    data class Invalid(val message: String) : DocumentValidationResult()
    data class Suspicious(val message: String) : DocumentValidationResult()
    data class Error(val message: String) : DocumentValidationResult()
}

/**
 * Dados da empresa obtidos da ReceitaWS
 */
data class CnpjCompanyData(
    val cnpj: String,
    val companyName: String,
    val situation: String,
    val openingDate: String,
    val legalNature: String,
    val mainActivity: String
)


```

## [FRONTEND]: core/validation/PasswordValidator.kt

```kotlin
package com.taskgoapp.taskgo.core.validation

/**
 * Enum para representar a for√ßa da senha
 */
enum class PasswordStrength {
    MUITO_FRACA,  // N√£o atende requisitos m√≠nimos
    FRACA,        // Atende apenas requisitos m√≠nimos
    MEDIA,        // Atende requisitos + extens√£o
    FORTE,        // Atende requisitos + boa extens√£o
    MUITO_FORTE   // Atende todos requisitos + extens√£o excelente
}

/**
 * Classe para valida√ß√£o de senha
 * Requisitos:
 * - M√≠nimo 8 caracteres
 * - Pelo menos 1 n√∫mero
 * - Pelo menos 1 caractere especial
 * - Pelo menos 1 letra mai√∫scula
 */
class PasswordValidator {
    
    /**
     * Valida se a senha atende todos os requisitos
     */
    fun validate(password: String): ValidationResult {
        if (password.isEmpty()) {
            return ValidationResult.Invalid("Senha √© obrigat√≥ria")
        }
        
        val requirements = getPasswordRequirements(password)
        val missingRequirements = requirements.filter { !it.met }
        
        if (missingRequirements.isNotEmpty()) {
            val messages = missingRequirements.map { it.message }
            return ValidationResult.Invalid(messages.joinToString(", "))
        }
        
        return ValidationResult.Valid
    }
    
    /**
     * Calcula a for√ßa da senha
     */
    fun calculateStrength(password: String): PasswordStrength {
        if (password.isEmpty()) {
            return PasswordStrength.MUITO_FRACA
        }
        
        val requirements = getPasswordRequirements(password)
        val metRequirements = requirements.count { it.met }
        val totalRequirements = requirements.size
        
        // Se n√£o atende todos os requisitos b√°sicos
        if (metRequirements < totalRequirements) {
            return PasswordStrength.MUITO_FRACA
        }
        
        // Calcula pontua√ß√£o baseada na extens√£o e diversidade
        var score = 0
        
        // Extens√£o (0-3 pontos)
        when {
            password.length >= 16 -> score += 3
            password.length >= 12 -> score += 2
            password.length >= 8 -> score += 1
        }
        
        // Diversidade de caracteres (0-2 pontos)
        val hasNumbers = password.any { it.isDigit() }
        val hasLowercase = password.any { it.isLowerCase() }
        val hasUppercase = password.any { it.isUpperCase() }
        val hasSpecial = password.any { !it.isLetterOrDigit() }
        
        val diversityCount = listOf(hasNumbers, hasLowercase, hasUppercase, hasSpecial).count { it }
        when {
            diversityCount == 4 -> score += 2
            diversityCount == 3 -> score += 1
        }
        
        // Retorna for√ßa baseada na pontua√ß√£o
        return when {
            score >= 5 -> PasswordStrength.MUITO_FORTE
            score >= 4 -> PasswordStrength.FORTE
            score >= 3 -> PasswordStrength.MEDIA
            score >= 1 -> PasswordStrength.FRACA
            else -> PasswordStrength.MUITO_FRACA
        }
    }
    
    /**
     * Obt√©m os requisitos da senha e se foram atendidos
     */
    private fun getPasswordRequirements(password: String): List<PasswordRequirement> {
        return listOf(
            PasswordRequirement(
                met = password.length >= 8,
                message = "M√≠nimo 8 caracteres"
            ),
            PasswordRequirement(
                met = password.any { it.isDigit() },
                message = "Pelo menos 1 n√∫mero"
            ),
            PasswordRequirement(
                met = password.any { it.isUpperCase() },
                message = "Pelo menos 1 letra mai√∫scula"
            ),
            PasswordRequirement(
                met = password.any { !it.isLetterOrDigit() },
                message = "Pelo menos 1 caractere especial"
            )
        )
    }
    
    /**
     * Data class para representar um requisito de senha
     */
    private data class PasswordRequirement(
        val met: Boolean,
        val message: String
    )
}


```

## [FRONTEND]: core/validation/Validators.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.core.validation

import java.util.regex.Pattern

object Validators {
    
    // Email validation
    fun isValidEmail(email: String): Boolean {
        val emailPattern = Pattern.compile(
            "^[A-Za-z0-9+_.-]+@([A-Za-z0-9.-]+\\.[A-Za-z]{2,})$"
        )
        return emailPattern.matcher(email).matches()
    }
    
    // Phone validation (Brazilian format)
    fun isValidPhone(phone: String): Boolean {
        val cleanPhone = phone.replace(Regex("[^0-9]"), "")
        return cleanPhone.length >= 10 && cleanPhone.length <= 11
    }
    
    // CEP validation (Brazilian postal code)
    fun isValidCep(cep: String): Boolean {
        val cleanCep = cep.replace(Regex("[^0-9]"), "")
        return cleanCep.length == 8
    }
    
    // Credit card number validation (Luhn algorithm)
    fun isValidCreditCard(cardNumber: String): Boolean {
        val cleanNumber = cardNumber.replace(Regex("[^0-9]"), "")
        if (cleanNumber.length < 13 || cleanNumber.length > 19) return false
        
        var sum = 0
        var alternate = false
        
        for (i in cleanNumber.length - 1 downTo 0) {
            var n = cleanNumber[i].toString().toInt()
            
            if (alternate) {
                n *= 2
                if (n > 9) {
                    n = (n % 10) + 1
                }
            }
            
            sum += n
            alternate = !alternate
        }
        
        return sum % 10 == 0
    }
    
    // CVC validation
    fun isValidCvc(cvc: String): Boolean {
        val cleanCvc = cvc.replace(Regex("[^0-9]"), "")
        return cleanCvc.length == 3
    }
    
    // Expiry date validation (MM/YY format)
    fun isValidExpiryDate(expiryDate: String): Boolean {
        val pattern = Pattern.compile("^(0[1-9]|1[0-2])/([0-9]{2})$")
        val matcher = pattern.matcher(expiryDate)
        
        if (!matcher.matches()) return false
        
        val month = matcher.group(1)!!.toInt()
        val year = matcher.group(2)!!.toInt()
        val currentYear = java.util.Calendar.getInstance().get(java.util.Calendar.YEAR) % 100
        val currentMonth = java.util.Calendar.getInstance().get(java.util.Calendar.MONTH) + 1
        
        return if (year > currentYear) {
            true
        } else if (year == currentYear) {
            month >= currentMonth
        } else {
            false
        }
    }
    
    // Name validation
    fun isValidName(name: String): Boolean {
        return name.trim().length >= 2 && name.matches(Regex("^[a-zA-Z√Ä-√ø\\s]+$"))
    }
    
    // Password validation
    fun isValidPassword(password: String): Boolean {
        return password.length >= 6
    }
    
    // Price validation
    fun isValidPrice(price: String): Boolean {
        return try {
            val value = price.replace(",", ".").toDouble()
            value > 0
        } catch (e: NumberFormatException) {
            false
        }
    }
    
    // Description validation (minimum 10 characters)
    fun isValidDescription(description: String): Boolean {
        return description.trim().length >= 10
    }
    
    // Address validation
    fun isValidAddress(address: String): Boolean {
        return address.trim().length >= 5
    }
    
    // City validation
    fun isValidCity(city: String): Boolean {
        return city.trim().length >= 2
    }
    
    // State validation (2 characters)
    fun isValidState(state: String): Boolean {
        return state.trim().length == 2
    }
}

// Validation result wrapper
sealed class ValidationResult {
    object Valid : ValidationResult()
    data class Invalid(val message: String) : ValidationResult()
}

// Form validation helper
class FormValidator {
    private val errors = mutableMapOf<String, String>()
    
    fun validate(fieldName: String, value: String, validator: (String) -> Boolean, errorMessage: String): FormValidator {
        if (!validator(value)) {
            errors[fieldName] = errorMessage
        } else {
            errors.remove(fieldName)
        }
        return this
    }
    
    fun isValid(): Boolean = errors.isEmpty()
    
    fun getErrors(): Map<String, String> = errors.toMap()
    
    fun getError(fieldName: String): String? = errors[fieldName]
}

```

# Core - work


## [FRONTEND]: core/work/AccountChangeProcessorWorker.kt

```kotlin
package com.taskgoapp.taskgo.core.work

import android.content.Context
import android.util.Log
import androidx.hilt.work.HiltWorker
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import com.taskgoapp.taskgo.data.repository.FirestoreAccountChangeRepository
import com.taskgoapp.taskgo.data.repository.FirestoreUserRepository
import com.taskgoapp.taskgo.data.firestore.models.UserFirestore
import dagger.assisted.Assisted
import dagger.assisted.AssistedInject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.util.Date

@HiltWorker
class AccountChangeProcessorWorker @AssistedInject constructor(
    @Assisted appContext: Context,
    @Assisted workerParams: WorkerParameters,
    private val accountChangeRepository: FirestoreAccountChangeRepository,
    private val firestoreUserRepository: FirestoreUserRepository
) : CoroutineWorker(appContext, workerParams) {
    
    companion object {
        private const val TAG = "AccountChangeProcessor"
    }
    
    override suspend fun doWork(): Result = withContext(Dispatchers.IO) {
        return@withContext try {
            Log.d(TAG, "Iniciando processamento de solicita√ß√µes de mudan√ßa de conta")
            
            // Buscar todas as solicita√ß√µes pendentes que devem ser processadas
            val pendingRequests = accountChangeRepository.getPendingRequestsToProcess()
            
            if (pendingRequests.isEmpty()) {
                Log.d(TAG, "Nenhuma solicita√ß√£o pendente para processar")
                return@withContext Result.success()
            }
            
            Log.d(TAG, "Encontradas ${pendingRequests.size} solicita√ß√µes para processar")
            
            var successCount = 0
            var failureCount = 0
            
            for (request in pendingRequests) {
                try {
                    // Buscar usu√°rio atual
                    val user = firestoreUserRepository.getUser(request.userId)
                    if (user == null) {
                        Log.e(TAG, "Usu√°rio n√£o encontrado: ${request.userId}")
                        accountChangeRepository.updateRequestStatus(
                            requestId = request.id,
                            status = "REJECTED",
                            rejectionReason = "Usu√°rio n√£o encontrado"
                        )
                        failureCount++
                        continue
                    }
                    
                    // Mapear AccountType para role
                    val newRole = when (request.requestedAccountType) {
                        "PARCEIRO" -> "partner"
                        "PRESTADOR" -> "partner" // Legacy - migrar para partner
                        "VENDEDOR" -> "partner" // Legacy - migrar para partner
                        "CLIENTE" -> "client"
                        else -> {
                            Log.e(TAG, "Tipo de conta inv√°lido: ${request.requestedAccountType}")
                            accountChangeRepository.updateRequestStatus(
                                requestId = request.id,
                                status = "REJECTED",
                                rejectionReason = "Tipo de conta inv√°lido"
                            )
                            failureCount++
                            continue
                        }
                    }
                    
                    // Atualizar role do usu√°rio
                    val updatedUser = user.copy(
                        role = newRole,
                        updatedAt = Date()
                    )
                    
                    val updateResult = firestoreUserRepository.updateUser(updatedUser)
                    updateResult.fold(
                        onSuccess = {
                            // Marcar solicita√ß√£o como processada
                            accountChangeRepository.updateRequestStatus(
                                requestId = request.id,
                                status = "PROCESSED",
                                processedBy = "system"
                            )
                            Log.d(TAG, "Conta do usu√°rio ${request.userId} alterada de ${user.role} para $newRole")
                            successCount++
                        },
                        onFailure = { exception ->
                            Log.e(TAG, "Erro ao atualizar usu√°rio ${request.userId}: ${exception.message}", exception)
                            accountChangeRepository.updateRequestStatus(
                                requestId = request.id,
                                status = "REJECTED",
                                rejectionReason = "Erro ao atualizar usu√°rio: ${exception.message}"
                            )
                            failureCount++
                        }
                    )
                } catch (e: Exception) {
                    Log.e(TAG, "Erro ao processar solicita√ß√£o ${request.id}: ${e.message}", e)
                    accountChangeRepository.updateRequestStatus(
                        requestId = request.id,
                        status = "REJECTED",
                        rejectionReason = "Erro inesperado: ${e.message}"
                    )
                    failureCount++
                }
            }
            
            Log.d(TAG, "Processamento conclu√≠do: $successCount sucessos, $failureCount falhas")
            Result.success()
        } catch (e: Exception) {
            Log.e(TAG, "Erro no processamento de solicita√ß√µes: ${e.message}", e)
            Result.retry()
        }
    }
}


```

## [FRONTEND]: core/work/OrderTrackingWorker.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.core.work

import android.content.Context
import androidx.hilt.work.HiltWorker
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import com.taskgoapp.taskgo.core.notifications.NotificationManager
import com.taskgoapp.taskgo.domain.repository.TrackingRepository
import dagger.assisted.Assisted
import dagger.assisted.AssistedInject

@HiltWorker
class OrderTrackingWorker @AssistedInject constructor(
    @Assisted context: Context,
    @Assisted workerParams: WorkerParameters,
    private val trackingRepository: TrackingRepository,
    private val notificationManager: NotificationManager
) : CoroutineWorker(context, workerParams) {

    override suspend fun doWork(): Result {
        val orderId = inputData.getString("order_id") ?: return Result.failure()
        val eventType = inputData.getString("event_type") ?: return Result.failure()
        
        return try {
            when (eventType) {
                "order_shipped" -> {
                    trackingRepository.updateEventDone("shipped_$orderId", true)
                    notificationManager.showOrderShippedNotification(orderId)
                }
                "in_transit" -> {
                    trackingRepository.updateEventDone("transit_$orderId", true)
                }
                "out_for_delivery" -> {
                    trackingRepository.updateEventDone("delivery_$orderId", true)
                }
                "delivered" -> {
                    trackingRepository.updateEventDone("delivered_$orderId", true)
                }
            }
            Result.success()
        } catch (e: Exception) {
            Result.failure()
        }
    }
}

```

## [FRONTEND]: core/work/WorkManagerHelper.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.core.work

import android.content.Context
import androidx.work.*
import java.util.concurrent.TimeUnit
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class WorkManagerHelper @Inject constructor(
    private val context: Context
) {
    
    private val workManager = WorkManager.getInstance(context)
    
    fun scheduleOrderTracking(orderId: String) {
        // Schedule "Pedido Enviado" notification after 5 seconds
        val orderShippedRequest = OneTimeWorkRequestBuilder<OrderTrackingWorker>()
            .setInputData(workDataOf(
                "order_id" to orderId,
                "event_type" to "order_shipped"
            ))
            .setInitialDelay(5, TimeUnit.SECONDS)
            .build()
        
        // Schedule "Em Tr√¢nsito" after 1 day
        val inTransitRequest = OneTimeWorkRequestBuilder<OrderTrackingWorker>()
            .setInputData(workDataOf(
                "order_id" to orderId,
                "event_type" to "in_transit"
            ))
            .setInitialDelay(1, TimeUnit.DAYS)
            .build()
        
        // Schedule "Saiu para Entrega" after 2 days
        val outForDeliveryRequest = OneTimeWorkRequestBuilder<OrderTrackingWorker>()
            .setInputData(workDataOf(
                "order_id" to orderId,
                "event_type" to "out_for_delivery"
            ))
            .setInitialDelay(2, TimeUnit.DAYS)
            .build()
        
        // Schedule "Entregue" after 3 days
        val deliveredRequest = OneTimeWorkRequestBuilder<OrderTrackingWorker>()
            .setInputData(workDataOf(
                "order_id" to orderId,
                "event_type" to "delivered"
            ))
            .setInitialDelay(3, TimeUnit.DAYS)
            .build()
        
        // Enqueue all work requests
        workManager.enqueueUniqueWork(
            "order_tracking_$orderId",
            ExistingWorkPolicy.REPLACE,
            orderShippedRequest
        )
        
        workManager.enqueue(inTransitRequest)
        workManager.enqueue(outForDeliveryRequest)
        workManager.enqueue(deliveredRequest)
    }
    
    fun scheduleProposalResponse(proposalId: String, delayMinutes: Long = 30) {
        val proposalRequest = OneTimeWorkRequestBuilder<OrderTrackingWorker>()
            .setInputData(workDataOf(
                "proposal_id" to proposalId,
                "event_type" to "proposal_approved"
            ))
            .setInitialDelay(delayMinutes, TimeUnit.MINUTES)
            .build()
        
        workManager.enqueue(proposalRequest)
    }
    
    fun scheduleChatResponse(threadId: String, delaySeconds: Long = 10) {
        val chatRequest = OneTimeWorkRequestBuilder<OrderTrackingWorker>()
            .setInputData(workDataOf(
                "thread_id" to threadId,
                "event_type" to "chat_response"
            ))
            .setInitialDelay(delaySeconds, TimeUnit.SECONDS)
            .build()
        
        workManager.enqueue(chatRequest)
    }
    
    fun cancelOrderTracking(orderId: String) {
        workManager.cancelUniqueWork("order_tracking_$orderId")
    }
}

```

# Data Layer - firebase


## [FRONTEND]: data/firebase/FirebaseFunctionsService.kt

```kotlin
package com.taskgoapp.taskgo.data.firebase

import android.util.Log
import com.taskgoapp.taskgo.data.firestore.models.ProposalDetails
import com.google.firebase.functions.FirebaseFunctions
import com.google.firebase.functions.FirebaseFunctionsException
import com.google.firebase.functions.HttpsCallableResult
import kotlinx.coroutines.tasks.await
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class FirebaseFunctionsService @Inject constructor(
    private val functions: FirebaseFunctions
) {

    // Auth Functions
    suspend fun getUserEmailByDocument(document: String): Result<Map<String, Any>> {
        val data = mapOf("document" to document)
        return executeFunction("getUserEmailByDocument", data)
    }

    suspend fun setInitialUserRole(role: String, accountType: String? = null): Result<Map<String, Any>> {
        val data = mapOf(
            "role" to role
        ).plus(accountType?.let { mapOf("accountType" to it) } ?: emptyMap())
        return executeFunction("setInitialUserRole", data)
    }

    suspend fun promoteToProvider(): Result<Map<String, Any>> {
        return executeFunction("promoteToProvider", null)
    }

    suspend fun approveProviderDocuments(providerId: String, documents: Map<String, Any>): Result<Map<String, Any>> {
        val data = mapOf(
            "providerId" to providerId,
            "documents" to documents
        )
        return executeFunction("approveProviderDocuments", data)
    }

    // Order Functions
    suspend fun createOrder(
        serviceId: String? = null,
        category: String? = null,
        details: String,
        location: String,
        budget: Double? = null,
        dueDate: String? = null
    ): Result<Map<String, Any>> {
        require(serviceId != null || category != null) { "Either serviceId or category must be provided" }
        
        val data = mutableMapOf<String, Any>(
            "details" to details,
            "location" to location
        )
        
        serviceId?.let { data["serviceId"] = it }
        category?.let { data["category"] = it }
        budget?.let { data["budget"] = it }
        dueDate?.let { data["dueDate"] = it }
        
        return executeFunction("createOrder", data)
    }

    suspend fun updateOrderStatus(
        orderId: String,
        status: String,
        proposalDetails: ProposalDetails? = null
    ): Result<Map<String, Any>> {
        val data = mapOf(
            "orderId" to orderId,
            "status" to status
        ).plus(
            proposalDetails?.let { mapOf("proposalDetails" to mapOf(
                "price" to it.price,
                "description" to it.description,
                "estimatedCompletionDate" to (it.estimatedCompletionDate ?: ""),
                "notes" to (it.notes ?: "")
            )) } ?: emptyMap()
        )
        
        return executeFunction("updateOrderStatus", data)
    }

    suspend fun getMyOrders(role: String? = null, status: String? = null): Result<Map<String, Any>> {
        val data = mapOf<String, Any>()
            .plus(role?.let { mapOf("role" to it) } ?: emptyMap())
            .plus(status?.let { mapOf("status" to it) } ?: emptyMap())
        
        return executeFunction("getMyOrders", data)
    }

    // Payment Functions
    suspend fun createPaymentIntent(orderId: String): Result<Map<String, Any>> {
        val data = mapOf("orderId" to orderId)
        return executeFunction("createPaymentIntent", data)
    }

    suspend fun confirmPayment(paymentIntentId: String): Result<Map<String, Any>> {
        val data = mapOf("paymentIntentId" to paymentIntentId)
        return executeFunction("confirmPayment", data)
    }

    suspend fun requestRefund(orderId: String, reason: String): Result<Map<String, Any>> {
        val data = mapOf(
            "orderId" to orderId,
            "reason" to reason
        )
        return executeFunction("requestRefund", data)
    }

    // Stripe Connect Functions
    suspend fun createOnboardingLink(): Result<Map<String, Any>> {
        return executeFunction("createOnboardingLink", null)
    }

    suspend fun getAccountStatus(): Result<Map<String, Any>> {
        return executeFunction("getAccountStatus", null)
    }

    suspend fun createDashboardLink(): Result<Map<String, Any>> {
        return executeFunction("createDashboardLink", null)
    }

    // Services Functions
    suspend fun createService(
        title: String,
        description: String,
        category: String,
        price: Double? = null,
        latitude: Double? = null,
        longitude: Double? = null,
        active: Boolean = true
    ): Result<Map<String, Any>> {
        val data = mapOf(
            "title" to title,
            "description" to description,
            "category" to category,
            "active" to active
        ).plus(price?.let { mapOf("price" to it) } ?: emptyMap())
         .plus(latitude?.let { mapOf("latitude" to it) } ?: emptyMap())
         .plus(longitude?.let { mapOf("longitude" to it) } ?: emptyMap())
        
        return executeFunction("createService", data)
    }
    
    suspend fun updateService(
        serviceId: String,
        updates: Map<String, Any>
    ): Result<Map<String, Any>> {
        val data = mapOf(
            "serviceId" to serviceId,
            "updates" to updates
        )
        return executeFunction("updateService", data)
    }
    
    suspend fun deleteService(serviceId: String): Result<Map<String, Any>> {
        val data = mapOf("serviceId" to serviceId)
        return executeFunction("deleteService", data)
    }

    // Stories Functions
    suspend fun createStory(
        mediaUrl: String,
        mediaType: String = "image",
        caption: String? = null,
        thumbnailUrl: String? = null,
        location: Map<String, Any>? = null,
        expiresAt: Long? = null
    ): Result<Map<String, Any>> {
        val data = mapOf(
            "mediaUrl" to mediaUrl,
            "mediaType" to mediaType
        ).plus(caption?.let { mapOf("caption" to it) } ?: emptyMap())
         .plus(thumbnailUrl?.let { mapOf("thumbnailUrl" to it) } ?: emptyMap())
         .plus(location?.let { mapOf("location" to it) } ?: emptyMap())
         .plus(expiresAt?.let { mapOf("expiresAt" to it) } ?: emptyMap())
        
        return executeFunction("createStory", data)
    }

    // AI Chat Functions
    suspend fun aiChatProxy(message: String, conversationId: String? = null): Result<Map<String, Any>> {
        val data = mapOf("message" to message)
            .plus(conversationId?.let { mapOf("conversationId" to it) } ?: emptyMap())
        
        return executeFunction("aiChatProxy", data)
    }

    suspend fun createConversation(): Result<Map<String, Any>> {
        return executeFunction("createConversation", null)
    }

    suspend fun getConversationHistory(conversationId: String): Result<Map<String, Any>> {
        val data = mapOf("conversationId" to conversationId)
        return executeFunction("getConversationHistory", data)
    }
    
    suspend fun listConversations(limit: Int = 50): Result<Map<String, Any>> {
        val data = mapOf("limit" to limit)
        return executeFunction("listConversations", data)
    }

    // Notification Functions
    suspend fun sendPushNotification(
        userId: String,
        title: String,
        message: String,
        data: Map<String, Any>? = null
    ): Result<Map<String, Any>> {
        val request = mapOf(
            "userId" to userId,
            "title" to title,
            "message" to message
        ).plus(data?.let { mapOf("data" to it) } ?: emptyMap())
        
        return executeFunction("sendPushNotification", request)
    }

    suspend fun getMyNotifications(limit: Int = 50, unreadOnly: Boolean = false): Result<Map<String, Any>> {
        val data = mapOf(
            "limit" to limit,
            "unreadOnly" to unreadOnly
        )
        return executeFunction("getMyNotifications", data)
    }

    suspend fun markNotificationRead(notificationId: String): Result<Map<String, Any>> {
        val data = mapOf("notificationId" to notificationId)
        return executeFunction("markNotificationRead", data)
    }

    suspend fun markAllNotificationsRead(): Result<Map<String, Any>> {
        return executeFunction("markAllNotificationsRead", null)
    }

    // User Preferences Functions
    suspend fun updateNotificationSettings(settings: Map<String, Boolean>): Result<Map<String, Any>> {
        return executeFunction("updateNotificationSettings", settings.mapValues { it.value as Any })
    }
    
    suspend fun updatePrivacySettings(settings: Map<String, Boolean>): Result<Map<String, Any>> {
        return executeFunction("updatePrivacySettings", settings.mapValues { it.value as Any })
    }
    
    suspend fun updateLanguagePreference(languageCode: String): Result<Map<String, Any>> {
        val data = mapOf("language" to languageCode)
        return executeFunction("updateLanguagePreference", data)
    }
    
    suspend fun updateUserPreferences(categories: List<String>): Result<Map<String, Any>> {
        val data = mapOf("categories" to categories)
        return executeFunction("updateUserPreferences", data)
    }

    suspend fun getUserPreferences(): Result<Map<String, Any>> {
        return executeFunction("getUserPreferences", null)
    }
    
    suspend fun getUserSettings(): Result<Map<String, Any>> {
        return executeFunction("getUserSettings", null)
    }
    
    // Account Deletion Function
    suspend fun deleteUserAccount(): Result<Map<String, Any>> {
        return executeFunction("deleteUserAccount", null)
    }
    
    // Two Factor Authentication Functions
    suspend fun sendTwoFactorCode(): Result<Map<String, Any>> {
        return executeFunction("sendTwoFactorCode", null)
    }
    
    suspend fun verifyTwoFactorCode(code: String): Result<Map<String, Any>> {
        val data = mapOf("code" to code)
        return executeFunction("verifyTwoFactorCode", data)
    }
    
    // Identity Verification Function
    suspend fun startIdentityVerification(
        documentFrontUrl: String,
        documentBackUrl: String?,
        selfieUrl: String,
        addressProofUrl: String? = null
    ): Result<Map<String, Any>> {
        val data = mapOf(
            "documentFrontUrl" to documentFrontUrl,
            "selfieUrl" to selfieUrl
        ).plus(documentBackUrl?.let { mapOf("documentBackUrl" to it) } ?: emptyMap())
         .plus(addressProofUrl?.let { mapOf("addressProofUrl" to it) } ?: emptyMap())
        return executeFunction("startIdentityVerification", data)
    }
    
    // Product Functions
    suspend fun createProduct(
        title: String,
        description: String,
        category: String,
        price: Double,
        images: List<String> = emptyList(),
        stock: Int? = null,
        active: Boolean = true
    ): Result<Map<String, Any>> {
        val data = mapOf(
            "title" to title,
            "description" to description,
            "category" to category,
            "price" to price,
            "images" to images,
            "active" to active
        ).plus(stock?.let { mapOf("stock" to it) } ?: emptyMap())
        return executeFunction("createProduct", data)
    }
    
    suspend fun updateProduct(
        productId: String,
        updates: Map<String, Any>
    ): Result<Map<String, Any>> {
        val data = mapOf(
            "productId" to productId,
            "updates" to updates
        )
        return executeFunction("updateProduct", data)
    }
    
    suspend fun deleteProduct(productId: String): Result<Map<String, Any>> {
        val data = mapOf("productId" to productId)
        return executeFunction("deleteProduct", data)
    }
    
    // Product Payment Functions
    suspend fun createProductPaymentIntent(orderId: String): Result<Map<String, Any>> {
        val data = mapOf("orderId" to orderId)
        return executeFunction("createProductPaymentIntent", data)
    }
    
    suspend fun confirmProductPayment(paymentIntentId: String): Result<Map<String, Any>> {
        val data = mapOf("paymentIntentId" to paymentIntentId)
        return executeFunction("confirmProductPayment", data)
    }
    
    suspend fun transferPaymentToSeller(orderId: String): Result<Map<String, Any>> {
        val data = mapOf("orderId" to orderId)
        return executeFunction("transferPaymentToSeller", data)
    }
    
    suspend fun refundProductPayment(orderId: String, reason: String? = null): Result<Map<String, Any>> {
        val data = mapOf("orderId" to orderId).plus(reason?.let { mapOf("reason" to it) } ?: emptyMap())
        return executeFunction("refundProductPayment", data)
    }

    // PIX Payment Functions
    suspend fun createPixPayment(orderId: String): Result<Map<String, Any>> {
        val data = mapOf("orderId" to orderId)
        return executeFunction("createPixPayment", data)
    }
    
    suspend fun verifyPixPayment(paymentId: String): Result<Map<String, Any>> {
        val data = mapOf("paymentId" to paymentId)
        return executeFunction("verifyPixPayment", data)
    }
    
    suspend fun confirmPixPayment(paymentId: String): Result<Map<String, Any>> {
        val data = mapOf("paymentId" to paymentId)
        return executeFunction("confirmPixPayment", data)
    }
    
    // Stripe Configuration
    suspend fun getStripePublishableKey(): Result<Map<String, Any>> {
        return executeFunction("getStripePublishableKey", null)
    }
    
    // Shipment Tracking Functions
    suspend fun updateShipmentTracking(
        shipmentId: String,
        status: String,
        trackingCode: String? = null,
        carrier: String? = null,
        customTrackingUrl: String? = null,
        deliveryConfirmationPhotoUrl: String? = null,
        isLocalDelivery: Boolean = false
    ): Result<Map<String, Any>> {
        val data = hashMapOf<String, Any>(
            "shipmentId" to shipmentId,
            "status" to status
        )
        trackingCode?.let { data["trackingCode"] = it }
        carrier?.let { data["carrier"] = it }
        customTrackingUrl?.let { data["customTrackingUrl"] = it }
        deliveryConfirmationPhotoUrl?.let { data["deliveryConfirmationPhotoUrl"] = it }
        data["isLocalDelivery"] = isLocalDelivery
        return executeFunction("updateShipmentTracking", data)
    }
    
    suspend fun trackCorreiosOrder(shipmentId: String): Result<Map<String, Any>> {
        val data = mapOf("shipmentId" to shipmentId)
        return executeFunction("trackCorreiosOrder", data)
    }
    
    // Helper function
    private suspend fun executeFunction(
        functionName: String,
        data: Map<String, Any>?
    ): Result<Map<String, Any>> {
        return try {
            Log.d("FirebaseFunctionsService", "Chamando fun√ß√£o: $functionName com dados: $data")
            val callable = functions.getHttpsCallable(functionName)
            val result: Any? = if (data != null) {
                callable.call(data).await()
            } else {
                callable.call().await()
            }
            
            // Access the data property using reflection
            val dataField = result?.javaClass?.getDeclaredField("data")?.apply {
                isAccessible = true
            }
            val resultData = dataField?.get(result) as? Map<String, Any>
            
            Log.d("FirebaseFunctionsService", "Fun√ß√£o $functionName executada com sucesso")
            Result.success(resultData ?: emptyMap())
        } catch (e: FirebaseFunctionsException) {
            val code = e.code
            val message = e.message ?: "Erro desconhecido"
            val details = e.details
            
            Log.e("FirebaseFunctionsService", "Erro na fun√ß√£o $functionName: code=$code, message=$message, details=$details", e)
            
            // Criar mensagem de erro mais clara
            val errorMessage = when (code) {
                FirebaseFunctionsException.Code.PERMISSION_DENIED -> {
                    "Permiss√£o negada: $message"
                }
                FirebaseFunctionsException.Code.UNAUTHENTICATED -> {
                    "N√£o autenticado: Fa√ßa login novamente"
                }
                FirebaseFunctionsException.Code.INVALID_ARGUMENT -> {
                    "Dados inv√°lidos: $message"
                }
                FirebaseFunctionsException.Code.NOT_FOUND -> {
                    "Recurso n√£o encontrado: $message"
                }
                FirebaseFunctionsException.Code.FAILED_PRECONDITION -> {
                    "Pr√©-condi√ß√£o falhou: $message"
                }
                else -> {
                    "Erro ao executar $functionName: $message"
                }
            }
            
            Result.failure(Exception(errorMessage, e))
        } catch (e: Exception) {
            Log.e("FirebaseFunctionsService", "Erro inesperado na fun√ß√£o $functionName: ${e.message}", e)
            Result.failure(e)
        }
    }
}






```

# Data Layer - firestore


## [FRONTEND]: data/firestore/models/AccountChangeRequest.kt

```kotlin
package com.taskgoapp.taskgo.data.firestore.models

import java.util.Date

data class AccountChangeRequest(
    val id: String = "",
    val userId: String = "",
    val currentAccountType: String = "", // "PRESTADOR", "VENDEDOR", "CLIENTE"
    val requestedAccountType: String = "", // "PRESTADOR", "VENDEDOR", "CLIENTE"
    val status: String = "PENDING", // PENDING, APPROVED, PROCESSED, REJECTED
    val requestedAt: Date = Date(),
    val scheduledProcessDate: Date? = null, // Data agendada para processamento (1 dia √∫til)
    val processedAt: Date? = null,
    val processedBy: String? = null, // ID do admin ou sistema que processou
    val rejectionReason: String? = null,
    val createdAt: Date = Date(),
    val updatedAt: Date = Date()
)


```

## [FRONTEND]: data/firestore/models/BankAccount.kt

```kotlin
package com.taskgoapp.taskgo.data.firestore.models

import java.util.Date

/**
 * Conta banc√°ria do vendedor para receber pagamentos
 */
data class BankAccount(
    val id: String = "",
    val userId: String = "", // ID do vendedor
    val bankName: String = "", // Nome do banco
    val bankCode: String = "", // C√≥digo do banco (ex: 001 para Banco do Brasil)
    val agency: String = "", // Ag√™ncia
    val account: String = "", // Conta
    val accountType: String = "", // "CHECKING" ou "SAVINGS"
    val accountHolderName: String = "", // Nome do titular
    val accountHolderDocument: String = "", // CPF ou CNPJ do titular
    val accountHolderDocumentType: String = "", // "CPF" ou "CNPJ"
    val stripeAccountId: String? = null, // ID da conta Stripe Connect (se configurada)
    val isDefault: Boolean = false, // Conta padr√£o para recebimentos
    val isVerified: Boolean = false, // Conta verificada pelo Stripe
    val createdAt: Date? = null,
    val updatedAt: Date? = null
)


```

## [FRONTEND]: data/firestore/models/NotificationFirestore.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.data.firestore.models

import java.util.Date

data class NotificationFirestore(
    val id: String = "",
    val userId: String = "",
    val orderId: String? = null,
    val type: String = "", // order_created, order_accepted, order_completed, payment_received, review_received, system_alert
    val title: String = "",
    val message: String = "",
    val data: Map<String, Any>? = null,
    val read: Boolean = false,
    val readAt: Date? = null,
    val createdAt: Date? = null
)






```

## [FRONTEND]: data/firestore/models/OrderFirestore.kt

```kotlin
package com.taskgoapp.taskgo.data.firestore.models

import java.util.Date

data class OrderFirestore(
    val id: String = "",
    val clientId: String = "",
    val providerId: String? = null,
    val serviceId: String = "",
    val category: String? = null, // Categoria do servi√ßo (ex: "Montagem", "Jardinagem")
    val details: String = "",
    val location: String = "",
    val latitude: Double? = null, // Latitude da localiza√ß√£o da ordem
    val longitude: Double? = null, // Longitude da localiza√ß√£o da ordem
    val budget: Double = 0.0,
    val status: String = "pending", // pending, proposed, accepted, payment_pending, paid, in_progress, completed, cancelled, disputed
    val proposalDetails: ProposalDetails? = null,
    val proposedAt: Date? = null,
    val acceptedAt: Date? = null,
    val disputeReason: String? = null,
    val disputedAt: Date? = null,
    val deleted: Boolean = false,
    val deletedAt: Date? = null,
    val dueDate: String? = null,
    val createdAt: Date? = null,
    val updatedAt: Date? = null,
    // Campos para rastreamento de aceita√ß√£o m√∫tua
    val acceptedByProvider: Boolean = false,
    val acceptedByClient: Boolean = false,
    // Campos para cancelamento
    val cancelledReason: String? = null,
    val cancelledRefundAmount: Double? = null,
    // Campos para conclus√£o
    val completedDescription: String? = null,
    val completedTime: String? = null,
    val completedMediaUrls: List<String>? = null
)

data class ProposalDetails(
    val price: Double = 0.0,
    val description: String = "",
    val estimatedCompletionDate: String? = null,
    val notes: String? = null
)






```

## [FRONTEND]: data/firestore/models/PaymentFirestore.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.data.firestore.models

import java.util.Date

data class PaymentFirestore(
    val id: String = "",
    val orderId: String = "",
    val clientId: String = "",
    val providerId: String = "",
    val amount: Double = 0.0,
    val applicationFee: Double = 0.0,
    val currency: String = "usd",
    val stripePaymentIntentId: String = "",
    val status: String = "pending", // pending, processing, succeeded, failed, refunded
    val paidAt: Date? = null,
    val failedAt: Date? = null,
    val createdAt: Date? = null,
    val updatedAt: Date? = null
)






```

## [FRONTEND]: data/firestore/models/PostFirestore.kt

```kotlin
package com.taskgoapp.taskgo.data.firestore.models

import java.util.Date

/**
 * Modelo de Post no Firestore
 */
data class PostFirestore(
    val id: String = "",
    val userId: String = "",
    val userName: String = "",
    val userAvatarUrl: String? = null,
    val text: String = "",
    val mediaUrls: List<String> = emptyList(),
    val mediaTypes: List<String> = emptyList(), // "image" ou "video"
    val location: PostLocation? = null,
    val createdAt: Date? = null,
    val updatedAt: Date? = null,
    val likesCount: Int = 0,
    val commentsCount: Int = 0,
    val likedBy: List<String> = emptyList(), // Lista de userIds que curtiram
    val tags: List<String>? = null // Hashtags opcionais
)

/**
 * Localiza√ß√£o do post (cidade, estado e coordenadas)
 */
data class PostLocation(
    val city: String = "",
    val state: String = "",
    val latitude: Double = 0.0,
    val longitude: Double = 0.0
)

```

## [FRONTEND]: data/firestore/models/ProductFirestore.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.data.firestore.models

import java.util.Date

data class ProductFirestore(
    val id: String = "",
    val title: String = "",
    val price: Double = 0.0,
    val description: String? = null,
    val sellerId: String = "",
    val sellerName: String? = null,
    val imageUrls: List<String> = emptyList(),
    val category: String? = null,
    val tags: List<String> = emptyList(),
    val active: Boolean = true,
    val status: String = "active", // Status do produto: "active" ou "inactive"
    val featured: Boolean = false, // Produto em destaque/promocional
    val discountPercentage: Double? = null, // Percentual de desconto para destaque/promo√ß√µes
    val createdAt: Date? = null,
    val updatedAt: Date? = null,
    val rating: Double? = null,
    val latitude: Double? = null,
    val longitude: Double? = null
)


```

## [FRONTEND]: data/firestore/models/ProductPayment.kt

```kotlin
package com.taskgoapp.taskgo.data.firestore.models

import java.util.Date

/**
 * Pagamento de produto com split de comiss√£o
 */
data class ProductPayment(
    val id: String = "",
    val orderId: String = "", // ID do pedido de compra
    val clientId: String = "", // ID do cliente que comprou
    val sellerId: String = "", // ID do vendedor
    val storeId: String? = null, // ID da loja (se aplic√°vel)
    val totalAmount: Double = 0.0, // Valor total pago pelo cliente
    val sellerAmount: Double = 0.0, // Valor que o vendedor receber√° (98%)
    val platformFee: Double = 0.0, // Comiss√£o da plataforma (2%)
    val currency: String = "BRL",
    val paymentMethod: String = "", // "PIX", "CREDIT_CARD", "DEBIT_CARD"
    val stripePaymentIntentId: String? = null, // ID do PaymentIntent do Stripe
    val stripeTransferId: String? = null, // ID da transfer√™ncia para o vendedor
    val status: String = "PENDING", // PENDING, PROCESSING, SUCCEEDED, FAILED, REFUNDED
    val paidAt: Date? = null,
    val transferredAt: Date? = null, // Quando o valor foi transferido para o vendedor
    val failedAt: Date? = null,
    val failureReason: String? = null,
    val createdAt: Date? = null,
    val updatedAt: Date? = null
)


```

## [FRONTEND]: data/firestore/models/PurchaseOrderFirestore.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.data.firestore.models

import java.util.Date

/**
 * PurchaseOrder para Firestore
 * Representa pedidos de compra de produtos no marketplace
 */
data class PurchaseOrderFirestore(
    val id: String = "",
    val orderNumber: String = "",
    val clientId: String = "",
    val storeId: String? = null, // ID da loja que vendeu o produto
    val createdAt: Date? = null,
    val total: Double = 0.0,
    val subtotal: Double = 0.0,
    val deliveryFee: Double = 0.0,
    val status: String = "", // PENDING_PAYMENT, PAID, PREPARING, SHIPPED, IN_TRANSIT, OUT_FOR_DELIVERY, DELIVERED, CANCELLED
    val items: List<PurchaseOrderItemFirestore> = emptyList(),
    val paymentMethod: String = "", // "Pix" | "Cr√©dito" | "D√©bito"
    val paymentIntentId: String? = null, // Stripe PaymentIntent ID
    val paymentStatus: String? = null, // PENDING, PROCESSING, SUCCEEDED, FAILED
    val trackingCode: String? = null,
    val deliveryAddress: String? = null,
    val deliveryAddressDetails: DeliveryAddressDetails? = null,
    val shippingStatus: String? = null,
    val shippedAt: Date? = null,
    val deliveredAt: Date? = null,
    val estimatedDelivery: Date? = null,
    val updatedAt: Date? = null
)

data class DeliveryAddressDetails(
    val street: String = "",
    val number: String = "",
    val neighborhood: String = "",
    val city: String = "",
    val state: String = "",
    val zipCode: String = "",
    val complement: String? = null,
    val latitude: Double? = null,
    val longitude: Double? = null
)

data class PurchaseOrderItemFirestore(
    val productId: String = "",
    val productName: String? = null,
    val productImage: String? = null,
    val price: Double = 0.0,
    val quantity: Int = 0
)


```

## [FRONTEND]: data/firestore/models/ReviewFirestore.kt

```kotlin
package com.taskgoapp.taskgo.data.firestore.models

import java.util.Date

data class ReviewFirestore(
    val id: String = "",
    val type: String = "", // "PRODUCT", "SERVICE", "PROVIDER"
    val targetId: String = "",
    val reviewerId: String = "",
    val reviewerName: String = "",
    val reviewerAvatarUri: String? = null,
    val rating: Int = 0,
    val comment: String? = null,
    val photoUrls: List<String> = emptyList(),
    val createdAt: Date? = null,
    val updatedAt: Date? = null,
    val orderId: String? = null,
    val helpfulCount: Int = 0,
    val verifiedPurchase: Boolean = false
)


```

## [FRONTEND]: data/firestore/models/ServiceFirestore.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.data.firestore.models

import java.util.Date

data class ServiceFirestore(
    val id: String = "",
    val providerId: String = "",
    val title: String = "",
    val description: String = "",
    val category: String = "",
    val price: Double = 0.0,
    val images: List<String> = emptyList(), // URLs das imagens no Firebase Storage
    val videos: List<String> = emptyList(), // URLs dos v√≠deos MP4 no Firebase Storage
    val tags: List<String> = emptyList(),
    val active: Boolean = true,
    val featured: Boolean = false, // Servi√ßo em destaque
    val rating: Double? = null, // Avalia√ß√£o m√©dia do servi√ßo
    val createdAt: Date? = null,
    val updatedAt: Date? = null,
    val latitude: Double? = null, // Latitude da localiza√ß√£o do servi√ßo
    val longitude: Double? = null // Longitude da localiza√ß√£o do servi√ßo
)






```

## [FRONTEND]: data/firestore/models/Shipment.kt

```kotlin
package com.taskgoapp.taskgo.data.firestore.models

import java.util.Date

/**
 * Informa√ß√µes de envio do pedido
 */
data class Shipment(
    val id: String = "",
    val orderId: String = "", // ID do pedido
    val sellerId: String = "", // ID do vendedor
    val clientId: String = "", // ID do cliente
    val isSameCity: Boolean = false, // Se o pedido √© na mesma cidade
    val shippingMethod: String? = null, // "CORREIOS", "OTHER", "SAME_CITY"
    val trackingCode: String? = null, // C√≥digo de rastreamento (Correios ou outro)
    val trackingUrl: String? = null, // URL de rastreamento (para outras transportadoras)
    val carrierName: String? = null, // Nome da transportadora
    val shippedAt: Date? = null, // Data/hora do envio
    val estimatedDelivery: Date? = null, // Data estimada de entrega
    val deliveredAt: Date? = null, // Data/hora da entrega (para pedidos na mesma cidade)
    val deliveryAddress: DeliveryAddressDetails? = null,
    val status: String = "PENDING", // PENDING, SHIPPED, IN_TRANSIT, OUT_FOR_DELIVERY, DELIVERED
    val createdAt: Date? = null,
    val updatedAt: Date? = null
)

/**
 * Evento de rastreamento do pedido
 */
data class TrackingEvent(
    val id: String = "",
    val orderId: String = "",
    val shipmentId: String? = null,
    val eventType: String = "", // SHIPPED, IN_TRANSIT, OUT_FOR_DELIVERY, DELIVERED, etc.
    val description: String = "",
    val location: String? = null, // Localiza√ß√£o do evento
    val timestamp: Date? = null,
    val done: Boolean = false, // Se o evento j√° foi conclu√≠do
    val source: String = "MANUAL" // MANUAL, CORREIOS_API, OTHER_API
)


```

## [FRONTEND]: data/firestore/models/StoryFirestore.kt

```kotlin
package com.taskgoapp.taskgo.data.firestore.models

import com.google.firebase.Timestamp
import java.util.Date

/**
 * Modelo Firestore para Story
 * Stories s√£o armazenadas em: stories/{storyId}
 */
data class StoryFirestore(
    val id: String = "",
    val userId: String = "",
    val userName: String = "",
    val userAvatarUrl: String? = null,
    val mediaUrl: String = "",
    val mediaType: String = "", // "image" ou "video"
    val thumbnailUrl: String? = null,
    val caption: String? = null,
    val createdAt: Timestamp? = null,
    val expiresAt: Timestamp? = null, // Data de expira√ß√£o (criado + 24 horas)
    val viewsCount: Int = 0,
    val location: StoryLocationFirestore? = null
)

/**
 * Localiza√ß√£o da Story no Firestore
 */
data class StoryLocationFirestore(
    val city: String = "",
    val state: String = "",
    val latitude: Double = 0.0,
    val longitude: Double = 0.0
)


```

## [FRONTEND]: data/firestore/models/TrackingEventFirestore.kt

```kotlin
package com.taskgoapp.taskgo.data.firestore.models

import java.util.Date

/**
 * TrackingEvent para Firestore
 * Representa eventos de rastreamento de pedidos
 */
data class TrackingEventFirestore(
    val id: String = "",
    val orderId: String = "",
    val type: String = "", // PENDING_PAYMENT, PAID, PREPARING, SHIPPED, IN_TRANSIT, OUT_FOR_DELIVERY, DELIVERED
    val description: String = "",
    val location: TrackingLocation? = null,
    val timestamp: Date? = null,
    val done: Boolean = false
)

data class TrackingLocation(
    val latitude: Double = 0.0,
    val longitude: Double = 0.0,
    val address: String? = null
)


```

## [FRONTEND]: data/firestore/models/UserFirestore.kt

```kotlin
package com.taskgoapp.taskgo.data.firestore.models

import com.taskgoapp.taskgo.core.model.Address
import java.util.Date

data class UserFirestore(
    val uid: String = "",
    val email: String = "",
    val displayName: String? = null,
    val photoURL: String? = null,
    val phone: String? = null,
    val role: String = "client", // client, partner, admin (legacy: provider, seller - devem ser migrados)
    val pendingAccountType: Boolean = false, // Flag para indicar que o app precisa mostrar dialog de sele√ß√£o de tipo de conta
    val profileComplete: Boolean = false,
    val verified: Boolean = false,
    
    // Identity Verification Fields
    val cpf: String? = null,
    val rg: String? = null,
    val cnpj: String? = null,
    val birthDate: Date? = null,
    val documentFront: String? = null, // URL da foto do documento (frente)
    val documentBack: String? = null, // URL da foto do documento (verso)
    val selfie: String? = null, // URL da selfie para verifica√ß√£o facial
    val address: Address? = null,
    val addressProof: String? = null, // URL do comprovante de endere√ßo
    val verifiedAt: Date? = null,
    val verifiedBy: String? = null,
    
    // Biometric & 2FA
    val biometricEnabled: Boolean = false,
    val twoFactorEnabled: Boolean = false,
    val twoFactorMethod: String? = null, // "sms", "email", "authenticator"
    
    // Payment Fields
    val stripeAccountId: String? = null,
    val stripeChargesEnabled: Boolean = false,
    val stripePayoutsEnabled: Boolean = false,
    val stripeDetailsSubmitted: Boolean = false,
    
    // Document Fields (legacy)
    val documents: List<String>? = null,
    val documentsApproved: Boolean = false,
    val documentsApprovedAt: Date? = null,
    val documentsApprovedBy: String? = null,
    
    // Provider Preferences
    val preferredCategories: List<String>? = null, // Categories the provider prefers to receive orders for
    
    // User Identifier (calculado automaticamente)
    val userIdentifier: String? = null, // ID √∫nico baseado em role, localiza√ß√£o e categorias
    
    // App Preferences
    val notificationSettings: NotificationSettingsFirestore? = null,
    val privacySettings: PrivacySettingsFirestore? = null,
    val language: String? = "pt",
    
    // Rating (calculado a partir de avalia√ß√µes)
    val rating: Double? = null, // M√©dia de avalia√ß√µes recebidas
    
    // Timestamps
    val createdAt: Date? = null,
    val updatedAt: Date? = null
)

data class NotificationSettingsFirestore(
    val push: Boolean = true,
    val promos: Boolean = true,
    val sound: Boolean = true,
    val lockscreen: Boolean = true,
    val email: Boolean = false,
    val sms: Boolean = false
)

data class PrivacySettingsFirestore(
    val locationSharing: Boolean = true,
    val profileVisible: Boolean = true,
    val contactInfoSharing: Boolean = false,
    val analytics: Boolean = true,
    val personalizedAds: Boolean = false,
    val dataCollection: Boolean = true,
    val thirdPartySharing: Boolean = false
)






```

# Data Layer - local


## [FRONTEND]: data/local/converter/Converters.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.data.local.converter

import androidx.room.TypeConverter
import com.taskgoapp.taskgo.core.model.AccountType
import com.taskgoapp.taskgo.core.model.OrderStatus

class Converters {
    
    @TypeConverter
    fun fromAccountType(accountType: AccountType): String {
        return accountType.name
    }

    @TypeConverter
    fun toAccountType(accountType: String): AccountType {
        return AccountType.valueOf(accountType)
    }

    @TypeConverter
    fun fromOrderStatus(status: OrderStatus): String {
        return status.name
    }

    @TypeConverter
    fun toOrderStatus(status: String): OrderStatus {
        return OrderStatus.valueOf(status)
    }
}

```

## [FRONTEND]: data/local/dao/Daos.kt

```kotlin
package com.taskgoapp.taskgo.data.local.dao

import androidx.room.*
import com.taskgoapp.taskgo.data.local.entity.*
import kotlinx.coroutines.flow.Flow

@Dao
interface ProductDao {
    @Query("SELECT * FROM product WHERE active = 1 ORDER BY title")
    fun observeAll(): Flow<List<ProductEntity>>

    @Query("SELECT * FROM product WHERE active = 1 ORDER BY title")
    suspend fun getAll(): List<ProductEntity>

    @Transaction
    @Query("SELECT * FROM product WHERE id = :id")
    suspend fun getById(id: String): ProductEntity?

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun upsert(product: ProductEntity)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun upsertImages(images: List<ProductImageEntity>)

    @Query("SELECT * FROM product_image WHERE productId = :productId")
    suspend fun images(productId: String): List<ProductImageEntity>

    @Query("DELETE FROM product_image WHERE productId = :productId")
    suspend fun deleteImagesByProductId(productId: String)

    @Delete 
    suspend fun delete(product: ProductEntity)
}

@Dao
interface MarketplaceProductDao {
    @Query("SELECT * FROM marketplace_product ORDER BY name")
    fun observeAll(): Flow<List<MarketplaceProductEntity>>

    @Query("SELECT * FROM marketplace_product ORDER BY name")
    suspend fun getAll(): List<MarketplaceProductEntity>

    @Query("SELECT * FROM marketplace_product WHERE id = :id")
    suspend fun getById(id: String): MarketplaceProductEntity?

    @Query("SELECT * FROM marketplace_product WHERE category = :category ORDER BY name")
    suspend fun getByCategory(category: String): List<MarketplaceProductEntity>

    @Query("SELECT * FROM marketplace_product WHERE name LIKE '%' || :query || '%' OR description LIKE '%' || :query || '%' ORDER BY name")
    suspend fun search(query: String): List<MarketplaceProductEntity>

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun upsert(product: MarketplaceProductEntity)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun upsertAll(products: List<MarketplaceProductEntity>)

    @Delete 
    suspend fun delete(product: MarketplaceProductEntity)

    @Query("DELETE FROM marketplace_product")
    suspend fun deleteAll()
}

@Dao
interface ServiceOrderDao {
    @Query("SELECT * FROM service_order ORDER BY date DESC")
    fun observeAll(): Flow<List<ServiceOrderEntity>>

    @Query("SELECT * FROM service_order WHERE id = :id")
    suspend fun getById(id: String): ServiceOrderEntity?

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun upsert(order: ServiceOrderEntity)

    @Delete
    suspend fun delete(order: ServiceOrderEntity)
}

@Dao
interface ProposalDao {
    @Query("SELECT * FROM proposal WHERE orderId = :orderId ORDER BY scheduledDate")
    fun observeByOrderId(orderId: String): Flow<List<ProposalEntity>>

    @Query("SELECT * FROM proposal WHERE id = :id")
    suspend fun getById(id: String): ProposalEntity?

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun upsert(proposal: ProposalEntity)

    @Query("UPDATE proposal SET accepted = :accepted WHERE id = :id")
    suspend fun updateAccepted(id: String, accepted: Boolean)

    @Delete
    suspend fun delete(proposal: ProposalEntity)
}

@Dao
interface CartDao {
    @Query("SELECT * FROM cart_item")
    fun observeAll(): Flow<List<CartItemEntity>>

    @Query("SELECT * FROM cart_item WHERE productId = :productId")
    suspend fun getByProductId(productId: String): CartItemEntity?

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun upsert(item: CartItemEntity)

    @Query("DELETE FROM cart_item WHERE productId = :productId")
    suspend fun deleteByProductId(productId: String)

    @Query("DELETE FROM cart_item")
    suspend fun clearAll()
}

@Dao
interface PurchaseOrderDao {
    @Query("SELECT * FROM purchase_order ORDER BY createdAt DESC")
    fun observeAll(): Flow<List<PurchaseOrderEntity>>

    @Query("SELECT * FROM purchase_order WHERE id = :id")
    suspend fun getById(id: String): PurchaseOrderEntity?

    @Query("SELECT * FROM purchase_order WHERE status = :status ORDER BY createdAt DESC")
    fun observeByStatus(status: String): Flow<List<PurchaseOrderEntity>>

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun upsert(order: PurchaseOrderEntity)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun upsertItems(items: List<PurchaseOrderItemEntity>)

    @Query("SELECT * FROM purchase_order_item WHERE orderId = :orderId")
    suspend fun getItemsByOrderId(orderId: String): List<PurchaseOrderItemEntity>

    @Query("UPDATE purchase_order SET status = :status WHERE id = :id")
    suspend fun updateStatus(id: String, status: String)
}

@Dao
interface TrackingDao {
    @Query("SELECT * FROM tracking_event WHERE orderId = :orderId ORDER BY date")
    fun observeByOrderId(orderId: String): Flow<List<TrackingEventEntity>>

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun upsert(event: TrackingEventEntity)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun upsertAll(events: List<TrackingEventEntity>)

    @Query("UPDATE tracking_event SET done = :done WHERE id = :id")
    suspend fun updateDone(id: String, done: Boolean)
}

@Dao
interface MessageDao {
    @Query("SELECT * FROM message_thread ORDER BY lastTime DESC")
    fun observeThreads(): Flow<List<MessageThreadEntity>>

    @Query("SELECT * FROM message_thread WHERE id = :id")
    suspend fun getThreadById(id: String): MessageThreadEntity?

    @Query("SELECT * FROM chat_message WHERE threadId = :threadId ORDER BY time")
    fun observeMessages(threadId: String): Flow<List<ChatMessageEntity>>

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun upsertThread(thread: MessageThreadEntity)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun upsertMessage(message: ChatMessageEntity)
}

@Dao
interface AddressDao {
    @Query("SELECT * FROM address ORDER BY id")
    fun observeAll(): Flow<List<AddressEntity>>

    @Query("SELECT * FROM address WHERE id = :id")
    suspend fun getById(id: String): AddressEntity?

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun upsert(address: AddressEntity)

    @Delete
    suspend fun delete(address: AddressEntity)
}

@Dao
interface CardDao {
    @Query("SELECT * FROM card ORDER BY id")
    fun observeAll(): Flow<List<CardEntity>>

    @Query("SELECT * FROM card WHERE id = :id")
    suspend fun getById(id: String): CardEntity?

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun upsert(card: CardEntity)

    @Delete
    suspend fun delete(card: CardEntity)
}

@Dao
interface UserProfileDao {
    @Query("SELECT * FROM user_profile WHERE id = :userId LIMIT 1")
    fun observeCurrent(userId: String): Flow<UserProfileEntity?>

    @Query("SELECT * FROM user_profile WHERE id = :userId LIMIT 1")
    suspend fun getCurrent(userId: String): UserProfileEntity?

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun upsert(profile: UserProfileEntity)

    @Query("DELETE FROM user_profile")
    suspend fun clear()
    
    @Query("DELETE FROM user_profile WHERE id != :userId")
    suspend fun clearOtherUsers(userId: String)
}

```

## [FRONTEND]: data/local/dao/SyncQueueDao.kt

```kotlin
package com.taskgoapp.taskgo.data.local.dao

import androidx.room.*
import com.taskgoapp.taskgo.data.local.entity.SyncQueueEntity
import kotlinx.coroutines.flow.Flow

/**
 * DAO para gerenciar fila de sincroniza√ß√£o
 */
@Dao
interface SyncQueueDao {
    
    /**
     * Observa todas as pend√™ncias de sincroniza√ß√£o
     */
    @Query("SELECT * FROM sync_queue WHERE status = 'pending' AND syncAt <= :currentTime ORDER BY syncAt ASC")
    fun observePendingSyncs(currentTime: Long = System.currentTimeMillis()): Flow<List<SyncQueueEntity>>
    
    /**
     * Busca pend√™ncias prontas para sincroniza√ß√£o
     */
    @Query("SELECT * FROM sync_queue WHERE status = 'pending' AND syncAt <= :currentTime ORDER BY syncAt ASC LIMIT :limit")
    suspend fun getPendingSyncs(currentTime: Long = System.currentTimeMillis(), limit: Int = 50): List<SyncQueueEntity>
    
    /**
     * Busca pend√™ncia espec√≠fica por tipo e ID
     */
    @Query("SELECT * FROM sync_queue WHERE syncType = :syncType AND entityId = :entityId AND status = 'pending'")
    suspend fun getPendingSync(syncType: String, entityId: String): SyncQueueEntity?
    
    /**
     * Insere ou atualiza pend√™ncia de sincroniza√ß√£o
     * Se j√° existe uma pend√™ncia para o mesmo tipo e ID, atualiza em vez de criar nova
     */
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun upsert(sync: SyncQueueEntity)
    
    /**
     * Marca sincroniza√ß√£o como em progresso
     */
    @Query("UPDATE sync_queue SET status = 'syncing' WHERE id = :id")
    suspend fun markAsSyncing(id: Long)
    
    /**
     * Marca sincroniza√ß√£o como conclu√≠da
     */
    @Query("UPDATE sync_queue SET status = 'completed' WHERE id = :id")
    suspend fun markAsCompleted(id: Long)
    
    /**
     * Marca sincroniza√ß√£o como falha e incrementa retry count
     */
    @Query("UPDATE sync_queue SET status = 'failed', retryCount = retryCount + 1, errorMessage = :errorMessage WHERE id = :id")
    suspend fun markAsFailed(id: Long, errorMessage: String)
    
    /**
     * Reagenda sincroniza√ß√£o para nova tentativa (ap√≥s 1 minuto)
     */
    @Query("UPDATE sync_queue SET status = 'pending', syncAt = :newSyncAt, retryCount = retryCount + 1 WHERE id = :id")
    suspend fun reschedule(id: Long, newSyncAt: Long = System.currentTimeMillis() + 60_000)
    
    /**
     * Remove sincroniza√ß√£o conclu√≠da ou falha ap√≥s muitas tentativas
     */
    @Query("DELETE FROM sync_queue WHERE status = 'completed' OR (status = 'failed' AND retryCount >= 3)")
    suspend fun cleanupCompletedAndFailed()
    
    /**
     * Remove todas as pend√™ncias de um tipo espec√≠fico
     */
    @Query("DELETE FROM sync_queue WHERE syncType = :syncType AND entityId = :entityId")
    suspend fun removeByTypeAndId(syncType: String, entityId: String)
    
    /**
     * Remove todas as pend√™ncias
     */
    @Query("DELETE FROM sync_queue")
    suspend fun clearAll()
    
    /**
     * Conta pend√™ncias por status
     */
    @Query("SELECT COUNT(*) FROM sync_queue WHERE status = :status")
    suspend fun countByStatus(status: String): Int
}


```

## [FRONTEND]: data/local/datastore/FilterPreferencesManager.kt

```kotlin
package com.taskgoapp.taskgo.data.local.datastore

import android.content.Context
import androidx.datastore.core.DataStore
import androidx.datastore.preferences.core.*
import androidx.datastore.preferences.preferencesDataStore
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import com.taskgoapp.taskgo.core.design.FilterState
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.mapNotNull
import javax.inject.Inject
import javax.inject.Singleton

private val Context.filterPreferencesDataStore: DataStore<Preferences> by preferencesDataStore(name = "taskgo_filter_preferences")

object FilterPrefsKeys {
    val PRODUCT_FILTERS = stringPreferencesKey("product_filters_json")
    val SERVICE_FILTERS = stringPreferencesKey("service_filters_json")
}

@Singleton
class FilterPreferencesManager @Inject constructor(
    private val context: Context
) {
    private val dataStore = context.filterPreferencesDataStore
    private val gson = Gson()
    
    /**
     * Salva filtros preferidos para produtos
     */
    suspend fun saveProductFilters(filterState: FilterState) {
        dataStore.edit { preferences ->
            val json = gson.toJson(filterState)
            preferences[FilterPrefsKeys.PRODUCT_FILTERS] = json
        }
    }
    
    /**
     * Carrega filtros preferidos para produtos
     */
    fun getProductFilters(): Flow<FilterState?> = dataStore.data.map { preferences ->
        val json = preferences[FilterPrefsKeys.PRODUCT_FILTERS]
        if (json != null) {
            try {
                gson.fromJson(json, FilterState::class.java)
            } catch (e: Exception) {
                null
            }
        } else {
            null
        }
    }
    
    /**
     * Salva filtros preferidos para servi√ßos
     */
    suspend fun saveServiceFilters(filterState: FilterState) {
        dataStore.edit { preferences ->
            val json = gson.toJson(filterState)
            preferences[FilterPrefsKeys.SERVICE_FILTERS] = json
        }
    }
    
    /**
     * Carrega filtros preferidos para servi√ßos
     */
    fun getServiceFilters(): Flow<FilterState?> = dataStore.data.map { preferences ->
        val json = preferences[FilterPrefsKeys.SERVICE_FILTERS]
        if (json != null) {
            try {
                gson.fromJson(json, FilterState::class.java)
            } catch (e: Exception) {
                null
            }
        } else {
            null
        }
    }
    
    /**
     * Limpa filtros salvos
     */
    suspend fun clearProductFilters() {
        dataStore.edit { preferences ->
            preferences.remove(FilterPrefsKeys.PRODUCT_FILTERS)
        }
    }
    
    suspend fun clearServiceFilters() {
        dataStore.edit { preferences ->
            preferences.remove(FilterPrefsKeys.SERVICE_FILTERS)
        }
    }
}


```

## [FRONTEND]: data/local/datastore/PreferencesManager.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.data.local.datastore

import android.content.Context
import androidx.datastore.core.DataStore
import androidx.datastore.preferences.core.*
import androidx.datastore.preferences.preferencesDataStore
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.map
import javax.inject.Inject
import javax.inject.Singleton

private val Context.dataStore: DataStore<Preferences> by preferencesDataStore(name = "taskgo_preferences")

object PrefsKeys {
    val PROMOS = booleanPreferencesKey("notif_promotions")
    val SOUND = booleanPreferencesKey("notif_sound")
    val PUSH = booleanPreferencesKey("notif_push")
    val LOCKSCREEN = booleanPreferencesKey("notif_lockscreen")
    val EMAIL_NOTIFICATIONS = booleanPreferencesKey("notif_email")
    val SMS_NOTIFICATIONS = booleanPreferencesKey("notif_sms")
    val LANGUAGE = stringPreferencesKey("language") // "pt","en","es","fr","it","de"
    val THEME = stringPreferencesKey("theme") // "light","dark","system"
    val CATEGORIES = stringPreferencesKey("categories_json")
    
    // Privacy
    val PRIVACY_LOCATION = booleanPreferencesKey("privacy_location")
    val PRIVACY_PROFILE_VISIBLE = booleanPreferencesKey("privacy_profile_visible")
    val PRIVACY_CONTACT_INFO = booleanPreferencesKey("privacy_contact_info")
    val PRIVACY_ANALYTICS = booleanPreferencesKey("privacy_analytics")
    val PRIVACY_PERSONALIZED_ADS = booleanPreferencesKey("privacy_personalized_ads")
    val PRIVACY_DATA_COLLECTION = booleanPreferencesKey("privacy_data_collection")
    val PRIVACY_THIRD_PARTY = booleanPreferencesKey("privacy_third_party")
    
    // Biometric & 2FA
    val BIOMETRIC_ENABLED = booleanPreferencesKey("biometric_enabled")
    val TWO_FACTOR_ENABLED = booleanPreferencesKey("two_factor_enabled")
    val TWO_FACTOR_METHOD = stringPreferencesKey("two_factor_method") // "sms", "email", "authenticator"
    val SAVED_EMAIL_FOR_BIOMETRIC = stringPreferencesKey("saved_email_biometric")
    
    // Permissions
    val PERMISSIONS_REQUESTED = booleanPreferencesKey("permissions_requested")
    
    // Initial sync tracking (por usu√°rio)
    // Usa stringPreferencesKey para armazenar JSON com userId -> timestamp
    val INITIAL_SYNC_COMPLETED = stringPreferencesKey("initial_sync_completed")
}

@Singleton
class PreferencesManager @Inject constructor(
    private val context: Context
) {
    private val dataStore = context.dataStore

    // Notification preferences
    val promosEnabled: Flow<Boolean> = dataStore.data.map { preferences ->
        preferences[PrefsKeys.PROMOS] ?: true
    }

    val soundEnabled: Flow<Boolean> = dataStore.data.map { preferences ->
        preferences[PrefsKeys.SOUND] ?: true
    }

    val pushEnabled: Flow<Boolean> = dataStore.data.map { preferences ->
        preferences[PrefsKeys.PUSH] ?: true
    }

    val lockscreenEnabled: Flow<Boolean> = dataStore.data.map { preferences ->
        preferences[PrefsKeys.LOCKSCREEN] ?: true
    }
    
    val emailNotificationsEnabled: Flow<Boolean> = dataStore.data.map { preferences ->
        preferences[PrefsKeys.EMAIL_NOTIFICATIONS] ?: false
    }
    
    val smsNotificationsEnabled: Flow<Boolean> = dataStore.data.map { preferences ->
        preferences[PrefsKeys.SMS_NOTIFICATIONS] ?: false
    }

    // Language preference
    val language: Flow<String> = dataStore.data.map { preferences ->
        preferences[PrefsKeys.LANGUAGE] ?: "pt"
    }

    // Theme preference
    val theme: Flow<String> = dataStore.data.map { preferences ->
        preferences[PrefsKeys.THEME] ?: "system"
    }

    // Categories preference
    val categories: Flow<String> = dataStore.data.map { preferences ->
        preferences[PrefsKeys.CATEGORIES] ?: "[]"
    }
    
    // Privacy preferences
    val privacyLocationSharing: Flow<Boolean> = dataStore.data.map { preferences ->
        preferences[PrefsKeys.PRIVACY_LOCATION] ?: true
    }
    
    val privacyProfileVisible: Flow<Boolean> = dataStore.data.map { preferences ->
        preferences[PrefsKeys.PRIVACY_PROFILE_VISIBLE] ?: true
    }
    
    val privacyContactInfo: Flow<Boolean> = dataStore.data.map { preferences ->
        preferences[PrefsKeys.PRIVACY_CONTACT_INFO] ?: false
    }
    
    val privacyAnalytics: Flow<Boolean> = dataStore.data.map { preferences ->
        preferences[PrefsKeys.PRIVACY_ANALYTICS] ?: true
    }
    
    val privacyPersonalizedAds: Flow<Boolean> = dataStore.data.map { preferences ->
        preferences[PrefsKeys.PRIVACY_PERSONALIZED_ADS] ?: false
    }
    
    val privacyDataCollection: Flow<Boolean> = dataStore.data.map { preferences ->
        preferences[PrefsKeys.PRIVACY_DATA_COLLECTION] ?: true
    }
    
    val privacyThirdPartySharing: Flow<Boolean> = dataStore.data.map { preferences ->
        preferences[PrefsKeys.PRIVACY_THIRD_PARTY] ?: false
    }

    suspend fun updatePromosEnabled(enabled: Boolean) {
        dataStore.edit { preferences ->
            preferences[PrefsKeys.PROMOS] = enabled
        }
    }

    suspend fun updateSoundEnabled(enabled: Boolean) {
        dataStore.edit { preferences ->
            preferences[PrefsKeys.SOUND] = enabled
        }
    }

    suspend fun updatePushEnabled(enabled: Boolean) {
        dataStore.edit { preferences ->
            preferences[PrefsKeys.PUSH] = enabled
        }
    }

    suspend fun updateLockscreenEnabled(enabled: Boolean) {
        dataStore.edit { preferences ->
            preferences[PrefsKeys.LOCKSCREEN] = enabled
        }
    }
    
    suspend fun updateEmailNotificationsEnabled(enabled: Boolean) {
        dataStore.edit { preferences ->
            preferences[PrefsKeys.EMAIL_NOTIFICATIONS] = enabled
        }
    }
    
    suspend fun updateSmsNotificationsEnabled(enabled: Boolean) {
        dataStore.edit { preferences ->
            preferences[PrefsKeys.SMS_NOTIFICATIONS] = enabled
        }
    }

    suspend fun updateLanguage(language: String) {
        dataStore.edit { preferences ->
            preferences[PrefsKeys.LANGUAGE] = language
        }
    }

    // Biometric & 2FA preferences
    val biometricEnabled: Flow<Boolean> = dataStore.data.map { preferences ->
        preferences[PrefsKeys.BIOMETRIC_ENABLED] ?: false
    }

    val twoFactorEnabled: Flow<Boolean> = dataStore.data.map { preferences ->
        preferences[PrefsKeys.TWO_FACTOR_ENABLED] ?: false
    }

    val twoFactorMethod: Flow<String?> = dataStore.data.map { preferences ->
        preferences[PrefsKeys.TWO_FACTOR_METHOD]
    }

    suspend fun updateBiometricEnabled(enabled: Boolean) {
        dataStore.edit { preferences ->
            preferences[PrefsKeys.BIOMETRIC_ENABLED] = enabled
        }
    }

    suspend fun updateTwoFactorEnabled(enabled: Boolean) {
        dataStore.edit { preferences ->
            preferences[PrefsKeys.TWO_FACTOR_ENABLED] = enabled
        }
    }

    suspend fun updateTwoFactorMethod(method: String?) {
        dataStore.edit { preferences ->
            if (method != null) {
                preferences[PrefsKeys.TWO_FACTOR_METHOD] = method
            } else {
                preferences.remove(PrefsKeys.TWO_FACTOR_METHOD)
            }
        }
    }

    suspend fun saveEmailForBiometric(email: String) {
        dataStore.edit { preferences ->
            preferences[PrefsKeys.SAVED_EMAIL_FOR_BIOMETRIC] = email
        }
    }

    suspend fun getEmailForBiometric(): String? {
        return dataStore.data.map { preferences ->
            preferences[PrefsKeys.SAVED_EMAIL_FOR_BIOMETRIC]
        }.first()
    }

    suspend fun updateTheme(theme: String) {
        dataStore.edit { preferences ->
            preferences[PrefsKeys.THEME] = theme
        }
    }

    suspend fun updateCategories(categories: String) {
        dataStore.edit { preferences ->
            preferences[PrefsKeys.CATEGORIES] = categories
        }
    }
    
    suspend fun updatePrivacyLocationSharing(enabled: Boolean) {
        dataStore.edit { preferences ->
            preferences[PrefsKeys.PRIVACY_LOCATION] = enabled
        }
    }
    
    suspend fun updatePrivacyProfileVisible(enabled: Boolean) {
        dataStore.edit { preferences ->
            preferences[PrefsKeys.PRIVACY_PROFILE_VISIBLE] = enabled
        }
    }
    
    suspend fun updatePrivacyContactInfo(enabled: Boolean) {
        dataStore.edit { preferences ->
            preferences[PrefsKeys.PRIVACY_CONTACT_INFO] = enabled
        }
    }
    
    suspend fun updatePrivacyAnalytics(enabled: Boolean) {
        dataStore.edit { preferences ->
            preferences[PrefsKeys.PRIVACY_ANALYTICS] = enabled
        }
    }
    
    suspend fun updatePrivacyPersonalizedAds(enabled: Boolean) {
        dataStore.edit { preferences ->
            preferences[PrefsKeys.PRIVACY_PERSONALIZED_ADS] = enabled
        }
    }
    
    suspend fun updatePrivacyDataCollection(enabled: Boolean) {
        dataStore.edit { preferences ->
            preferences[PrefsKeys.PRIVACY_DATA_COLLECTION] = enabled
        }
    }
    
    suspend fun updatePrivacyThirdPartySharing(enabled: Boolean) {
        dataStore.edit { preferences ->
            preferences[PrefsKeys.PRIVACY_THIRD_PARTY] = enabled
        }
    }
    
    // Permissions tracking
    val permissionsRequested: Flow<Boolean> = dataStore.data.map { preferences ->
        preferences[PrefsKeys.PERMISSIONS_REQUESTED] ?: false
    }
    
    suspend fun setPermissionsRequested(requested: Boolean) {
        dataStore.edit { preferences ->
            preferences[PrefsKeys.PERMISSIONS_REQUESTED] = requested
        }
    }
    
    // Initial sync tracking
    suspend fun isInitialSyncCompleted(userId: String): Boolean {
        val syncData = dataStore.data.first()[PrefsKeys.INITIAL_SYNC_COMPLETED] ?: "{}"
        return try {
            val json = org.json.JSONObject(syncData)
            json.has(userId) && json.getLong(userId) > 0
        } catch (e: Exception) {
            false
        }
    }
    
    suspend fun setInitialSyncCompleted(userId: String) {
        dataStore.edit { preferences ->
            val syncData = preferences[PrefsKeys.INITIAL_SYNC_COMPLETED] ?: "{}"
            try {
                val json = org.json.JSONObject(syncData)
                json.put(userId, System.currentTimeMillis())
                preferences[PrefsKeys.INITIAL_SYNC_COMPLETED] = json.toString()
            } catch (e: Exception) {
                // Se houver erro, criar novo JSON
                val json = org.json.JSONObject()
                json.put(userId, System.currentTimeMillis())
                preferences[PrefsKeys.INITIAL_SYNC_COMPLETED] = json.toString()
            }
        }
    }
    
    suspend fun clearInitialSyncForUser(userId: String) {
        dataStore.edit { preferences ->
            val syncData = preferences[PrefsKeys.INITIAL_SYNC_COMPLETED] ?: "{}"
            try {
                val json = org.json.JSONObject(syncData)
                json.remove(userId)
                preferences[PrefsKeys.INITIAL_SYNC_COMPLETED] = json.toString()
            } catch (e: Exception) {
                // Ignorar erro
            }
        }
    }
}

```

## [FRONTEND]: data/local/entity/Entities.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.data.local.entity

import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity(tableName = "user_profile")
data class UserProfileEntity(
    @PrimaryKey val id: String,
    val name: String,
    val email: String,
    val phone: String?,
    val city: String?,
    val state: String? = null, // Estado (UF) - adicionado para suporte a arquitetura regional
    val profession: String?,
    val accountType: String,
    val rating: Double?,
    val avatarUri: String?,
    val profileImages: String? // JSON string com lista de URIs
)

@Entity(tableName = "product")
data class ProductEntity(
    @PrimaryKey val id: String,
    val title: String,
    val price: Double,
    val description: String?,
    val sellerId: String? = null,
    val sellerName: String?,
    val rating: Double? = null, // Avalia√ß√£o m√©dia do produto
    val latitude: Double? = null, // Latitude da localiza√ß√£o do produto
    val longitude: Double? = null, // Longitude da localiza√ß√£o do produto
    val featured: Boolean = false, // Produto em destaque
    val discountPercentage: Double? = null, // Percentual de desconto para destaque/promo√ß√µes
    val active: Boolean = true // Controle de soft-delete
)

@Entity(tableName = "product_image")
data class ProductImageEntity(
    @PrimaryKey val id: String = java.util.UUID.randomUUID().toString(),
    val productId: String,
    val uri: String
)

@Entity(tableName = "marketplace_product")
data class MarketplaceProductEntity(
    @PrimaryKey val id: String,
    val name: String,
    val description: String,
    val price: Double,
    val sellerId: String,
    val sellerName: String,
    val sellerEmail: String,
    val sellerPhone: String,
    val sellerCity: String,
    val sellerRating: Double,
    val sellerReviewCount: Int,
    val category: String,
    val imageUrl: String? = null,
    val inStock: Boolean = true
)

@Entity(tableName = "service_order")
data class ServiceOrderEntity(
    @PrimaryKey val id: String,
    val category: String,
    val description: String,
    val date: Long,
    val addressLine: String,
    val city: String,
    val state: String
)

@Entity(tableName = "proposal")
data class ProposalEntity(
    @PrimaryKey val id: String,
    val orderId: String,
    val providerName: String,
    val rating: Double,
    val amount: Double,
    val message: String,
    val scheduledDate: Long,
    val address: String,
    val accepted: Boolean = false
)

@Entity(tableName = "cart_item", primaryKeys = ["productId"])
data class CartItemEntity(
    val productId: String,
    val qty: Int
)

@Entity(tableName = "purchase_order")
data class PurchaseOrderEntity(
    @PrimaryKey val id: String,
    val orderNumber: String?,
    val createdAt: Long,
    val total: Double,
    val subtotal: Double?,
    val deliveryFee: Double?,
    val status: String,
    val paymentMethod: String,
    val trackingCode: String?,
    val deliveryAddress: String?
)

@Entity(tableName = "purchase_order_item", primaryKeys = ["orderId","productId"])
data class PurchaseOrderItemEntity(
    val orderId: String,
    val productId: String,
    val productName: String?,
    val productImage: String?,
    val price: Double,
    val qty: Int,
    val deliveryDate: String?
)

@Entity(tableName = "tracking_event")
data class TrackingEventEntity(
    @PrimaryKey val id: String,
    val orderId: String,
    val label: String,
    val date: Long,
    val done: Boolean
)

@Entity(tableName = "message_thread")
data class MessageThreadEntity(
    @PrimaryKey val id: String,
    val title: String,
    val lastMessage: String,
    val lastTime: Long
)

@Entity(tableName = "chat_message")
data class ChatMessageEntity(
    @PrimaryKey val id: String,
    val threadId: String,
    val senderMe: Boolean,
    val text: String,
    val time: Long
)

@Entity(tableName = "address")
data class AddressEntity(
    @PrimaryKey val id: String,
    val name: String,
    val phone: String,
    val cep: String,
    val street: String,
    val district: String,
    val city: String,
    val state: String
)

@Entity(tableName = "card")
data class CardEntity(
    @PrimaryKey val id: String,
    val holder: String,
    val numberMasked: String,
    val brand: String,
    val expMonth: Int,
    val expYear: Int,
    val type: String
)

```

## [FRONTEND]: data/local/entity/SyncQueueEntity.kt

```kotlin
package com.taskgoapp.taskgo.data.local.entity

import androidx.room.Entity
import androidx.room.PrimaryKey
import androidx.room.Index

/**
 * Entidade para gerenciar fila de sincroniza√ß√£o com Firebase
 * Armazena opera√ß√µes pendentes que ser√£o sincronizadas ap√≥s 1 minuto
 */
@Entity(
    tableName = "sync_queue",
    indices = [Index(value = ["syncType", "entityId"], unique = true)]
)
data class SyncQueueEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,
    
    /**
     * Tipo de entidade a ser sincronizada
     * Ex: "product", "service", "user_profile", "settings", etc.
     */
    val syncType: String,
    
    /**
     * ID da entidade a ser sincronizada
     */
    val entityId: String,
    
    /**
     * Tipo de opera√ß√£o: "create", "update", "delete"
     */
    val operation: String,
    
    /**
     * Dados da entidade em formato JSON para sincroniza√ß√£o
     */
    val data: String,
    
    /**
     * Timestamp de quando a opera√ß√£o foi criada
     */
    val createdAt: Long = System.currentTimeMillis(),
    
    /**
     * Timestamp de quando deve ser sincronizada (createdAt + 1 minuto)
     */
    val syncAt: Long = System.currentTimeMillis() + 60_000,
    
    /**
     * N√∫mero de tentativas de sincroniza√ß√£o
     */
    val retryCount: Int = 0,
    
    /**
     * Status da sincroniza√ß√£o: "pending", "syncing", "completed", "failed"
     */
    val status: String = "pending",
    
    /**
     * Mensagem de erro (se houver)
     */
    val errorMessage: String? = null
)


```

## [FRONTEND]: data/local/TaskGoDatabase.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.data.local

import androidx.room.Database
import androidx.room.Room
import androidx.room.RoomDatabase
import androidx.room.TypeConverters
import androidx.room.migration.Migration
import androidx.sqlite.db.SupportSQLiteDatabase
import android.content.Context
import com.taskgoapp.taskgo.data.local.dao.*
import com.taskgoapp.taskgo.data.local.entity.*
import com.taskgoapp.taskgo.data.local.converter.Converters

@Database(
    entities = [
        UserProfileEntity::class,
        ProductEntity::class,
        ProductImageEntity::class,
        MarketplaceProductEntity::class,
        ServiceOrderEntity::class,
        ProposalEntity::class,
        CartItemEntity::class,
        PurchaseOrderEntity::class,
        PurchaseOrderItemEntity::class,
        TrackingEventEntity::class,
        MessageThreadEntity::class,
        ChatMessageEntity::class,
        AddressEntity::class,
        CardEntity::class,
        SyncQueueEntity::class
    ],
    version = 8,
    exportSchema = false
)
@TypeConverters(Converters::class)
abstract class TaskGoDatabase : RoomDatabase() {
    
    abstract fun userProfileDao(): UserProfileDao
    abstract fun productDao(): ProductDao
    abstract fun marketplaceProductDao(): MarketplaceProductDao
    abstract fun serviceOrderDao(): ServiceOrderDao
    abstract fun proposalDao(): ProposalDao
    abstract fun cartDao(): CartDao
    abstract fun purchaseOrderDao(): PurchaseOrderDao
    abstract fun trackingDao(): TrackingDao
    abstract fun messageDao(): MessageDao
    abstract fun addressDao(): AddressDao
    abstract fun cardDao(): CardDao
    abstract fun syncQueueDao(): SyncQueueDao

    companion object {
        @Volatile
        private var INSTANCE: TaskGoDatabase? = null

        // Migration de vers√£o 7 para 8: adiciona coluna 'state' √† tabela user_profile
        private val MIGRATION_7_8 = object : Migration(7, 8) {
            override fun migrate(database: SupportSQLiteDatabase) {
                database.execSQL("ALTER TABLE user_profile ADD COLUMN state TEXT")
            }
        }

        fun getDatabase(context: Context): TaskGoDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    TaskGoDatabase::class.java,
                    "taskgo_database"
                )
                .addMigrations(MIGRATION_7_8)
                .fallbackToDestructiveMigration()
                .build()
                INSTANCE = instance
                instance
            }
        }
    }
}

```

# Data Layer - mapper


## [FRONTEND]: data/mapper/AddressMapper.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.data.mapper

import com.taskgoapp.taskgo.data.local.entity.AddressEntity
import com.taskgoapp.taskgo.core.model.Address

object AddressMapper {
    
    fun AddressEntity.toModel(): Address {
        return Address(
            id = this.id,
            name = this.name,
            phone = this.phone,
            cep = this.cep,
            street = this.street,
            district = this.district,
            city = this.city,
            state = this.state
        )
    }
    
    fun Address.toEntity(): AddressEntity {
        return AddressEntity(
            id = this.id,
            name = this.name,
            phone = this.phone,
            cep = this.cep,
            street = this.street,
            district = this.district,
            city = this.city,
            state = this.state
        )
    }
}
```

## [FRONTEND]: data/mapper/CardMapper.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.data.mapper

import com.taskgoapp.taskgo.data.local.entity.CardEntity
import com.taskgoapp.taskgo.core.model.Card

object CardMapper {
    
    fun CardEntity.toModel(): Card {
        return Card(
            id = this.id,
            holder = this.holder,
            numberMasked = this.numberMasked,
            brand = this.brand,
            expMonth = this.expMonth,
            expYear = this.expYear,
            type = this.type
        )
    }
    
    fun Card.toEntity(): CardEntity {
        return CardEntity(
            id = this.id,
            holder = this.holder,
            numberMasked = this.numberMasked,
            brand = this.brand,
            expMonth = this.expMonth,
            expYear = this.expYear,
            type = this.type
        )
    }
}



```

## [FRONTEND]: data/mapper/CartMapper.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.data.mapper

import com.taskgoapp.taskgo.data.local.entity.CartItemEntity
import com.taskgoapp.taskgo.core.model.CartItem

object CartMapper {
    
    fun CartItemEntity.toModel(): CartItem {
        return CartItem(
            productId = this.productId,
            qty = this.qty
        )
    }
    
    fun CartItem.toEntity(): CartItemEntity {
        return CartItemEntity(
            productId = this.productId,
            qty = this.qty
        )
    }
}
```

## [FRONTEND]: data/mapper/ChatMapper.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.data.mapper

import com.taskgoapp.taskgo.data.local.entity.ChatMessageEntity
import com.taskgoapp.taskgo.core.model.ChatMessage

object ChatMapper {
    
    fun ChatMessageEntity.toModel(): ChatMessage {
        return ChatMessage(
            id = this.id,
            threadId = this.threadId,
            text = this.text,
            senderMe = this.senderMe,
            time = this.time
        )
    }
    
    fun ChatMessage.toEntity(): ChatMessageEntity {
        return ChatMessageEntity(
            id = this.id,
            threadId = this.threadId,
            text = this.text,
            senderMe = this.senderMe,
            time = this.time
        )
    }
}

```

## [FRONTEND]: data/mapper/MessageMapper.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.data.mapper

import com.taskgoapp.taskgo.data.local.entity.MessageThreadEntity
import com.taskgoapp.taskgo.data.local.entity.ChatMessageEntity
import com.taskgoapp.taskgo.core.model.MessageThread
import com.taskgoapp.taskgo.core.model.ChatMessage

object MessageMapper {
    
    fun MessageThreadEntity.toModel(): MessageThread {
        return MessageThread(
            id = this.id,
            title = this.title,
            lastMessage = this.lastMessage,
            lastTime = this.lastTime
        )
    }
    
    fun MessageThread.toEntity(): MessageThreadEntity {
        return MessageThreadEntity(
            id = this.id,
            title = this.title,
            lastMessage = this.lastMessage,
            lastTime = this.lastTime
        )
    }
    
    fun ChatMessageEntity.toModel(): ChatMessage {
        return ChatMessage(
            id = this.id,
            threadId = this.threadId,
            senderMe = this.senderMe,
            text = this.text,
            time = this.time
        )
    }
    
    fun ChatMessage.toEntity(): ChatMessageEntity {
        return ChatMessageEntity(
            id = this.id,
            threadId = this.threadId,
            senderMe = this.senderMe,
            text = this.text,
            time = this.time
        )
    }
}
```

## [FRONTEND]: data/mapper/OrderMapper.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.data.mapper

import com.taskgoapp.taskgo.data.local.entity.PurchaseOrderEntity
import com.taskgoapp.taskgo.data.local.entity.PurchaseOrderItemEntity
import com.taskgoapp.taskgo.core.model.PurchaseOrder
import com.taskgoapp.taskgo.core.model.OrderItem
import com.taskgoapp.taskgo.core.model.OrderStatus
import com.taskgoapp.taskgo.data.firestore.models.PurchaseOrderFirestore
import com.taskgoapp.taskgo.data.firestore.models.PurchaseOrderItemFirestore

object OrderMapper {
    
    fun PurchaseOrderEntity.toModel(items: List<OrderItem> = emptyList()): PurchaseOrder {
        return PurchaseOrder(
            id = this.id,
            orderNumber = this.orderNumber ?: "",
            createdAt = this.createdAt,
            total = this.total,
            subtotal = this.subtotal ?: 0.0,
            deliveryFee = this.deliveryFee ?: 0.0,
            status = when (this.status) {
                "EM_ANDAMENTO" -> OrderStatus.EM_ANDAMENTO
                "CONCLUIDO" -> OrderStatus.CONCLUIDO
                "CANCELADO" -> OrderStatus.CANCELADO
                else -> OrderStatus.EM_ANDAMENTO
            },
            items = items,
            paymentMethod = this.paymentMethod,
            trackingCode = this.trackingCode,
            deliveryAddress = this.deliveryAddress
        )
    }
    
    fun PurchaseOrder.toEntity(): PurchaseOrderEntity {
        return PurchaseOrderEntity(
            id = this.id,
            orderNumber = this.orderNumber,
            createdAt = this.createdAt,
            total = this.total,
            subtotal = this.subtotal,
            deliveryFee = this.deliveryFee,
            status = this.status.name,
            paymentMethod = this.paymentMethod,
            trackingCode = this.trackingCode,
            deliveryAddress = this.deliveryAddress
        )
    }
    
    fun PurchaseOrderItemEntity.toModel(): OrderItem {
        return OrderItem(
            productId = this.productId,
            price = this.price,
            quantity = this.qty
        )
    }
    
    fun OrderItem.toEntity(orderId: String): PurchaseOrderItemEntity {
        return PurchaseOrderItemEntity(
            orderId = orderId,
            productId = this.productId.toString(),
            productName = null,
            productImage = null,
            price = this.price,
            qty = this.quantity,
            deliveryDate = null
        )
    }
    
    // Firestore Mappers for PurchaseOrder
    fun PurchaseOrderFirestore.toModel(): PurchaseOrder {
        return PurchaseOrder(
            id = this.id,
            orderNumber = this.orderNumber,
            createdAt = this.createdAt?.time ?: System.currentTimeMillis(),
            total = this.total,
            subtotal = this.subtotal,
            deliveryFee = this.deliveryFee,
            status = when (this.status) {
                "EM_ANDAMENTO" -> OrderStatus.EM_ANDAMENTO
                "CONCLUIDO" -> OrderStatus.CONCLUIDO
                "CANCELADO" -> OrderStatus.CANCELADO
                else -> OrderStatus.EM_ANDAMENTO
            },
            items = this.items.map { it.toModel() },
            paymentMethod = this.paymentMethod,
            trackingCode = this.trackingCode,
            deliveryAddress = this.deliveryAddress
        )
    }
    
    fun PurchaseOrder.toFirestore(): PurchaseOrderFirestore {
        return PurchaseOrderFirestore(
            id = this.id,
            orderNumber = this.orderNumber,
            clientId = "", // TODO: Get from auth
            createdAt = java.util.Date(this.createdAt),
            total = this.total,
            subtotal = this.subtotal,
            deliveryFee = this.deliveryFee,
            status = this.status.name,
            items = this.items.map { it.toFirestore() },
            paymentMethod = this.paymentMethod,
            trackingCode = this.trackingCode,
            deliveryAddress = this.deliveryAddress
        )
    }
    
    fun PurchaseOrderItemFirestore.toModel(): OrderItem {
        return OrderItem(
            productId = this.productId,
            price = this.price,
            quantity = this.quantity
        )
    }
    
    fun OrderItem.toFirestore(): PurchaseOrderItemFirestore {
        return PurchaseOrderItemFirestore(
            productId = this.productId.toString(),
            productName = null,
            productImage = null,
            price = this.price,
            quantity = this.quantity
        )
    }
}
```

## [FRONTEND]: data/mapper/PostMapper.kt

```kotlin
package com.taskgoapp.taskgo.data.mapper

import com.taskgoapp.taskgo.data.firestore.models.PostFirestore
import com.taskgoapp.taskgo.data.firestore.models.PostLocation as PostLocationFirestore
import com.taskgoapp.taskgo.core.model.Post
import com.taskgoapp.taskgo.core.model.PostLocation
import java.util.Date

object PostMapper {
    
    /**
     * Converte PostFirestore para Post, verificando se o usu√°rio atual curtiu
     */
    fun PostFirestore.toModel(currentUserId: String?): Post {
        return Post(
            id = this.id,
            userId = this.userId,
            userName = this.userName,
            userAvatarUrl = this.userAvatarUrl,
            text = this.text,
            mediaUrls = this.mediaUrls,
            mediaTypes = this.mediaTypes,
            location = this.location?.toModel(),
            createdAt = this.createdAt,
            updatedAt = this.updatedAt,
            likesCount = this.likesCount,
            commentsCount = this.commentsCount,
            isLiked = currentUserId?.let { this.likedBy.contains(it) } ?: false,
            tags = this.tags
        )
    }
    
    /**
     * Converte Post para PostFirestore
     */
    fun Post.toFirestore(): PostFirestore {
        return PostFirestore(
            id = this.id,
            userId = this.userId,
            userName = this.userName,
            userAvatarUrl = this.userAvatarUrl,
            text = this.text,
            mediaUrls = this.mediaUrls,
            mediaTypes = this.mediaTypes,
            location = this.location?.toFirestore(),
            createdAt = this.createdAt,
            updatedAt = this.updatedAt,
            likesCount = this.likesCount,
            commentsCount = this.commentsCount,
            likedBy = emptyList(), // N√£o incluir likedBy no toFirestore, ser√° atualizado separadamente
            tags = this.tags
        )
    }
    
    /**
     * Converte PostLocation do Firestore para modelo de dom√≠nio
     */
    fun PostLocationFirestore.toModel(): PostLocation {
        return PostLocation(
            city = this.city,
            state = this.state,
            latitude = this.latitude,
            longitude = this.longitude
        )
    }
    
    /**
     * Converte PostLocation do modelo de dom√≠nio para Firestore
     */
    fun PostLocation.toFirestore(): PostLocationFirestore {
        return PostLocationFirestore(
            city = this.city,
            state = this.state,
            latitude = this.latitude,
            longitude = this.longitude
        )
    }
}

```

## [FRONTEND]: data/mapper/ProductMapper.kt

```kotlin
package com.taskgoapp.taskgo.data.mapper

import com.taskgoapp.taskgo.data.local.entity.ProductEntity
import com.taskgoapp.taskgo.data.local.entity.ProductImageEntity
import com.taskgoapp.taskgo.core.model.Product
import com.taskgoapp.taskgo.data.firestore.models.ProductFirestore

object ProductMapper {
    
    fun ProductEntity.toModel(imageUris: List<String> = emptyList()): Product {
        return Product(
            id = this.id,
            title = this.title,
            price = this.price,
            description = this.description,
            sellerId = this.sellerId,
            sellerName = this.sellerName,
            imageUris = imageUris,
            rating = this.rating,
            latitude = this.latitude,
            longitude = this.longitude,
            featured = this.featured,
            discountPercentage = this.discountPercentage,
            active = this.active
        )
    }
    
    fun Product.toEntity(): ProductEntity {
        return ProductEntity(
            id = this.id,
            title = this.title,
            price = this.price,
            description = this.description,
            sellerId = this.sellerId,
            sellerName = this.sellerName,
            rating = this.rating,
            latitude = this.latitude,
            longitude = this.longitude,
            featured = this.featured ?: false,
            discountPercentage = this.discountPercentage,
            active = this.active
        )
    }
    
    fun ProductImageEntity.toModel(): String {
        return this.uri
    }
    
    fun String.toImageEntity(productId: String): ProductImageEntity {
        return ProductImageEntity(
            productId = productId,
            uri = this
        )
    }
    
    // Firestore Mappers
    fun ProductFirestore.toModel(): Product {
        return Product(
            id = this.id,
            title = this.title,
            price = this.price,
            description = this.description,
            sellerId = this.sellerId.takeIf { it.isNotBlank() },
            sellerName = this.sellerName,
            imageUris = this.imageUrls,
            category = this.category,
            rating = this.rating,
            latitude = this.latitude,
            longitude = this.longitude,
            featured = this.featured,
            discountPercentage = this.discountPercentage,
            active = this.active
        )
    }
    
    fun Product.toFirestore(): ProductFirestore {
        return ProductFirestore(
            id = this.id,
            title = this.title,
            price = this.price,
            description = this.description,
            sellerId = this.sellerId ?: "",
            sellerName = this.sellerName,
            imageUrls = this.imageUris,
            category = this.category,
            tags = emptyList(),
            active = this.active,
            featured = this.featured ?: false,
            discountPercentage = this.discountPercentage,
            rating = this.rating,
            latitude = this.latitude,
            longitude = this.longitude
        )
    }
}
```

## [FRONTEND]: data/mapper/ProposalMapper.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.data.mapper

import com.taskgoapp.taskgo.data.local.entity.ProposalEntity
import com.taskgoapp.taskgo.core.model.Proposal

object ProposalMapper {
    
    fun ProposalEntity.toModel(): Proposal {
        return Proposal(
            id = this.id,
            orderId = this.orderId,
            providerName = this.providerName,
            rating = this.rating,
            amount = this.amount,
            message = this.message,
            scheduledDate = this.scheduledDate,
            address = this.address,
            accepted = this.accepted
        )
    }
    
    fun Proposal.toEntity(): ProposalEntity {
        return ProposalEntity(
            id = this.id,
            orderId = this.orderId,
            providerName = this.providerName,
            rating = this.rating,
            amount = this.amount,
            message = this.message,
            scheduledDate = this.scheduledDate,
            address = this.address,
            accepted = this.accepted
        )
    }
}

```

## [FRONTEND]: data/mapper/ReviewMapper.kt

```kotlin
package com.taskgoapp.taskgo.data.mapper

import com.taskgoapp.taskgo.core.model.Review
import com.taskgoapp.taskgo.core.model.ReviewType
import com.taskgoapp.taskgo.data.firestore.models.ReviewFirestore

object ReviewMapper {
    
    fun ReviewFirestore.toModel(): Review {
        return Review(
            id = this.id,
            type = when (this.type) {
                "PRODUCT" -> ReviewType.PRODUCT
                "SERVICE" -> ReviewType.SERVICE
                "PROVIDER" -> ReviewType.PROVIDER
                else -> ReviewType.PRODUCT
            },
            targetId = this.targetId,
            reviewerId = this.reviewerId,
            reviewerName = this.reviewerName,
            reviewerAvatarUri = this.reviewerAvatarUri,
            rating = this.rating,
            comment = this.comment,
            photoUrls = this.photoUrls,
            createdAt = this.createdAt?.time ?: System.currentTimeMillis(),
            updatedAt = this.updatedAt?.time,
            orderId = this.orderId,
            helpfulCount = this.helpfulCount,
            verifiedPurchase = this.verifiedPurchase
        )
    }
    
    fun Review.toFirestore(): ReviewFirestore {
        return ReviewFirestore(
            id = this.id,
            type = when (this.type) {
                ReviewType.PRODUCT -> "PRODUCT"
                ReviewType.SERVICE -> "SERVICE"
                ReviewType.PROVIDER -> "PROVIDER"
            },
            targetId = this.targetId,
            reviewerId = this.reviewerId,
            reviewerName = this.reviewerName,
            reviewerAvatarUri = this.reviewerAvatarUri,
            rating = this.rating,
            comment = this.comment,
            photoUrls = this.photoUrls,
            createdAt = java.util.Date(this.createdAt),
            updatedAt = this.updatedAt?.let { java.util.Date(it) },
            orderId = this.orderId,
            helpfulCount = this.helpfulCount,
            verifiedPurchase = this.verifiedPurchase
        )
    }
}


```

## [FRONTEND]: data/mapper/ServiceMapper.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.data.mapper

import com.taskgoapp.taskgo.data.local.entity.ServiceOrderEntity
import com.taskgoapp.taskgo.data.local.entity.ProposalEntity
import com.taskgoapp.taskgo.core.model.ServiceOrder
import com.taskgoapp.taskgo.core.model.Proposal

object ServiceMapper {
    
    fun ServiceOrderEntity.toModel(): ServiceOrder {
        return ServiceOrder(
            id = this.id,
            category = this.category,
            description = this.description,
            date = this.date,
            addressLine = this.addressLine,
            city = this.city,
            state = this.state
        )
    }
    
    fun ServiceOrder.toEntity(): ServiceOrderEntity {
        return ServiceOrderEntity(
            id = this.id,
            category = this.category,
            description = this.description,
            date = this.date,
            addressLine = this.addressLine,
            city = this.city,
            state = this.state
        )
    }
    
    fun ProposalEntity.toModel(): Proposal {
        return Proposal(
            id = this.id,
            orderId = this.orderId,
            providerName = this.providerName,
            rating = this.rating,
            amount = this.amount,
            message = this.message,
            scheduledDate = this.scheduledDate,
            address = this.address,
            accepted = this.accepted
        )
    }
    
    fun Proposal.toEntity(): ProposalEntity {
        return ProposalEntity(
            id = this.id,
            orderId = this.orderId,
            providerName = this.providerName,
            rating = this.rating,
            amount = this.amount,
            message = this.message,
            scheduledDate = this.scheduledDate,
            address = this.address,
            accepted = this.accepted
        )
    }
}
```

## [FRONTEND]: data/mapper/StoryMapper.kt

```kotlin
package com.taskgoapp.taskgo.data.mapper

import com.google.firebase.Timestamp
import com.taskgoapp.taskgo.core.model.Story
import com.taskgoapp.taskgo.core.model.StoryLocation
import com.taskgoapp.taskgo.data.firestore.models.StoryFirestore
import com.taskgoapp.taskgo.data.firestore.models.StoryLocationFirestore
import java.util.Date

/**
 * Mapper para converter entre Story (modelo de dom√≠nio) e StoryFirestore
 */

/**
 * Mapper para converter entre Story (modelo de dom√≠nio) e StoryFirestore
 */
object StoryMapper {
    
    /**
     * Converte StoryFirestore para Story (modelo de dom√≠nio)
     */
    fun StoryFirestore.toModel(isViewed: Boolean = false): Story {
        return Story(
            id = this.id,
            userId = this.userId,
            userName = this.userName,
            userAvatarUrl = this.userAvatarUrl,
            mediaUrl = this.mediaUrl,
            mediaType = this.mediaType,
            thumbnailUrl = this.thumbnailUrl,
            caption = this.caption,
            createdAt = this.createdAt?.toDate() ?: Date(),
            expiresAt = this.expiresAt?.toDate() ?: Date(System.currentTimeMillis() + 24 * 60 * 60 * 1000),
            viewsCount = this.viewsCount,
            isViewed = isViewed,
            location = this.location?.toModel()
        )
    }
    
    /**
     * Converte Story (modelo de dom√≠nio) para StoryFirestore
     */
    fun Story.toFirestore(): StoryFirestore {
        return StoryFirestore(
            id = this.id,
            userId = this.userId,
            userName = this.userName,
            userAvatarUrl = this.userAvatarUrl,
            mediaUrl = this.mediaUrl,
            mediaType = this.mediaType,
            thumbnailUrl = this.thumbnailUrl,
            caption = this.caption,
            createdAt = this.createdAt?.let { Timestamp(it) },
            expiresAt = this.expiresAt?.let { Timestamp(it) },
            viewsCount = this.viewsCount,
            location = this.location?.toFirestore()
        )
    }
    
    /**
     * Converte StoryLocationFirestore para StoryLocation
     */
    fun StoryLocationFirestore.toModel(): StoryLocation {
        return StoryLocation(
            city = this.city,
            state = this.state,
            latitude = this.latitude,
            longitude = this.longitude
        )
    }
    
    /**
     * Converte StoryLocation para StoryLocationFirestore
     */
    fun StoryLocation.toFirestore(): StoryLocationFirestore {
        return StoryLocationFirestore(
            city = this.city,
            state = this.state,
            latitude = this.latitude,
            longitude = this.longitude
        )
    }
}


```

## [FRONTEND]: data/mapper/TrackingMapper.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.data.mapper

import com.taskgoapp.taskgo.data.local.entity.TrackingEventEntity
import com.taskgoapp.taskgo.core.model.TrackingEvent

object TrackingMapper {
    
    fun TrackingEventEntity.toModel(): TrackingEvent {
        return TrackingEvent(
            label = this.label,
            date = this.date,
            done = this.done
        )
    }
    
    fun TrackingEvent.toEntity(orderId: String): TrackingEventEntity {
        return TrackingEventEntity(
            id = java.util.UUID.randomUUID().toString(),
            orderId = orderId,
            label = this.label,
            date = this.date,
            done = this.done
        )
    }
}
```

## [FRONTEND]: data/mapper/UserMapper.kt

```kotlin
package com.taskgoapp.taskgo.data.mapper

import com.taskgoapp.taskgo.data.local.entity.UserProfileEntity
import com.taskgoapp.taskgo.core.model.UserProfile
import com.taskgoapp.taskgo.core.model.AccountType
import com.taskgoapp.taskgo.data.firestore.models.UserFirestore
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken

object UserMapper {
    
    fun UserProfileEntity.toModel(): UserProfile {
        val profileImages = try {
            profileImages?.let { 
                Gson().fromJson<List<String>>(it, object : TypeToken<List<String>>() {}.type) 
            } ?: emptyList()
        } catch (e: Exception) {
            emptyList()
        }
        
        return UserProfile(
            id = this.id,
            name = this.name,
            email = this.email,
            phone = this.phone,
            city = this.city,
            state = this.state,
            profession = this.profession,
            accountType = when (this.accountType) {
                "PRESTADOR" -> AccountType.PARCEIRO // Legacy - migrar para PARCEIRO
                "VENDEDOR" -> AccountType.PARCEIRO // Legacy - migrar para PARCEIRO
                "PARCEIRO" -> AccountType.PARCEIRO
                "CLIENTE" -> AccountType.CLIENTE
                else -> AccountType.CLIENTE
            },
            rating = this.rating,
            avatarUri = this.avatarUri,
            profileImages = profileImages
        )
    }
    
    fun UserProfile.toEntity(): UserProfileEntity {
        val profileImagesJson = profileImages?.let { 
            Gson().toJson(it) 
        }
        
        return UserProfileEntity(
            id = this.id,
            name = this.name,
            email = this.email,
            phone = this.phone,
            city = this.city,
            state = this.state,
            profession = this.profession,
            accountType = this.accountType.name,
            rating = this.rating,
            avatarUri = this.avatarUri,
            profileImages = profileImagesJson
        )
    }
    
    fun UserFirestore.toModel(): UserProfile {
        // Mapear role string para AccountType enum
        // Suporta legacy roles (provider, seller) mapeando para PARCEIRO
        val accountType = when (this.role.lowercase()) {
            "provider" -> AccountType.PARCEIRO // Legacy - migrar para partner
            "seller" -> AccountType.PARCEIRO // Legacy - migrar para partner
            "partner" -> AccountType.PARCEIRO
            "client" -> AccountType.CLIENTE
            else -> AccountType.CLIENTE
        }
        
        return UserProfile(
            id = this.uid,
            name = this.displayName ?: "",
            email = this.email,
            phone = this.phone,
            city = this.address?.city,
            state = this.address?.state, // Extrair state do address
            profession = null, // UserFirestore n√£o tem profession diretamente
            accountType = accountType,
            rating = this.rating,
            avatarUri = this.photoURL,
            profileImages = emptyList()
        )
    }
}
```

# Data Layer - realtime


## [FRONTEND]: data/realtime/RealtimeDatabaseRepository.kt

```kotlin
package com.taskgoapp.taskgo.data.realtime

import com.google.firebase.database.FirebaseDatabase
import com.google.firebase.database.DatabaseReference
import kotlinx.coroutines.tasks.await
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Reposit√≥rio para opera√ß√µes no Realtime Database
 * Garante que dados cr√≠ticos sejam salvos em tempo real
 */
@Singleton
class RealtimeDatabaseRepository @Inject constructor(
    private val database: FirebaseDatabase
) {
    private val rootRef: DatabaseReference = database.reference
    
    /**
     * DEPRECATED: Salva um produto no Realtime Database
     * 
     * ATEN√á√ÉO: Escrita direta em 'products' est√° bloqueada por regras de seguran√ßa.
     * Use Cloud Function 'createProduct' ou 'updateProduct' ao inv√©s deste m√©todo.
     * 
     * Este m√©todo foi mantido apenas para compatibilidade, mas sempre falhar√°.
     * Remova chamadas a este m√©todo e use FirebaseFunctionsService.createProduct().
     */
    @Deprecated(
        message = "Use FirebaseFunctionsService.createProduct() ou updateProduct() ao inv√©s de escrita direta",
        level = DeprecationLevel.ERROR
    )
    suspend fun saveProduct(productId: String, productData: Map<String, Any>) {
        android.util.Log.w("RealtimeDB", "‚ö†Ô∏è saveProduct est√° DEPRECATED. Use Cloud Function 'createProduct' ou 'updateProduct'.")
        throw UnsupportedOperationException(
            "Escrita direta em 'products' est√° bloqueada. Use Cloud Function 'createProduct' ou 'updateProduct'."
        )
    }
    
    /**
     * DEPRECATED: Salva um servi√ßo no Realtime Database
     * 
     * ATEN√á√ÉO: Escrita direta em 'services' est√° bloqueada por regras de seguran√ßa.
     * Use Cloud Function 'createService' ou 'updateService' ao inv√©s deste m√©todo.
     * 
     * Este m√©todo foi mantido apenas para compatibilidade, mas sempre falhar√°.
     * Remova chamadas a este m√©todo e use FirebaseFunctionsService.createService().
     */
    @Deprecated(
        message = "Use FirebaseFunctionsService.createService() ou updateService() ao inv√©s de escrita direta",
        level = DeprecationLevel.ERROR
    )
    suspend fun saveService(serviceId: String, serviceData: Map<String, Any>) {
        android.util.Log.w("RealtimeDB", "‚ö†Ô∏è saveService est√° DEPRECATED. Use Cloud Function 'createService' ou 'updateService'.")
        throw UnsupportedOperationException(
            "Escrita direta em 'services' est√° bloqueada. Use Cloud Function 'createService' ou 'updateService'."
        )
    }
    
    /**
     * DEPRECATED: Salva uma ordem de servi√ßo no Realtime Database
     * 
     * ATEN√á√ÉO: Escrita direta em 'orders' est√° bloqueada por regras de seguran√ßa.
     * Use Cloud Function 'createOrder' ou 'updateOrderStatus' ao inv√©s deste m√©todo.
     * 
     * Este m√©todo foi mantido apenas para compatibilidade, mas sempre falhar√°.
     * Remova chamadas a este m√©todo e use FirebaseFunctionsService.createOrder().
     */
    @Deprecated(
        message = "Use FirebaseFunctionsService.createOrder() ou updateOrderStatus() ao inv√©s de escrita direta",
        level = DeprecationLevel.ERROR
    )
    suspend fun saveOrder(orderId: String, orderData: Map<String, Any>) {
        android.util.Log.w("RealtimeDB", "‚ö†Ô∏è saveOrder est√° DEPRECATED. Use Cloud Function 'createOrder' ou 'updateOrderStatus'.")
        throw UnsupportedOperationException(
            "Escrita direta em 'orders' est√° bloqueada. Use Cloud Function 'createOrder' ou 'updateOrderStatus'."
        )
    }
    
    /**
     * DEPRECATED: Salva um pedido de compra (purchase_order) no Realtime Database
     * 
     * ATEN√á√ÉO: Escrita direta em 'purchase_orders' est√° bloqueada por regras de seguran√ßa.
     * Use Cloud Functions apropriadas ao inv√©s deste m√©todo.
     * 
     * Este m√©todo foi mantido apenas para compatibilidade, mas sempre falhar√°.
     */
    @Deprecated(
        message = "Use Cloud Functions apropriadas ao inv√©s de escrita direta",
        level = DeprecationLevel.ERROR
    )
    suspend fun savePurchaseOrder(orderId: String, orderData: Map<String, Any>) {
        android.util.Log.w("RealtimeDB", "‚ö†Ô∏è savePurchaseOrder est√° DEPRECATED. Use Cloud Functions apropriadas.")
        throw UnsupportedOperationException(
            "Escrita direta em 'purchase_orders' est√° bloqueada. Use Cloud Functions apropriadas."
        )
    }
    
    /**
     * DEPRECATED: Remove um produto do Realtime Database
     * 
     * ATEN√á√ÉO: Escrita direta em 'products' est√° bloqueada por regras de seguran√ßa.
     * Use Cloud Function 'deleteProduct' ao inv√©s deste m√©todo.
     * 
     * Este m√©todo foi mantido apenas para compatibilidade, mas sempre falhar√°.
     * Remova chamadas a este m√©todo e use FirebaseFunctionsService.deleteProduct().
     */
    @Deprecated(
        message = "Use FirebaseFunctionsService.deleteProduct() ao inv√©s de escrita direta",
        level = DeprecationLevel.ERROR
    )
    suspend fun deleteProduct(productId: String) {
        android.util.Log.w("RealtimeDB", "‚ö†Ô∏è deleteProduct est√° DEPRECATED. Use Cloud Function 'deleteProduct'.")
        throw UnsupportedOperationException(
            "Escrita direta em 'products' est√° bloqueada. Use Cloud Function 'deleteProduct'."
        )
    }
    
    /**
     * DEPRECATED: Remove um servi√ßo do Realtime Database
     * 
     * ATEN√á√ÉO: Escrita direta em 'services' est√° bloqueada por regras de seguran√ßa.
     * Use Cloud Function 'deleteService' ao inv√©s deste m√©todo.
     * 
     * Este m√©todo foi mantido apenas para compatibilidade, mas sempre falhar√°.
     * Remova chamadas a este m√©todo e use FirebaseFunctionsService.deleteService().
     */
    @Deprecated(
        message = "Use FirebaseFunctionsService.deleteService() ao inv√©s de escrita direta",
        level = DeprecationLevel.ERROR
    )
    suspend fun deleteService(serviceId: String) {
        android.util.Log.w("RealtimeDB", "‚ö†Ô∏è deleteService est√° DEPRECATED. Use Cloud Function 'deleteService'.")
        throw UnsupportedOperationException(
            "Escrita direta em 'services' est√° bloqueada. Use Cloud Function 'deleteService'."
        )
    }
    
    /**
     * Atualiza presen√ßa do usu√°rio (online/offline)
     */
    suspend fun updatePresence(userId: String, isOnline: Boolean) {
        try {
            val presenceRef = rootRef.child("presence").child(userId)
            if (isOnline) {
                presenceRef.setValue(true).await()
                // Remover automaticamente quando desconectar
                presenceRef.onDisconnect().removeValue()
            } else {
                presenceRef.removeValue().await()
            }
        } catch (e: Exception) {
            android.util.Log.e("RealtimeDB", "Erro ao atualizar presen√ßa: ${e.message}", e)
        }
    }
}


```

# Data Layer - repository


## [FRONTEND]: data/repository/AddressRepositoryImpl.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.data.repository

import com.taskgoapp.taskgo.data.local.dao.AddressDao
import com.taskgoapp.taskgo.data.mapper.AddressMapper.toEntity
import com.taskgoapp.taskgo.data.mapper.AddressMapper.toModel
import com.taskgoapp.taskgo.domain.repository.AddressRepository
import com.taskgoapp.taskgo.core.model.Address
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.onStart
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.tasks.await
import kotlinx.coroutines.withContext
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.launch
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class AddressRepositoryImpl @Inject constructor(
    private val addressDao: AddressDao,
    private val firestore: com.google.firebase.firestore.FirebaseFirestore,
    private val syncManager: com.taskgoapp.taskgo.core.sync.SyncManager,
    private val authRepository: FirebaseAuthRepository
) : AddressRepository {
    
    private val addressesCollection = firestore.collection("addresses")

    override fun observeAddresses(): Flow<List<Address>> {
        val userId = authRepository.getCurrentUser()?.uid
        
        // CR√çTICO: Sempre filtrar por userId para garantir isolamento de dados
        return if (userId != null) {
            // Observar do Firestore filtrando por userId e sincronizar com cache local
            kotlinx.coroutines.flow.callbackFlow {
                val listenerRegistration = addressesCollection
                    .whereEqualTo("userId", userId)
                    .addSnapshotListener { snapshot, error ->
                        if (error != null) {
                            android.util.Log.e("AddressRepository", "Erro ao observar endere√ßos: ${error.message}", error)
                            trySend(emptyList())
                            return@addSnapshotListener
                        }
                        
                        kotlinx.coroutines.CoroutineScope(kotlinx.coroutines.Dispatchers.IO).launch {
                            val addressesList = mutableListOf<com.taskgoapp.taskgo.core.model.Address>()
                            
                            snapshot?.documents?.forEach { doc ->
                                val data = doc.data
                                val address = com.taskgoapp.taskgo.core.model.Address(
                                    id = doc.id,
                                    name = data?.get("name") as? String ?: "",
                                    phone = data?.get("phone") as? String ?: "",
                                    cep = data?.get("cep") as? String ?: "",
                                    street = data?.get("street") as? String ?: "",
                                    district = data?.get("district") as? String ?: "",
                                    city = data?.get("city") as? String ?: "",
                                    state = data?.get("state") as? String ?: "",
                                    number = data?.get("number") as? String ?: "",
                                    complement = data?.get("complement") as? String,
                                    neighborhood = data?.get("neighborhood") as? String ?: "",
                                    zipCode = data?.get("zipCode") as? String ?: ""
                                )
                                addressDao.upsert(address.toEntity())
                                addressesList.add(address)
                            }
                            
                            // Enviar lista atualizada diretamente do Firestore
                            trySend(addressesList)
                        }
                    }
                
                awaitClose { listenerRegistration.remove() }
            }
        } else {
            // Se n√£o h√° usu√°rio autenticado, retornar lista vazia
            kotlinx.coroutines.flow.flowOf(emptyList<Address>())
        }
    }

    override suspend fun getAddress(id: String): Address? {
        return addressDao.getById(id)?.toModel()
    }

    override suspend fun upsertAddress(address: Address) {
        val userId = authRepository.getCurrentUser()?.uid
            ?: throw IllegalStateException("Usu√°rio n√£o autenticado. Fa√ßa login novamente.")
        
        // 1. Salva localmente primeiro (instant√¢neo)
        addressDao.upsert(address.toEntity())
        
        // 2. Salva diretamente no Firestore com userId garantido
        val addressId = if (address.id.isBlank()) {
            // Gerar novo ID se n√£o tiver
            addressesCollection.document().id
        } else {
            address.id
        }
        
        val addressData = hashMapOf<String, Any>(
            "userId" to userId, // CR√çTICO: Sempre incluir userId
            "name" to (address.name.takeIf { it.isNotBlank() } ?: ""),
            "phone" to (address.phone.takeIf { it.isNotBlank() } ?: ""),
            "cep" to (address.cep.takeIf { it.isNotBlank() } ?: ""),
            "street" to (address.street.takeIf { it.isNotBlank() } ?: ""),
            "district" to (address.district.takeIf { it.isNotBlank() } ?: ""),
            "city" to (address.city.takeIf { it.isNotBlank() } ?: ""),
            "state" to (address.state.takeIf { it.isNotBlank() } ?: ""),
            "number" to (address.number.takeIf { it.isNotBlank() } ?: ""),
            "neighborhood" to (address.neighborhood.takeIf { it.isNotBlank() } ?: ""),
            "zipCode" to (address.zipCode.takeIf { it.isNotBlank() } ?: ""),
            "createdAt" to com.google.firebase.firestore.FieldValue.serverTimestamp(),
            "updatedAt" to com.google.firebase.firestore.FieldValue.serverTimestamp()
        )
        
        // Adicionar complemento se existir
        address.complement?.takeIf { it.isNotBlank() }?.let {
            addressData["complement"] = it
        }
        
        try {
            addressesCollection.document(addressId).set(addressData).await()
            android.util.Log.d("AddressRepository", "Endere√ßo salvo no Firestore com userId: $userId")
        } catch (e: Exception) {
            android.util.Log.e("AddressRepository", "Erro ao salvar endere√ßo no Firestore: ${e.message}", e)
            throw e
        }
    }

    override suspend fun deleteAddress(id: String) {
        // 1. Remove localmente primeiro (instant√¢neo)
        val entity = addressDao.getById(id) ?: return
        addressDao.delete(entity)
        
        // 2. Agenda sincroniza√ß√£o com Firebase ap√≥s 1 minuto
        syncManager.scheduleSync(
            syncType = "address",
            entityId = id,
            operation = "delete",
            data = emptyMap<String, Any>()
        )
    }
}
```

## [FRONTEND]: data/repository/CardRepositoryImpl.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.data.repository

import com.taskgoapp.taskgo.data.local.dao.CardDao
import com.taskgoapp.taskgo.data.mapper.CardMapper.toEntity
import com.taskgoapp.taskgo.data.mapper.CardMapper.toModel
import com.taskgoapp.taskgo.domain.repository.CardRepository
import com.taskgoapp.taskgo.core.model.Card
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.tasks.await
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.launch
import kotlinx.coroutines.Dispatchers
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class CardRepositoryImpl @Inject constructor(
    private val cardDao: CardDao,
    private val firestore: com.google.firebase.firestore.FirebaseFirestore,
    private val syncManager: com.taskgoapp.taskgo.core.sync.SyncManager,
    private val authRepository: FirebaseAuthRepository
) : CardRepository {
    
    private val cardsCollection = firestore.collection("cards")

    override fun observeCards(): Flow<List<Card>> {
        val userId = authRepository.getCurrentUser()?.uid
        
        // CR√çTICO: Sempre filtrar por userId para garantir isolamento de dados
        return if (userId != null) {
            // Observar do Firestore filtrando por userId e sincronizar com cache local
            kotlinx.coroutines.flow.callbackFlow {
                val listenerRegistration = cardsCollection
                    .whereEqualTo("userId", userId)
                    .addSnapshotListener { snapshot, error ->
                        if (error != null) {
                            android.util.Log.e("CardRepository", "Erro ao observar cart√µes: ${error.message}", error)
                            trySend(emptyList())
                            return@addSnapshotListener
                        }
                        
                        kotlinx.coroutines.CoroutineScope(kotlinx.coroutines.Dispatchers.IO).launch {
                            val cardsList = mutableListOf<com.taskgoapp.taskgo.core.model.Card>()
                            
                            snapshot?.documents?.forEach { doc ->
                                val data = doc.data
                                val card = com.taskgoapp.taskgo.core.model.Card(
                                    id = doc.id,
                                    holder = data?.get("holder") as? String ?: "",
                                    numberMasked = data?.get("numberMasked") as? String ?: "",
                                    brand = data?.get("brand") as? String ?: "",
                                    expMonth = (data?.get("expMonth") as? Number)?.toInt() ?: 0,
                                    expYear = (data?.get("expYear") as? Number)?.toInt() ?: 0,
                                    type = data?.get("type") as? String ?: ""
                                )
                                cardDao.upsert(card.toEntity())
                                cardsList.add(card)
                            }
                            
                            // Enviar lista atualizada diretamente do Firestore
                            trySend(cardsList)
                        }
                    }
                
                awaitClose { listenerRegistration.remove() }
            }
        } else {
            kotlinx.coroutines.flow.flowOf(emptyList<Card>())
        }
    }

    override suspend fun getCard(id: String): Card? {
        return cardDao.getById(id)?.toModel()
    }

    override suspend fun upsertCard(card: Card) {
        val userId = authRepository.getCurrentUser()?.uid
            ?: throw IllegalStateException("Usu√°rio n√£o autenticado. Fa√ßa login novamente.")
        
        // 1. Salva localmente primeiro (instant√¢neo)
        cardDao.upsert(card.toEntity())
        
        // 2. Salva diretamente no Firestore com userId garantido
        val cardId = if (card.id.isBlank()) {
            cardsCollection.document().id
        } else {
            card.id
        }
        
        val cardData = hashMapOf<String, Any>(
            "userId" to userId, // CR√çTICO: Sempre incluir userId
            "holder" to card.holder,
            "numberMasked" to card.numberMasked,
            "brand" to card.brand,
            "expMonth" to card.expMonth,
            "expYear" to card.expYear,
            "type" to card.type,
            "createdAt" to com.google.firebase.firestore.FieldValue.serverTimestamp(),
            "updatedAt" to com.google.firebase.firestore.FieldValue.serverTimestamp()
        )
        
        try {
            cardsCollection.document(cardId).set(cardData).await()
            android.util.Log.d("CardRepository", "Cart√£o salvo no Firestore com userId: $userId")
        } catch (e: Exception) {
            android.util.Log.e("CardRepository", "Erro ao salvar cart√£o no Firestore: ${e.message}", e)
            throw e
        }
    }

    override suspend fun deleteCard(id: String) {
        // 1. Remove localmente primeiro (instant√¢neo)
        val entity = cardDao.getById(id) ?: return
        cardDao.delete(entity)
        
        // 2. Agenda sincroniza√ß√£o com Firebase ap√≥s 1 minuto
        syncManager.scheduleSync(
            syncType = "card",
            entityId = id,
            operation = "delete",
            data = emptyMap<String, Any>()
        )
    }
}



```

## [FRONTEND]: data/repository/FeedMediaRepository.kt

```kotlin
package com.taskgoapp.taskgo.data.repository

import android.content.Context
import android.net.Uri
import android.os.ParcelFileDescriptor
import com.google.firebase.storage.FirebaseStorage
import com.google.firebase.storage.StorageReference
import com.taskgoapp.taskgo.core.model.Result
import kotlinx.coroutines.tasks.await
import java.util.UUID
import javax.inject.Inject
import javax.inject.Singleton
import dagger.hilt.android.qualifiers.ApplicationContext

@Singleton
class FeedMediaRepository @Inject constructor(
    private val storage: FirebaseStorage,
    private val authRepository: FirebaseAuthRepository,
    @ApplicationContext private val context: Context
) {
    
    private val postsStoragePath = "posts"
    private val storiesStoragePath = "stories"
    
    /**
     * Faz upload de uma m√≠dia (imagem ou v√≠deo) para o Firebase Storage
     * Segue a mesma l√≥gica de produtos e servi√ßos: sempre usa o userId do usu√°rio autenticado
     * @param uri URI local da m√≠dia
     * @param userId ID do usu√°rio (deve corresponder ao usu√°rio autenticado)
     * @param mediaType "image" ou "video"
     * @return URL p√∫blica da m√≠dia no Storage
     */
    suspend fun uploadPostMedia(
        uri: Uri,
        userId: String,
        mediaType: String
    ): Result<String> {
        // Gerar nome √∫nico para o arquivo (fora do try para estar acess√≠vel no catch)
        val fileName = "${UUID.randomUUID()}_${System.currentTimeMillis()}"
        val extension = try {
            getFileExtension(uri, mediaType)
        } catch (e: Exception) {
            android.util.Log.w("FeedMediaRepository", "Erro ao obter extens√£o do arquivo: ${e.message}")
            when (mediaType) {
                "video" -> "mp4"
                else -> "jpg"
            }
        }
        val fullFileName = "$fileName.$extension"
        
        return try {
            // CR√çTICO: Sempre obter userId do usu√°rio autenticado (mesma l√≥gica de produtos/servi√ßos)
            val currentUser = authRepository.getCurrentUser()
            if (currentUser == null) {
                android.util.Log.e("FeedMediaRepository", "Usu√°rio n√£o autenticado")
                return Result.Error(Exception("Usu√°rio n√£o autenticado"))
            }
            
            // Usar sempre o userId do usu√°rio autenticado para garantir permiss√µes corretas
            val authenticatedUserId = currentUser.uid
            
            // Validar que o userId passado corresponde ao autenticado (seguran√ßa adicional)
            if (userId != authenticatedUserId) {
                android.util.Log.e("FeedMediaRepository", "UserId passado ($userId) n√£o corresponde ao autenticado ($authenticatedUserId)")
                return Result.Error(Exception("Permiss√£o negada: userId n√£o corresponde ao usu√°rio autenticado"))
            }
            
            android.util.Log.d("FeedMediaRepository", "Upload de post - userId: $authenticatedUserId, path: posts/$authenticatedUserId/$fullFileName")
            
            // Criar refer√™ncia no Storage: posts/{userId}/{fileName} (mesma estrutura de produtos/servi√ßos)
            val storageRef: StorageReference = storage.reference
                .child(postsStoragePath)
                .child(authenticatedUserId)
                .child(fullFileName)
            
            android.util.Log.d("FeedMediaRepository", "Storage path criado: posts/$authenticatedUserId/$fullFileName")
            
            // Validar tamanho do arquivo antes do upload (limite de 50MB conforme regras do Storage)
            // Usar abordagem segura para evitar problemas durante an√°lise est√°tica do R8
            val fileSize = try {
                context.contentResolver.openFileDescriptor(uri, "r")?.use { pfd ->
                    pfd.statSize
                } ?: 0L
            } catch (e: Exception) {
                android.util.Log.w("FeedMediaRepository", "Erro ao obter tamanho do arquivo: ${e.message}", e)
                0L
            } catch (e: OutOfMemoryError) {
                android.util.Log.e("FeedMediaRepository", "OutOfMemoryError ao obter tamanho do arquivo: ${e.message}", e)
                0L
            } catch (e: Throwable) {
                android.util.Log.e("FeedMediaRepository", "Erro inesperado ao obter tamanho do arquivo: ${e.message}", e)
                0L
            }
            
            // Calcular tamanho em MB para valida√ß√£o e exibi√ß√£o
            val fileSizeMB = if (fileSize > 0) {
                val mb = fileSize / (1024 * 1024)
                mb
            } else {
                0
            }
            val maxSizeMB = 50 * 1024 * 1024
            
            if (fileSize <= 0) {
                android.util.Log.w("FeedMediaRepository", "N√£o foi poss√≠vel determinar o tamanho do arquivo. Continuando com upload...")
            } else if (fileSize > maxSizeMB) {
                // Calcular tamanho formatado para mensagem de erro
                val fileSizeMBDouble = fileSize.toDouble() / (1024.0 * 1024.0)
                val fileSizeMBFormatted = try {
                    String.format(java.util.Locale.US, "%.2f", fileSizeMBDouble)
                } catch (e: Exception) {
                    fileSizeMB.toString()
                }
                android.util.Log.e("FeedMediaRepository", "Arquivo muito grande: ${fileSizeMB}MB. Limite: 50MB")
                return Result.Error(Exception("Arquivo muito grande. Limite m√°ximo: 50MB. Tamanho do arquivo: ${fileSizeMBFormatted}MB"))
            } else {
                android.util.Log.d("FeedMediaRepository", "Tamanho do arquivo validado: ${fileSizeMB}MB")
            }
            
            // Detectar contentType real do arquivo
            val detectedMimeType = try {
                context.contentResolver.getType(uri)
            } catch (e: Exception) {
                android.util.Log.w("FeedMediaRepository", "Erro ao obter MIME type: ${e.message}", e)
                null
            }
            
            // Garantir que contentType est√° sempre definido corretamente
            val actualContentType = when {
                detectedMimeType != null && detectedMimeType.startsWith("image/") -> {
                    android.util.Log.d("FeedMediaRepository", "MIME type detectado (imagem): $detectedMimeType para URI: $uri")
                    detectedMimeType
                }
                detectedMimeType != null && detectedMimeType.startsWith("video/") -> {
                    android.util.Log.d("FeedMediaRepository", "MIME type detectado (v√≠deo): $detectedMimeType para URI: $uri")
                    detectedMimeType
                }
                else -> {
                    // Fallback baseado no tipo de m√≠dia informado e extens√£o do arquivo
                    val fallbackType = when {
                        extension == "mp4" || extension == "mov" || mediaType == "video" -> "video/mp4"
                        extension == "jpg" || extension == "jpeg" -> "image/jpeg"
                        extension == "png" -> "image/png"
                        extension == "gif" -> "image/gif"
                        extension == "webp" -> "image/webp"
                        else -> "image/jpeg" // Padr√£o seguro
                    }
                    android.util.Log.w("FeedMediaRepository", "MIME type n√£o detectado ou inv√°lido ($detectedMimeType). Usando fallback baseado em extens√£o ($extension) e tipo ($mediaType): $fallbackType")
                    fallbackType
                }
            }
            
            val fileSizeDisplay = if (fileSize > 0) "${fileSizeMB}MB" else "desconhecido"
            android.util.Log.d("FeedMediaRepository", "Fazendo upload para: posts/$authenticatedUserId/$fullFileName com contentType: $actualContentType, tamanho: $fileSizeDisplay")
            
            // Criar metadata com contentType garantido
            val metadata = com.google.firebase.storage.StorageMetadata.Builder()
                .setContentType(actualContentType)
                .build()
            
            // Fazer upload do arquivo com metadata
            android.util.Log.d("FeedMediaRepository", "Iniciando upload...")
            val uploadTask = storageRef.putFile(uri, metadata)
            val uploadSnapshot = uploadTask.await()
            
            // Log informa√ß√µes do upload conclu√≠do (usando o snapshot para informa√ß√µes detalhadas)
            android.util.Log.d("FeedMediaRepository", "Upload conclu√≠do com sucesso. Bytes transferidos: ${uploadSnapshot.bytesTransferred}, Total bytes: ${uploadSnapshot.totalByteCount}")
            
            // Obter URL de download usando a refer√™ncia original do storage
            val downloadUrl = storageRef.downloadUrl.await()
            Result.Success(downloadUrl.toString())
        } catch (e: Exception) {
            android.util.Log.e("FeedMediaRepository", "Erro ao fazer upload de m√≠dia: ${e.message}", e)
            android.util.Log.e("FeedMediaRepository", "URI: $uri, userId: $userId, mediaType: $mediaType, fileName: $fullFileName")
            
            // Tratamento detalhado de diferentes tipos de erros do Firebase Storage
            val errorMessage = when {
                // Erro de autentica√ß√£o
                e.message?.contains("UNAUTHENTICATED", ignoreCase = true) == true ||
                e.message?.contains("authentication", ignoreCase = true) == true -> {
                    android.util.Log.e("FeedMediaRepository", "Erro de autentica√ß√£o: usu√°rio n√£o autenticado")
                    "Usu√°rio n√£o autenticado. Por favor, fa√ßa login novamente."
                }
                // Erro de permiss√£o
                e.message?.contains("PERMISSION_DENIED", ignoreCase = true) == true ||
                e.message?.contains("does not have permission", ignoreCase = true) == true ||
                e.message?.contains("Permission denied", ignoreCase = true) == true -> {
                    android.util.Log.e("FeedMediaRepository", "Erro de permiss√£o: verificar regras do Storage e autentica√ß√£o")
                    "Voc√™ n√£o tem permiss√£o para fazer upload deste arquivo. Verifique se est√° autenticado e tente novamente."
                }
                // Erro de rede/conex√£o
                e.message?.contains("network", ignoreCase = true) == true ||
                e.message?.contains("connection", ignoreCase = true) == true ||
                e.message?.contains("timeout", ignoreCase = true) == true -> {
                    android.util.Log.e("FeedMediaRepository", "Erro de rede: problema de conex√£o")
                    "Erro de conex√£o. Verifique sua internet e tente novamente."
                }
                // Erro de tamanho de arquivo
                e.message?.contains("size", ignoreCase = true) == true ||
                e.message?.contains("too large", ignoreCase = true) == true -> {
                    android.util.Log.e("FeedMediaRepository", "Erro de tamanho: arquivo muito grande")
                    "Arquivo muito grande. Limite m√°ximo: 50MB."
                }
                // Erro de formato
                e.message?.contains("contentType", ignoreCase = true) == true ||
                e.message?.contains("format", ignoreCase = true) == true -> {
                    android.util.Log.e("FeedMediaRepository", "Erro de formato: tipo de arquivo n√£o suportado")
                    "Formato de arquivo n√£o suportado. Use imagens (JPG, PNG) ou v√≠deos (MP4)."
                }
                // Erro gen√©rico
                else -> {
                    android.util.Log.e("FeedMediaRepository", "Erro desconhecido: ${e.message}")
                    "Erro ao fazer upload: ${e.message ?: "Erro desconhecido. Tente novamente."}"
                }
            }
            Result.Error(Exception(errorMessage, e))
        }
    }
    
    /**
     * Faz upload de m√∫ltiplas m√≠dias
     */
    suspend fun uploadPostMediaBatch(
        uris: List<Uri>,
        userId: String,
        mediaTypes: List<String>
    ): Result<List<String>> {
        return try {
            if (uris.size != mediaTypes.size) {
                return Result.Error(Exception("N√∫mero de URIs e tipos de m√≠dia n√£o correspondem"))
            }
            
            val urls = mutableListOf<String>()
            for (i in uris.indices) {
                val result = uploadPostMedia(uris[i], userId, mediaTypes[i])
                when (result) {
                    is Result.Success -> urls.add(result.data)
                    is Result.Error -> return Result.Error(result.exception)
                    else -> return Result.Error(Exception("Resultado desconhecido"))
                }
            }
            
            Result.Success(urls)
        } catch (e: Exception) {
            android.util.Log.e("FeedMediaRepository", "Erro ao fazer upload em lote: ${e.message}", e)
            Result.Error(e)
        }
    }
    
    /**
     * Deleta uma m√≠dia do Storage
     */
    suspend fun deletePostMedia(mediaUrl: String): Result<Unit> {
        return try {
            val storageRef = storage.getReferenceFromUrl(mediaUrl)
            storageRef.delete().await()
            Result.Success(Unit)
        } catch (e: Exception) {
            android.util.Log.e("FeedMediaRepository", "Erro ao deletar m√≠dia: ${e.message}", e)
            Result.Error(e)
        }
    }
    
    /**
     * Faz upload de m√≠dia de Story para Firebase Storage
     * Segue a mesma l√≥gica de produtos e servi√ßos: sempre usa o userId do usu√°rio autenticado
     */
    suspend fun uploadStoryMedia(
        uri: Uri,
        userId: String,
        mediaType: String
    ): Result<String> {
        return try {
            // CR√çTICO: Sempre obter userId do usu√°rio autenticado (mesma l√≥gica de produtos/servi√ßos)
            val currentUser = authRepository.getCurrentUser()
            if (currentUser == null) {
                android.util.Log.e("FeedMediaRepository", "Usu√°rio n√£o autenticado")
                return Result.Error(Exception("Usu√°rio n√£o autenticado"))
            }
            
            // Usar sempre o userId do usu√°rio autenticado para garantir permiss√µes corretas
            val authenticatedUserId = currentUser.uid
            
            // Validar que o userId passado corresponde ao autenticado (seguran√ßa adicional)
            if (userId != authenticatedUserId) {
                android.util.Log.e("FeedMediaRepository", "UserId passado ($userId) n√£o corresponde ao autenticado ($authenticatedUserId)")
                return Result.Error(Exception("Permiss√£o negada: userId n√£o corresponde ao usu√°rio autenticado"))
            }
            
            val fileName = "${UUID.randomUUID()}_${System.currentTimeMillis()}"
            val extension = getFileExtension(uri, mediaType)
            val fullFileName = "$fileName.$extension"
            
            android.util.Log.d("FeedMediaRepository", "Upload de story - userId: $authenticatedUserId, path: stories/$authenticatedUserId/$fullFileName")
            
            // Criar refer√™ncia no Storage: stories/{userId}/{fileName} (mesma estrutura de produtos/servi√ßos)
            val storageRef: StorageReference = storage.reference
                .child(storiesStoragePath)
                .child(authenticatedUserId)
                .child(fullFileName)
            
            // Detectar contentType real do arquivo
            val actualContentType = try {
                context.contentResolver.getType(uri) ?: when (mediaType) {
                    "video" -> "video/mp4"
                    else -> "image/jpeg"
                }
            } catch (e: Exception) {
                when (mediaType) {
                    "video" -> "video/mp4"
                    else -> "image/jpeg"
                }
            }
            
            val metadata = com.google.firebase.storage.StorageMetadata.Builder()
                .setContentType(actualContentType)
                .build()
            
            val uploadTask = storageRef.putFile(uri, metadata)
            val uploadSnapshot = uploadTask.await()
            
            // Log informa√ß√µes do upload de story conclu√≠do (usando o snapshot para informa√ß√µes detalhadas)
            android.util.Log.d("FeedMediaRepository", "Story upload conclu√≠do com sucesso. Bytes transferidos: ${uploadSnapshot.bytesTransferred}, Total bytes: ${uploadSnapshot.totalByteCount}")
            
            // Obter URL de download usando a refer√™ncia original do storage
            val downloadUrl = storageRef.downloadUrl.await()
            Result.Success(downloadUrl.toString())
        } catch (e: Exception) {
            android.util.Log.e("FeedMediaRepository", "Erro ao fazer upload de story: ${e.message}", e)
            Result.Error(e)
        }
    }
    
    /**
     * Obt√©m a extens√£o do arquivo baseado no URI e tipo de m√≠dia
     * Usa ContentResolver para detectar MIME type correto
     */
    private fun getFileExtension(uri: Uri, mediaType: String): String {
        // Tentar obter MIME type usando ContentResolver primeiro
        val mimeType = try {
            context.contentResolver.getType(uri)
        } catch (e: Exception) {
            android.util.Log.w("FeedMediaRepository", "Erro ao obter MIME type: ${e.message}")
            null
        }
        
        // Se temos MIME type, extrair extens√£o dele
        if (mimeType != null) {
            return when {
                mimeType.startsWith("image/") -> mimeType.substringAfter("image/")
                mimeType.startsWith("video/") -> mimeType.substringAfter("video/")
                else -> {
                    // Fallback: tentar obter extens√£o do URI
                    val uriPath = uri.toString()
                    val lastDot = uriPath.lastIndexOf('.')
                    if (lastDot > 0 && lastDot < uriPath.length - 1) {
                        uriPath.substring(lastDot + 1).lowercase()
                    } else {
                        when (mediaType) {
                            "video" -> "mp4"
                            else -> "jpg"
                        }
                    }
                }
            }
        }
        
        // Fallback: tentar obter extens√£o do URI
        val uriPath = uri.toString()
        val lastDot = uriPath.lastIndexOf('.')
        if (lastDot > 0 && lastDot < uriPath.length - 1) {
            val extension = uriPath.substring(lastDot + 1).lowercase()
            if (extension.isNotEmpty() && (extension == "jpg" || extension == "jpeg" || extension == "png" || extension == "mp4" || extension == "mov")) {
                return extension
            }
        }
        
        // √öltimo fallback baseado no tipo de m√≠dia
        return when (mediaType) {
            "video" -> "mp4"
            "image" -> "jpg"
            else -> "jpg"
        }
    }
}

```

## [FRONTEND]: data/repository/FirebaseAuthRepository.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.data.repository

import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.auth.FirebaseUser
import com.google.firebase.auth.UserProfileChangeRequest
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.tasks.await
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class FirebaseAuthRepository @Inject constructor(
    private val firebaseAuth: FirebaseAuth
) {
    
    fun getCurrentUser(): FirebaseUser? {
        return firebaseAuth.currentUser
    }

    fun isLoggedIn(): Boolean {
        return firebaseAuth.currentUser != null
    }

    suspend fun signUpWithEmail(email: String, password: String): Result<FirebaseUser> {
        return try {
            android.util.Log.d("FirebaseAuthRepository", "Criando usu√°rio com email: $email")
            android.util.Log.d("FirebaseAuthRepository", "FirebaseAuth instance: $firebaseAuth")
            android.util.Log.d("FirebaseAuthRepository", "FirebaseApp: ${com.google.firebase.FirebaseApp.getInstance().name}")
            
            val result = firebaseAuth.createUserWithEmailAndPassword(email, password).await()
            val user = result.user ?: throw Exception("User is null")
            
            android.util.Log.d("FirebaseAuthRepository", "Usu√°rio criado com sucesso: ${user.uid}, email: ${user.email}")
            Result.success(user)
        } catch (e: Exception) {
            android.util.Log.e("FirebaseAuthRepository", "Erro ao criar usu√°rio: ${e.message}", e)
            android.util.Log.e("FirebaseAuthRepository", "Tipo de erro: ${e.javaClass.simpleName}")
            Result.failure(e)
        }
    }

    suspend fun signInWithEmail(email: String, password: String): Result<FirebaseUser> {
        return try {
            // Verificar se Firebase Auth est√° inicializado
            if (firebaseAuth.app == null) {
                android.util.Log.e("FirebaseAuthRepository", "‚ùå Firebase Auth n√£o inicializado")
                return Result.failure(Exception("Firebase Auth n√£o inicializado. Reinicie o app."))
            }
            
            android.util.Log.d("FirebaseAuthRepository", "=== IN√çCIO LOGIN ===")
            android.util.Log.d("FirebaseAuthRepository", "Email: $email")
            android.util.Log.d("FirebaseAuthRepository", "BuildConfig.DEBUG: ${com.taskgoapp.taskgo.BuildConfig.DEBUG}")
            android.util.Log.d("FirebaseAuthRepository", "App Check Enabled: ${com.taskgoapp.taskgo.BuildConfig.FIREBASE_APP_CHECK_ENABLED}")
            
            // Diagnosticar conectividade em background (n√£o bloqueia)
            val appContext = firebaseAuth.app.applicationContext
            try {
                val diagnostic = com.taskgoapp.taskgo.core.network.NetworkDiagnostic.diagnose(appContext)
                android.util.Log.d("FirebaseAuthRepository", "Diagn√≥stico de rede: Internet=${diagnostic.hasInternet}, Firebase=${diagnostic.canReachFirebase}")
            } catch (e: Exception) {
                android.util.Log.w("FirebaseAuthRepository", "Erro ao diagnosticar rede (continuando): ${e.message}")
            }
            
            android.util.Log.d("FirebaseAuthRepository", "Chamando signInWithEmailAndPassword...")
            val result = firebaseAuth.signInWithEmailAndPassword(email, password).await()
            android.util.Log.d("FirebaseAuthRepository", "=== LOGIN BEM-SUCEDIDO ===")
            android.util.Log.d("FirebaseAuthRepository", "UID: ${result.user?.uid}")
            android.util.Log.d("FirebaseAuthRepository", "Email: ${result.user?.email}")
            android.util.Log.d("FirebaseAuthRepository", "Email Verified: ${result.user?.isEmailVerified}")
            Result.success(result.user ?: throw Exception("User is null"))
        } catch (e: Exception) {
            android.util.Log.e("FirebaseAuthRepository", "=== ERRO NO LOGIN ===")
            android.util.Log.e("FirebaseAuthRepository", "Tipo: ${e.javaClass.name}")
            android.util.Log.e("FirebaseAuthRepository", "Mensagem: ${e.message}")
            android.util.Log.e("FirebaseAuthRepository", "Stack trace completo:", e)
            
            // Log mais detalhado do erro
            val errorMsg = e.message ?: ""
            val fullStackTrace = e.stackTraceToString()
            
            when (e) {
                is com.google.firebase.FirebaseNetworkException -> {
                    android.util.Log.e("FirebaseAuthRepository", "Erro de rede do Firebase")
                    
                    // Verificar se o erro est√° relacionado ao App Check ou API bloqueada
                    if (errorMsg.contains("app-check", ignoreCase = true) || 
                        errorMsg.contains("403", ignoreCase = true) ||
                        errorMsg.contains("API has not been used", ignoreCase = true) ||
                        errorMsg.contains("blocked", ignoreCase = true) ||
                        fullStackTrace.contains("API_KEY_SERVICE_BLOCKED", ignoreCase = true)) {
                        android.util.Log.e("FirebaseAuthRepository", "‚ö†Ô∏è ERRO RELACIONADO AO APP CHECK OU API KEY BLOQUEADA")
                        android.util.Log.e("FirebaseAuthRepository", "Poss√≠veis causas:")
                        android.util.Log.e("FirebaseAuthRepository", "   1. APIs do Firebase n√£o habilitadas no Google Cloud Console")
                        android.util.Log.e("FirebaseAuthRepository", "   2. API Key com restri√ß√µes bloqueando as APIs necess√°rias")
                        android.util.Log.e("FirebaseAuthRepository", "Consulte CORRECAO_API_KEY_BLOQUEADA.md para resolver")
                        android.util.Log.e("FirebaseAuthRepository", "API Key: ${com.google.firebase.FirebaseApp.getInstance().options.apiKey}")
                    }
                }
                is com.google.firebase.auth.FirebaseAuthException -> {
                    android.util.Log.e("FirebaseAuthRepository", "=== FIREBASE AUTH EXCEPTION ===")
                    android.util.Log.e("FirebaseAuthRepository", "Error Code: ${e.errorCode}")
                    android.util.Log.e("FirebaseAuthRepository", "Error Message: ${e.message}")
                    android.util.Log.e("FirebaseAuthRepository", "Full Stack Trace:")
                    android.util.Log.e("FirebaseAuthRepository", fullStackTrace)
                    
                    // Verificar se √© erro relacionado ao App Check
                    val isAppCheckError = errorMsg.contains("app-check", ignoreCase = true) || 
                        errorMsg.contains("App Check token is invalid", ignoreCase = true) ||
                        errorMsg.contains("app check", ignoreCase = true) ||
                        fullStackTrace.contains("appcheck", ignoreCase = true) ||
                        fullStackTrace.contains("AppCheck", ignoreCase = true)
                    
                    if (isAppCheckError) {
                        android.util.Log.e("FirebaseAuthRepository", "üî¥ ERRO CR√çTICO: APP CHECK FALHANDO")
                        android.util.Log.e("FirebaseAuthRepository", "Causa: Token do App Check inv√°lido ou n√£o gerado")
                        android.util.Log.e("FirebaseAuthRepository", "Solu√ß√µes:")
                        android.util.Log.e("FirebaseAuthRepository", "  1. Verificar SHA-256 cadastrado no Firebase Console")
                        android.util.Log.e("FirebaseAuthRepository", "  2. Verificar Play Integrity API habilitada no Google Cloud")
                        android.util.Log.e("FirebaseAuthRepository", "  3. Verificar App Check configurado no Firebase Console")
                        android.util.Log.e("FirebaseAuthRepository", "  4. Se app n√£o est√° na Play Store, Play Integrity n√£o funciona")
                    }
                    
                    // Verificar se √© erro de API bloqueada
                    if (errorMsg.contains("403", ignoreCase = true) ||
                        errorMsg.contains("blocked", ignoreCase = true) ||
                        fullStackTrace.contains("API_KEY_SERVICE_BLOCKED", ignoreCase = true)) {
                        android.util.Log.e("FirebaseAuthRepository", "‚ö†Ô∏è ERRO: API KEY BLOQUEADA")
                        android.util.Log.e("FirebaseAuthRepository", "API Key: ${com.google.firebase.FirebaseApp.getInstance().options.apiKey}")
                    }
                }
                is java.net.UnknownHostException -> {
                    android.util.Log.e("FirebaseAuthRepository", "‚ùå Host desconhecido - problema de DNS ou conex√£o")
                    android.util.Log.e("FirebaseAuthRepository", "SOLU√á√ÉO:")
                    android.util.Log.e("FirebaseAuthRepository", "   1. Verifique sua conex√£o com a internet")
                    android.util.Log.e("FirebaseAuthRepository", "   2. Verifique as configura√ß√µes de DNS do dispositivo")
                    android.util.Log.e("FirebaseAuthRepository", "   3. Verifique se h√° firewall ou proxy bloqueando")
                    android.util.Log.e("FirebaseAuthRepository", "   4. Tente reiniciar o dispositivo")
                }
                is java.net.ConnectException -> {
                    android.util.Log.e("FirebaseAuthRepository", "‚ùå Erro de conex√£o - n√£o foi poss√≠vel conectar ao servidor")
                    android.util.Log.e("FirebaseAuthRepository", "SOLU√á√ÉO:")
                    android.util.Log.e("FirebaseAuthRepository", "   1. Verifique sua conex√£o com a internet")
                    android.util.Log.e("FirebaseAuthRepository", "   2. Verifique se h√° firewall bloqueando")
                    android.util.Log.e("FirebaseAuthRepository", "   3. Verifique se o dispositivo est√° em uma rede corporativa/VPN")
                    android.util.Log.e("FirebaseAuthRepository", "   4. Consulte DIAGNOSTICO_CONECTIVIDADE.md para mais informa√ß√µes")
                }
                is java.net.SocketTimeoutException -> {
                    android.util.Log.e("FirebaseAuthRepository", "‚ùå Timeout de conex√£o")
                    android.util.Log.e("FirebaseAuthRepository", "SOLU√á√ÉO:")
                    android.util.Log.e("FirebaseAuthRepository", "   1. Verifique sua conex√£o com a internet")
                    android.util.Log.e("FirebaseAuthRepository", "   2. Verifique se h√° firewall bloqueando")
                    android.util.Log.e("FirebaseAuthRepository", "   3. Tente novamente em alguns instantes")
                }
            }
            
            // Verificar se o erro pode estar relacionado ao App Check mesmo que n√£o seja uma exce√ß√£o espec√≠fica
            val errorMessage = e.message ?: ""
            if (errorMessage.contains("network error", ignoreCase = true) && 
                errorMessage.contains("timeout", ignoreCase = true)) {
                android.util.Log.w("FirebaseAuthRepository", "‚ö†Ô∏è Este erro de rede pode estar relacionado ao App Check n√£o configurado")
                android.util.Log.w("FirebaseAuthRepository", "Verifique se as APIs do Firebase est√£o habilitadas no Google Cloud Console")
            }
            
            Result.failure(e)
        }
    }

    fun signOut() {
        // CR√çTICO: Limpar dados locais antes de fazer logout para evitar mistura de dados
        firebaseAuth.signOut()
    }

    suspend fun resetPassword(email: String): Result<Unit> {
        return try {
            firebaseAuth.sendPasswordResetEmail(email).await()
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    suspend fun updateProfile(displayName: String, photoUrl: String? = null): Result<Unit> {
        return try {
            val user = firebaseAuth.currentUser
                ?: return Result.failure(Exception("No user signed in"))
            
            val profileUpdates = UserProfileChangeRequest.Builder()
                .setDisplayName(displayName)
                .apply {
                    if (photoUrl != null) {
                        setPhotoUri(android.net.Uri.parse(photoUrl))
                    }
                }
                .build()
            
            user.updateProfile(profileUpdates).await()
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    suspend fun updateEmail(newEmail: String): Result<Unit> {
        return try {
            val user = firebaseAuth.currentUser
                ?: return Result.failure(Exception("No user signed in"))
            user.updateEmail(newEmail).await()
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    suspend fun updatePassword(newPassword: String): Result<Unit> {
        return try {
            val user = firebaseAuth.currentUser
                ?: return Result.failure(Exception("No user signed in"))
            user.updatePassword(newPassword).await()
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    suspend fun reauthenticate(password: String): Result<Unit> {
        return try {
            val user = firebaseAuth.currentUser
                ?: return Result.failure(Exception("No user signed in"))
            
            val email = user.email ?: return Result.failure(Exception("User email is null"))
            val credential = com.google.firebase.auth.EmailAuthProvider.getCredential(email, password)
            
            user.reauthenticate(credential).await()
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    suspend fun deleteAccount(): Result<Unit> {
        return try {
            val user = firebaseAuth.currentUser
                ?: return Result.failure(Exception("No user signed in"))
            user.delete().await()
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    suspend fun signInWithGoogle(idToken: String): Result<FirebaseUser> {
        return try {
            // Verificar se Firebase Auth est√° inicializado
            if (firebaseAuth.app == null) {
                android.util.Log.e("FirebaseAuthRepository", "‚ùå Firebase Auth n√£o inicializado")
                return Result.failure(Exception("Firebase Auth n√£o inicializado. Reinicie o app."))
            }
            
            android.util.Log.d("FirebaseAuthRepository", "Iniciando login com Google")
            
            val credential = com.google.firebase.auth.GoogleAuthProvider.getCredential(idToken, null)
            val result = firebaseAuth.signInWithCredential(credential).await()
            val user = result.user ?: throw Exception("User is null")
            
            android.util.Log.d("FirebaseAuthRepository", "‚úÖ Login com Google bem-sucedido: ${user.uid}, email: ${user.email}")
            Result.success(user)
        } catch (e: Exception) {
            android.util.Log.e("FirebaseAuthRepository", "‚ùå Erro ao fazer login com Google: ${e.message}", e)
            if (e is com.google.firebase.auth.FirebaseAuthException) {
                android.util.Log.e("FirebaseAuthRepository", "C√≥digo de erro Firebase: ${e.errorCode}")
            }
            Result.failure(e)
        }
    }

    fun observeAuthState(): Flow<FirebaseUser?> = callbackFlow {
        val listener = FirebaseAuth.AuthStateListener { auth ->
            trySend(auth.currentUser)
        }
        firebaseAuth.addAuthStateListener(listener)
        awaitClose { firebaseAuth.removeAuthStateListener(listener) }
    }
}






```

## [FRONTEND]: data/repository/FirebaseStorageRepository.kt

```kotlin
package com.taskgoapp.taskgo.data.repository

import android.net.Uri
import com.google.firebase.storage.FirebaseStorage
import kotlinx.coroutines.tasks.await
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class FirebaseStorageRepository @Inject constructor(
    private val storage: FirebaseStorage
) {
    
    suspend fun uploadDocument(
        userId: String,
        documentType: String,
        uri: Uri
    ): Result<String> {
        return try {
            val fileName = "${System.currentTimeMillis()}_${uri.lastPathSegment ?: "document"}"
            val storageRef = storage.reference
                .child("$userId/documents/$documentType/$fileName")
            
            storageRef.putFile(uri).await()
            val downloadUrl = storageRef.downloadUrl.await()
            
            Result.success(downloadUrl.toString())
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    suspend fun uploadSelfie(
        userId: String,
        uri: Uri
    ): Result<String> {
        return try {
            val fileName = "${System.currentTimeMillis()}_selfie.jpg"
            val storageRef = storage.reference
                .child("$userId/documents/selfie/$fileName")
            
            storageRef.putFile(uri).await()
            val downloadUrl = storageRef.downloadUrl.await()
            
            Result.success(downloadUrl.toString())
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    suspend fun uploadAddressProof(
        userId: String,
        uri: Uri
    ): Result<String> {
        return try {
            val fileName = "${System.currentTimeMillis()}_address_proof.jpg"
            val storageRef = storage.reference
                .child("$userId/documents/address_proof/$fileName")
            
            storageRef.putFile(uri).await()
            val downloadUrl = storageRef.downloadUrl.await()
            
            Result.success(downloadUrl.toString())
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    /**
     * Upload de imagem para servi√ßo
     * Path: {providerId}/services/{serviceId}/images/{filename}
     */
    suspend fun uploadServiceImage(
        providerId: String,
        serviceId: String,
        uri: Uri,
        imageIndex: Int = 0
    ): Result<String> {
        return try {
            val extension = uri.lastPathSegment?.substringAfterLast('.', "jpg") ?: "jpg"
            val fileName = "${System.currentTimeMillis()}_img_$imageIndex.$extension"
            val storageRef = storage.reference
                .child("$providerId/services/$serviceId/images/$fileName")
            
            storageRef.putFile(uri).await()
            val downloadUrl = storageRef.downloadUrl.await()
            
            Result.success(downloadUrl.toString())
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    /**
     * Upload de v√≠deo MP4 para servi√ßo
     * Path: {providerId}/services/{serviceId}/videos/{filename}
     */
    suspend fun uploadServiceVideo(
        providerId: String,
        serviceId: String,
        uri: Uri,
        videoIndex: Int = 0
    ): Result<String> {
        return try {
            val fileName = "${System.currentTimeMillis()}_video_$videoIndex.mp4"
            val storageRef = storage.reference
                .child("$providerId/services/$serviceId/videos/$fileName")
            
            // Metadata para v√≠deo
            val metadata = com.google.firebase.storage.StorageMetadata.Builder()
                .setContentType("video/mp4")
                .build()
            
            val uploadTask = storageRef.putFile(uri, metadata).await()
            val downloadUrl = uploadTask.storage.downloadUrl.await()
            
            Result.success(downloadUrl.toString())
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    /**
     * Upload de foto de perfil do usu√°rio
     * Path: {userId}/profile/{filename}
     */
    suspend fun uploadProfileImage(
        userId: String,
        uri: Uri
    ): Result<String> {
        return try {
            val extension = uri.lastPathSegment?.substringAfterLast('.', "jpg") ?: "jpg"
            val fileName = "${System.currentTimeMillis()}_profile.$extension"
            val storageRef = storage.reference
                .child("$userId/profile/$fileName")
            
            storageRef.putFile(uri).await()
            val downloadUrl = storageRef.downloadUrl.await()
            
            Result.success(downloadUrl.toString())
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    /**
     * Upload de imagem para produto
     * Path: {sellerId}/products/{productId}/images/{filename}
     */
    suspend fun uploadProductImage(
        userId: String,
        productId: String,
        uri: Uri,
        imageIndex: Int = 0
    ): Result<String> {
        return try {
            val extension = uri.lastPathSegment?.substringAfterLast('.', "jpg") ?: "jpg"
            val fileName = "${System.currentTimeMillis()}_img_$imageIndex.$extension"
            val storageRef = storage.reference
                .child("$userId/products/$productId/images/$fileName")
            
            storageRef.putFile(uri).await()
            val downloadUrl = storageRef.downloadUrl.await()
            
            Result.success(downloadUrl.toString())
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    /**
     * Deleta arquivo do Storage
     */
    suspend fun deleteFile(downloadUrl: String): Result<Unit> {
        return try {
            val storageRef = storage.getReferenceFromUrl(downloadUrl)
            storageRef.delete().await()
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}



```

## [FRONTEND]: data/repository/FirestoreAccountChangeRepository.kt

```kotlin
package com.taskgoapp.taskgo.data.repository

import com.taskgoapp.taskgo.data.firestore.models.AccountChangeRequest
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.FieldValue
import kotlinx.coroutines.tasks.await
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.channels.awaitClose
import java.util.Calendar
import java.util.Date
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class FirestoreAccountChangeRepository @Inject constructor(
    private val firestore: FirebaseFirestore
) {
    private val accountChangeRequestsCollection = firestore.collection("account_change_requests")
    
    /**
     * Cria uma solicita√ß√£o de mudan√ßa de modo de conta
     * Calcula automaticamente a data de processamento (1 dia √∫til)
     */
    suspend fun createAccountChangeRequest(
        userId: String,
        currentAccountType: String,
        requestedAccountType: String
    ): Result<String> {
        return try {
            // Calcular data de processamento (1 dia √∫til)
            val scheduledDate = calculateNextBusinessDay(Date())
            
            // Converter Date para Timestamp do Firestore
            val scheduledTimestamp = com.google.firebase.Timestamp(scheduledDate)
            val requestedTimestamp = com.google.firebase.Timestamp.now()
            
            // Criar mapa de dados com Timestamps para evitar problemas de serializa√ß√£o
            val requestData = mapOf(
                "userId" to userId,
                "currentAccountType" to currentAccountType,
                "requestedAccountType" to requestedAccountType,
                "status" to "PENDING",
                "requestedAt" to requestedTimestamp,
                "scheduledProcessDate" to scheduledTimestamp,
                "createdAt" to FieldValue.serverTimestamp(),
                "updatedAt" to FieldValue.serverTimestamp()
            )
            
            val docRef = accountChangeRequestsCollection.add(requestData).await()
            
            android.util.Log.d("AccountChangeRepo", "Solicita√ß√£o de mudan√ßa criada: ${docRef.id} para usu√°rio $userId")
            Result.success(docRef.id)
        } catch (e: Exception) {
            android.util.Log.e("AccountChangeRepo", "Erro ao criar solicita√ß√£o: ${e.message}", e)
            Result.failure(e)
        }
    }
    
    /**
     * Busca solicita√ß√µes pendentes de um usu√°rio
     */
    suspend fun getPendingRequest(userId: String): AccountChangeRequest? {
        return try {
            val snapshot = accountChangeRequestsCollection
                .whereEqualTo("userId", userId)
                .whereEqualTo("status", "PENDING")
                .orderBy("requestedAt", com.google.firebase.firestore.Query.Direction.DESCENDING)
                .limit(1)
                .get()
                .await()
            
            snapshot.documents.firstOrNull()?.let { doc ->
                doc.toObject(AccountChangeRequest::class.java)?.copy(id = doc.id)
            }
        } catch (e: Exception) {
            android.util.Log.e("AccountChangeRepo", "Erro ao buscar solicita√ß√£o pendente: ${e.message}", e)
            null
        }
    }
    
    /**
     * Observa solicita√ß√µes de mudan√ßa de conta de um usu√°rio
     */
    fun observeUserRequests(userId: String): Flow<List<AccountChangeRequest>> = callbackFlow {
        try {
            val listenerRegistration = accountChangeRequestsCollection
                .whereEqualTo("userId", userId)
                .orderBy("requestedAt", com.google.firebase.firestore.Query.Direction.DESCENDING)
                .addSnapshotListener { snapshot, error ->
                    if (error != null) {
                        android.util.Log.e("AccountChangeRepo", "Erro ao observar solicita√ß√µes: ${error.message}", error)
                        trySend(emptyList())
                        return@addSnapshotListener
                    }
                    
                    val requests = snapshot?.documents?.mapNotNull { doc ->
                        try {
                            doc.toObject(AccountChangeRequest::class.java)?.copy(id = doc.id)
                        } catch (e: Exception) {
                            android.util.Log.e("AccountChangeRepo", "Erro ao converter documento: ${e.message}", e)
                            null
                        }
                    } ?: emptyList()
                    
                    trySend(requests)
                }
            
            awaitClose { listenerRegistration.remove() }
        } catch (e: Exception) {
            android.util.Log.e("AccountChangeRepo", "Erro ao observar solicita√ß√µes: ${e.message}", e)
            close(e)
        }
    }
    
    /**
     * Atualiza o status de uma solicita√ß√£o
     */
    suspend fun updateRequestStatus(
        requestId: String,
        status: String,
        processedBy: String? = null,
        rejectionReason: String? = null
    ): Result<Unit> {
        return try {
            val updateData = mutableMapOf<String, Any>(
                "status" to status,
                "updatedAt" to FieldValue.serverTimestamp()
            )
            
            if (status == "PROCESSED") {
                updateData["processedAt"] = FieldValue.serverTimestamp()
                processedBy?.let { updateData["processedBy"] = it }
            }
            
            if (status == "REJECTED" && rejectionReason != null) {
                updateData["rejectionReason"] = rejectionReason
            }
            
            accountChangeRequestsCollection.document(requestId).update(updateData).await()
            
            android.util.Log.d("AccountChangeRepo", "Status da solicita√ß√£o $requestId atualizado para $status")
            Result.success(Unit)
        } catch (e: Exception) {
            android.util.Log.e("AccountChangeRepo", "Erro ao atualizar status: ${e.message}", e)
            Result.failure(e)
        }
    }
    
    /**
     * Busca todas as solicita√ß√µes pendentes que devem ser processadas
     * (scheduledProcessDate <= hoje e status = PENDING)
     */
    suspend fun getPendingRequestsToProcess(): List<AccountChangeRequest> {
        return try {
            val today = Calendar.getInstance().apply {
                set(Calendar.HOUR_OF_DAY, 0)
                set(Calendar.MINUTE, 0)
                set(Calendar.SECOND, 0)
                set(Calendar.MILLISECOND, 0)
            }.time
            
            val snapshot = accountChangeRequestsCollection
                .whereEqualTo("status", "PENDING")
                .whereLessThanOrEqualTo("scheduledProcessDate", today)
                .get()
                .await()
            
            snapshot.documents.mapNotNull { doc ->
                try {
                    doc.toObject(AccountChangeRequest::class.java)?.copy(id = doc.id)
                } catch (e: Exception) {
                    android.util.Log.e("AccountChangeRepo", "Erro ao converter documento: ${e.message}", e)
                    null
                }
            }
        } catch (e: Exception) {
            android.util.Log.e("AccountChangeRepo", "Erro ao buscar solicita√ß√µes pendentes: ${e.message}", e)
            emptyList()
        }
    }
    
    /**
     * Calcula o pr√≥ximo dia √∫til (1 dia √∫til a partir de hoje)
     * Ignora s√°bados e domingos
     */
    private fun calculateNextBusinessDay(startDate: Date): Date {
        val calendar = Calendar.getInstance().apply {
            time = startDate
            add(Calendar.DAY_OF_MONTH, 1) // Come√ßar do dia seguinte
        }
        
        // Avan√ßar at√© encontrar um dia √∫til (segunda a sexta)
        while (calendar.get(Calendar.DAY_OF_WEEK) == Calendar.SATURDAY || 
               calendar.get(Calendar.DAY_OF_WEEK) == Calendar.SUNDAY) {
            calendar.add(Calendar.DAY_OF_MONTH, 1)
        }
        
        // Zerar horas para comparar apenas a data
        calendar.set(Calendar.HOUR_OF_DAY, 0)
        calendar.set(Calendar.MINUTE, 0)
        calendar.set(Calendar.SECOND, 0)
        calendar.set(Calendar.MILLISECOND, 0)
        
        return calendar.time
    }
}


```

## [FRONTEND]: data/repository/FirestoreBankAccountRepository.kt

```kotlin
package com.taskgoapp.taskgo.data.repository

import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.ListenerRegistration
import com.google.firebase.firestore.SetOptions
import com.taskgoapp.taskgo.data.firestore.models.BankAccount
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.tasks.await
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class FirestoreBankAccountRepository @Inject constructor(
    private val firestore: FirebaseFirestore,
    private val firebaseAuth: FirebaseAuth
) {
    
    private val collection = firestore.collection("bank_accounts")
    
    /**
     * Observa todas as contas banc√°rias do usu√°rio atual
     * CR√çTICO: Sempre usa o userId do usu√°rio autenticado
     */
    fun observeUserBankAccounts(): Flow<List<BankAccount>> = callbackFlow {
        // CR√çTICO: Sempre obter userId do usu√°rio autenticado
        val currentUser = firebaseAuth.currentUser
        if (currentUser == null) {
            android.util.Log.w("BankAccountRepo", "Usu√°rio n√£o autenticado ao observar contas banc√°rias")
            trySend(emptyList())
            close()
            return@callbackFlow
        }
        
        val authenticatedUserId = currentUser.uid
        android.util.Log.d("BankAccountRepo", "Observando contas banc√°rias do usu√°rio: $authenticatedUserId")
        
        val listener = collection
            .whereEqualTo("userId", authenticatedUserId)
            .addSnapshotListener { snapshot, error ->
                if (error != null) {
                    android.util.Log.e("BankAccountRepo", "Erro ao observar contas banc√°rias: ${error.message}", error)
                    close(error)
                    return@addSnapshotListener
                }
                
                val accounts = snapshot?.documents?.mapNotNull { doc ->
                    try {
                        val account = doc.toBankAccount(doc.id)
                        // Valida√ß√£o adicional: garantir que a conta pertence ao usu√°rio autenticado
                        if (account.userId != authenticatedUserId) {
                            android.util.Log.w("BankAccountRepo", "Conta banc√°ria ${doc.id} pertence a outro usu√°rio (${account.userId} != $authenticatedUserId), ignorando")
                            null
                        } else {
                            account
                        }
                    } catch (e: Exception) {
                        android.util.Log.e("BankAccountRepo", "Erro ao converter conta banc√°ria: ${e.message}", e)
                        null
                    }
                } ?: emptyList()
                
                android.util.Log.d("BankAccountRepo", "Contas banc√°rias observadas: ${accounts.size}")
                trySend(accounts)
            }
        
        awaitClose { listener.remove() }
    }
    
    /**
     * Obt√©m uma conta banc√°ria por ID
     */
    suspend fun getBankAccount(accountId: String): BankAccount? {
        return try {
            val doc = collection.document(accountId).get().await()
            if (doc.exists()) {
                doc.toBankAccount(doc.id)
            } else {
                null
            }
        } catch (e: Exception) {
            android.util.Log.e("BankAccountRepo", "Erro ao obter conta banc√°ria: ${e.message}", e)
            null
        }
    }
    
    /**
     * Cria ou atualiza uma conta banc√°ria
     * CR√çTICO: Sempre usa o userId do usu√°rio autenticado para garantir permiss√µes corretas
     */
    suspend fun saveBankAccount(account: BankAccount): Result<String> {
        return try {
            // CR√çTICO: Sempre obter userId do usu√°rio autenticado (mesma l√≥gica de produtos/servi√ßos/feed)
            val currentUser = firebaseAuth.currentUser
            if (currentUser == null) {
                android.util.Log.e("BankAccountRepo", "Usu√°rio n√£o autenticado")
                return Result.failure(Exception("Usu√°rio n√£o autenticado"))
            }
            
            // Usar sempre o userId do usu√°rio autenticado para garantir permiss√µes corretas
            val authenticatedUserId = currentUser.uid
            
            // Se estiver editando, validar que a conta pertence ao usu√°rio autenticado
            if (account.id.isNotBlank()) {
                val existingAccount = getBankAccount(account.id)
                if (existingAccount == null) {
                    android.util.Log.e("BankAccountRepo", "Conta banc√°ria n√£o encontrada: ${account.id}")
                    return Result.failure(Exception("Conta banc√°ria n√£o encontrada"))
                }
                if (existingAccount.userId != authenticatedUserId) {
                    android.util.Log.e("BankAccountRepo", "Permiss√£o negada: conta pertence a outro usu√°rio (${existingAccount.userId} != $authenticatedUserId)")
                    return Result.failure(Exception("Permiss√£o negada: voc√™ n√£o pode editar esta conta banc√°ria"))
                }
            }
            
            // Garantir que o userId sempre seja o do usu√°rio autenticado
            val accountToSave = account.copy(
                userId = authenticatedUserId
            )
            val accountData = accountToSave.toMap().toMutableMap()
            
            val docRef = if (account.id.isBlank()) {
                // Nova conta - criar novo documento
                collection.document()
            } else {
                // Editar conta existente - usar o ID existente
                collection.document(account.id)
            }
            
            if (account.id.isBlank()) {
                accountData["createdAt"] = com.google.firebase.firestore.FieldValue.serverTimestamp()
            }
            
            android.util.Log.d("BankAccountRepo", "Salvando conta banc√°ria - userId: $authenticatedUserId, accountId: ${docRef.id}, isNew: ${account.id.isBlank()}")
            
            docRef.set(accountData, SetOptions.merge()).await()
            
            android.util.Log.d("BankAccountRepo", "Conta banc√°ria salva com sucesso: ${docRef.id}")
            
            // Se esta √© a conta padr√£o, remover padr√£o das outras
            if (account.isDefault) {
                val otherDefaultAccounts = collection
                    .whereEqualTo("userId", authenticatedUserId)
                    .whereEqualTo("isDefault", true)
                    .get()
                    .await()
                    .documents
                    .filter { it.id != docRef.id }
                
                if (otherDefaultAccounts.isNotEmpty()) {
                    android.util.Log.d("BankAccountRepo", "Removendo padr√£o de ${otherDefaultAccounts.size} outras contas")
                    otherDefaultAccounts.forEach { doc ->
                        doc.reference.update("isDefault", false).await()
                    }
                }
            }
            
            Result.success(docRef.id)
        } catch (e: Exception) {
            android.util.Log.e("BankAccountRepo", "Erro ao salvar conta banc√°ria: ${e.message}", e)
            android.util.Log.e("BankAccountRepo", "Stack trace:", e)
            Result.failure(e)
        }
    }
    
    /**
     * Deleta uma conta banc√°ria
     * CR√çTICO: Valida que a conta pertence ao usu√°rio autenticado
     */
    suspend fun deleteBankAccount(accountId: String): Result<Unit> {
        return try {
            // CR√çTICO: Sempre obter userId do usu√°rio autenticado
            val currentUser = firebaseAuth.currentUser
            if (currentUser == null) {
                android.util.Log.e("BankAccountRepo", "Usu√°rio n√£o autenticado ao deletar conta")
                return Result.failure(Exception("Usu√°rio n√£o autenticado"))
            }
            
            val authenticatedUserId = currentUser.uid
            
            val account = getBankAccount(accountId)
            if (account == null) {
                android.util.Log.e("BankAccountRepo", "Conta banc√°ria n√£o encontrada: $accountId")
                return Result.failure(Exception("Conta banc√°ria n√£o encontrada"))
            }
            
            if (account.userId != authenticatedUserId) {
                android.util.Log.e("BankAccountRepo", "Permiss√£o negada: conta pertence a outro usu√°rio (${account.userId} != $authenticatedUserId)")
                return Result.failure(Exception("Sem permiss√£o para deletar esta conta"))
            }
            
            android.util.Log.d("BankAccountRepo", "Deletando conta banc√°ria: $accountId")
            collection.document(accountId).delete().await()
            android.util.Log.d("BankAccountRepo", "Conta banc√°ria deletada com sucesso: $accountId")
            Result.success(Unit)
        } catch (e: Exception) {
            android.util.Log.e("BankAccountRepo", "Erro ao deletar conta banc√°ria: ${e.message}", e)
            android.util.Log.e("BankAccountRepo", "Stack trace:", e)
            Result.failure(e)
        }
    }
    
    /**
     * Obt√©m a conta banc√°ria padr√£o do usu√°rio
     */
    suspend fun getDefaultBankAccount(): BankAccount? {
        return try {
            val currentUser = firebaseAuth.currentUser
            if (currentUser == null) return null
            
            val snapshot = collection
                .whereEqualTo("userId", currentUser.uid)
                .whereEqualTo("isDefault", true)
                .limit(1)
                .get()
                .await()
            
            snapshot.documents.firstOrNull()?.let { doc ->
                doc.toBankAccount(doc.id)
            }
        } catch (e: Exception) {
            android.util.Log.e("BankAccountRepo", "Erro ao obter conta padr√£o: ${e.message}", e)
            null
        }
    }
}

// Extension functions para convers√£o
private fun com.google.firebase.firestore.DocumentSnapshot.toBankAccount(id: String): BankAccount {
    return BankAccount(
        id = id,
        userId = getString("userId") ?: "",
        bankName = getString("bankName") ?: "",
        bankCode = getString("bankCode") ?: "",
        agency = getString("agency") ?: "",
        account = getString("account") ?: "",
        accountType = getString("accountType") ?: "",
        accountHolderName = getString("accountHolderName") ?: "",
        accountHolderDocument = getString("accountHolderDocument") ?: "",
        accountHolderDocumentType = getString("accountHolderDocumentType") ?: "",
        stripeAccountId = getString("stripeAccountId"),
        isDefault = getBoolean("isDefault") ?: false,
        isVerified = getBoolean("isVerified") ?: false,
        createdAt = getDate("createdAt"),
        updatedAt = getDate("updatedAt")
    )
}

private fun BankAccount.toMap(): Map<String, Any?> {
    return mapOf(
        "userId" to userId,
        "bankName" to bankName,
        "bankCode" to bankCode,
        "agency" to agency,
        "account" to account,
        "accountType" to accountType,
        "accountHolderName" to accountHolderName,
        "accountHolderDocument" to accountHolderDocument,
        "accountHolderDocumentType" to accountHolderDocumentType,
        "stripeAccountId" to stripeAccountId,
        "isDefault" to isDefault,
        "isVerified" to isVerified,
        "updatedAt" to com.google.firebase.firestore.FieldValue.serverTimestamp()
    )
}


```

## [FRONTEND]: data/repository/FirestoreCategoriesRepository.kt

```kotlin
package com.taskgoapp.taskgo.data.repository

import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.Source
import com.taskgoapp.taskgo.core.data.models.ServiceCategory
import com.taskgoapp.taskgo.domain.repository.CategoriesRepository
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.tasks.await
import kotlinx.coroutines.channels.awaitClose
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class FirestoreCategoriesRepository @Inject constructor(
    private val firestore: FirebaseFirestore
) : CategoriesRepository {
    
    private val productCategoriesCollection = firestore.collection("product_categories")
    private val serviceCategoriesCollection = firestore.collection("service_categories")
    
    override fun observeProductCategories(): Flow<List<String>> = callbackFlow {
        // Primeiro, tentar buscar do cache (instant√¢neo)
        try {
            val cachedSnapshot = productCategoriesCollection
                .orderBy("name")
                .get(Source.CACHE)
                .await()
            
            val cachedCategories = cachedSnapshot.documents.mapNotNull { doc ->
                doc.getString("name")
            }
            
            if (cachedCategories.isNotEmpty()) {
                trySend(cachedCategories)
            } else {
                trySend(getDefaultProductCategories())
            }
        } catch (e: Exception) {
            // Se n√£o houver cache, usar categorias padr√£o
            trySend(getDefaultProductCategories())
        }
        
        // Depois, escutar mudan√ßas em tempo real
        val listenerRegistration = productCategoriesCollection
            .orderBy("name")
            .addSnapshotListener { snapshot, error ->
                if (error != null) {
                    // Se n√£o existir a cole√ß√£o, retorna categorias padr√£o
                    trySend(getDefaultProductCategories())
                    return@addSnapshotListener
                }
                
                val categories = snapshot?.documents?.mapNotNull { doc ->
                    doc.getString("name")
                } ?: getDefaultProductCategories()
                
                trySend(categories)
            }
        
        awaitClose { listenerRegistration.remove() }
    }
    
    override fun observeServiceCategories(): Flow<List<ServiceCategory>> = callbackFlow {
        var hasSentInitialData = false
        
        // Primeiro, tentar buscar do cache (instant√¢neo)
        try {
            val cachedSnapshot = serviceCategoriesCollection
                .orderBy("name")
                .get(Source.CACHE)
                .await()
            
            val cachedCategories = cachedSnapshot.documents.mapNotNull { doc ->
                ServiceCategory(
                    id = doc.id.toLongOrNull() ?: 0L,
                    name = doc.getString("name") ?: "",
                    icon = doc.getString("icon") ?: "",
                    description = doc.getString("description") ?: ""
                )
            }
            
            if (cachedCategories.isNotEmpty()) {
                trySend(cachedCategories)
                hasSentInitialData = true
            } else {
                val defaultCategories = getDefaultServiceCategories()
                trySend(defaultCategories)
                hasSentInitialData = true
            }
        } catch (e: Exception) {
            // Se n√£o houver cache, usar categorias padr√£o
            val defaultCategories = getDefaultServiceCategories()
            trySend(defaultCategories)
            hasSentInitialData = true
        }
        
        // Depois, escutar mudan√ßas em tempo real
        val listenerRegistration = serviceCategoriesCollection
            .orderBy("name")
            .addSnapshotListener { snapshot, error ->
                if (error != null) {
                    // Se n√£o existir a cole√ß√£o e ainda n√£o enviamos dados, retorna categorias padr√£o
                    if (!hasSentInitialData) {
                        trySend(getDefaultServiceCategories())
                    }
                    return@addSnapshotListener
                }
                
                val categories = snapshot?.documents?.mapNotNull { doc ->
                    ServiceCategory(
                        id = doc.id.toLongOrNull() ?: 0L,
                        name = doc.getString("name") ?: "",
                        icon = doc.getString("icon") ?: "",
                        description = doc.getString("description") ?: ""
                    )
                } ?: getDefaultServiceCategories()
                
                // S√≥ enviar se houver dados v√°lidos ou se ainda n√£o enviamos nada
                if (categories.isNotEmpty() || !hasSentInitialData) {
                    trySend(categories)
                    hasSentInitialData = true
                }
            }
        
        awaitClose { listenerRegistration.remove() }
    }
    
    override suspend fun getProductCategories(): List<String> {
        return try {
            val snapshot = productCategoriesCollection.get().await()
            snapshot.documents.mapNotNull { doc ->
                doc.getString("name")
            }.ifEmpty { getDefaultProductCategories() }
        } catch (e: Exception) {
            getDefaultProductCategories()
        }
    }
    
    override suspend fun getServiceCategories(): List<ServiceCategory> {
        return try {
            val snapshot = serviceCategoriesCollection.get().await()
            snapshot.documents.mapNotNull { doc ->
                ServiceCategory(
                    id = doc.id.toLongOrNull() ?: 0L,
                    name = doc.getString("name") ?: "",
                    icon = doc.getString("icon") ?: "",
                    description = doc.getString("description") ?: ""
                )
            }.ifEmpty { getDefaultServiceCategories() }
        } catch (e: Exception) {
            getDefaultServiceCategories()
        }
    }
    
    private fun getDefaultProductCategories(): List<String> {
        return listOf(
            "Todos",
            "Eletr√¥nicos",
            "Casa e Decora√ß√£o",
            "Ferramentas",
            "M√≥veis",
            "Roupas",
            "Esportes",
            "Livros",
            "Brinquedos",
            "Beleza e Cuidados"
        )
    }
    
    private fun getDefaultServiceCategories(): List<ServiceCategory> {
        return listOf(
            ServiceCategory(1, "Montagem", "build", "Servi√ßos de montagem de m√≥veis e equipamentos"),
            ServiceCategory(2, "Reforma", "home", "Reformas e constru√ß√µes"),
            ServiceCategory(3, "Jardinagem", "eco", "Servi√ßos de jardinagem e paisagismo"),
            ServiceCategory(4, "El√©trica", "flash_on", "Servi√ßos el√©tricos"),
            ServiceCategory(5, "Encanamento", "plumbing", "Servi√ßos de encanamento"),
            ServiceCategory(6, "Pintura", "format_paint", "Servi√ßos de pintura"),
            ServiceCategory(7, "Limpeza", "cleaning_services", "Servi√ßos de limpeza"),
            ServiceCategory(8, "Outros", "more_horiz", "Outros servi√ßos")
        )
    }
}


```

## [FRONTEND]: data/repository/FirestoreFeedRepository.kt

```kotlin
package com.taskgoapp.taskgo.data.repository

import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.FieldValue
import com.google.firebase.firestore.ListenerRegistration
import com.taskgoapp.taskgo.core.model.Post
import com.taskgoapp.taskgo.core.model.PostLocation
import com.taskgoapp.taskgo.core.model.Result
import com.taskgoapp.taskgo.data.firestore.models.PostFirestore
import com.taskgoapp.taskgo.data.firestore.models.PostLocation as PostLocationFirestore
import com.taskgoapp.taskgo.data.mapper.PostMapper
import com.taskgoapp.taskgo.domain.repository.FeedRepository
import com.taskgoapp.taskgo.core.firebase.LocationHelper
import com.taskgoapp.taskgo.core.location.LocationStateManager
import com.taskgoapp.taskgo.core.location.LocationState
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.flatMapLatest
import kotlinx.coroutines.flow.flowOf
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.tasks.await
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import java.util.Date
import android.util.Log
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class FirestoreFeedRepository @Inject constructor(
    private val firestore: FirebaseFirestore,
    private val authRepository: FirebaseAuthRepository,
    private val locationStateManager: LocationStateManager
) : FeedRepository {
    
    // CR√çTICO: Agora usamos cole√ß√µes por localiza√ß√£o, mas mantemos esta para compatibilidade
    private val postsCollection = firestore.collection("posts")
    private val currentUserId: String?
        get() = authRepository.getCurrentUser()?.uid
    
    // Helper para obter subcole√ß√£o de posts do usu√°rio
    private fun getUserPostsCollection(userId: String) = 
        firestore.collection("users").document(userId).collection("posts")
    
    override fun observeFeedPosts(
        userLatitude: Double,
        userLongitude: Double,
        radiusKm: Double
    ): Flow<List<Post>> = locationStateManager.locationState
        .flatMapLatest { locationState ->
            when (locationState) {
                is LocationState.Loading -> {
                    Log.w("BLOCKED_QUERY", "Firestore query blocked: location not ready (Loading) - observeFeedPosts")
                    flowOf(emptyList())
                }
                is LocationState.Error -> {
                    Log.e("BLOCKED_QUERY", "Firestore query blocked: location error - ${locationState.reason} - observeFeedPosts")
                    flowOf(emptyList())
                }
                is LocationState.Ready -> {
                    // ‚úÖ Localiza√ß√£o pronta - fazer query Firestore
                    val locationId = locationState.locationId
                    
                    // üö® PROTE√á√ÉO: Nunca permitir "unknown" como locationId v√°lido
                    if (locationId == "unknown" || locationId.isBlank()) {
                        Log.e("FATAL_LOCATION", "Attempted Firestore query with invalid locationId: $locationId - observeFeedPosts")
                        flowOf(emptyList())
                    } else {
                        observeFeedPostsFromFirestore(locationState, userLatitude, userLongitude, radiusKm)
                    }
                }
            }
        }
    
    private fun observeFeedPostsFromFirestore(
        locationState: LocationState.Ready,
        userLatitude: Double,
        userLongitude: Double,
        radiusKm: Double
    ): Flow<List<Post>> = callbackFlow {
        val listenerRegistration: ListenerRegistration
        
        try {
            // ‚úÖ Usar cole√ß√£o por localiza√ß√£o
            val collectionToUse = LocationHelper.getLocationCollection(
                firestore,
                "feed",
                locationState.city,
                locationState.state
            )
            
            Log.d("FirestoreFeedRepository", """
                üìç Querying Firestore with location:
                City: ${locationState.city}
                State: ${locationState.state}
                LocationId: ${locationState.locationId}
                Firestore Path: locations/${locationState.locationId}/feed
            """.trimIndent())
            
            // Buscar todos os posts ordenados por data de cria√ß√£o (mais recentes primeiro)
            // O filtro por dist√¢ncia ser√° feito em mem√≥ria ap√≥s buscar os posts
            listenerRegistration = collectionToUse
                .orderBy("createdAt", com.google.firebase.firestore.Query.Direction.DESCENDING)
                .limit(100) // Limitar a 100 posts por vez para performance
                .addSnapshotListener { snapshot, error ->
                    if (error != null) {
                        android.util.Log.e("FirestoreFeedRepository", "Erro ao observar posts: ${error.message}", error)
                        trySend(emptyList())
                        return@addSnapshotListener
                    }
                    
                    val posts = snapshot?.documents?.mapNotNull { doc ->
                        try {
                            val postData = doc.data ?: return@mapNotNull null
                            val locationData = postData["location"] as? Map<*, *>
                            
                            val location = if (locationData != null) {
                                PostLocationFirestore(
                                    city = locationData["city"] as? String ?: "",
                                    state = locationData["state"] as? String ?: "",
                                    latitude = (locationData["latitude"] as? Number)?.toDouble() ?: 0.0,
                                    longitude = (locationData["longitude"] as? Number)?.toDouble() ?: 0.0
                                )
                            } else null
                            
                            val createdAt = (postData["createdAt"] as? com.google.firebase.Timestamp)?.toDate()
                            val updatedAt = (postData["updatedAt"] as? com.google.firebase.Timestamp)?.toDate()
                            
                            PostFirestore(
                                id = doc.id,
                                userId = postData["userId"] as? String ?: "",
                                userName = postData["userName"] as? String ?: "",
                                userAvatarUrl = postData["userAvatarUrl"] as? String,
                                text = postData["text"] as? String ?: "",
                                mediaUrls = (postData["mediaUrls"] as? List<*>)?.mapNotNull { it as? String } ?: emptyList(),
                                mediaTypes = (postData["mediaTypes"] as? List<*>)?.mapNotNull { it as? String } ?: emptyList(),
                                location = location,
                                createdAt = createdAt,
                                updatedAt = updatedAt,
                                likesCount = (postData["likesCount"] as? Number)?.toInt() ?: 0,
                                commentsCount = (postData["commentsCount"] as? Number)?.toInt() ?: 0,
                                likedBy = (postData["likedBy"] as? List<*>)?.mapNotNull { it as? String } ?: emptyList(),
                                tags = (postData["tags"] as? List<*>)?.mapNotNull { it as? String }
                            )
                        } catch (e: Exception) {
                            android.util.Log.e("FirestoreFeedRepository", "Erro ao converter post: ${e.message}", e)
                            null
                        }
                    } ?: emptyList()
                    
                    // Filtrar por dist√¢ncia usando f√≥rmula de Haversine
                    val userLocation = PostLocationFirestore(
                        city = "",
                        state = "",
                        latitude = userLatitude,
                        longitude = userLongitude
                    )
                    
                    // Filtrar por dist√¢ncia usando f√≥rmula de Haversine
                    val filteredPosts = posts.filter { post ->
                        post.location?.let { postLocation ->
                            val distance = calculateDistance(
                                userLocation.latitude,
                                userLocation.longitude,
                                postLocation.latitude,
                                postLocation.longitude
                            )
                            distance <= radiusKm
                        } ?: false // Excluir posts sem localiza√ß√£o
                    }
                    
                    // Processar posts de forma ass√≠ncrona para evitar bloqueio da thread
                    // Usar CoroutineScope para executar fun√ß√µes suspend sem bloquear
                    val userId = currentUserId
                    CoroutineScope(Dispatchers.IO).launch {
                        try {
                            val userInterests = if (userId != null) {
                                getUserInterestsSync(userId)
                            } else emptyMap()
                            
                            val blockedUserIds = if (userId != null) {
                                getBlockedUserIdsSync(userId)
                            } else emptySet()
                            
                            // Filtrar posts de usu√°rios bloqueados
                            val postsWithoutBlocked = filteredPosts.filter { post ->
                                post.userId !in blockedUserIds
                            }
                            
                            // Buscar dados de rating dos posts (j√° temos os dados no snapshot)
                            val postsWithRatings = postsWithoutBlocked.map { post ->
                                val postDoc = snapshot?.documents?.find { it.id == post.id }
                                val postData = postDoc?.data
                                val ratingAverage = (postData?.get("ratingAverage") as? Number)?.toDouble() ?: 0.0
                                val ratingCount = (postData?.get("ratingCount") as? Number)?.toInt() ?: 0
                                Triple(post, ratingAverage, ratingCount)
                            }
                            
                            // Converter para modelo de dom√≠nio e calcular score de relev√¢ncia
                            val domainPostsWithScore = postsWithRatings.map { (post, ratingAverage, ratingCount) ->
                                val domainPost = with(PostMapper) {
                                    post.toModel(currentUserId)
                                }
                                val interestScore = calculatePostRelevanceScore(
                                    postId = post.id,
                                    userInterests = userInterests,
                                    postLikes = post.likesCount,
                                    postComments = post.commentsCount,
                                    postRating = ratingAverage,
                                    postRatingCount = ratingCount,
                                    postCreatedAt = post.createdAt
                                )
                                Pair(domainPost, interestScore)
                            }
                            
                            // Ordenar por score de relev√¢ncia (maior primeiro) e depois por data
                            val sortedPosts = domainPostsWithScore
                                .sortedWith(compareByDescending<Pair<Post, Float>> { it.second }
                                    .thenByDescending { it.first.createdAt?.time ?: 0L })
                                .map { it.first }
                            
                            trySend(sortedPosts)
                        } catch (e: Exception) {
                            android.util.Log.e("FirestoreFeedRepository", "Erro ao processar feed personalizado: ${e.message}", e)
                            // Em caso de erro, enviar posts filtrados sem personaliza√ß√£o
                            val fallbackPosts = filteredPosts.map { post ->
                                with(PostMapper) {
                                    post.toModel(currentUserId)
                                }
                            }
                            trySend(fallbackPosts)
                        }
                    }
                }
            
            awaitClose {
                listenerRegistration.remove()
            }
        } catch (e: Exception) {
            android.util.Log.e("FirestoreFeedRepository", "Erro ao configurar listener de posts: ${e.message}", e)
            trySend(emptyList())
            awaitClose { }
        }
    }
    
    override suspend fun getPostById(postId: String): Post? {
        return try {
            val doc = postsCollection.document(postId).get().await()
            if (!doc.exists()) {
                return null
            }
            
            val postData = doc.data ?: return null
            val locationData = postData["location"] as? Map<*, *>
            
            val location = if (locationData != null) {
                PostLocationFirestore(
                    city = locationData["city"] as? String ?: "",
                    state = locationData["state"] as? String ?: "",
                    latitude = (locationData["latitude"] as? Number)?.toDouble() ?: 0.0,
                    longitude = (locationData["longitude"] as? Number)?.toDouble() ?: 0.0
                )
            } else null
            
            val createdAt = (postData["createdAt"] as? com.google.firebase.Timestamp)?.toDate()
            val updatedAt = (postData["updatedAt"] as? com.google.firebase.Timestamp)?.toDate()
            
            val postFirestore = PostFirestore(
                id = doc.id,
                userId = postData["userId"] as? String ?: "",
                userName = postData["userName"] as? String ?: "",
                userAvatarUrl = postData["userAvatarUrl"] as? String,
                text = postData["text"] as? String ?: "",
                mediaUrls = (postData["mediaUrls"] as? List<*>)?.mapNotNull { it as? String } ?: emptyList(),
                mediaTypes = (postData["mediaTypes"] as? List<*>)?.mapNotNull { it as? String } ?: emptyList(),
                location = location,
                createdAt = createdAt,
                updatedAt = updatedAt,
                likesCount = (postData["likesCount"] as? Number)?.toInt() ?: 0,
                commentsCount = (postData["commentsCount"] as? Number)?.toInt() ?: 0,
                likedBy = (postData["likedBy"] as? List<*>)?.mapNotNull { it as? String } ?: emptyList(),
                tags = (postData["tags"] as? List<*>)?.mapNotNull { it as? String }
            )
            
            with(PostMapper) {
                postFirestore.toModel(currentUserId)
            }
        } catch (e: Exception) {
            android.util.Log.e("FirestoreFeedRepository", "Erro ao obter post: ${e.message}", e)
            null
        }
    }
    
    override fun observeUserPosts(userId: String): Flow<List<Post>> = callbackFlow {
        val listenerRegistration: ListenerRegistration
        
        try {
            listenerRegistration = postsCollection
                .whereEqualTo("userId", userId)
                .orderBy("createdAt", com.google.firebase.firestore.Query.Direction.DESCENDING)
                .addSnapshotListener { snapshot, error ->
                    if (error != null) {
                        android.util.Log.e("FirestoreFeedRepository", "Erro ao observar posts do usu√°rio: ${error.message}", error)
                        trySend(emptyList())
                        return@addSnapshotListener
                    }
                    
                    val posts = snapshot?.documents?.mapNotNull { doc ->
                        try {
                            val postData = doc.data ?: return@mapNotNull null
                            val locationData = postData["location"] as? Map<*, *>
                            
                            val location = if (locationData != null) {
                                PostLocationFirestore(
                                    city = locationData["city"] as? String ?: "",
                                    state = locationData["state"] as? String ?: "",
                                    latitude = (locationData["latitude"] as? Number)?.toDouble() ?: 0.0,
                                    longitude = (locationData["longitude"] as? Number)?.toDouble() ?: 0.0
                                )
                            } else null
                            
                            val createdAt = (postData["createdAt"] as? com.google.firebase.Timestamp)?.toDate()
                            val updatedAt = (postData["updatedAt"] as? com.google.firebase.Timestamp)?.toDate()
                            
                            PostFirestore(
                                id = doc.id,
                                userId = postData["userId"] as? String ?: "",
                                userName = postData["userName"] as? String ?: "",
                                userAvatarUrl = postData["userAvatarUrl"] as? String,
                                text = postData["text"] as? String ?: "",
                                mediaUrls = (postData["mediaUrls"] as? List<*>)?.mapNotNull { it as? String } ?: emptyList(),
                                mediaTypes = (postData["mediaTypes"] as? List<*>)?.mapNotNull { it as? String } ?: emptyList(),
                                location = location,
                                createdAt = createdAt,
                                updatedAt = updatedAt,
                                likesCount = (postData["likesCount"] as? Number)?.toInt() ?: 0,
                                commentsCount = (postData["commentsCount"] as? Number)?.toInt() ?: 0,
                                likedBy = (postData["likedBy"] as? List<*>)?.mapNotNull { it as? String } ?: emptyList(),
                                tags = (postData["tags"] as? List<*>)?.mapNotNull { it as? String }
                            )
                        } catch (e: Exception) {
                            android.util.Log.e("FirestoreFeedRepository", "Erro ao converter post: ${e.message}", e)
                            null
                        }
                    } ?: emptyList()
                    
                    val domainPosts = posts.map { post ->
                        with(PostMapper) {
                            post.toModel(currentUserId)
                        }
                    }
                    trySend(domainPosts)
                }
            
            awaitClose {
                listenerRegistration.remove()
            }
        } catch (e: Exception) {
            android.util.Log.e("FirestoreFeedRepository", "Erro ao configurar listener de posts do usu√°rio: ${e.message}", e)
            trySend(emptyList())
            awaitClose { }
        }
    }
    
    override suspend fun createPost(
        text: String,
        mediaUrls: List<String>,
        mediaTypes: List<String>,
        location: PostLocation
    ): Result<String> {
        return try {
            val userId = currentUserId
                ?: return Result.Error(Exception("Usu√°rio n√£o autenticado"))
            
            // Buscar dados do usu√°rio para incluir no post
            val userDoc = firestore.collection("users").document(userId).get().await()
            val userData = userDoc.data
            val userName = userData?.get("displayName") as? String ?: "Usu√°rio"
            val userAvatarUrl = userData?.get("photoURL") as? String
            
            // Converter PostLocation do dom√≠nio para Firestore
            val locationFirestore = with(PostMapper) {
                location.toFirestore()
            }
            
            // CR√çTICO: Extrair cidade e estado da localiza√ß√£o para salvar na cole√ß√£o correta
            val city = locationFirestore.city
            val state = locationFirestore.state
            
            if (city.isBlank() || state.isBlank()) {
                android.util.Log.w("FirestoreFeedRepository", "‚ö†Ô∏è Post sem localiza√ß√£o completa (city=$city, state=$state), ser√° salvo em 'unknown'")
            }
            
            val postData = hashMapOf<String, Any>(
                "userId" to userId,
                "userName" to userName,
                "userAvatarUrl" to (userAvatarUrl ?: ""),
                "text" to text,
                "mediaUrls" to mediaUrls,
                "mediaTypes" to mediaTypes,
                "city" to city, // Adicionar cidade explicitamente
                "state" to state, // Adicionar estado explicitamente
                "location" to hashMapOf(
                    "city" to locationFirestore.city,
                    "state" to locationFirestore.state,
                    "latitude" to locationFirestore.latitude,
                    "longitude" to locationFirestore.longitude
                ),
                "createdAt" to FieldValue.serverTimestamp(),
                "updatedAt" to FieldValue.serverTimestamp(),
                "likesCount" to 0,
                "commentsCount" to 0,
                "likedBy" to emptyList<String>()
            )
            
            // Criar na subcole√ß√£o do usu√°rio (fonte de verdade - dados privados)
            val userPostsCollection = getUserPostsCollection(userId)
            val docRef = userPostsCollection.add(postData).await()
            val postId = docRef.id
            
            // CR√çTICO: Salvar na cole√ß√£o p√∫blica por localiza√ß√£o
            try {
                val locationId = LocationHelper.normalizeLocationId(city.ifBlank { "unknown" }, state.ifBlank { "unknown" })
                val locationPostsCollection = firestore.collection("locations").document(locationId).collection("posts")
                locationPostsCollection.document(postId).set(postData).await()
                android.util.Log.d("FirestoreFeedRepository", "‚úÖ Post salvo na cole√ß√£o por localiza√ß√£o: locations/$locationId/posts")
            } catch (e: Exception) {
                android.util.Log.e("FirestoreFeedRepository", "‚ùå Erro ao salvar post na cole√ß√£o por localiza√ß√£o: ${e.message}", e)
            }
            
            // Tamb√©m salvar na cole√ß√£o global para compatibilidade (ser√° removido futuramente)
            try {
                postsCollection.document(postId).set(postData).await()
            } catch (e: Exception) {
                android.util.Log.w("FirestoreFeedRepository", "Erro ao salvar post na cole√ß√£o global: ${e.message}")
                // N√£o falhar se p√∫blica falhar, mas logar o erro
            }
            
            Result.Success(postId)
        } catch (e: Exception) {
            android.util.Log.e("FirestoreFeedRepository", "Erro ao criar post: ${e.message}", e)
            Result.Error(e)
        }
    }
    
    override suspend fun likePost(postId: String, userId: String): Result<Unit> {
        return try {
            val postRef = postsCollection.document(postId)
            
            // Usar transa√ß√£o para garantir atomicidade
            firestore.runTransaction { transaction ->
                val postDoc = transaction.get(postRef)
                if (!postDoc.exists()) {
                    throw Exception("Post n√£o encontrado")
                }
                
                val postData = postDoc.data ?: throw Exception("Dados do post inv√°lidos")
                val likedBy = (postData["likedBy"] as? List<*>)?.mapNotNull { it as? String }?.toMutableList() ?: mutableListOf()
                
                if (!likedBy.contains(userId)) {
                    likedBy.add(userId)
                    val likesCount = (postData["likesCount"] as? Number)?.toInt() ?: 0
                    transaction.update(postRef, mapOf(
                        "likedBy" to likedBy,
                        "likesCount" to (likesCount + 1),
                        "updatedAt" to FieldValue.serverTimestamp()
                    ))
                }
            }.await()
            
            Result.Success(Unit)
        } catch (e: Exception) {
            android.util.Log.e("FirestoreFeedRepository", "Erro ao curtir post: ${e.message}", e)
            Result.Error(e)
        }
    }
    
    override suspend fun unlikePost(postId: String, userId: String): Result<Unit> {
        return try {
            val postRef = postsCollection.document(postId)
            
            firestore.runTransaction { transaction ->
                val postDoc = transaction.get(postRef)
                if (!postDoc.exists()) {
                    throw Exception("Post n√£o encontrado")
                }
                
                val postData = postDoc.data ?: throw Exception("Dados do post inv√°lidos")
                val likedBy = (postData["likedBy"] as? List<*>)?.mapNotNull { it as? String }?.toMutableList() ?: mutableListOf()
                
                if (likedBy.contains(userId)) {
                    likedBy.remove(userId)
                    val likesCount = (postData["likesCount"] as? Number)?.toInt() ?: 0
                    transaction.update(postRef, mapOf(
                        "likedBy" to likedBy,
                        "likesCount" to (likesCount - 1).coerceAtLeast(0),
                        "updatedAt" to FieldValue.serverTimestamp()
                    ))
                }
            }.await()
            
            Result.Success(Unit)
        } catch (e: Exception) {
            android.util.Log.e("FirestoreFeedRepository", "Erro ao descurtir post: ${e.message}", e)
            Result.Error(e)
        }
    }
    
    override suspend fun deletePost(postId: String): Result<Unit> {
        return try {
            val userId = currentUserId
                ?: return Result.Error(Exception("Usu√°rio n√£o autenticado"))
            
            // Verificar na subcole√ß√£o do usu√°rio primeiro (fonte de verdade)
            val userPostsCollection = getUserPostsCollection(userId)
            val userPostDoc = userPostsCollection.document(postId).get().await()
            
            // Se n√£o existe na subcole√ß√£o, verificar na cole√ß√£o p√∫blica
            if (!userPostDoc.exists()) {
                val postDoc = postsCollection.document(postId).get().await()
                val postData = postDoc.data
                
                if (!postDoc.exists() || postData?.get("userId") != userId) {
                    return Result.Error(Exception("Post n√£o encontrado ou voc√™ n√£o tem permiss√£o para excluir"))
                }
                
                // Se existe apenas na cole√ß√£o p√∫blica, deletar apenas dela
                postsCollection.document(postId).delete().await()
            } else {
                // Se existe na subcole√ß√£o do usu√°rio, deletar de ambas
                // Deletar da subcole√ß√£o primeiro (fonte de verdade)
                // A Cloud Function vai sincronizar e deletar da cole√ß√£o p√∫blica automaticamente
                userPostsCollection.document(postId).delete().await()
                
                // Tamb√©m deletar da cole√ß√£o p√∫blica para garantir sincroniza√ß√£o imediata
                try {
                    postsCollection.document(postId).delete().await()
                } catch (e: Exception) {
                    android.util.Log.w("FirestoreFeedRepository", "Erro ao deletar post da cole√ß√£o p√∫blica: ${e.message}")
                    // N√£o falhar se p√∫blica falhar, a Cloud Function vai fazer a limpeza
                }
            }
            
            Result.Success(Unit)
        } catch (e: Exception) {
            android.util.Log.e("FirestoreFeedRepository", "Erro ao deletar post: ${e.message}", e)
            Result.Error(e)
        }
    }
    
    /**
     * Calcula a dist√¢ncia em km entre duas coordenadas usando a f√≥rmula de Haversine
     */
    private fun calculateDistance(
        lat1: Double,
        lon1: Double,
        lat2: Double,
        lon2: Double
    ): Double {
        val earthRadius = 6371.0 // Raio da Terra em km
        
        val lat1Rad = Math.toRadians(lat1)
        val lat2Rad = Math.toRadians(lat2)
        val deltaLat = Math.toRadians(lat2 - lat1)
        val deltaLon = Math.toRadians(lon2 - lon1)
        
        val a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
                Math.cos(lat1Rad) * Math.cos(lat2Rad) *
                Math.sin(deltaLon / 2) * Math.sin(deltaLon / 2)
        
        val c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))
        
        return earthRadius * c
    }
    
    // Helper para obter subcole√ß√£o de coment√°rios de um post
    private fun getPostCommentsCollection(postId: String) = 
        postsCollection.document(postId).collection("comments")
    
    override fun observePostComments(postId: String): Flow<List<com.taskgoapp.taskgo.feature.feed.presentation.components.CommentItem>> = callbackFlow {
        val listenerRegistration: ListenerRegistration
        
        try {
            val commentsCollection = getPostCommentsCollection(postId)
            
            listenerRegistration = commentsCollection
                .orderBy("createdAt", com.google.firebase.firestore.Query.Direction.ASCENDING)
                .addSnapshotListener { snapshot, error ->
                    if (error != null) {
                        android.util.Log.e("FirestoreFeedRepository", "Erro ao observar coment√°rios: ${error.message}", error)
                        trySend(emptyList())
                        return@addSnapshotListener
                    }
                    
                    val comments = snapshot?.documents?.mapNotNull { doc ->
                        try {
                            val data = doc.data ?: return@mapNotNull null
                            val createdAt = when (val createdAtValue = data["createdAt"]) {
                                is com.google.firebase.Timestamp -> createdAtValue.toDate()
                                is Long -> Date(createdAtValue)
                                is java.util.Date -> createdAtValue
                                else -> Date()
                            }
                            
                            com.taskgoapp.taskgo.feature.feed.presentation.components.CommentItem(
                                id = doc.id,
                                postId = postId,
                                userId = data["userId"] as? String ?: "",
                                userName = data["userName"] as? String ?: "Usu√°rio",
                                userAvatarUrl = data["userAvatarUrl"] as? String,
                                text = data["text"] as? String ?: "",
                                createdAt = createdAt,
                                isLiked = (data["isLiked"] as? Boolean) ?: false,
                                likesCount = (data["likesCount"] as? Number)?.toInt() ?: 0
                            )
                        } catch (e: Exception) {
                            android.util.Log.e("FirestoreFeedRepository", "Erro ao converter coment√°rio: ${e.message}", e)
                            null
                        }
                    } ?: emptyList()
                    
                    trySend(comments)
                }
            
            awaitClose {
                listenerRegistration.remove()
            }
        } catch (e: Exception) {
            android.util.Log.e("FirestoreFeedRepository", "Erro ao configurar listener de coment√°rios: ${e.message}", e)
            trySend(emptyList())
            awaitClose { }
        }
    }
    
    override suspend fun createComment(postId: String, text: String): Result<String> {
        return try {
            val userId = currentUserId
                ?: return Result.Error(Exception("Usu√°rio n√£o autenticado"))
            
            // Buscar dados do usu√°rio para incluir no coment√°rio
            val userDoc = firestore.collection("users").document(userId).get().await()
            val userData = userDoc.data
            val userName = userData?.get("displayName") as? String ?: "Usu√°rio"
            val userAvatarUrl = userData?.get("photoURL") as? String
            
            val commentsCollection = getPostCommentsCollection(postId)
            
            val commentData = hashMapOf<String, Any>(
                "userId" to userId,
                "userName" to userName,
                "userAvatarUrl" to (userAvatarUrl ?: ""),
                "text" to text.trim(),
                "postId" to postId,
                "createdAt" to FieldValue.serverTimestamp(),
                "updatedAt" to FieldValue.serverTimestamp(),
                "isLiked" to false,
                "likesCount" to 0
            )
            
            // Criar coment√°rio
            val docRef = commentsCollection.add(commentData).await()
            val commentId = docRef.id
            
            // Atualizar contador de coment√°rios do post
            try {
                val postRef = postsCollection.document(postId)
                firestore.runTransaction { transaction ->
                    val postDoc = transaction.get(postRef)
                    if (postDoc.exists()) {
                        val currentCount = (postDoc.data?.get("commentsCount") as? Number)?.toInt() ?: 0
                        transaction.update(postRef, mapOf(
                            "commentsCount" to (currentCount + 1),
                            "updatedAt" to FieldValue.serverTimestamp()
                        ))
                    }
                }.await()
            } catch (e: Exception) {
                android.util.Log.w("FirestoreFeedRepository", "Erro ao atualizar contador de coment√°rios: ${e.message}")
                // N√£o falhar se n√£o conseguir atualizar o contador
            }
            
            android.util.Log.d("FirestoreFeedRepository", "Coment√°rio criado com sucesso: $commentId")
            Result.Success(commentId)
        } catch (e: Exception) {
            android.util.Log.e("FirestoreFeedRepository", "Erro ao criar coment√°rio: ${e.message}", e)
            Result.Error(e)
        }
    }
    
    override suspend fun deleteComment(postId: String, commentId: String): Result<Unit> {
        return try {
            val userId = currentUserId
                ?: return Result.Error(Exception("Usu√°rio n√£o autenticado"))
            
            val commentsCollection = getPostCommentsCollection(postId)
            val commentDoc = commentsCollection.document(commentId).get().await()
            
            if (!commentDoc.exists()) {
                return Result.Error(Exception("Coment√°rio n√£o encontrado"))
            }
            
            val commentData = commentDoc.data
            if (commentData?.get("userId") != userId) {
                return Result.Error(Exception("Voc√™ n√£o tem permiss√£o para deletar este coment√°rio"))
            }
            
            // Deletar coment√°rio
            commentsCollection.document(commentId).delete().await()
            
            // Atualizar contador de coment√°rios do post
            try {
                val postRef = postsCollection.document(postId)
                firestore.runTransaction { transaction ->
                    val postDoc = transaction.get(postRef)
                    if (postDoc.exists()) {
                        val currentCount = (postDoc.data?.get("commentsCount") as? Number)?.toInt() ?: 0
                        transaction.update(postRef, mapOf(
                            "commentsCount" to (currentCount - 1).coerceAtLeast(0),
                            "updatedAt" to FieldValue.serverTimestamp()
                        ))
                    }
                }.await()
            } catch (e: Exception) {
                android.util.Log.w("FirestoreFeedRepository", "Erro ao atualizar contador de coment√°rios: ${e.message}")
            }
            
            Result.Success(Unit)
        } catch (e: Exception) {
            android.util.Log.e("FirestoreFeedRepository", "Erro ao deletar coment√°rio: ${e.message}", e)
            Result.Error(e)
        }
    }
    
    // ========== INTERESSE EM POSTS ==========
    
    override suspend fun setPostInterest(postId: String, isInterested: Boolean): Result<Unit> {
        return try {
            val userId = currentUserId
                ?: return Result.Error(Exception("Usu√°rio n√£o autenticado"))
            
            val interestsCollection = firestore
                .collection("users")
                .document(userId)
                .collection("postInterests")
            
            // Verificar se j√° existe interesse
            val existingInterest = interestsCollection
                .whereEqualTo("postId", postId)
                .limit(1)
                .get()
                .await()
            
            val interestData = hashMapOf<String, Any>(
                "postId" to postId,
                "isInterested" to isInterested,
                "updatedAt" to FieldValue.serverTimestamp()
            )
            
            if (existingInterest.documents.isNotEmpty()) {
                // Atualizar interesse existente
                existingInterest.documents[0].reference.update(interestData).await()
            } else {
                // Criar novo interesse
                interestData["createdAt"] = FieldValue.serverTimestamp()
                interestsCollection.add(interestData).await()
            }
            
            android.util.Log.d("FirestoreFeedRepository", "Interesse em post $postId definido: $isInterested")
            Result.Success(Unit)
        } catch (e: Exception) {
            android.util.Log.e("FirestoreFeedRepository", "Erro ao definir interesse: ${e.message}", e)
            Result.Error(e)
        }
    }
    
    override suspend fun removePostInterest(postId: String): Result<Unit> {
        return try {
            val userId = currentUserId
                ?: return Result.Error(Exception("Usu√°rio n√£o autenticado"))
            
            val interestsCollection = firestore
                .collection("users")
                .document(userId)
                .collection("postInterests")
            
            val existingInterest = interestsCollection
                .whereEqualTo("postId", postId)
                .limit(1)
                .get()
                .await()
            
            if (existingInterest.documents.isNotEmpty()) {
                existingInterest.documents[0].reference.delete().await()
            }
            
            Result.Success(Unit)
        } catch (e: Exception) {
            android.util.Log.e("FirestoreFeedRepository", "Erro ao remover interesse: ${e.message}", e)
            Result.Error(e)
        }
    }
    
    override suspend fun getPostInterest(postId: String): Boolean? {
        return try {
            val userId = currentUserId ?: return null
            
            val interestsCollection = firestore
                .collection("users")
                .document(userId)
                .collection("postInterests")
            
            val interestDoc = interestsCollection
                .whereEqualTo("postId", postId)
                .limit(1)
                .get()
                .await()
            
            if (interestDoc.documents.isNotEmpty()) {
                interestDoc.documents[0].data?.get("isInterested") as? Boolean
            } else {
                null
            }
        } catch (e: Exception) {
            android.util.Log.e("FirestoreFeedRepository", "Erro ao obter interesse: ${e.message}", e)
            null
        }
    }
    
    // ========== AVALIA√á√ÉO DE POSTS ==========
    
    override suspend fun ratePost(postId: String, rating: Int, comment: String?): Result<String> {
        return try {
            val userId = currentUserId
                ?: return Result.Error(Exception("Usu√°rio n√£o autenticado"))
            
            // Buscar dados do usu√°rio
            val userDoc = firestore.collection("users").document(userId).get().await()
            val userData = userDoc.data
            val userName = userData?.get("displayName") as? String ?: "Usu√°rio"
            val userAvatarUrl = userData?.get("photoURL") as? String
            
            val ratingsCollection = firestore
                .collection("posts")
                .document(postId)
                .collection("ratings")
            
            // Verificar se j√° existe avalia√ß√£o do usu√°rio
            val existingRating = ratingsCollection
                .whereEqualTo("userId", userId)
                .limit(1)
                .get()
                .await()
            
            val ratingData = hashMapOf<String, Any>(
                "postId" to postId,
                "userId" to userId,
                "userName" to userName,
                "userAvatarUrl" to (userAvatarUrl ?: ""),
                "rating" to rating,
                "updatedAt" to FieldValue.serverTimestamp()
            )
            
            if (comment != null && comment.isNotBlank()) {
                ratingData["comment"] = comment.trim()
            }
            
            val ratingId: String
            if (existingRating.documents.isNotEmpty()) {
                // Atualizar avalia√ß√£o existente
                ratingId = existingRating.documents[0].id
                existingRating.documents[0].reference.update(ratingData).await()
            } else {
                // Criar nova avalia√ß√£o
                ratingData["createdAt"] = FieldValue.serverTimestamp()
                val docRef = ratingsCollection.add(ratingData).await()
                ratingId = docRef.id
            }
            
            // Atualizar m√©dia de avalia√ß√µes do post
            updatePostRatingAverage(postId)
            
            android.util.Log.d("FirestoreFeedRepository", "Post $postId avaliado com $rating estrelas")
            Result.Success(ratingId)
        } catch (e: Exception) {
            android.util.Log.e("FirestoreFeedRepository", "Erro ao avaliar post: ${e.message}", e)
            Result.Error(e)
        }
    }
    
    override suspend fun getUserPostRating(postId: String): com.taskgoapp.taskgo.core.model.PostRating? {
        return try {
            val userId = currentUserId ?: return null
            
            val ratingsCollection = firestore
                .collection("posts")
                .document(postId)
                .collection("ratings")
            
            val ratingDoc = ratingsCollection
                .whereEqualTo("userId", userId)
                .limit(1)
                .get()
                .await()
            
            if (ratingDoc.documents.isNotEmpty()) {
                val doc = ratingDoc.documents[0]
                val data = doc.data ?: return null
                
                com.taskgoapp.taskgo.core.model.PostRating(
                    id = doc.id,
                    postId = postId,
                    userId = data["userId"] as? String ?: "",
                    userName = data["userName"] as? String,
                    userAvatarUrl = data["userAvatarUrl"] as? String,
                    rating = (data["rating"] as? Number)?.toInt() ?: 0,
                    comment = data["comment"] as? String,
                    createdAt = (data["createdAt"] as? com.google.firebase.Timestamp)?.toDate() ?: java.util.Date()
                )
            } else {
                null
            }
        } catch (e: Exception) {
            android.util.Log.e("FirestoreFeedRepository", "Erro ao obter avalia√ß√£o: ${e.message}", e)
            null
        }
    }
    
    private suspend fun updatePostRatingAverage(postId: String) {
        try {
            val ratingsCollection = firestore
                .collection("posts")
                .document(postId)
                .collection("ratings")
            
            val ratings = ratingsCollection.get().await()
            val ratingsList = ratings.documents.mapNotNull { doc ->
                (doc.data?.get("rating") as? Number)?.toInt()
            }
            
            if (ratingsList.isNotEmpty()) {
                val average = ratingsList.average()
                val count = ratingsList.size
                
                postsCollection.document(postId).update(
                    mapOf(
                        "ratingAverage" to average,
                        "ratingCount" to count,
                        "updatedAt" to FieldValue.serverTimestamp()
                    )
                ).await()
            }
        } catch (e: Exception) {
            android.util.Log.w("FirestoreFeedRepository", "Erro ao atualizar m√©dia de avalia√ß√µes: ${e.message}")
        }
    }
    
    // ========== BLOQUEIO DE USU√ÅRIOS ==========
    
    override suspend fun blockUser(userId: String): Result<Unit> {
        return try {
            val blockerId = currentUserId
                ?: return Result.Error(Exception("Usu√°rio n√£o autenticado"))
            
            if (blockerId == userId) {
                return Result.Error(Exception("Voc√™ n√£o pode bloquear a si mesmo"))
            }
            
            // Buscar dados do usu√°rio a ser bloqueado
            val userDoc = firestore.collection("users").document(userId).get().await()
            val userData = userDoc.data
            val blockedName = userData?.get("displayName") as? String
            val blockedAvatarUrl = userData?.get("photoURL") as? String
            
            val blockedUsersCollection = firestore
                .collection("users")
                .document(blockerId)
                .collection("blockedUsers")
            
            // Verificar se j√° est√° bloqueado
            val existingBlock = blockedUsersCollection
                .whereEqualTo("blockedId", userId)
                .limit(1)
                .get()
                .await()
            
            if (existingBlock.documents.isEmpty()) {
                val blockData = hashMapOf<String, Any>(
                    "blockedId" to userId,
                    "blockedName" to (blockedName ?: ""),
                    "blockedAvatarUrl" to (blockedAvatarUrl ?: ""),
                    "createdAt" to FieldValue.serverTimestamp()
                )
                
                blockedUsersCollection.add(blockData).await()
            }
            
            android.util.Log.d("FirestoreFeedRepository", "Usu√°rio $userId bloqueado por $blockerId")
            Result.Success(Unit)
        } catch (e: Exception) {
            android.util.Log.e("FirestoreFeedRepository", "Erro ao bloquear usu√°rio: ${e.message}", e)
            Result.Error(e)
        }
    }
    
    override suspend fun unblockUser(userId: String): Result<Unit> {
        return try {
            val blockerId = currentUserId
                ?: return Result.Error(Exception("Usu√°rio n√£o autenticado"))
            
            val blockedUsersCollection = firestore
                .collection("users")
                .document(blockerId)
                .collection("blockedUsers")
            
            val existingBlock = blockedUsersCollection
                .whereEqualTo("blockedId", userId)
                .limit(1)
                .get()
                .await()
            
            if (existingBlock.documents.isNotEmpty()) {
                existingBlock.documents[0].reference.delete().await()
            }
            
            Result.Success(Unit)
        } catch (e: Exception) {
            android.util.Log.e("FirestoreFeedRepository", "Erro ao desbloquear usu√°rio: ${e.message}", e)
            Result.Error(e)
        }
    }
    
    override suspend fun isUserBlocked(userId: String): Boolean {
        return try {
            val blockerId = currentUserId ?: return false
            
            val blockedUsersCollection = firestore
                .collection("users")
                .document(blockerId)
                .collection("blockedUsers")
            
            val blockDoc = blockedUsersCollection
                .whereEqualTo("blockedId", userId)
                .limit(1)
                .get()
                .await()
            
            blockDoc.documents.isNotEmpty()
        } catch (e: Exception) {
            android.util.Log.e("FirestoreFeedRepository", "Erro ao verificar bloqueio: ${e.message}", e)
            false
        }
    }
    
    override fun observeBlockedUsers(): Flow<List<com.taskgoapp.taskgo.core.model.BlockedUser>> = callbackFlow {
        val userId = currentUserId
        if (userId == null) {
            trySend(emptyList())
            awaitClose { }
            return@callbackFlow
        }
        
        val blockedUsersCollection = firestore
            .collection("users")
            .document(userId)
            .collection("blockedUsers")
        
        val listenerRegistration = blockedUsersCollection
            .orderBy("createdAt", com.google.firebase.firestore.Query.Direction.DESCENDING)
            .addSnapshotListener { snapshot, error ->
                if (error != null) {
                    android.util.Log.e("FirestoreFeedRepository", "Erro ao observar usu√°rios bloqueados: ${error.message}", error)
                    trySend(emptyList())
                    return@addSnapshotListener
                }
                
                val blockedUsers = snapshot?.documents?.mapNotNull { doc ->
                    try {
                        val data = doc.data ?: return@mapNotNull null
                        com.taskgoapp.taskgo.core.model.BlockedUser(
                            id = doc.id,
                            blockerId = userId,
                            blockedId = data["blockedId"] as? String ?: "",
                            blockedName = data["blockedName"] as? String,
                            blockedAvatarUrl = data["blockedAvatarUrl"] as? String,
                            createdAt = (data["createdAt"] as? com.google.firebase.Timestamp)?.toDate() ?: java.util.Date()
                        )
                    } catch (e: Exception) {
                        android.util.Log.e("FirestoreFeedRepository", "Erro ao converter usu√°rio bloqueado: ${e.message}", e)
                        null
                    }
                } ?: emptyList()
                
                trySend(blockedUsers)
            }
        
        awaitClose {
            listenerRegistration.remove()
        }
    }
    
    // ========== FUN√á√ïES AUXILIARES PARA ALGORITMO DE FEED ==========
    
    /**
     * Busca interesses do usu√°rio de forma s√≠ncrona (dentro do listener)
     */
    private suspend fun getUserInterestsSync(userId: String): Map<String, Boolean> {
        return try {
            val interestsCollection = firestore
                .collection("users")
                .document(userId)
                .collection("postInterests")
            
            val interests = interestsCollection.get().await()
            interests.documents.associate { doc ->
                val postId = doc.data?.get("postId") as? String ?: ""
                val isInterested = doc.data?.get("isInterested") as? Boolean ?: false
                postId to isInterested
            }
        } catch (e: Exception) {
            android.util.Log.w("FirestoreFeedRepository", "Erro ao buscar interesses: ${e.message}")
            emptyMap()
        }
    }
    
    /**
     * Busca IDs de usu√°rios bloqueados de forma s√≠ncrona (dentro do listener)
     */
    private suspend fun getBlockedUserIdsSync(userId: String): Set<String> {
        return try {
            val blockedUsersCollection = firestore
                .collection("users")
                .document(userId)
                .collection("blockedUsers")
            
            val blockedUsers = blockedUsersCollection.get().await()
            blockedUsers.documents.mapNotNull { doc ->
                doc.data?.get("blockedId") as? String
            }.toSet()
        } catch (e: Exception) {
            android.util.Log.w("FirestoreFeedRepository", "Erro ao buscar usu√°rios bloqueados: ${e.message}")
            emptySet()
        }
    }
    
    /**
     * Calcula score de relev√¢ncia de um post baseado em interesses, likes, coment√°rios e avalia√ß√µes
     * Score maior = mais relevante (aparece primeiro no feed)
     */
    private fun calculatePostRelevanceScore(
        postId: String,
        userInterests: Map<String, Boolean>,
        postLikes: Int,
        postComments: Int,
        postRating: Double,
        postRatingCount: Int,
        postCreatedAt: java.util.Date?
    ): Float {
        var score = 0f
        
        // 1. Interesse do usu√°rio (peso: 40%)
        // Posts com interesse positivo ganham muito score, posts com interesse negativo perdem score
        val interest = userInterests[postId]
        when {
            interest == true -> score += 0.4f  // Tenho interesse - boost significativo
            interest == false -> score -= 0.2f // N√£o tenho interesse - reduz score
            else -> score += 0f // Sem interesse definido - neutro
        }
        
        // 2. Engajamento (likes + coment√°rios) (peso: 25%)
        // Normalizar engajamento (assumindo m√°ximo de 100 likes e 50 coment√°rios)
        val engagementScore = ((postLikes.coerceIn(0, 100) / 100f) * 0.15f) +
                              ((postComments.coerceIn(0, 50) / 50f) * 0.10f)
        score += engagementScore
        
        // 3. Avalia√ß√£o m√©dia (peso: 20%)
        // Posts bem avaliados aparecem mais
        if (postRatingCount > 0) {
            val ratingScore = (postRating / 5.0).coerceIn(0.0, 1.0).toFloat() * 0.2f
            score += ratingScore
        }
        
        // 4. Rec√™ncia (peso: 15%)
        // Posts mais recentes ganham score adicional
        postCreatedAt?.let { createdAt ->
            val now = System.currentTimeMillis()
            val postTime = createdAt.time
            val hoursSinceCreation = (now - postTime) / (1000.0 * 60.0 * 60.0)
            
            // Decaimento exponencial: posts de 24h atr√°s t√™m score 0.5, posts de 1h t√™m score 1.0
            val recencyScore = when {
                hoursSinceCreation < 1.0 -> 1.0f
                hoursSinceCreation < 24.0 -> (1.0f - (hoursSinceCreation.toFloat() / 24.0f) * 0.5f).coerceAtLeast(0.5f)
                else -> 0.3f // Posts antigos ainda aparecem, mas com menos prioridade
            }
            score += recencyScore * 0.15f
        } ?: run {
            // Se n√£o tem data, assume score neutro de rec√™ncia
            score += 0.075f
        }
        
        return score.coerceIn(-1f, 1f)
    }
}

```

## [FRONTEND]: data/repository/FirestoreHomeBannersRepository.kt

```kotlin
package com.taskgoapp.taskgo.data.repository

import com.google.firebase.firestore.FirebaseFirestore
import com.taskgoapp.taskgo.core.model.HomeBanner
import com.taskgoapp.taskgo.domain.repository.HomeBannersRepository
import javax.inject.Inject
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow

class FirestoreHomeBannersRepository @Inject constructor(
    private val firestore: FirebaseFirestore
) : HomeBannersRepository {

    override fun observeHomeBanners(): Flow<List<HomeBanner>> = callbackFlow {
        val registration = firestore.collection("homeBanners")
            .whereEqualTo("active", true)
            .addSnapshotListener { snapshot, error ->
                if (error != null) {
                    trySend(emptyList()).isSuccess
                    return@addSnapshotListener
                }

                val banners = snapshot?.documents?.mapNotNull { document ->
                    document.toObject(HomeBannerDocument::class.java)?.toModel(document.id)
                }.orEmpty()

                trySend(banners.sortedBy { it.priority }).isSuccess
            }

        awaitClose { registration.remove() }
    }

    private data class HomeBannerDocument(
        val title: String? = null,
        val subtitle: String? = null,
        val actionLabel: String? = null,
        val imageUrl: String? = null,
        val audience: String? = null,
        val actionRoute: String? = null,
        val priority: Long? = null,
        val active: Boolean? = null
    ) {
        fun toModel(id: String): HomeBanner? {
            if (active == false || title.isNullOrBlank() || subtitle.isNullOrBlank() || actionLabel.isNullOrBlank()) {
                return null
            }

            val audienceEnum = when (audience?.uppercase()) {
                "CLIENTE", "CLIENT", "CLIENTES" -> HomeBanner.Audience.CLIENTE
                "PRESTADOR", "PROVIDER", "PRESTADORES" -> HomeBanner.Audience.PRESTADOR
                else -> HomeBanner.Audience.TODOS
            }

            return HomeBanner(
                id = id,
                title = title,
                subtitle = subtitle,
                actionLabel = actionLabel,
                imageUrl = imageUrl,
                audience = audienceEnum,
                actionRoute = actionRoute,
                priority = priority?.toInt() ?: 0
            )
        }
    }
}


```

## [FRONTEND]: data/repository/FirestoreMapLocationsRepository.kt

```kotlin
package com.taskgoapp.taskgo.data.repository

import com.taskgoapp.taskgo.core.maps.ProviderLocation
import com.taskgoapp.taskgo.core.maps.StoreLocation
import com.taskgoapp.taskgo.core.location.GeocodingService
import com.taskgoapp.taskgo.data.firestore.models.UserFirestore
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.ListenerRegistration
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.launch
import kotlinx.coroutines.Deferred
import kotlinx.coroutines.tasks.await
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Reposit√≥rio para buscar prestadores e lojas em tempo real para exibi√ß√£o no mapa
 */
@Singleton
class FirestoreMapLocationsRepository @Inject constructor(
    private val firestore: FirebaseFirestore,
    private val geocodingService: GeocodingService
) {
    private val usersCollection = firestore.collection("users")
    
    // Cache de geocoding para evitar m√∫ltiplas chamadas √† API
    private val geocodingCache = mutableMapOf<String, Pair<Double, Double>>()
    
    /**
     * Observa prestadores de servi√ßo com localiza√ß√£o em tempo real
     * Usa cache de geocoding e processamento ass√≠ncrono para otimizar performance
     */
    fun observeProvidersWithLocation(): Flow<List<ProviderLocation>> = callbackFlow {
        val listenerRegistration = usersCollection
            .whereEqualTo("role", "provider")
            .addSnapshotListener { snapshot, error ->
                if (error != null) {
                    android.util.Log.e("FirestoreMapLocationsRepository", "Erro ao observar providers: ${error.message}", error)
                    // N√£o fecha o flow, apenas envia lista vazia para evitar crash
                    trySend(emptyList())
                    return@addSnapshotListener
                }
                
                // Processar geocoding de forma ass√≠ncrona para n√£o bloquear o listener
                kotlinx.coroutines.CoroutineScope(kotlinx.coroutines.Dispatchers.IO).launch {
                    val providers = coroutineScope {
                        snapshot?.documents?.mapNotNull { doc ->
                            async {
                                val user = doc.toObject(UserFirestore::class.java)?.copy(uid = doc.id)
                                user?.let { provider ->
                                    // Obter localiza√ß√£o via geocoding do endere√ßo (com cache)
                                    val latitude: Double?
                                    val longitude: Double?
                                    
                                    if (provider.address != null) {
                                        // Criar chave de cache baseada no CEP ou endere√ßo completo
                                        val cacheKey = provider.address.zipCode.ifEmpty { 
                                            "${provider.address.street}, ${provider.address.city}, ${provider.address.state}"
                                        }
                                        
                                        // Verificar cache primeiro
                                        val cached = geocodingCache[cacheKey]
                                        if (cached != null) {
                                            latitude = cached.first
                                            longitude = cached.second
                                        } else {
                                            // Fazer geocoding apenas se n√£o estiver em cache
                                            val geocodingResult = geocodingService.geocodeAddress(provider.address)
                                            if (geocodingResult is com.taskgoapp.taskgo.core.location.GeocodingResult.Success) {
                                                latitude = geocodingResult.latitude
                                                longitude = geocodingResult.longitude
                                                // Armazenar no cache
                                                geocodingCache[cacheKey] = Pair(latitude, longitude)
                                            } else {
                                                latitude = null
                                                longitude = null
                                            }
                                        }
                                    } else {
                                        latitude = null
                                        longitude = null
                                    }
                                    
                                    if (latitude != null && longitude != null) {
                                        ProviderLocation(
                                            id = provider.uid,
                                            name = provider.displayName ?: "Prestador",
                                            category = provider.preferredCategories?.firstOrNull() ?: "Servi√ßos",
                                            latitude = latitude,
                                            longitude = longitude,
                                            rating = provider.rating?.toFloat(),
                                            isOnline = true
                                        )
                                    } else {
                                        null
                                    }
                                }
                            }
                        }?.awaitAll()?.filterNotNull() ?: emptyList()
                    }
                    
                    trySend(providers)
                }
            }
        
        awaitClose { listenerRegistration.remove() }
    }
    
    /**
     * Observa lojas com localiza√ß√£o em tempo real
     */
    fun observeStoresWithLocation(): Flow<List<StoreLocation>> = callbackFlow {
        val listenerRegistration = usersCollection
            .whereEqualTo("role", "store")
            .addSnapshotListener { snapshot, error ->
                if (error != null) {
                    android.util.Log.e("FirestoreMapLocationsRepository", "Erro ao observar stores: ${error.message}", error)
                    // N√£o fecha o flow, apenas envia lista vazia para evitar crash
                    trySend(emptyList())
                    return@addSnapshotListener
                }
                
                // Processar geocoding de forma ass√≠ncrona para n√£o bloquear o listener
                kotlinx.coroutines.CoroutineScope(kotlinx.coroutines.Dispatchers.IO).launch {
                    val stores = coroutineScope {
                        snapshot?.documents?.mapNotNull { doc ->
                            async {
                                val user = doc.toObject(UserFirestore::class.java)?.copy(uid = doc.id)
                                user?.let { store ->
                                    // Obter localiza√ß√£o via geocoding do endere√ßo (com cache)
                                    val latitude: Double?
                                    val longitude: Double?
                                    
                                    if (store.address != null) {
                                        // Criar chave de cache baseada no CEP ou endere√ßo completo
                                        val cacheKey = store.address.zipCode.ifEmpty { 
                                            "${store.address.street}, ${store.address.city}, ${store.address.state}"
                                        }
                                        
                                        // Verificar cache primeiro
                                        val cached = geocodingCache[cacheKey]
                                        if (cached != null) {
                                            latitude = cached.first
                                            longitude = cached.second
                                        } else {
                                            // Fazer geocoding apenas se n√£o estiver em cache
                                            val geocodingResult = geocodingService.geocodeAddress(store.address)
                                            if (geocodingResult is com.taskgoapp.taskgo.core.location.GeocodingResult.Success) {
                                                latitude = geocodingResult.latitude
                                                longitude = geocodingResult.longitude
                                                // Armazenar no cache
                                                geocodingCache[cacheKey] = Pair(latitude, longitude)
                                            } else {
                                                latitude = null
                                                longitude = null
                                            }
                                        }
                                    } else {
                                        latitude = null
                                        longitude = null
                                    }
                                    
                                    if (latitude != null && longitude != null) {
                                        StoreLocation(
                                            id = store.uid,
                                            name = store.displayName ?: "Loja",
                                            type = store.preferredCategories?.firstOrNull() ?: "Loja",
                                            latitude = latitude,
                                            longitude = longitude,
                                            rating = store.rating?.toFloat(),
                                            isOpen = true
                                        )
                                    } else {
                                        null
                                    }
                                }
                            }
                        }?.awaitAll()?.filterNotNull() ?: emptyList()
                    }
                    
                    trySend(stores)
                }
            }
        
        awaitClose { listenerRegistration.remove() }
    }
    
    /**
     * Busca prestadores e lojas pr√≥ximos a uma localiza√ß√£o
     */
    suspend fun getNearbyProvidersAndStores(
        latitude: Double,
        longitude: Double,
        radiusKm: Double = 50.0
    ): Pair<List<ProviderLocation>, List<StoreLocation>> {
        return try {
            // Buscar todos os prestadores e lojas
            val providersSnapshot = usersCollection
                .whereEqualTo("role", "provider")
                .get()
                .await()
            
            val storesSnapshot = usersCollection
                .whereEqualTo("role", "store")
                .get()
                .await()
            
            // Filtrar por dist√¢ncia
            // Fazer geocoding de todos os endere√ßos em paralelo
            val nearbyProviders = coroutineScope {
                providersSnapshot.documents.map { doc ->
                    async<ProviderLocation?> {
                        val user = doc.toObject(UserFirestore::class.java)?.copy(uid = doc.id)
                        user?.let { provider ->
                            if (provider.address != null) {
                                val geocodingResult = geocodingService.geocodeAddress(provider.address)
                                if (geocodingResult is com.taskgoapp.taskgo.core.location.GeocodingResult.Success) {
                                    val distance = calculateDistance(
                                        latitude, longitude,
                                        geocodingResult.latitude, geocodingResult.longitude
                                    )
                                    
                                    if (distance <= radiusKm) {
                                        ProviderLocation(
                                            id = provider.uid,
                                            name = provider.displayName ?: "Prestador",
                                            category = provider.preferredCategories?.firstOrNull() ?: "Servi√ßos",
                                            latitude = geocodingResult.latitude,
                                            longitude = geocodingResult.longitude,
                                            rating = provider.rating?.toFloat(),
                                            isOnline = true
                                        )
                                    } else null
                                } else null
                            } else null
                        }
                    }
                }.awaitAll().filterNotNull()
            }
            
            val nearbyStores = coroutineScope {
                storesSnapshot.documents.map { doc ->
                    async<StoreLocation?> {
                        val user = doc.toObject(UserFirestore::class.java)?.copy(uid = doc.id)
                        user?.let { store ->
                            if (store.address != null) {
                                val geocodingResult = geocodingService.geocodeAddress(store.address)
                                if (geocodingResult is com.taskgoapp.taskgo.core.location.GeocodingResult.Success) {
                                    val distance = calculateDistance(
                                        latitude, longitude,
                                        geocodingResult.latitude, geocodingResult.longitude
                                    )
                                    
                                    if (distance <= radiusKm) {
                                        StoreLocation(
                                            id = store.uid,
                                            name = store.displayName ?: "Loja",
                                            type = store.preferredCategories?.firstOrNull() ?: "Loja",
                                            latitude = geocodingResult.latitude,
                                            longitude = geocodingResult.longitude,
                                            rating = store.rating?.toFloat(),
                                            isOpen = true
                                        )
                                    } else null
                                } else null
                            } else null
                        }
                    }
                }.awaitAll().filterNotNull()
            }
            
            Pair(nearbyProviders, nearbyStores)
        } catch (e: Exception) {
            android.util.Log.e("FirestoreMapLocationsRepository", "Erro ao buscar locais pr√≥ximos: ${e.message}", e)
            Pair(emptyList(), emptyList())
        }
    }
    
    /**
     * Calcula dist√¢ncia entre duas coordenadas (Haversine)
     */
    private fun calculateDistance(lat1: Double, lon1: Double, lat2: Double, lon2: Double): Double {
        val R = 6371.0 // Raio da Terra em km
        val dLat = Math.toRadians(lat2 - lat1)
        val dLon = Math.toRadians(lon2 - lon1)
        val a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2)) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2)
        val c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))
        return R * c
    }
}


```

## [FRONTEND]: data/repository/FirestoreNotificationRepository.kt

```kotlin
package com.taskgoapp.taskgo.data.repository

import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.ListenerRegistration
import com.taskgoapp.taskgo.core.model.Result
import com.taskgoapp.taskgo.data.firestore.models.NotificationFirestore
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.tasks.await
import kotlinx.coroutines.channels.awaitClose
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class FirestoreNotificationRepository @Inject constructor(
    private val firestore: FirebaseFirestore,
    private val auth: FirebaseAuth
) {
    private val notificationsCollection = firestore.collection("notifications")

    fun observeNotifications(): Flow<List<NotificationFirestore>> = callbackFlow {
        val currentUser = auth.currentUser
        if (currentUser == null) {
            trySend(emptyList())
            close()
            return@callbackFlow
        }

        val listenerRegistration = notificationsCollection
            .whereEqualTo("userId", currentUser.uid)
            .orderBy("createdAt", com.google.firebase.firestore.Query.Direction.DESCENDING)
            .limit(50)
            .addSnapshotListener { snapshot, error ->
                if (error != null) {
                    close(error)
                    return@addSnapshotListener
                }

                val notifications = snapshot?.documents?.mapNotNull { doc ->
                    doc.toObject(NotificationFirestore::class.java)?.copy(id = doc.id)
                } ?: emptyList()

                trySend(notifications)
            }

        awaitClose { listenerRegistration.remove() }
    }

    suspend fun markAsRead(notificationId: String): Result<Unit> {
        return try {
            val currentUser = auth.currentUser
            if (currentUser == null) {
                return Result.Error(Exception("Usu√°rio n√£o autenticado"))
            }

            notificationsCollection
                .document(notificationId)
                .update("read", true, "readAt", com.google.firebase.firestore.FieldValue.serverTimestamp())
                .await()

            Result.Success(Unit)
        } catch (e: Exception) {
            Result.Error(e)
        }
    }

    suspend fun createNotification(
        type: String,
        title: String,
        message: String,
        orderId: String? = null,
        data: Map<String, Any>? = null
    ): Result<String> {
        return try {
            val currentUser = auth.currentUser
            if (currentUser == null) {
                return Result.Error(Exception("Usu√°rio n√£o autenticado"))
            }

            val notification = NotificationFirestore(
                userId = currentUser.uid,
                orderId = orderId,
                type = type,
                title = title,
                message = message,
                data = data,
                read = false,
                createdAt = java.util.Date()
            )

            val docRef = notificationsCollection.add(notification).await()
            Result.Success(docRef.id)
        } catch (e: Exception) {
            Result.Error(e)
        }
    }
}


```

## [FRONTEND]: data/repository/FirestoreOrderRepository.kt

```kotlin
package com.taskgoapp.taskgo.data.repository

import com.taskgoapp.taskgo.data.firestore.models.OrderFirestore
import com.taskgoapp.taskgo.data.firestore.models.ProposalDetails
import com.taskgoapp.taskgo.core.model.Result
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.FieldValue
import com.google.firebase.firestore.ListenerRegistration
import kotlinx.coroutines.tasks.await
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.channels.awaitClose
import com.taskgoapp.taskgo.core.firebase.LocationHelper
import com.taskgoapp.taskgo.core.location.LocationStateManager
import com.taskgoapp.taskgo.core.location.LocationState
import kotlinx.coroutines.flow.flatMapLatest
import kotlinx.coroutines.flow.flowOf
import android.util.Log
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class FirestoreOrderRepository @Inject constructor(
    private val firestore: FirebaseFirestore,
    private val authRepository: FirebaseAuthRepository,
    private val locationStateManager: LocationStateManager
) {
    // Construtor secund√°rio para compatibilidade com c√≥digo que n√£o usa inje√ß√£o de depend√™ncia
    constructor(
        firestore: FirebaseFirestore,
        authRepository: FirebaseAuthRepository
    ) : this(
        firestore,
        authRepository,
        // Criar LocationStateManager tempor√°rio - n√£o ser√° usado para queries neste contexto
        LocationStateManager(
            object : com.taskgoapp.taskgo.domain.repository.UserRepository {
                override fun observeCurrentUser() = kotlinx.coroutines.flow.flowOf(null)
                override suspend fun updateUser(user: com.taskgoapp.taskgo.core.model.UserProfile) {}
                override suspend fun updateAvatar(avatarUri: String) {}
            }
        )
    )
    // Cole√ß√£o p√∫blica para queries (prestadores precisam ver ordens pendentes)
    // CR√çTICO: Agora usamos cole√ß√µes por localiza√ß√£o, mas mantemos esta para compatibilidade
    private val publicOrdersCollection = firestore.collection("orders")
    
    // Helper para obter subcole√ß√£o do usu√°rio
    private fun getUserOrdersCollection(userId: String) = 
        firestore.collection("users").document(userId).collection("orders")

    /**
     * Observa ordens de um usu√°rio (cliente ou prestador)
     * Para clientes: busca na subcole√ß√£o users/{userId}/orders
     * Para prestadores: busca na cole√ß√£o p√∫blica onde providerId == userId
     */
    fun observeOrders(userId: String, role: String = "client"): Flow<List<OrderFirestore>> = callbackFlow {
        try {
            if (role == "client" || role == "user") {
                // CR√çTICO: Cliente deve observar a cole√ß√£o p√∫blica 'orders' onde clientId == userId
                // A Cloud Function createOrder salva na cole√ß√£o p√∫blica, n√£o na subcole√ß√£o
                android.util.Log.d("FirestoreOrderRepo", "üîµ Observando ordens do cliente na cole√ß√£o p√∫blica: userId=$userId, role=$role")
                val listenerRegistration = publicOrdersCollection
                    .whereEqualTo("clientId", userId)
                    .orderBy("createdAt", com.google.firebase.firestore.Query.Direction.DESCENDING)
                    .addSnapshotListener { snapshot, error ->
                        if (error != null) {
                            android.util.Log.e("FirestoreOrderRepo", "‚ùå Erro ao observar ordens do cliente: ${error.message}", error)
                            trySend(emptyList())
                            return@addSnapshotListener
                        }
                        
                        val orders = snapshot?.documents?.mapNotNull { doc ->
                            try {
                                doc.toObject(OrderFirestore::class.java)?.copy(id = doc.id)
                            } catch (e: Exception) {
                                android.util.Log.e("FirestoreOrderRepo", "Erro ao converter documento ${doc.id}: ${e.message}", e)
                                null
                            }
                        } ?: emptyList()
                        
                        android.util.Log.d("FirestoreOrderRepo", "üì¶ ${orders.size} ordens encontradas para cliente $userId")
                        trySend(orders)
                    }
                
                awaitClose { listenerRegistration.remove() }
            } else {
                // Parceiro/Prestador: busca na cole√ß√£o p√∫blica onde providerId == userId (tratar "partner", "provider" e "seller" da mesma forma)
                val listenerRegistration = publicOrdersCollection
                    .whereEqualTo("providerId", userId)
                    .orderBy("createdAt", com.google.firebase.firestore.Query.Direction.DESCENDING)
                    .addSnapshotListener { snapshot, error ->
                        if (error != null) {
                            android.util.Log.e("FirestoreOrderRepo", "Erro ao observar ordens do prestador: ${error.message}", error)
                            trySend(emptyList())
                            return@addSnapshotListener
                        }
                        
                        val orders = snapshot?.documents?.mapNotNull { doc ->
                            try {
                                doc.toObject(OrderFirestore::class.java)?.copy(id = doc.id)
                            } catch (e: Exception) {
                                android.util.Log.e("FirestoreOrderRepo", "Erro ao converter documento ${doc.id}: ${e.message}", e)
                                null
                            }
                        } ?: emptyList()
                        
                        trySend(orders)
                    }
                
                awaitClose { listenerRegistration.remove() }
            }
        } catch (e: Exception) {
            android.util.Log.e("FirestoreOrderRepo", "Erro ao configurar listener de ordens: ${e.message}", e)
            trySend(emptyList())
            close()
        }
    }

    /**
     * Observa ordens por status
     * Para clientes: busca na subcole√ß√£o
     * Para prestadores: busca na cole√ß√£o p√∫blica
     */
    fun observeOrdersByStatus(userId: String, role: String, status: String): Flow<List<OrderFirestore>> = callbackFlow {
        try {
            if (role == "client" || role == "user") {
                // CR√çTICO: Cliente deve observar a cole√ß√£o p√∫blica 'orders' onde clientId == userId
                // A Cloud Function createOrder salva na cole√ß√£o p√∫blica, n√£o na subcole√ß√£o
                android.util.Log.d("FirestoreOrderRepo", "üîµ Observando ordens do cliente por status na cole√ß√£o p√∫blica: userId=$userId, status=$status")
                val listenerRegistration = publicOrdersCollection
                    .whereEqualTo("clientId", userId)
                    .whereEqualTo("status", status)
                    .orderBy("createdAt", com.google.firebase.firestore.Query.Direction.DESCENDING)
                    .addSnapshotListener { snapshot, error ->
                        if (error != null) {
                            android.util.Log.e("FirestoreOrderRepo", "‚ùå Erro ao observar ordens por status: ${error.message}", error)
                            trySend(emptyList())
                            return@addSnapshotListener
                        }
                        
                        val orders = snapshot?.documents?.mapNotNull { doc ->
                            try {
                                doc.toObject(OrderFirestore::class.java)?.copy(id = doc.id)
                            } catch (e: Exception) {
                                android.util.Log.e("FirestoreOrderRepo", "Erro ao converter documento ${doc.id}: ${e.message}", e)
                                null
                            }
                        } ?: emptyList()
                        
                        android.util.Log.d("FirestoreOrderRepo", "üì¶ ${orders.size} ordens encontradas para cliente $userId com status $status")
                        trySend(orders)
                    }
                
                awaitClose { listenerRegistration.remove() }
            } else {
                // Parceiro/Prestador: busca na cole√ß√£o p√∫blica (tratar "partner" e "provider" da mesma forma)
                val listenerRegistration = publicOrdersCollection
                    .whereEqualTo("providerId", userId)
                    .whereEqualTo("status", status)
                    .orderBy("createdAt", com.google.firebase.firestore.Query.Direction.DESCENDING)
                    .addSnapshotListener { snapshot, error ->
                        if (error != null) {
                            android.util.Log.e("FirestoreOrderRepo", "Erro ao observar ordens por status: ${error.message}", error)
                            trySend(emptyList())
                            return@addSnapshotListener
                        }
                        
                        val orders = snapshot?.documents?.mapNotNull { doc ->
                            try {
                                doc.toObject(OrderFirestore::class.java)?.copy(id = doc.id)
                            } catch (e: Exception) {
                                android.util.Log.e("FirestoreOrderRepo", "Erro ao converter documento ${doc.id}: ${e.message}", e)
                                null
                            }
                        } ?: emptyList()
                        
                        trySend(orders)
                    }
                
                awaitClose { listenerRegistration.remove() }
            }
        } catch (e: Exception) {
            android.util.Log.e("FirestoreOrderRepo", "Erro ao configurar listener de ordens por status: ${e.message}", e)
            trySend(emptyList())
            close()
        }
    }

    /**
     * Busca uma ordem por ID
     * Tenta primeiro na cole√ß√£o p√∫blica
     */
    suspend fun getOrder(orderId: String): OrderFirestore? {
        return try {
            val document = publicOrdersCollection.document(orderId).get().await()
            if (document.exists()) {
                document.toObject(OrderFirestore::class.java)?.copy(id = document.id)
            } else {
                null
            }
        } catch (e: Exception) {
            android.util.Log.e("FirestoreOrderRepo", "Erro ao buscar ordem: ${e.message}", e)
            null
        }
    }

    /**
     * Atualiza status de uma ordem
     * Atualiza tanto na subcole√ß√£o do cliente quanto na cole√ß√£o p√∫blica
     */
    suspend fun updateOrderStatus(orderId: String, status: String): Result<Unit> {
        return try {
            // Buscar ordem para obter clientId
            val order = getOrder(orderId)
            if (order == null) {
                return Result.Error(Exception("Ordem n√£o encontrada"))
            }
            
            // Atualizar na cole√ß√£o p√∫blica (sempre)
            publicOrdersCollection.document(orderId).update(
                "status", status,
                "updatedAt", FieldValue.serverTimestamp()
            ).await()
            
            // Atualizar tamb√©m na subcole√ß√£o do cliente se existir
            if (order.clientId.isNotBlank()) {
                try {
                    val userOrdersCollection = getUserOrdersCollection(order.clientId)
                    userOrdersCollection.document(orderId).update(
                        "status", status,
                        "updatedAt", FieldValue.serverTimestamp()
                    ).await()
                } catch (e: Exception) {
                    android.util.Log.w("FirestoreOrderRepo", "Erro ao atualizar na subcole√ß√£o do cliente: ${e.message}")
                }
            }
            
            Result.Success(Unit)
        } catch (e: Exception) {
            android.util.Log.e("FirestoreOrderRepo", "Erro ao atualizar status da ordem: ${e.message}", e)
            Result.Error(e)
        }
    }

    /**
     * Adiciona proposta a uma ordem
     * Atualiza tanto na subcole√ß√£o do cliente quanto na cole√ß√£o p√∫blica
     */
    suspend fun addProposal(orderId: String, proposal: ProposalDetails): Result<Unit> {
        return try {
            // Buscar ordem para obter clientId
            val order = getOrder(orderId)
            if (order == null) {
                return Result.Error(Exception("Ordem n√£o encontrada"))
            }
            
            // Atualizar na cole√ß√£o p√∫blica
            publicOrdersCollection.document(orderId).update(
                "status", "proposed",
                "proposalDetails", proposal,
                "proposedAt", FieldValue.serverTimestamp(),
                "updatedAt", FieldValue.serverTimestamp()
            ).await()
            
            // Atualizar tamb√©m na subcole√ß√£o do cliente
            if (order.clientId.isNotBlank()) {
                try {
                    val userOrdersCollection = getUserOrdersCollection(order.clientId)
                    userOrdersCollection.document(orderId).update(
                        "status", "proposed",
                        "proposalDetails", proposal,
                        "proposedAt", FieldValue.serverTimestamp(),
                        "updatedAt", FieldValue.serverTimestamp()
                    ).await()
                } catch (e: Exception) {
                    android.util.Log.w("FirestoreOrderRepo", "Erro ao atualizar na subcole√ß√£o do cliente: ${e.message}")
                }
            }
            
            Result.Success(Unit)
        } catch (e: Exception) {
            android.util.Log.e("FirestoreOrderRepo", "Erro ao adicionar proposta: ${e.message}", e)
            Result.Error(e)
        }
    }
    
    /**
     * Observa ordens de servi√ßo dispon√≠veis na regi√£o do usu√°rio
     * ‚úÖ Agora usa LocationStateManager e cole√ß√£o por localiza√ß√£o locations/{locationId}/orders
     */
    fun observeLocalServiceOrders(
        category: String? = null
    ): Flow<List<OrderFirestore>> = locationStateManager.locationState
        .flatMapLatest { locationState ->
            when (locationState) {
                is LocationState.Loading -> {
                    Log.w("BLOCKED_QUERY", "Firestore query blocked: location not ready (Loading) - observeLocalServiceOrders")
                    flowOf(emptyList())
                }
                is LocationState.Error -> {
                    Log.e("BLOCKED_QUERY", "Firestore query blocked: location error - ${locationState.reason} - observeLocalServiceOrders")
                    flowOf(emptyList())
                }
                is LocationState.Ready -> {
                    // ‚úÖ Localiza√ß√£o pronta - fazer query Firestore
                    val locationId = locationState.locationId
                    
                    // üö® PROTE√á√ÉO: Nunca permitir "unknown" como locationId v√°lido
                    if (locationId == "unknown" || locationId.isBlank()) {
                        Log.e("FATAL_LOCATION", "Attempted Firestore query with invalid locationId: $locationId - observeLocalServiceOrders")
                        flowOf(emptyList())
                    } else {
                        observeLocalServiceOrdersFromFirestore(locationState, category)
                    }
                }
            }
        }
    
    private fun observeLocalServiceOrdersFromFirestore(
        locationState: LocationState.Ready,
        category: String?
    ): Flow<List<OrderFirestore>> = callbackFlow {
        var listenerRegistration: com.google.firebase.firestore.ListenerRegistration? = null
        try {
            // ‚úÖ Usar cole√ß√£o por localiza√ß√£o
            val locationOrdersCollection = LocationHelper.getLocationCollection(
                firestore,
                "orders",
                locationState.city,
                locationState.state
            )
            
            Log.d("FirestoreOrderRepo", """
                üìç Querying Firestore with location:
                City: ${locationState.city}
                State: ${locationState.state}
                LocationId: ${locationState.locationId}
                Category: $category
                Firestore Path: locations/${locationState.locationId}/orders
            """.trimIndent())
                
                var query = locationOrdersCollection
                    .whereEqualTo("status", "pending")
                    .whereEqualTo("deleted", false)
                
                // Filtrar por categoria se fornecida
                if (category != null && category.isNotBlank()) {
                    query = query.whereEqualTo("category", category)
                }
                
                listenerRegistration = query
                    .orderBy("createdAt", com.google.firebase.firestore.Query.Direction.DESCENDING)
                    .addSnapshotListener { snapshot, error ->
                        if (error != null) {
                            android.util.Log.e("FirestoreOrderRepo", "‚ùå Erro ao observar ordens locais por localiza√ß√£o: ${error.message}", error)
                            try {
                                trySend(emptyList())
                            } catch (e: kotlinx.coroutines.channels.ClosedSendChannelException) {
                                // Canal j√° foi fechado, ignorar
                            } catch (e: Exception) {
                                android.util.Log.w("FirestoreOrderRepo", "Erro ao enviar dados (canal pode estar fechado): ${e.message}")
                            }
                            return@addSnapshotListener
                        }
                        
                        try {
                            val orders = snapshot?.documents?.mapNotNull { doc ->
                                try {
                                    doc.toObject(OrderFirestore::class.java)?.copy(id = doc.id)
                                } catch (e: Exception) {
                                    android.util.Log.e("FirestoreOrderRepo", "Erro ao converter documento ${doc.id}: ${e.message}", e)
                                    null
                                }
                            } ?: emptyList()
                            
                            Log.d("FirestoreOrderRepo", "üì¶ ${orders.size} ordens encontradas na localiza√ß√£o ${locationState.city}, ${locationState.state}")
                            trySend(orders)
                        } catch (e: kotlinx.coroutines.channels.ClosedSendChannelException) {
                            // Canal j√° foi fechado, ignorar
                        } catch (e: Exception) {
                            android.util.Log.w("FirestoreOrderRepo", "Erro ao enviar dados (canal pode estar fechado): ${e.message}")
                }
            }
        } catch (e: Exception) {
            android.util.Log.e("FirestoreOrderRepo", "Erro ao configurar listener de ordens locais: ${e.message}", e)
            try {
                trySend(emptyList())
            } catch (ex: Exception) {
                // Ignorar se n√£o conseguir enviar
            }
        }
        
        awaitClose { 
            try {
                listenerRegistration?.remove()
            } catch (e: Exception) {
                android.util.Log.w("FirestoreOrderRepo", "Erro ao remover listener: ${e.message}")
            }
        }
    }
    
    /**
     * Busca ordens por categoria (para prestadores verem ordens na categoria deles)
     * Usa cole√ß√£o p√∫blica
     */
    fun observeOrdersByCategory(category: String): Flow<List<OrderFirestore>> = callbackFlow {
        try {
            val listenerRegistration = publicOrdersCollection
                .whereEqualTo("category", category)
                .whereEqualTo("status", "pending")
                .whereEqualTo("deleted", false)
                .orderBy("createdAt", com.google.firebase.firestore.Query.Direction.DESCENDING)
                .addSnapshotListener { snapshot, error ->
                    if (error != null) {
                        android.util.Log.e("FirestoreOrderRepo", "Erro ao observar ordens por categoria: ${error.message}", error)
                        trySend(emptyList())
                        return@addSnapshotListener
                    }
                    
                    val orders = snapshot?.documents?.mapNotNull { doc ->
                        try {
                            doc.toObject(OrderFirestore::class.java)?.copy(id = doc.id)
                        } catch (e: Exception) {
                            android.util.Log.e("FirestoreOrderRepo", "Erro ao converter documento ${doc.id}: ${e.message}", e)
                            null
                        }
                    } ?: emptyList()
                    
                    trySend(orders)
                }
            
            awaitClose { listenerRegistration.remove() }
        } catch (e: Exception) {
            android.util.Log.e("FirestoreOrderRepo", "Erro ao configurar listener de ordens por categoria: ${e.message}", e)
            trySend(emptyList())
            close()
        }
    }
    
    /**
     * Cria uma nova ordem (chamado por Cloud Function ou pelo app)
     * Salva tanto na subcole√ß√£o do cliente quanto na cole√ß√£o p√∫blica
     */
    suspend fun createOrder(order: OrderFirestore): Result<String> {
        return try {
            val currentUserId = authRepository.getCurrentUser()?.uid
                ?: return Result.Error(Exception("Usu√°rio n√£o autenticado"))
            
            // Garantir que clientId corresponde ao usu√°rio atual
            if (order.clientId != currentUserId) {
                return Result.Error(Exception("clientId n√£o corresponde ao usu√°rio atual"))
            }
            
            // Criar na subcole√ß√£o do cliente
            val userOrdersCollection = getUserOrdersCollection(order.clientId)
            val docRef = userOrdersCollection.add(order).await()
            val orderId = docRef.id
            
            // Criar tamb√©m na cole√ß√£o p√∫blica (para prestadores verem)
            try {
                publicOrdersCollection.document(orderId).set(order).await()
            } catch (e: Exception) {
                android.util.Log.w("FirestoreOrderRepo", "Erro ao salvar na cole√ß√£o p√∫blica: ${e.message}")
            }
            
            Result.Success(orderId)
        } catch (e: Exception) {
            android.util.Log.e("FirestoreOrderRepo", "Erro ao criar ordem: ${e.message}", e)
            Result.Error(e)
        }
    }
    
    /**
     * Aceita servi√ßo pelo prestador
     * Marca acceptedByProvider = true e verifica se ambos aceitaram para mudar status para in_progress
     */
    suspend fun acceptServiceByProvider(orderId: String): Result<Unit> {
        return try {
            val currentUserId = authRepository.getCurrentUser()?.uid
                ?: return Result.Error(Exception("Usu√°rio n√£o autenticado"))
            
            // Buscar ordem para validar
            val order = getOrder(orderId)
            if (order == null) {
                return Result.Error(Exception("Ordem n√£o encontrada"))
            }
            
            // Validar que o usu√°rio atual √© o provider da ordem
            if (order.providerId != currentUserId) {
                return Result.Error(Exception("Apenas o prestador da ordem pode aceitar o servi√ßo"))
            }
            
            // Verificar se j√° foi aceito pelo provider
            if (order.acceptedByProvider) {
                return Result.Success(Unit) // J√° foi aceito, nada a fazer
            }
            
            // Preparar dados de atualiza√ß√£o
            val updateData = hashMapOf<String, Any>(
                "acceptedByProvider" to true,
                "updatedAt" to FieldValue.serverTimestamp()
            )
            
            // Se ambos j√° aceitaram (cliente j√° aceitou), mudar status para in_progress
            if (order.acceptedByClient) {
                updateData["status"] = "in_progress"
                updateData["acceptedAt"] = FieldValue.serverTimestamp()
            }
            
            // Atualizar na cole√ß√£o p√∫blica
            publicOrdersCollection.document(orderId).update(updateData).await()
            
            // Atualizar tamb√©m na subcole√ß√£o do cliente
            if (order.clientId.isNotBlank()) {
                try {
                    val userOrdersCollection = getUserOrdersCollection(order.clientId)
                    userOrdersCollection.document(orderId).update(updateData).await()
                } catch (e: Exception) {
                    android.util.Log.w("FirestoreOrderRepo", "Erro ao atualizar na subcole√ß√£o do cliente: ${e.message}")
                }
            }
            
            Result.Success(Unit)
        } catch (e: Exception) {
            android.util.Log.e("FirestoreOrderRepo", "Erro ao aceitar servi√ßo pelo prestador: ${e.message}", e)
            Result.Error(e)
        }
    }
    
    /**
     * Aceita or√ßamento pelo cliente
     * Marca acceptedByClient = true e verifica se ambos aceitaram para mudar status para in_progress
     */
    suspend fun acceptQuoteByClient(orderId: String): Result<Unit> {
        return try {
            val currentUserId = authRepository.getCurrentUser()?.uid
                ?: return Result.Error(Exception("Usu√°rio n√£o autenticado"))
            
            // Buscar ordem para validar
            val order = getOrder(orderId)
            if (order == null) {
                return Result.Error(Exception("Ordem n√£o encontrada"))
            }
            
            // Validar que o usu√°rio atual √© o client da ordem
            if (order.clientId != currentUserId) {
                return Result.Error(Exception("Apenas o cliente da ordem pode aceitar o or√ßamento"))
            }
            
            // Verificar se j√° foi aceito pelo cliente
            if (order.acceptedByClient) {
                return Result.Success(Unit) // J√° foi aceito, nada a fazer
            }
            
            // Preparar dados de atualiza√ß√£o
            val updateData = hashMapOf<String, Any>(
                "acceptedByClient" to true,
                "updatedAt" to FieldValue.serverTimestamp()
            )
            
            // Se ambos j√° aceitaram (prestador j√° aceitou), mudar status para in_progress
            if (order.acceptedByProvider) {
                updateData["status"] = "in_progress"
                updateData["acceptedAt"] = FieldValue.serverTimestamp()
            }
            
            // Atualizar na cole√ß√£o p√∫blica
            publicOrdersCollection.document(orderId).update(updateData).await()
            
            // Atualizar tamb√©m na subcole√ß√£o do cliente
            try {
                val userOrdersCollection = getUserOrdersCollection(order.clientId)
                userOrdersCollection.document(orderId).update(updateData).await()
            } catch (e: Exception) {
                android.util.Log.w("FirestoreOrderRepo", "Erro ao atualizar na subcole√ß√£o do cliente: ${e.message}")
            }
            
            Result.Success(Unit)
        } catch (e: Exception) {
            android.util.Log.e("FirestoreOrderRepo", "Erro ao aceitar or√ßamento pelo cliente: ${e.message}", e)
            Result.Error(e)
        }
    }
    
    /**
     * Cancela uma ordem com motivo e valor de reembolso
     */
    suspend fun cancelOrder(orderId: String, reason: String, refundAmount: Double?): Result<Unit> {
        return try {
            val currentUserId = authRepository.getCurrentUser()?.uid
                ?: return Result.Error(Exception("Usu√°rio n√£o autenticado"))
            
            // Buscar ordem para validar
            val order = getOrder(orderId)
            if (order == null) {
                return Result.Error(Exception("Ordem n√£o encontrada"))
            }
            
            // Validar que o usu√°rio atual √© o provider ou client da ordem
            if (order.providerId != currentUserId && order.clientId != currentUserId) {
                return Result.Error(Exception("Apenas o prestador ou cliente da ordem podem cancelar"))
            }
            
            // Validar que a ordem est√° em andamento
            if (order.status != "in_progress") {
                return Result.Error(Exception("Apenas ordens em andamento podem ser canceladas"))
            }
            
            // Preparar dados de atualiza√ß√£o
            val updateData = hashMapOf<String, Any>(
                "status" to "cancelled",
                "cancelledReason" to reason,
                "updatedAt" to FieldValue.serverTimestamp()
            )
            
            if (refundAmount != null && refundAmount > 0) {
                updateData["cancelledRefundAmount"] = refundAmount
            }
            
            // Atualizar na cole√ß√£o p√∫blica
            publicOrdersCollection.document(orderId).update(updateData).await()
            
            // Atualizar tamb√©m na subcole√ß√£o do cliente
            if (order.clientId.isNotBlank()) {
                try {
                    val userOrdersCollection = getUserOrdersCollection(order.clientId)
                    userOrdersCollection.document(orderId).update(updateData).await()
                } catch (e: Exception) {
                    android.util.Log.w("FirestoreOrderRepo", "Erro ao atualizar na subcole√ß√£o do cliente: ${e.message}")
                }
            }
            
            Result.Success(Unit)
        } catch (e: Exception) {
            android.util.Log.e("FirestoreOrderRepo", "Erro ao cancelar ordem: ${e.message}", e)
            Result.Error(e)
        }
    }
    
    /**
     * Conclui uma ordem com descri√ß√£o, tempo e URLs das m√≠dias
     */
    suspend fun completeOrder(
        orderId: String,
        description: String,
        time: String,
        mediaUrls: List<String>
    ): Result<Unit> {
        return try {
            val currentUserId = authRepository.getCurrentUser()?.uid
                ?: return Result.Error(Exception("Usu√°rio n√£o autenticado"))
            
            // Buscar ordem para validar
            val order = getOrder(orderId)
            if (order == null) {
                return Result.Error(Exception("Ordem n√£o encontrada"))
            }
            
            // Validar que o usu√°rio atual √© o provider da ordem
            if (order.providerId != currentUserId) {
                return Result.Error(Exception("Apenas o prestador da ordem pode concluir o servi√ßo"))
            }
            
            // Validar que a ordem est√° em andamento
            if (order.status != "in_progress") {
                return Result.Error(Exception("Apenas ordens em andamento podem ser conclu√≠das"))
            }
            
            // Preparar dados de atualiza√ß√£o
            val updateData = hashMapOf<String, Any>(
                "status" to "completed",
                "completedDescription" to description,
                "completedTime" to time,
                "completedMediaUrls" to mediaUrls,
                "updatedAt" to FieldValue.serverTimestamp()
            )
            
            // Atualizar na cole√ß√£o p√∫blica
            publicOrdersCollection.document(orderId).update(updateData).await()
            
            // Atualizar tamb√©m na subcole√ß√£o do cliente
            if (order.clientId.isNotBlank()) {
                try {
                    val userOrdersCollection = getUserOrdersCollection(order.clientId)
                    userOrdersCollection.document(orderId).update(updateData).await()
                } catch (e: Exception) {
                    android.util.Log.w("FirestoreOrderRepo", "Erro ao atualizar na subcole√ß√£o do cliente: ${e.message}")
                }
            }
            
            Result.Success(Unit)
        } catch (e: Exception) {
            android.util.Log.e("FirestoreOrderRepo", "Erro ao concluir ordem: ${e.message}", e)
            Result.Error(e)
        }
    }
}

```

## [FRONTEND]: data/repository/FirestoreOrdersRepositoryImpl.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.data.repository

import com.taskgoapp.taskgo.core.model.PurchaseOrder
import com.taskgoapp.taskgo.core.model.CartItem
import com.taskgoapp.taskgo.core.model.OrderStatus
import com.taskgoapp.taskgo.data.local.dao.CartDao
import com.taskgoapp.taskgo.domain.repository.OrdersRepository
import com.taskgoapp.taskgo.data.firestore.models.PurchaseOrderFirestore
import com.taskgoapp.taskgo.data.mapper.OrderMapper.toFirestore
import com.taskgoapp.taskgo.data.mapper.OrderMapper.toModel
import com.taskgoapp.taskgo.data.mapper.OrderMapper.toEntity
import com.taskgoapp.taskgo.data.mapper.CartMapper.toEntity as cartItemToEntity
import com.taskgoapp.taskgo.data.local.dao.PurchaseOrderDao
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.flow.onStart
import kotlinx.coroutines.launch
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.Dispatchers
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.ListenerRegistration
import com.google.firebase.firestore.FieldValue
import kotlinx.coroutines.tasks.await
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.collect
import kotlinx.coroutines.channels.awaitClose
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class FirestoreOrdersRepositoryImpl @Inject constructor(
    private val firestore: FirebaseFirestore,
    private val firebaseAuth: FirebaseAuth,
    private val cartDao: CartDao,
    private val purchaseOrderDao: PurchaseOrderDao,
    private val syncManager: com.taskgoapp.taskgo.core.sync.SyncManager,
    private val realtimeRepository: com.taskgoapp.taskgo.data.realtime.RealtimeDatabaseRepository
) : OrdersRepository {
    
    private val purchaseOrdersCollection = firestore.collection("purchase_orders")
    private val syncScope = CoroutineScope(SupervisorJob() + Dispatchers.IO)

    override fun observeOrders(): Flow<List<PurchaseOrder>> = flow {
        val userId = firebaseAuth.currentUser?.uid ?: return@flow
        
        // 1. Emite dados do cache local primeiro (instant√¢neo)
        purchaseOrderDao.observeAll().collect { cachedOrders ->
            val ordersWithItems = cachedOrders.map { entity ->
                val items = purchaseOrderDao.getItemsByOrderId(entity.id)
                entity.toModel(items.map { it.toModel() })
            }
            emit(ordersWithItems)
        }
    }.onStart {
        // 2. Sincroniza com Firebase em background quando o Flow √© coletado
        val userId = firebaseAuth.currentUser?.uid ?: return@onStart
        try {
            val snapshot = purchaseOrdersCollection
                .whereEqualTo("clientId", userId)
                .orderBy("createdAt")
                .get()
                .await()
            
            snapshot.documents.forEach { doc ->
                val order = doc.toObject(PurchaseOrderFirestore::class.java)?.copy(id = doc.id)?.toModel()
                order?.let {
                    purchaseOrderDao.upsert(it.toEntity())
                    val items = it.items.map { item: com.taskgoapp.taskgo.core.model.OrderItem -> item.toEntity(it.id) }
                    purchaseOrderDao.upsertItems(items)
                }
            }
        } catch (e: Exception) {
            android.util.Log.e("FirestoreOrdersRepo", "Erro ao sincronizar pedidos: ${e.message}", e)
        }
    }
    
    private fun observeOrdersOld(): Flow<List<PurchaseOrder>> = callbackFlow {
        val userId = firebaseAuth.currentUser?.uid ?: run {
            close()
            return@callbackFlow
        }
        
        val listenerRegistration = purchaseOrdersCollection
            .whereEqualTo("clientId", userId)
            .orderBy("createdAt")
            .addSnapshotListener { snapshot, error ->
                if (error != null) {
                    close(error)
                    return@addSnapshotListener
                }
                
                val orders = snapshot?.documents?.mapNotNull { doc ->
                    doc.toObject(PurchaseOrderFirestore::class.java)?.copy(id = doc.id)?.toModel()
                } ?: emptyList()
                
                trySend(orders)
            }
        
        awaitClose { listenerRegistration.remove() }
    }

    override fun observeOrdersByStatus(status: OrderStatus): Flow<List<PurchaseOrder>> = flow {
        val userId = firebaseAuth.currentUser?.uid ?: return@flow
        
        // 1. Emite dados do cache local primeiro (instant√¢neo)
        purchaseOrderDao.observeByStatus(status.name).collect { cachedOrders ->
            val ordersWithItems = cachedOrders.map { entity ->
                val items = purchaseOrderDao.getItemsByOrderId(entity.id)
                entity.toModel(items.map { it.toModel() })
            }
            emit(ordersWithItems)
        }
    }.onStart {
        // 2. Sincroniza com Firebase em background quando o Flow √© coletado
        val userId = firebaseAuth.currentUser?.uid ?: return@onStart
        try {
            val snapshot = purchaseOrdersCollection
                .whereEqualTo("clientId", userId)
                .whereEqualTo("status", status.name)
                .orderBy("createdAt")
                .get()
                .await()
            
            snapshot.documents.forEach { doc ->
                val order = doc.toObject(PurchaseOrderFirestore::class.java)?.copy(id = doc.id)?.toModel()
                order?.let {
                    purchaseOrderDao.upsert(it.toEntity())
                    val items = it.items.map { item: com.taskgoapp.taskgo.core.model.OrderItem -> item.toEntity(it.id) }
                    purchaseOrderDao.upsertItems(items)
                }
            }
        } catch (e: Exception) {
            android.util.Log.e("FirestoreOrdersRepo", "Erro ao sincronizar pedidos por status: ${e.message}", e)
        }
    }
    
    private fun observeOrdersByStatusOld(status: OrderStatus): Flow<List<PurchaseOrder>> = callbackFlow {
        val userId = firebaseAuth.currentUser?.uid ?: run {
            close()
            return@callbackFlow
        }
        
        val listenerRegistration = purchaseOrdersCollection
            .whereEqualTo("clientId", userId)
            .whereEqualTo("status", status.name)
            .orderBy("createdAt")
            .addSnapshotListener { snapshot, error ->
                if (error != null) {
                    close(error)
                    return@addSnapshotListener
                }
                
                val orders = snapshot?.documents?.mapNotNull { doc ->
                    doc.toObject(PurchaseOrderFirestore::class.java)?.copy(id = doc.id)?.toModel()
                } ?: emptyList()
                
                trySend(orders)
            }
        
        awaitClose { listenerRegistration.remove() }
    }

    override suspend fun getOrder(id: String): PurchaseOrder? {
        // 1. Tenta buscar do cache local primeiro (instant√¢neo)
        val cachedEntity = purchaseOrderDao.getById(id)
        if (cachedEntity != null) {
            val items = purchaseOrderDao.getItemsByOrderId(id)
            return cachedEntity.toModel(items.map { it.toModel() })
        }
        
        // 2. Se n√£o encontrou no cache, busca do Firebase
        return try {
            val document = purchaseOrdersCollection.document(id).get().await()
            val order = document.toObject(PurchaseOrderFirestore::class.java)?.copy(id = document.id)?.toModel()
            
            // Salva no cache para pr√≥ximas consultas
            order?.let {
                purchaseOrderDao.upsert(it.toEntity())
                val items = it.items.map { item: com.taskgoapp.taskgo.core.model.OrderItem -> item.toEntity(it.id) }
                purchaseOrderDao.upsertItems(items)
            }
            
            order
        } catch (e: Exception) {
            null
        }
    }

    override suspend fun createOrder(
        cart: List<CartItem>,
        total: Double,
        paymentMethod: String,
        addressId: String
    ): String {
        val userId = firebaseAuth.currentUser?.uid ?: throw IllegalStateException("User not authenticated")
        val orderId = generateOrderId()
        val orderNumber = "TG${System.currentTimeMillis()}"
        
        val order = PurchaseOrder(
            id = orderId,
            orderNumber = orderNumber,
            createdAt = System.currentTimeMillis(),
            total = total,
            subtotal = total,
            deliveryFee = 0.0,
            status = OrderStatus.EM_ANDAMENTO, // Ser√° atualizado para PENDING_PAYMENT no Firestore
            items = emptyList(), // Will be populated from cart when we implement cart to order items
            paymentMethod = paymentMethod,
            deliveryAddress = addressId
        )
        
        // 1. Salva localmente primeiro (instant√¢neo)
        purchaseOrderDao.upsert(order.toEntity())
        
        // Salva itens do pedido localmente
        val orderItems = cart.mapNotNull { cartItem ->
            com.taskgoapp.taskgo.core.model.OrderItem(
                productId = cartItem.productId,
                price = 0.0, // TODO: Fetch from product
                quantity = cartItem.qty
            )
        }
        val itemEntities = orderItems.map { orderItem: com.taskgoapp.taskgo.core.model.OrderItem -> orderItem.toEntity(orderId) }
        purchaseOrderDao.upsertItems(itemEntities)
        
        // Clear cart
        cartDao.clearAll()
        
        // 2. Salva no Realtime Database imediatamente
        val firestoreOrder = order.toFirestore().copy(clientId = userId)
        val firestoreItems = orderItems.map { it.toFirestore() }
        val orderWithItems = firestoreOrder.copy(items = firestoreItems)
        
        val orderData = mapOf(
            "id" to orderId,
            "orderNumber" to orderNumber,
            "clientId" to userId,
            "total" to total,
            "subtotal" to total,
            "deliveryFee" to 0.0,
            "status" to "PENDING_PAYMENT", // Status inicial para produtos (aguardando pagamento)
            "paymentMethod" to paymentMethod,
            "deliveryAddress" to addressId,
            "createdAt" to System.currentTimeMillis(),
            "items" to firestoreItems.map { item ->
                mapOf(
                    "productId" to item.productId,
                    "productName" to (item.productName ?: ""),
                    "productImage" to (item.productImage ?: ""),
                    "price" to item.price,
                    "quantity" to item.quantity
                )
            }
        )
        
        // REMOVIDO: savePurchaseOrder est√° DEPRECATED e lan√ßa UnsupportedOperationException
        // Ordens devem ser criadas apenas via Cloud Functions para garantir seguran√ßa
        // syncScope.launch {
        //     realtimeRepository.savePurchaseOrder(orderId, orderData)
        // }
        
        // 3. Agenda sincroniza√ß√£o com Firestore ap√≥s 1 minuto
        syncManager.scheduleSync(
            syncType = "order",
            entityId = orderId,
            operation = "create",
            data = orderWithItems
        )
        
        return orderId
    }

    override suspend fun updateOrderStatus(orderId: String, status: OrderStatus) {
        // 1. Atualiza localmente primeiro (instant√¢neo)
        purchaseOrderDao.updateStatus(orderId, status.name)
        
        // 2. Agenda sincroniza√ß√£o com Firebase ap√≥s 1 minuto
        val updateData = mapOf(
            "status" to status.name,
            "updatedAt" to com.google.firebase.firestore.FieldValue.serverTimestamp()
        )
        
        syncManager.scheduleSync(
            syncType = "order",
            entityId = orderId,
            operation = "update",
            data = updateData
        )
    }

    suspend fun getPurchaseOrder(orderId: String): PurchaseOrderFirestore? {
        return try {
            val document = purchaseOrdersCollection.document(orderId).get().await()
            document.toObject(PurchaseOrderFirestore::class.java)?.copy(id = document.id)
        } catch (e: Exception) {
            android.util.Log.e("FirestoreOrdersRepo", "Erro ao obter pedido: ${e.message}", e)
            null
        }
    }
    
    suspend fun updatePurchaseOrderStatus(orderId: String, status: String) {
        try {
            purchaseOrdersCollection.document(orderId).update(
                "status", status,
                "updatedAt", FieldValue.serverTimestamp()
            ).await()
            
            // Atualiza cache local tamb√©m
            purchaseOrderDao.updateStatus(orderId, status)
        } catch (e: Exception) {
            android.util.Log.e("FirestoreOrdersRepo", "Erro ao atualizar status: ${e.message}", e)
            throw e
        }
    }

    private fun generateOrderId(): String {
        return "order_${System.currentTimeMillis()}_${(1000..9999).random()}"
    }
}


```

## [FRONTEND]: data/repository/FirestoreProductsRepository.kt

```kotlin
package com.taskgoapp.taskgo.data.repository

import com.taskgoapp.taskgo.data.firestore.models.ProductFirestore
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.FieldValue
import com.google.firebase.firestore.ListenerRegistration
import kotlinx.coroutines.tasks.await
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.channels.awaitClose
import com.taskgoapp.taskgo.core.firebase.LocationHelper
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Reposit√≥rio Firebase puro (sem cache local) para produtos.
 * - Sempre l√™/escreve diretamente no Firestore.
 * - CR√çTICO: Usa cole√ß√£o por localiza√ß√£o locations/{city}_{state}/products para dados p√∫blicos.
 * - Usa subcole√ß√£o users/{uid}/products para dados privados.
 * - Filtra por active=true.
 */
@Singleton
class FirestoreProductsRepository @Inject constructor(
    private val firestore: FirebaseFirestore,
    private val authRepository: FirebaseAuthRepository
) {
    // Cole√ß√£o p√∫blica para queries (visualiza√ß√£o de produtos por outros usu√°rios)
    // CR√çTICO: Agora usamos cole√ß√µes por localiza√ß√£o, mas mantemos esta para compatibilidade
    private val publicProductsCollection = firestore.collection("products")
    
    // Helper para obter subcole√ß√£o do usu√°rio
    private fun getUserProductsCollection(userId: String) = 
        firestore.collection("users").document(userId).collection("products")

    /** 
     * Observa todos os produtos ativos (query p√∫blica)
     * CR√çTICO: Usa cole√ß√£o por localiza√ß√£o locations/{city}_{state}/products
     * @param city Cidade (opcional, se n√£o fornecido usa cole√ß√£o global)
     * @param state Estado (opcional, se n√£o fornecido usa cole√ß√£o global)
     */
    fun observeAllProducts(city: String? = null, state: String? = null): Flow<List<ProductFirestore>> = callbackFlow {
        // CR√çTICO: Se cidade e estado forem fornecidos, usar cole√ß√£o por localiza√ß√£o
        if (city != null && state != null && city.isNotBlank() && state.isNotBlank()) {
            android.util.Log.d("FirestoreProductsRepo", "üîµ Observando produtos por localiza√ß√£o: city=$city, state=$state")
            val locationProductsCollection = LocationHelper.getLocationCollection(firestore, "products", city, state)
            
            val listenerRegistration: ListenerRegistration = locationProductsCollection
                .whereEqualTo("active", true)
                .orderBy("createdAt")
                .addSnapshotListener { snapshot, error ->
                    if (error != null) {
                        android.util.Log.e("FirestoreProductsRepo", "‚ùå Erro ao observar produtos por localiza√ß√£o: ${error.message}", error)
                        trySend(emptyList())
                        return@addSnapshotListener
                    }
                    
                    val products = snapshot?.documents?.mapNotNull { doc ->
                        doc.toObject(ProductFirestore::class.java)?.copy(id = doc.id)
                    } ?: emptyList()
                    
                    android.util.Log.d("FirestoreProductsRepo", "üì¶ ${products.size} produtos encontrados na localiza√ß√£o $city, $state")
                    trySend(products)
                }
            
            awaitClose { listenerRegistration.remove() }
        } else {
            // Fallback: usar cole√ß√£o global se localiza√ß√£o n√£o fornecida
            android.util.Log.w("FirestoreProductsRepo", "‚ö†Ô∏è Localiza√ß√£o n√£o fornecida, usando cole√ß√£o global (compatibilidade)")
            val listenerRegistration: ListenerRegistration = publicProductsCollection
                .whereEqualTo("active", true)
                .orderBy("createdAt")
                .addSnapshotListener { snapshot, error ->
                    if (error != null) {
                        android.util.Log.e("FirestoreProductsRepo", "Erro ao observar produtos: ${error.message}", error)
                        trySend(emptyList())
                        return@addSnapshotListener
                    }
                    
                    val products = snapshot?.documents?.mapNotNull { doc ->
                        doc.toObject(ProductFirestore::class.java)?.copy(id = doc.id)
                    } ?: emptyList()
                    
                    trySend(products)
                }
            
            awaitClose { listenerRegistration.remove() }
        }
    }

    /** Observa produtos de um vendedor espec√≠fico (subcole√ß√£o users/{uid}/products) */
    fun observeProductsBySeller(sellerId: String): Flow<List<ProductFirestore>> = callbackFlow {
        try {
            val userProductsCollection = getUserProductsCollection(sellerId)
            val listenerRegistration = userProductsCollection
                .whereEqualTo("active", true)
                .orderBy("createdAt")
                .addSnapshotListener { snapshot, error ->
                    if (error != null) {
                        android.util.Log.e("FirestoreProductsRepo", "Erro ao observar produtos do vendedor: ${error.message}", error)
                        trySend(emptyList())
                        return@addSnapshotListener
                    }
                    
                    val products = snapshot?.documents?.mapNotNull { doc ->
                        doc.toObject(ProductFirestore::class.java)?.copy(id = doc.id)
                    } ?: emptyList()
                    
                    trySend(products)
                }
            
            awaitClose { listenerRegistration.remove() }
        } catch (e: Exception) {
            android.util.Log.e("FirestoreProductsRepo", "Erro ao configurar listener de produtos do vendedor: ${e.message}", e)
            trySend(emptyList())
            close()
        }
    }

    /** Busca um produto por ID na cole√ß√£o p√∫blica */
    suspend fun getProduct(productId: String): ProductFirestore? {
        return try {
            val document = publicProductsCollection.document(productId).get().await()
            if (document.exists()) {
                document.toObject(ProductFirestore::class.java)?.copy(id = document.id)
            } else {
                null
            }
        } catch (e: Exception) {
            android.util.Log.e("FirestoreProductsRepo", "Erro ao buscar produto: ${e.message}", e)
            null
        }
    }

    /** Cria um novo produto em subcole√ß√£o do usu√°rio e na cole√ß√£o p√∫blica */
    suspend fun createProduct(product: ProductFirestore): Result<String> {
        return try {
            val currentUserId = authRepository.getCurrentUser()?.uid
                ?: return Result.failure(Exception("Usu√°rio n√£o autenticado"))
            
            if (product.sellerId != currentUserId) {
                return Result.failure(Exception("sellerId n√£o corresponde ao usu√°rio atual"))
            }
            
            val userProductsCollection = getUserProductsCollection(product.sellerId)
            val docRef = userProductsCollection.add(product).await()
            val productId = docRef.id
            
            try {
                publicProductsCollection.document(productId).set(product).await()
            } catch (e: Exception) {
                android.util.Log.w("FirestoreProductsRepo", "Erro ao salvar na cole√ß√£o p√∫blica: ${e.message}")
            }
            
            Result.success(productId)
        } catch (e: Exception) {
            android.util.Log.e("FirestoreProductsRepo", "Erro ao criar produto: ${e.message}", e)
            Result.failure(e)
        }
    }

    /** Atualiza produto em subcole√ß√£o e na cole√ß√£o p√∫blica */
    suspend fun updateProduct(productId: String, product: ProductFirestore): Result<Unit> {
        return try {
            val currentUserId = authRepository.getCurrentUser()?.uid
                ?: return Result.failure(Exception("Usu√°rio n√£o autenticado"))
            
            if (product.sellerId != currentUserId) {
                return Result.failure(Exception("N√£o √© poss√≠vel atualizar produto de outro usu√°rio"))
            }
            
            val userProductsCollection = getUserProductsCollection(product.sellerId)
            userProductsCollection.document(productId).set(product).await()
            
            try {
                publicProductsCollection.document(productId).set(product).await()
            } catch (e: Exception) {
                android.util.Log.w("FirestoreProductsRepo", "Erro ao atualizar na cole√ß√£o p√∫blica: ${e.message}")
            }
            
            Result.success(Unit)
        } catch (e: Exception) {
            android.util.Log.e("FirestoreProductsRepo", "Erro ao atualizar produto: ${e.message}", e)
            Result.failure(e)
        }
    }

    /** Soft delete: marca active=false em subcole√ß√£o e p√∫blica */
    suspend fun deleteProduct(productId: String): Result<Unit> {
        return try {
            val currentUserId = authRepository.getCurrentUser()?.uid
                ?: return Result.failure(Exception("Usu√°rio n√£o autenticado"))
            
            val product = getProduct(productId)
            if (product == null) {
                return Result.failure(Exception("Produto n√£o encontrado"))
            }
            if (product.sellerId != currentUserId) {
                return Result.failure(Exception("N√£o √© poss√≠vel deletar produto de outro usu√°rio"))
            }
            
            val userProductsCollection = getUserProductsCollection(product.sellerId)
            userProductsCollection.document(productId).update(
                "active", false,
                "updatedAt", FieldValue.serverTimestamp()
            ).await()
            
            try {
                publicProductsCollection.document(productId).update(
                    "active", false,
                    "updatedAt", FieldValue.serverTimestamp()
                ).await()
            } catch (e: Exception) {
                android.util.Log.w("FirestoreProductsRepo", "Erro ao atualizar na cole√ß√£o p√∫blica: ${e.message}")
            }
            
            Result.success(Unit)
        } catch (e: Exception) {
            android.util.Log.e("FirestoreProductsRepo", "Erro ao deletar produto: ${e.message}", e)
            Result.failure(e)
        }
    }

    /** Busca produtos por query de texto, somente ativos */
    suspend fun searchProducts(query: String): Flow<List<ProductFirestore>> = callbackFlow {
        val listenerRegistration = publicProductsCollection
            .whereEqualTo("active", true)
            .orderBy("title")
            .startAt(query)
            .endAt(query + "\uf8ff")
            .addSnapshotListener { snapshot, error ->
                if (error != null) {
                    android.util.Log.e("FirestoreProductsRepo", "Erro ao buscar produtos: ${error.message}", error)
                    trySend(emptyList())
                    return@addSnapshotListener
                }
                
                val products = snapshot?.documents?.mapNotNull { doc ->
                    doc.toObject(ProductFirestore::class.java)?.copy(id = doc.id)
                } ?: emptyList()
                
                trySend(products)
            }
        
        awaitClose { listenerRegistration.remove() }
    }
}


```

## [FRONTEND]: data/repository/FirestoreProductsRepositoryImpl.kt

```kotlin
package com.taskgoapp.taskgo.data.repository

import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.ListenerRegistration
import com.google.firebase.firestore.Source
import com.taskgoapp.taskgo.core.model.CartItem
import com.taskgoapp.taskgo.core.model.Product
import com.taskgoapp.taskgo.data.firestore.models.ProductFirestore
import com.taskgoapp.taskgo.data.local.dao.CartDao
import com.taskgoapp.taskgo.data.mapper.CartMapper.toEntity
import com.taskgoapp.taskgo.data.mapper.CartMapper.toModel
import com.taskgoapp.taskgo.data.mapper.ProductMapper.toFirestore
import com.taskgoapp.taskgo.data.mapper.ProductMapper.toModel
import com.taskgoapp.taskgo.domain.repository.ProductsRepository
import com.taskgoapp.taskgo.core.firebase.LocationHelper
import com.taskgoapp.taskgo.core.location.LocationStateManager
import com.taskgoapp.taskgo.core.location.LocationState
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.asSharedFlow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.firstOrNull
import kotlinx.coroutines.flow.flowOf
import kotlinx.coroutines.flow.onEach
import kotlinx.coroutines.flow.flatMapLatest
import kotlinx.coroutines.tasks.await
import android.util.Log
import kotlinx.coroutines.launch
import kotlinx.coroutines.withTimeoutOrNull
import kotlinx.coroutines.delay
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class FirestoreProductsRepositoryImpl @Inject constructor(
    private val firestore: FirebaseFirestore,
    private val firebaseAuth: FirebaseAuth,
    private val cartDao: CartDao,
    private val userRepository: com.taskgoapp.taskgo.domain.repository.UserRepository,
    private val locationStateManager: LocationStateManager
) : ProductsRepository {

    // DEBUG ONLY - Cole√ß√£o global mantida apenas para compatibilidade durante migra√ß√£o
    // REMOVER AP√ìS VALIDA√á√ÉO COMPLETA
    private val productsCollectionGlobal = firestore.collection("products")
    private val productErrors = MutableSharedFlow<String>(extraBufferCapacity = 1)
    private val syncScope = CoroutineScope(SupervisorJob() + Dispatchers.IO)

    override fun observeProducts(): Flow<List<Product>> = locationStateManager.locationState
        .flatMapLatest { locationState ->
            when (locationState) {
                is LocationState.Loading -> {
                    Log.w("BLOCKED_QUERY", "Firestore query blocked: location not ready (Loading)")
                    flowOf(emptyList())
                }
                is LocationState.Error -> {
                    Log.e("BLOCKED_QUERY", "Firestore query blocked: location error - ${locationState.reason}")
                    flowOf(emptyList())
                }
                is LocationState.Ready -> {
                    // ‚úÖ Localiza√ß√£o pronta - fazer query Firestore
                    val locationId = locationState.locationId
                    
                    // üö® PROTE√á√ÉO: Nunca permitir "unknown" como locationId v√°lido
                    if (locationId == "unknown" || locationId.isBlank()) {
                        Log.e("FATAL_LOCATION", "Attempted Firestore query with invalid locationId: $locationId")
                        flowOf(emptyList())
                    } else {
                        observeProductsFromFirestore(locationState)
                    }
                }
            }
        }
    
    private fun observeProductsFromFirestore(locationState: LocationState.Ready): Flow<List<Product>> = callbackFlow {
        val listener: ListenerRegistration? = try {
            val collectionToUse = LocationHelper.getLocationCollection(
                firestore,
                "products",
                locationState.city,
                locationState.state
            )
            
            Log.d("FirestoreProductsRepo", """
                üìç Querying Firestore with location:
                City: ${locationState.city}
                State: ${locationState.state}
                LocationId: ${locationState.locationId}
                Firestore Path: locations/${locationState.locationId}/products
            """.trimIndent())
            
            // Configurar listener
            // ‚ö†Ô∏è ETAPA 5: Ajustar filtros para evitar exclus√µes silenciosas
            // Usar filtro mais permissivo temporariamente para estabilizar
            collectionToUse
                .orderBy("createdAt", com.google.firebase.firestore.Query.Direction.DESCENDING)
                .addSnapshotListener { snapshot, error ->
                    if (error != null) {
                        Log.e("FirestoreProductsRepo", 
                            "‚ùå Erro no listener de produtos: ${error.message}", error)
                        trySend(emptyList())
                        return@addSnapshotListener
                    }
                    if (snapshot == null) {
                        Log.w("FirestoreProductsRepo", 
                            "‚ö†Ô∏è Snapshot vazio (sem produtos encontrados)")
                        trySend(emptyList())
                        return@addSnapshotListener
                    }
                    
                    Log.d("FirestoreProductsRepo", 
                        "Snapshot recebido: size=${snapshot.size()}, collection=locations/${locationState.locationId}/products")
                    
                    // üìç SNAPSHOT PROOF - Logar TUDO que vem do Firestore
                    Log.d("FirestoreSnapshot", """
                        üìç FRONTEND SNAPSHOT PROOF
                        Collection path: ${collectionToUse.path}
                        Snapshot empty: ${snapshot.isEmpty}
                        Snapshot size: ${snapshot.size()}
                        Documents count: ${snapshot.documents.size}
                    """.trimIndent())
                    
                    snapshot.documents.forEachIndexed { index, doc ->
                        Log.d("FirestoreSnapshot", """
                            üìç FRONTEND SNAPSHOT PROOF - Document $index
                            Doc ID: ${doc.id}
                            Doc data keys: ${doc.data?.keys?.joinToString(", ") ?: "null"}
                            Doc has createdAt: ${doc.data?.containsKey("createdAt")}
                            Doc has active: ${doc.data?.get("active")}
                            Doc has status: ${doc.data?.get("status")}
                        """.trimIndent())
                    }
                    
                    val products = snapshot.documents.mapNotNull { doc ->
                        try {
                            val data = doc.data ?: return@mapNotNull null
                            val createdAt = when (val v = data["createdAt"]) {
                                is Long -> java.util.Date(v)
                                is java.util.Date -> v
                                is com.google.firebase.Timestamp -> v.toDate()
                                else -> null
                            }
                            val updatedAt = when (val v = data["updatedAt"]) {
                                is Long -> java.util.Date(v)
                                is java.util.Date -> v
                                is com.google.firebase.Timestamp -> v.toDate()
                                else -> null
                            }
                            ProductFirestore(
                                id = doc.id,
                                title = data["title"] as? String ?: "",
                                price = (data["price"] as? Number)?.toDouble() ?: 0.0,
                                description = data["description"] as? String,
                                sellerId = data["sellerId"] as? String ?: "",
                                sellerName = data["sellerName"] as? String,
                                imageUrls = ((data["imageUrls"] as? List<*>)?.mapNotNull { it as? String } 
                                    ?: (data["images"] as? List<*>)?.mapNotNull { it as? String } 
                                    ?: emptyList()),
                                category = data["category"] as? String,
                                tags = (data["tags"] as? List<*>)?.mapNotNull { it as? String } ?: emptyList(),
                                // ‚ö†Ô∏è ETAPA 5: Permitir aus√™ncia de campo no parsing (evitar exclus√µes silenciosas)
                                active = data["active"] as? Boolean ?: true,
                                status = data["status"] as? String ?: "active",
                                featured = data["featured"] as? Boolean ?: false,
                                discountPercentage = (data["discountPercentage"] as? Number)?.toDouble(),
                                createdAt = createdAt,
                                updatedAt = updatedAt,
                                rating = (data["rating"] as? Number)?.toDouble(),
                                latitude = (data["latitude"] as? Number)?.toDouble(),
                                longitude = (data["longitude"] as? Number)?.toDouble()
                            ).toModel()
                        } catch (e: Exception) {
                            Log.e("FirestoreProductsRepo", "Erro ao converter documento ${doc.id}: ${e.message}", e)
                            null
                        }
                    }
                    
                    // ‚ö†Ô∏è ETAPA 5: Filtrar produtos ap√≥s receber (evitar exclus√µes silenciosas)
                    // Filtrar apenas produtos ativos e com status "active" (produtos p√∫blicos)
                    // Permitir aus√™ncia de campo no parsing (evitar exclus√µes silenciosas)
                    val filteredProducts = products.filterIndexed { index, product ->
                        val doc = snapshot.documents.getOrNull(index)
                        val isActive = doc?.data?.get("active") as? Boolean ?: true
                        val status = doc?.data?.get("status") as? String ?: "active"
                        
                        isActive && status == "active"
                    }
                    
                    Log.d("FirestoreProductsRepo", 
                        "Produtos filtrados: total=${products.size}, ativos=${filteredProducts.size}")
                    
                    trySend(filteredProducts)
                }
        } catch (e: Exception) {
            android.util.Log.e("FirestoreProductsRepo", "Erro ao configurar listener: ${e.message}", e)
            trySend(emptyList())
            null
        }
        awaitClose { listener?.remove() }
    }

    override fun observeProductErrors(): Flow<String> = productErrors.asSharedFlow()

    override suspend fun getProduct(id: String): Product? {
        return try {
            // DEBUG ONLY - Tentar buscar da cole√ß√£o global primeiro (compatibilidade)
            // TODO: Buscar de todas as locations se necess√°rio, ou receber city/state como par√¢metro
            val document = productsCollectionGlobal.document(id).get(Source.SERVER).await()
            val data = document.data ?: return null
            val createdAt = when (val v = data["createdAt"]) {
                is Long -> java.util.Date(v)
                is java.util.Date -> v
                is com.google.firebase.Timestamp -> v.toDate()
                else -> null
            }
            val updatedAt = when (val v = data["updatedAt"]) {
                is Long -> java.util.Date(v)
                is java.util.Date -> v
                is com.google.firebase.Timestamp -> v.toDate()
                else -> null
            }
            ProductFirestore(
                id = document.id,
                title = data["title"] as? String ?: "",
                price = (data["price"] as? Number)?.toDouble() ?: 0.0,
                description = data["description"] as? String,
                sellerId = data["sellerId"] as? String ?: "",
                sellerName = data["sellerName"] as? String,
                imageUrls = (data["imageUrls"] as? List<*>)?.mapNotNull { it as? String } ?: emptyList(),
                category = data["category"] as? String,
                tags = (data["tags"] as? List<*>)?.mapNotNull { it as? String } ?: emptyList(),
                active = data["active"] as? Boolean ?: true,
                featured = data["featured"] as? Boolean ?: false,
                discountPercentage = (data["discountPercentage"] as? Number)?.toDouble(),
                createdAt = createdAt,
                updatedAt = updatedAt,
                rating = (data["rating"] as? Number)?.toDouble(),
                latitude = (data["latitude"] as? Number)?.toDouble(),
                longitude = (data["longitude"] as? Number)?.toDouble()
            ).toModel()
        } catch (e: Exception) {
            android.util.Log.e("FirestoreProductsRepo", "Erro ao buscar produto: ${e.message}", e)
            null
        }
    }

    override suspend fun getMyProducts(): List<Product> {
        val userId = firebaseAuth.currentUser?.uid ?: return emptyList()
        return try {
            // CR√çTICO: Buscar produtos do usu√°rio da cole√ß√£o por localiza√ß√£o
            // Primeiro, obter localiza√ß√£o do usu√°rio
            val user = withTimeoutOrNull(2000) {
                userRepository.observeCurrentUser().firstOrNull()
            }
            val userCity = user?.city?.takeIf { it.isNotBlank() }
            val userState = user?.state?.takeIf { it.isNotBlank() } ?: ""
            
            val productsList = mutableListOf<Product>()
            
            if (userCity != null && userState.isNotBlank()) {
                // Buscar da cole√ß√£o por localiza√ß√£o
                val locationCollection = LocationHelper.getLocationCollection(firestore, "products", userCity, userState)
                val snapshot = locationCollection
                    .whereEqualTo("sellerId", userId)
                    .whereEqualTo("active", true)
                    .get(Source.SERVER)
                    .await()
                
                snapshot.documents.forEach { doc ->
                    try {
                        val data = doc.data ?: return@forEach
                        val createdAt = when (val v = data["createdAt"]) {
                            is Long -> java.util.Date(v)
                            is java.util.Date -> v
                            is com.google.firebase.Timestamp -> v.toDate()
                            else -> null
                        }
                        val updatedAt = when (val v = data["updatedAt"]) {
                            is Long -> java.util.Date(v)
                            is java.util.Date -> v
                            is com.google.firebase.Timestamp -> v.toDate()
                            else -> null
                        }
                        val product = ProductFirestore(
                            id = doc.id,
                            title = data["title"] as? String ?: "",
                            price = (data["price"] as? Number)?.toDouble() ?: 0.0,
                            description = data["description"] as? String,
                            sellerId = data["sellerId"] as? String ?: "",
                            sellerName = data["sellerName"] as? String,
                            imageUrls = ((data["imageUrls"] as? List<*>)?.mapNotNull { it as? String } 
                                ?: (data["images"] as? List<*>)?.mapNotNull { it as? String } 
                                ?: emptyList()),
                            category = data["category"] as? String,
                            tags = (data["tags"] as? List<*>)?.mapNotNull { it as? String } ?: emptyList(),
                            active = data["active"] as? Boolean ?: true,
                            featured = data["featured"] as? Boolean ?: false,
                            discountPercentage = (data["discountPercentage"] as? Number)?.toDouble(),
                            createdAt = createdAt,
                            updatedAt = updatedAt,
                            rating = (data["rating"] as? Number)?.toDouble(),
                            latitude = (data["latitude"] as? Number)?.toDouble(),
                            longitude = (data["longitude"] as? Number)?.toDouble()
                        ).toModel()
                        productsList.add(product)
                    } catch (e: Exception) {
                        android.util.Log.e("FirestoreProductsRepo", "Erro ao converter documento ${doc.id}: ${e.message}", e)
                    }
                }
            }
            
            // Fallback: buscar da cole√ß√£o global (compatibilidade)
            val globalSnapshot = productsCollectionGlobal
                .whereEqualTo("sellerId", userId)
                .whereEqualTo("active", true)
                .get(Source.SERVER)
                .await()
            
            globalSnapshot.documents.forEach { doc ->
                // Evitar duplicatas
                if (productsList.none { it.id == doc.id }) {
                    try {
                        val data = doc.data ?: return@forEach
                        val createdAt = when (val v = data["createdAt"]) {
                            is Long -> java.util.Date(v)
                            is java.util.Date -> v
                            is com.google.firebase.Timestamp -> v.toDate()
                            else -> null
                        }
                        val updatedAt = when (val v = data["updatedAt"]) {
                            is Long -> java.util.Date(v)
                            is java.util.Date -> v
                            is com.google.firebase.Timestamp -> v.toDate()
                            else -> null
                        }
                        val product = ProductFirestore(
                            id = doc.id,
                            title = data["title"] as? String ?: "",
                            price = (data["price"] as? Number)?.toDouble() ?: 0.0,
                            description = data["description"] as? String,
                            sellerId = data["sellerId"] as? String ?: "",
                            sellerName = data["sellerName"] as? String,
                            imageUrls = ((data["imageUrls"] as? List<*>)?.mapNotNull { it as? String } 
                                ?: (data["images"] as? List<*>)?.mapNotNull { it as? String } 
                                ?: emptyList()),
                            category = data["category"] as? String,
                            tags = (data["tags"] as? List<*>)?.mapNotNull { it as? String } ?: emptyList(),
                            active = data["active"] as? Boolean ?: true,
                            featured = data["featured"] as? Boolean ?: false,
                            discountPercentage = (data["discountPercentage"] as? Number)?.toDouble(),
                            createdAt = createdAt,
                            updatedAt = updatedAt,
                            rating = (data["rating"] as? Number)?.toDouble(),
                            latitude = (data["latitude"] as? Number)?.toDouble(),
                            longitude = (data["longitude"] as? Number)?.toDouble()
                        ).toModel()
                        productsList.add(product)
                    } catch (e: Exception) {
                        android.util.Log.e("FirestoreProductsRepo", "Erro ao converter documento ${doc.id}: ${e.message}", e)
                    }
                }
            }
            
            productsList
        } catch (e: Exception) {
            android.util.Log.e("FirestoreProductsRepo", "Erro ao buscar meus produtos: ${e.message}", e)
            emptyList()
        }
    }

    override suspend fun upsertProduct(product: Product) {
        val firestoreProduct = product.toFirestore().copy(
            sellerId = firebaseAuth.currentUser?.uid ?: "",
            active = true
        )
        val operation = if (product.id.isNotEmpty()) "update" else "create"
        val entityId = product.id.ifEmpty { java.util.UUID.randomUUID().toString() }

        val existingCreatedAt = if (operation == "update") {
            try {
                // DEBUG ONLY - Buscar da cole√ß√£o global (compatibilidade)
                val existingDoc = productsCollectionGlobal.document(entityId).get(Source.SERVER).await()
                val existingData = existingDoc.data
                when (val createdAtValue = existingData?.get("createdAt")) {
                    is Long -> createdAtValue
                    is java.util.Date -> createdAtValue.time
                    is com.google.firebase.Timestamp -> createdAtValue.toDate().time
                    else -> null
                }
            } catch (_: Exception) {
                null
            }
        } else null

        val productData = mutableMapOf<String, Any>(
            "id" to entityId,
            "sellerId" to firestoreProduct.sellerId,
            "title" to firestoreProduct.title,
            "description" to (firestoreProduct.description ?: ""),
            "price" to firestoreProduct.price,
            "active" to true,
            "featured" to firestoreProduct.featured,
            "discountPercentage" to (firestoreProduct.discountPercentage ?: 0.0),
            "imageUrls" to firestoreProduct.imageUrls,
            "rating" to (firestoreProduct.rating ?: 0.0),
            "category" to (firestoreProduct.category ?: ""),
            "createdAt" to (existingCreatedAt ?: System.currentTimeMillis()),
            "updatedAt" to System.currentTimeMillis()
        )

        firestoreProduct.sellerName?.let { productData["sellerName"] = it }
        firestoreProduct.latitude?.let { productData["latitude"] = it }
        firestoreProduct.longitude?.let { productData["longitude"] = it }

        // DEBUG ONLY - upsertProduct salva na cole√ß√£o global para compatibilidade
        // CR√çTICO: Produtos devem ser criados via Cloud Function (createProduct) que salva em locations/{city}_{state}/products
        // Este m√©todo est√° aqui apenas para compatibilidade durante migra√ß√£o
        android.util.Log.w("FirestoreProductsRepo", 
            "‚ö†Ô∏è upsertProduct salva na cole√ß√£o global. Use Cloud Function createProduct para salvar em locations/{city}_{state}/products")
        
        if (operation == "create") {
            productsCollectionGlobal.document(entityId).set(productData).await()
        } else {
            productsCollectionGlobal.document(entityId).set(
                productData,
                com.google.firebase.firestore.SetOptions.merge()
            ).await()
        }
    }

    override suspend fun deleteProduct(id: String) {
        try {
            // DEBUG ONLY - Marcar como inativo na cole√ß√£o global (compatibilidade)
            // TODO: Marcar como inativo em todas as locations se necess√°rio
            productsCollectionGlobal.document(id).update(
                "active", false,
                "updatedAt", com.google.firebase.firestore.FieldValue.serverTimestamp()
            ).await()
        } catch (e: Exception) {
            android.util.Log.e("FirestoreProductsRepo", "Erro ao marcar inativo no p√∫blico: ${e.message}", e)
        }

        val currentUserId = firebaseAuth.currentUser?.uid
        if (currentUserId != null) {
            try {
                firestore.collection("users").document(currentUserId)
                    .collection("products").document(id).update(
                        "active", false,
                        "updatedAt", com.google.firebase.firestore.FieldValue.serverTimestamp()
                    ).await()
            } catch (e: Exception) {
                android.util.Log.e("FirestoreProductsRepo", "Erro ao marcar inativo na subcole√ß√£o: ${e.message}", e)
            }
        }
    }

    // Carrinho permanece local
    override suspend fun addToCart(productId: String, qtyDelta: Int) {
        val existing = cartDao.getByProductId(productId)
        if (existing != null) {
            val newQty = existing.qty + qtyDelta
            if (newQty <= 0) {
                cartDao.deleteByProductId(productId)
            } else {
                cartDao.upsert(existing.copy(qty = newQty))
            }
        } else if (qtyDelta > 0) {
            cartDao.upsert(CartItem(productId, qtyDelta).toEntity())
        }
    }

    override suspend fun removeFromCart(productId: String) {
        cartDao.deleteByProductId(productId)
    }

    override fun observeCart(): Flow<List<CartItem>> {
        return cartDao.observeAll().map { entities ->
            entities.map { it.toModel() }
        }
    }

    override suspend fun clearCart() {
        cartDao.clearAll()
    }
}

```

## [FRONTEND]: data/repository/FirestoreProvidersRepository.kt

```kotlin
package com.taskgoapp.taskgo.data.repository

import com.taskgoapp.taskgo.data.firestore.models.UserFirestore
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.Query
import kotlinx.coroutines.tasks.await

/**
 * Reposit√≥rio para buscar prestadores de servi√ßos com algoritmo de classifica√ß√£o por avalia√ß√µes
 */
class FirestoreProvidersRepository(
    private val firestore: FirebaseFirestore
) {
    private val usersCollection = firestore.collection("users")
    private val reviewsCollection = firestore.collection("reviews")
    
    /**
     * Busca prestadores em destaque ordenados por algoritmo de avalia√ß√µes
     * Algoritmo considera:
     * - M√©dia de avalia√ß√µes (peso 40%)
     * - N√∫mero de avalia√ß√µes (peso 20%)
     * - Qualidade dos coment√°rios (peso 20%)
     * - Rec√™ncia das avalia√ß√µes (peso 20%)
     */
    suspend fun getFeaturedProviders(limit: Int = 10): List<ProviderWithScore> {
        return try {
            // Buscar todos os prestadores
            val providersSnapshot = usersCollection
                .whereEqualTo("role", "provider")
                .get()
                .await()
            
            val providers = providersSnapshot.documents.mapNotNull { doc ->
                doc.toObject(UserFirestore::class.java)?.copy(uid = doc.id)
            }
            
            // Calcular score para cada prestador
            val providersWithScore = providers.map { provider ->
                calculateProviderScore(provider)
            }.filter { it.score > 0.0 } // Filtrar apenas prestadores com avalia√ß√µes
            
            // Ordenar por score (maior primeiro) e retornar top N
            providersWithScore
                .sortedByDescending { it.score }
                .take(limit)
        } catch (e: Exception) {
            android.util.Log.e("FirestoreProvidersRepository", "Erro ao buscar prestadores: ${e.message}", e)
            emptyList()
        }
    }
    
    /**
     * Calcula score de um prestador baseado em avalia√ß√µes
     */
    private suspend fun calculateProviderScore(provider: UserFirestore): ProviderWithScore {
        return try {
            // Buscar todas as avalia√ß√µes do prestador
            val reviewsSnapshot = reviewsCollection
                .whereEqualTo("type", "PROVIDER")
                .whereEqualTo("targetId", provider.uid)
                .get()
                .await()
            
            val reviews = reviewsSnapshot.documents.mapNotNull { doc ->
                doc.toObject(com.taskgoapp.taskgo.data.firestore.models.ReviewFirestore::class.java)
            }
            
            if (reviews.isEmpty()) {
                return ProviderWithScore(provider, 0.0)
            }
            
            // 1. M√©dia de avalia√ß√µes (peso 40%)
            val averageRating = reviews.map { it.rating }.average()
            val ratingScore = (averageRating / 5.0) * 0.4
            
            // 2. N√∫mero de avalia√ß√µes (peso 20%)
            // Normalizar: mais avalia√ß√µes = melhor, mas com limite de 100 avalia√ß√µes
            val reviewCount = reviews.size
            val reviewCountScore = (minOf(reviewCount, 100) / 100.0) * 0.2
            
            // 3. Qualidade dos coment√°rios (peso 20%)
            // Avaliar coment√°rios positivos (palavras-chave)
            val positiveKeywords = listOf("excelente", "√≥timo", "recomendo", "profissional", "qualidade", "satisfeito", "perfeito", "bom")
            val commentsWithKeywords = reviews.count { review ->
                val comment = review.comment?.lowercase() ?: ""
                positiveKeywords.any { keyword -> comment.contains(keyword) }
            }
            val commentQualityScore = if (reviewCount > 0) {
                (commentsWithKeywords.toDouble() / reviewCount) * 0.2
            } else {
                0.0
            }
            
            // 4. Rec√™ncia das avalia√ß√µes (peso 20%)
            // Avalia√ß√µes mais recentes t√™m mais peso
            val now = System.currentTimeMillis()
            val recentReviews = reviews.count { review ->
                val reviewTime = review.createdAt?.time ?: 0L
                val daysSinceReview = (now - reviewTime) / (1000 * 60 * 60 * 24)
                daysSinceReview <= 90 // √öltimos 90 dias
            }
            val recencyScore = if (reviewCount > 0) {
                (recentReviews.toDouble() / reviewCount) * 0.2
            } else {
                0.0
            }
            
            // Score final (0.0 a 1.0)
            val finalScore = ratingScore + reviewCountScore + commentQualityScore + recencyScore
            
            ProviderWithScore(provider, finalScore)
        } catch (e: Exception) {
            android.util.Log.e("FirestoreProvidersRepository", "Erro ao calcular score: ${e.message}", e)
            ProviderWithScore(provider, 0.0)
        }
    }
    
    /**
     * Busca prestadores por localiza√ß√£o e categoria
     */
    suspend fun getProvidersByLocationAndCategory(
        city: String?,
        state: String?,
        category: String?,
        limit: Int = 20
    ): List<ProviderWithScore> {
        return try {
            var query: Query = usersCollection.whereEqualTo("role", "provider")
            
            // Filtrar por localiza√ß√£o se fornecida
            // Nota: Firestore n√£o suporta m√∫ltiplos whereEqualTo em campos diferentes
            // Ent√£o vamos buscar todos e filtrar em mem√≥ria
            val snapshot = query.get().await()
            
            val providers = snapshot.documents.mapNotNull { doc ->
                doc.toObject(UserFirestore::class.java)?.copy(uid = doc.id)
            }.filter { provider ->
                var matches = true
                
                if (city != null) {
                    matches = matches && provider.address?.city?.equals(city, ignoreCase = true) == true
                }
                
                if (state != null) {
                    matches = matches && provider.address?.state?.equals(state, ignoreCase = true) == true
                }
                
                if (category != null) {
                    matches = matches && provider.preferredCategories?.any { 
                        it.equals(category, ignoreCase = true) 
                    } == true
                }
                
                matches
            }
            
            // Calcular scores e ordenar
            providers.map { provider ->
                calculateProviderScore(provider)
            }.sortedByDescending { it.score }.take(limit)
        } catch (e: Exception) {
            android.util.Log.e("FirestoreProvidersRepository", "Erro ao buscar prestadores: ${e.message}", e)
            emptyList()
        }
    }
}

/**
 * Classe para armazenar prestador com seu score calculado
 */
data class ProviderWithScore(
    val provider: UserFirestore,
    val score: Double
)


```

## [FRONTEND]: data/repository/FirestoreReviewsRepository.kt

```kotlin
package com.taskgoapp.taskgo.data.repository

import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.FieldValue
import com.google.firebase.firestore.ListenerRegistration
import com.taskgoapp.taskgo.core.model.Review
import com.taskgoapp.taskgo.core.model.ReviewSummary
import com.taskgoapp.taskgo.core.model.ReviewType
import com.taskgoapp.taskgo.core.model.Result
import com.taskgoapp.taskgo.data.firestore.models.ReviewFirestore
import com.taskgoapp.taskgo.data.mapper.ReviewMapper.toFirestore
import com.taskgoapp.taskgo.data.mapper.ReviewMapper.toModel
import com.taskgoapp.taskgo.domain.repository.ReviewsRepository
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.tasks.await
import kotlinx.coroutines.channels.awaitClose
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class FirestoreReviewsRepository @Inject constructor(
    private val firestore: FirebaseFirestore
) : ReviewsRepository {
    
    private val reviewsCollection = firestore.collection("reviews")
    
    override fun observeReviews(targetId: String, type: ReviewType): Flow<List<Review>> = callbackFlow {
        val typeString = when (type) {
            ReviewType.PRODUCT -> "PRODUCT"
            ReviewType.SERVICE -> "SERVICE"
            ReviewType.PROVIDER -> "PROVIDER"
        }
        
        val listenerRegistration = reviewsCollection
            .whereEqualTo("targetId", targetId)
            .whereEqualTo("type", typeString)
            .orderBy("createdAt", com.google.firebase.firestore.Query.Direction.DESCENDING)
            .addSnapshotListener { snapshot, error ->
                if (error != null) {
                    close(error)
                    return@addSnapshotListener
                }
                
                val reviews = snapshot?.documents?.mapNotNull { doc ->
                    doc.toObject(ReviewFirestore::class.java)?.copy(id = doc.id)?.toModel()
                } ?: emptyList()
                
                trySend(reviews)
            }
        
        awaitClose { listenerRegistration.remove() }
    }
    
    override suspend fun getReview(reviewId: String): Review? {
        return try {
            val document = reviewsCollection.document(reviewId).get().await()
            document.toObject(ReviewFirestore::class.java)?.copy(id = document.id)?.toModel()
        } catch (e: Exception) {
            null
        }
    }
    
    override suspend fun createReview(review: Review): Result<String> {
        return try {
            val reviewFirestore = review.toFirestore()
            val docRef = reviewsCollection.add(reviewFirestore).await()
            
            // Atualizar m√©dia de avalia√ß√µes do target
            updateTargetRating(review.targetId, review.type)
            
            Result.Success(docRef.id)
        } catch (e: Exception) {
            Result.Error(e)
        }
    }
    
    override suspend fun updateReview(
        reviewId: String,
        rating: Int?,
        comment: String?,
        photoUrls: List<String>?
    ): Result<Unit> {
        return try {
            val updates = mutableMapOf<String, Any>()
            rating?.let { updates["rating"] = it }
            comment?.let { updates["comment"] = it }
            photoUrls?.let { updates["photoUrls"] = it }
            updates["updatedAt"] = FieldValue.serverTimestamp()
            
            reviewsCollection.document(reviewId).update(updates).await()
            
            // Recuperar review para atualizar m√©dia
            val review = getReview(reviewId)
            review?.let {
                updateTargetRating(it.targetId, it.type)
            }
            
            Result.Success(Unit)
        } catch (e: Exception) {
            Result.Error(e)
        }
    }
    
    override suspend fun deleteReview(reviewId: String): Result<Unit> {
        return try {
            val review = getReview(reviewId)
            reviewsCollection.document(reviewId).delete().await()
            
            // Atualizar m√©dia de avalia√ß√µes do target
            review?.let {
                updateTargetRating(it.targetId, it.type)
            }
            
            Result.Success(Unit)
        } catch (e: Exception) {
            Result.Error(e)
        }
    }
    
    override suspend fun getReviewSummary(targetId: String, type: ReviewType): ReviewSummary {
        return try {
            val typeString = when (type) {
                ReviewType.PRODUCT -> "PRODUCT"
                ReviewType.SERVICE -> "SERVICE"
                ReviewType.PROVIDER -> "PROVIDER"
            }
            
            val snapshot = reviewsCollection
                .whereEqualTo("targetId", targetId)
                .whereEqualTo("type", typeString)
                .get()
                .await()
            
            val reviews = snapshot.documents.mapNotNull { doc ->
                doc.toObject(ReviewFirestore::class.java)?.rating
            }
            
            if (reviews.isEmpty()) {
                ReviewSummary(0.0, 0)
            } else {
                val averageRating = reviews.average()
                val ratingDistribution = reviews.groupingBy { it }.eachCount()
                
                ReviewSummary(
                    averageRating = averageRating,
                    totalReviews = reviews.size,
                    ratingDistribution = ratingDistribution
                )
            }
        } catch (e: Exception) {
            ReviewSummary(0.0, 0)
        }
    }
    
    override suspend fun markReviewAsHelpful(reviewId: String): Result<Unit> {
        return try {
            reviewsCollection.document(reviewId)
                .update("helpfulCount", FieldValue.increment(1))
                .await()
            Result.Success(Unit)
        } catch (e: Exception) {
            Result.Error(e)
        }
    }
    
    override suspend fun canUserReview(targetId: String, type: ReviewType, userId: String): Boolean {
        return try {
            val typeString = when (type) {
                ReviewType.PRODUCT -> "PRODUCT"
                ReviewType.SERVICE -> "SERVICE"
                ReviewType.PROVIDER -> "PROVIDER"
            }
            
            val snapshot = reviewsCollection
                .whereEqualTo("targetId", targetId)
                .whereEqualTo("type", typeString)
                .whereEqualTo("reviewerId", userId)
                .get()
                .await()
            
            snapshot.isEmpty
        } catch (e: Exception) {
            false
        }
    }
    
    private suspend fun updateTargetRating(targetId: String, type: ReviewType) {
        try {
            val summary = getReviewSummary(targetId, type)
            val collectionName = when (type) {
                ReviewType.PRODUCT -> "products"
                ReviewType.SERVICE -> "services" // Corrigido: usar "services" em vez de "service_orders"
                ReviewType.PROVIDER -> "users"
            }
            
            firestore.collection(collectionName).document(targetId)
                .update("rating", summary.averageRating)
                .await()
        } catch (e: Exception) {
            // Ignore errors - rating update is not critical
            android.util.Log.w("FirestoreReviewsRepo", "Erro ao atualizar rating: ${e.message}", e)
        }
    }
    
    override fun observeUserReviewsAsReviewer(userId: String): Flow<List<Review>> = callbackFlow {
        val listenerRegistration = reviewsCollection
            .whereEqualTo("reviewerId", userId)
            .orderBy("createdAt", com.google.firebase.firestore.Query.Direction.DESCENDING)
            .addSnapshotListener { snapshot, error ->
                if (error != null) {
                    close(error)
                    return@addSnapshotListener
                }
                
                val reviews = snapshot?.documents?.mapNotNull { doc ->
                    doc.toObject(ReviewFirestore::class.java)?.copy(id = doc.id)?.toModel()
                } ?: emptyList()
                
                trySend(reviews)
            }
        
        awaitClose { listenerRegistration.remove() }
    }
    
    override fun observeUserReviewsAsTarget(userId: String): Flow<List<Review>> = callbackFlow {
        // Buscar avalia√ß√µes onde o usu√°rio √© prestador/vendedor
        // Isso requer buscar em produtos e servi√ßos onde o usu√°rio √© o seller/provider
        // Por enquanto, vamos buscar avalia√ß√µes do tipo PROVIDER onde targetId = userId
        
        var listenerRegistration: ListenerRegistration? = null
        
        try {
            listenerRegistration = reviewsCollection
                .whereEqualTo("type", "PROVIDER")
                .whereEqualTo("targetId", userId)
                .orderBy("createdAt", com.google.firebase.firestore.Query.Direction.DESCENDING)
                .addSnapshotListener { snapshot, error ->
                    if (error != null) {
                        // Se houver erro de √≠ndice, tentar sem orderBy
                        listenerRegistration?.remove()
                        listenerRegistration = reviewsCollection
                            .whereEqualTo("type", "PROVIDER")
                            .whereEqualTo("targetId", userId)
                            .addSnapshotListener { snapshot2, error2 ->
                                if (error2 != null) {
                                    close(error2)
                                    return@addSnapshotListener
                                }
                                
                                val reviews = snapshot2?.documents?.mapNotNull { doc ->
                                    doc.toObject(ReviewFirestore::class.java)?.copy(id = doc.id)?.toModel()
                                }?.sortedByDescending { it.createdAt } ?: emptyList()
                                
                                trySend(reviews)
                            }
                    } else {
                        val reviews = snapshot?.documents?.mapNotNull { doc ->
                            doc.toObject(ReviewFirestore::class.java)?.copy(id = doc.id)?.toModel()
                        } ?: emptyList()
                        
                        trySend(reviews)
                    }
                }
        } catch (e: Exception) {
            // Se falhar com orderBy, tentar sem orderBy
            listenerRegistration = reviewsCollection
                .whereEqualTo("type", "PROVIDER")
                .whereEqualTo("targetId", userId)
                .addSnapshotListener { snapshot, error ->
                    if (error != null) {
                        close(error)
                        return@addSnapshotListener
                    }
                    
                    val reviews = snapshot?.documents?.mapNotNull { doc ->
                        doc.toObject(ReviewFirestore::class.java)?.copy(id = doc.id)?.toModel()
                    }?.sortedByDescending { it.createdAt } ?: emptyList()
                    
                    trySend(reviews)
                }
        }
        
        awaitClose { listenerRegistration?.remove() }
    }
    
    /**
     * Observa avalia√ß√µes de um prestador espec√≠fico
     */
    fun observeProviderReviews(providerId: String): Flow<List<ReviewFirestore>> = callbackFlow {
        var listenerRegistration: ListenerRegistration? = null
        
        try {
            listenerRegistration = reviewsCollection
                .whereEqualTo("type", "PROVIDER")
                .whereEqualTo("targetId", providerId)
                .orderBy("createdAt", com.google.firebase.firestore.Query.Direction.DESCENDING)
                .addSnapshotListener { snapshot, error ->
                    if (error != null) {
                        // Se houver erro de √≠ndice, tentar sem orderBy
                        listenerRegistration?.remove()
                        listenerRegistration = reviewsCollection
                            .whereEqualTo("type", "PROVIDER")
                            .whereEqualTo("targetId", providerId)
                            .addSnapshotListener { snapshot2, error2 ->
                                if (error2 != null) {
                                    close(error2)
                                    return@addSnapshotListener
                                }
                                
                                val reviews = snapshot2?.documents?.mapNotNull { doc ->
                                    doc.toObject(ReviewFirestore::class.java)?.copy(id = doc.id)
                                }?.sortedByDescending { it.createdAt?.time ?: 0L } ?: emptyList()
                                
                                trySend(reviews)
                            }
                    } else {
                        val reviews = snapshot?.documents?.mapNotNull { doc ->
                            doc.toObject(ReviewFirestore::class.java)?.copy(id = doc.id)
                        } ?: emptyList()
                        
                        trySend(reviews)
                    }
                }
        } catch (e: Exception) {
            // Se falhar com orderBy, tentar sem orderBy
            listenerRegistration = reviewsCollection
                .whereEqualTo("type", "PROVIDER")
                .whereEqualTo("targetId", providerId)
                .addSnapshotListener { snapshot, error ->
                    if (error != null) {
                        close(error)
                        return@addSnapshotListener
                    }
                    
                    val reviews = snapshot?.documents?.mapNotNull { doc ->
                        doc.toObject(ReviewFirestore::class.java)?.copy(id = doc.id)
                    }?.sortedByDescending { it.createdAt?.time ?: 0L } ?: emptyList()
                    
                    trySend(reviews)
                }
        }
        
        awaitClose { listenerRegistration?.remove() }
    }
    
    override suspend fun getUserReviewSummaryAsTarget(userId: String): ReviewSummary {
        return try {
            val snapshot = reviewsCollection
                .whereEqualTo("type", "PROVIDER")
                .whereEqualTo("targetId", userId)
                .get()
                .await()
            
            val reviews = snapshot.documents.mapNotNull { doc ->
                doc.toObject(ReviewFirestore::class.java)?.rating
            }
            
            if (reviews.isEmpty()) {
                ReviewSummary(0.0, 0)
            } else {
                val averageRating = reviews.average()
                val ratingDistribution = reviews.groupingBy { it }.eachCount()
                
                ReviewSummary(
                    averageRating = averageRating,
                    totalReviews = reviews.size,
                    ratingDistribution = ratingDistribution
                )
            }
        } catch (e: Exception) {
            ReviewSummary(0.0, 0)
        }
    }
}


```

## [FRONTEND]: data/repository/FirestoreServicesRepository.kt

```kotlin
package com.taskgoapp.taskgo.data.repository

import com.taskgoapp.taskgo.data.firestore.models.ServiceFirestore
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.FieldValue
import com.google.firebase.firestore.ListenerRegistration
import com.taskgoapp.taskgo.core.firebase.LocationHelper
import com.taskgoapp.taskgo.core.location.LocationStateManager
import com.taskgoapp.taskgo.core.location.LocationState
import kotlinx.coroutines.tasks.await
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.flow.flatMapLatest
import kotlinx.coroutines.flow.flowOf
import kotlinx.coroutines.channels.awaitClose
import android.util.Log
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class FirestoreServicesRepository @Inject constructor(
    private val firestore: FirebaseFirestore,
    private val realtimeRepository: com.taskgoapp.taskgo.data.realtime.RealtimeDatabaseRepository,
    private val authRepository: FirebaseAuthRepository,
    private val functionsService: com.taskgoapp.taskgo.data.firebase.FirebaseFunctionsService,
    private val locationStateManager: LocationStateManager
) {
    // Cole√ß√£o p√∫blica para queries (visualiza√ß√£o de servi√ßos por outros usu√°rios)
    // DEBUG ONLY - Mantida apenas para compatibilidade durante migra√ß√£o
    private val publicServicesCollection = firestore.collection("services")
    
    // Helper para obter subcole√ß√£o do usu√°rio
    private fun getUserServicesCollection(userId: String) = 
        firestore.collection("users").document(userId).collection("services")

    /**
     * Observa todos os servi√ßos de um prestador espec√≠fico
     * Agora usa subcole√ß√£o users/{providerId}/services para isolamento total
     */
    fun observeProviderServices(providerId: String): Flow<List<ServiceFirestore>> = callbackFlow {
        try {
            val userServicesCollection = getUserServicesCollection(providerId)
            val listenerRegistration = userServicesCollection
                .orderBy("createdAt", com.google.firebase.firestore.Query.Direction.DESCENDING)
                .addSnapshotListener { snapshot, error ->
                    if (error != null) {
                        android.util.Log.e("FirestoreServicesRepo", "Erro ao observar servi√ßos do prestador: ${error.message}", error)
                        trySend(emptyList())
                        return@addSnapshotListener
                    }
                    
                    val services = snapshot?.documents?.mapNotNull { doc ->
                        try {
                            doc.toObject(ServiceFirestore::class.java)?.copy(id = doc.id)
                        } catch (e: Exception) {
                            android.util.Log.e("FirestoreServicesRepo", "Erro ao converter documento ${doc.id}: ${e.message}", e)
                            null
                        }
                    } ?: emptyList()
                    
                    trySend(services)
                }
            
            awaitClose { listenerRegistration.remove() }
        } catch (e: Exception) {
            android.util.Log.e("FirestoreServicesRepo", "Erro ao configurar listener de servi√ßos do prestador: ${e.message}", e)
            trySend(emptyList())
            close()
        }
    }

    /**
     * Observa todos os servi√ßos ativos (sem filtro de categoria)
     * ‚úÖ Agora usa cole√ß√£o por localiza√ß√£o locations/{locationId}/services
     * NOTA: Esta cole√ß√£o √© sincronizada quando servi√ßos s√£o criados/atualizados
     */
    fun observeAllActiveServices(): Flow<List<ServiceFirestore>> = locationStateManager.locationState
        .flatMapLatest { locationState ->
            when (locationState) {
                is LocationState.Loading -> {
                    Log.w("BLOCKED_QUERY", "Firestore query blocked: location not ready (Loading) - observeAllActiveServices")
                    flowOf(emptyList())
                }
                is LocationState.Error -> {
                    Log.e("BLOCKED_QUERY", "Firestore query blocked: location error - ${locationState.reason} - observeAllActiveServices")
                    flowOf(emptyList())
                }
                is LocationState.Ready -> {
                    // ‚úÖ Localiza√ß√£o pronta - fazer query Firestore
                    val locationId = locationState.locationId
                    
                    // üö® PROTE√á√ÉO: Nunca permitir "unknown" como locationId v√°lido
                    if (locationId == "unknown" || locationId.isBlank()) {
                        Log.e("FATAL_LOCATION", "Attempted Firestore query with invalid locationId: $locationId - observeAllActiveServices")
                        flowOf(emptyList())
                    } else {
                        observeAllActiveServicesFromFirestore(locationState)
                    }
                }
            }
        }
    
    private fun observeAllActiveServicesFromFirestore(
        locationState: LocationState.Ready
    ): Flow<List<ServiceFirestore>> = callbackFlow {
        var listenerRegistration: com.google.firebase.firestore.ListenerRegistration? = null
        try {
            // ‚úÖ Usar cole√ß√£o por localiza√ß√£o
            val collectionToUse = LocationHelper.getLocationCollection(
                firestore,
                "services",
                locationState.city,
                locationState.state
            )
            
            Log.d("FirestoreServicesRepository", """
                üìç Querying Firestore with location:
                City: ${locationState.city}
                State: ${locationState.state}
                LocationId: ${locationState.locationId}
                Firestore Path: locations/${locationState.locationId}/services
            """.trimIndent())
            
            listenerRegistration = collectionToUse
                .whereEqualTo("active", true)
                .limit(50) // Aumentar limite para melhor cobertura
                .addSnapshotListener { snapshot, error ->
                    if (error != null) {
                        android.util.Log.e("FirestoreServicesRepo", "Erro ao observar servi√ßos ativos: ${error.message}", error)
                        try {
                            trySend(emptyList())
                        } catch (e: kotlinx.coroutines.channels.ClosedSendChannelException) {
                            // Canal j√° foi fechado, ignorar
                        } catch (e: Exception) {
                            android.util.Log.w("FirestoreServicesRepo", "Erro ao enviar dados (canal pode estar fechado): ${e.message}")
                        }
                        return@addSnapshotListener
                    }
                    
                    try {
                        val services = snapshot?.documents?.mapNotNull { doc ->
                            try {
                                doc.toObject(ServiceFirestore::class.java)?.copy(id = doc.id)
                            } catch (e: Exception) {
                                android.util.Log.e("FirestoreServicesRepo", "Erro ao converter documento ${doc.id}: ${e.message}", e)
                                null
                            }
                        }?.sortedByDescending { it.createdAt }
                        ?: emptyList()
                        
                        trySend(services)
                    } catch (e: kotlinx.coroutines.channels.ClosedSendChannelException) {
                        // Canal j√° foi fechado, ignorar
                    } catch (e: Exception) {
                        android.util.Log.w("FirestoreServicesRepo", "Erro ao enviar dados (canal pode estar fechado): ${e.message}")
                    }
                }
        } catch (e: Exception) {
            android.util.Log.e("FirestoreServicesRepo", "Erro ao configurar listener de servi√ßos ativos: ${e.message}", e)
            try {
                trySend(emptyList())
            } catch (ex: Exception) {
                // Ignorar se n√£o conseguir enviar
            }
        }
        
        awaitClose { 
            try {
                listenerRegistration?.remove()
            } catch (e: Exception) {
                android.util.Log.w("FirestoreServicesRepo", "Erro ao remover listener: ${e.message}")
            }
        }
    }
    
    /**
     * Observa todos os servi√ßos ativos de uma categoria
     * ‚úÖ Agora usa cole√ß√£o por localiza√ß√£o locations/{locationId}/services
     */
    fun observeServicesByCategory(category: String): Flow<List<ServiceFirestore>> = locationStateManager.locationState
        .flatMapLatest { locationState ->
            when (locationState) {
                is LocationState.Loading -> {
                    Log.w("BLOCKED_QUERY", "Firestore query blocked: location not ready (Loading) - observeServicesByCategory")
                    flowOf(emptyList())
                }
                is LocationState.Error -> {
                    Log.e("BLOCKED_QUERY", "Firestore query blocked: location error - ${locationState.reason} - observeServicesByCategory")
                    flowOf(emptyList())
                }
                is LocationState.Ready -> {
                    // ‚úÖ Localiza√ß√£o pronta - fazer query Firestore
                    val locationId = locationState.locationId
                    
                    // üö® PROTE√á√ÉO: Nunca permitir "unknown" como locationId v√°lido
                    if (locationId == "unknown" || locationId.isBlank()) {
                        Log.e("FATAL_LOCATION", "Attempted Firestore query with invalid locationId: $locationId - observeServicesByCategory")
                        flowOf(emptyList())
                    } else {
                        observeServicesByCategoryFromFirestore(locationState, category)
                    }
                }
            }
        }
    
    private fun observeServicesByCategoryFromFirestore(
        locationState: LocationState.Ready,
        category: String
    ): Flow<List<ServiceFirestore>> = callbackFlow {
        try {
            // ‚úÖ Usar cole√ß√£o por localiza√ß√£o
            val collectionToUse = LocationHelper.getLocationCollection(
                firestore,
                "services",
                locationState.city,
                locationState.state
            )
            
            Log.d("FirestoreServicesRepository", """
                üìç Querying Firestore with location:
                City: ${locationState.city}
                State: ${locationState.state}
                LocationId: ${locationState.locationId}
                Category: $category
                Firestore Path: locations/${locationState.locationId}/services
            """.trimIndent())
            
            val listenerRegistration = collectionToUse
                .whereEqualTo("category", category)
                .whereEqualTo("active", true)
                .orderBy("createdAt", com.google.firebase.firestore.Query.Direction.DESCENDING)
                .addSnapshotListener { snapshot, error ->
                    if (error != null) {
                        android.util.Log.e("FirestoreServicesRepo", "Erro ao observar servi√ßos por categoria: ${error.message}", error)
                        trySend(emptyList())
                        return@addSnapshotListener
                    }
                    
                    val services = snapshot?.documents?.mapNotNull { doc ->
                        try {
                            doc.toObject(ServiceFirestore::class.java)?.copy(id = doc.id)
                        } catch (e: Exception) {
                            android.util.Log.e("FirestoreServicesRepo", "Erro ao converter documento ${doc.id}: ${e.message}", e)
                            null
                        }
                    } ?: emptyList()
                    
                    trySend(services)
                }
            
            awaitClose { listenerRegistration.remove() }
        } catch (e: Exception) {
            android.util.Log.e("FirestoreServicesRepo", "Erro ao configurar listener de servi√ßos por categoria: ${e.message}", e)
            trySend(emptyList())
            close()
        }
    }

    /**
     * Busca um servi√ßo por ID
     * Tenta primeiro na cole√ß√£o p√∫blica (para visualiza√ß√£o), depois na subcole√ß√£o do usu√°rio se necess√°rio
     */
    suspend fun getService(serviceId: String): ServiceFirestore? {
        return try {
            // Primeiro tenta na cole√ß√£o p√∫blica
            val publicDoc = publicServicesCollection.document(serviceId).get().await()
            if (publicDoc.exists()) {
                return publicDoc.toObject(ServiceFirestore::class.java)?.copy(id = publicDoc.id)
            }
            
            // Se n√£o encontrou na p√∫blica, tenta buscar na subcole√ß√£o do providerId se conhecido
            // Para isso, seria necess√°rio saber o providerId, mas como n√£o temos, retornamos null
            // Em uma implementa√ß√£o completa, poderia manter um √≠ndice providerId -> serviceId
            null
        } catch (e: Exception) {
            android.util.Log.e("FirestoreServicesRepo", "Erro ao buscar servi√ßo: ${e.message}", e)
            null
        }
    }

    /**
     * Cria um novo servi√ßo
     * Salva na subcole√ß√£o do usu√°rio (users/{providerId}/services) para isolamento total
     * E tamb√©m na cole√ß√£o p√∫blica (services) para queries eficientes de visualiza√ß√£o
     */
    suspend fun createService(service: ServiceFirestore): Result<String> {
        return try {
            val currentUserId = authRepository.getCurrentUser()?.uid
                ?: return Result.failure(Exception("Usu√°rio n√£o autenticado"))
            
            // Garantir que providerId corresponde ao usu√°rio atual
            if (service.providerId != currentUserId) {
                return Result.failure(Exception("providerId n√£o corresponde ao usu√°rio atual"))
            }
            
            // Usar Cloud Function createService (backend como autoridade)
            val result = functionsService.createService(
                title = service.title,
                description = service.description,
                category = service.category,
                price = service.price,
                latitude = service.latitude,
                longitude = service.longitude,
                active = service.active
            )
            
            result.fold(
                onSuccess = { data ->
                    val serviceId = data["serviceId"] as? String
                        ?: return Result.failure(Exception("Service ID n√£o retornado pela Cloud Function"))
                    
                    android.util.Log.d("FirestoreServicesRepo", "Servi√ßo criado com sucesso via Cloud Function: $serviceId")
                    Result.success(serviceId)
                },
                onFailure = { error ->
                    android.util.Log.e("FirestoreServicesRepo", "Erro ao criar servi√ßo via Cloud Function: ${error.message}", error)
                    Result.failure(error)
                }
            )
        } catch (e: Exception) {
            android.util.Log.e("FirestoreServicesRepo", "Erro ao criar servi√ßo: ${e.message}", e)
            Result.failure(e)
        }
    }

    /**
     * Atualiza um servi√ßo existente
     * Atualiza tanto na subcole√ß√£o do usu√°rio quanto na cole√ß√£o p√∫blica
     */
    suspend fun updateService(serviceId: String, service: ServiceFirestore): Result<Unit> {
        return try {
            val currentUserId = authRepository.getCurrentUser()?.uid
                ?: return Result.failure(Exception("Usu√°rio n√£o autenticado"))
            
            // Garantir que providerId corresponde ao usu√°rio atual
            if (service.providerId != currentUserId) {
                return Result.failure(Exception("N√£o √© poss√≠vel atualizar servi√ßo de outro usu√°rio"))
            }
            
            // Usar Cloud Function updateService (backend como autoridade)
            val updates = mutableMapOf<String, Any>().apply {
                put("title", service.title)
                put("description", service.description)
                put("category", service.category)
                put("price", service.price)
                service.latitude?.let { put("latitude", it) }
                service.longitude?.let { put("longitude", it) }
                put("active", service.active)
            }
            
            val result = functionsService.updateService(serviceId, updates)
            
            result.fold(
                onSuccess = {
                    android.util.Log.d("FirestoreServicesRepo", "Servi√ßo atualizado com sucesso via Cloud Function: $serviceId")
                    Result.success(Unit)
                },
                onFailure = { error ->
                    android.util.Log.e("FirestoreServicesRepo", "Erro ao atualizar servi√ßo via Cloud Function: ${error.message}", error)
                    Result.failure(error)
                }
            )
        } catch (e: Exception) {
            android.util.Log.e("FirestoreServicesRepo", "Erro ao atualizar servi√ßo: ${e.message}", e)
            Result.failure(e)
        }
    }

    /**
     * Deleta um servi√ßo (soft delete - marca como inativo)
     * Atualiza tanto na subcole√ß√£o do usu√°rio quanto na cole√ß√£o p√∫blica
     */
    suspend fun deleteService(serviceId: String): Result<Unit> {
        return try {
            // Usar Cloud Function deleteService (backend como autoridade)
            val result = functionsService.deleteService(serviceId)
            
            result.fold(
                onSuccess = {
                    android.util.Log.d("FirestoreServicesRepo", "Servi√ßo deletado com sucesso via Cloud Function: $serviceId")
                    Result.success(Unit)
                },
                onFailure = { error ->
                    android.util.Log.e("FirestoreServicesRepo", "Erro ao deletar servi√ßo via Cloud Function: ${error.message}", error)
                    Result.failure(error)
                }
            )
        } catch (e: Exception) {
            android.util.Log.e("FirestoreServicesRepo", "Erro ao deletar servi√ßo: ${e.message}", e)
            Result.failure(e)
        }
    }
    
    @Deprecated("Usar deleteService que usa Cloud Function")
    suspend fun deleteServiceOld(serviceId: String): Result<Unit> {
        return try {
            val currentUserId = authRepository.getCurrentUser()?.uid
                ?: return Result.failure(Exception("Usu√°rio n√£o autenticado"))
            
            // Primeiro, buscar o servi√ßo para verificar se pertence ao usu√°rio
            val service = getService(serviceId)
            if (service == null) {
                return Result.failure(Exception("Servi√ßo n√£o encontrado"))
            }
            
            if (service.providerId != currentUserId) {
                return Result.failure(Exception("N√£o √© poss√≠vel deletar servi√ßo de outro usu√°rio"))
            }
            
            // Atualizar na subcole√ß√£o do usu√°rio
            val userServicesCollection = getUserServicesCollection(service.providerId)
            userServicesCollection.document(serviceId).update(
                "active", false,
                "updatedAt", FieldValue.serverTimestamp()
            ).await()
            
            // Atualizar tamb√©m na cole√ß√£o p√∫blica
            try {
                publicServicesCollection.document(serviceId).update(
                    "active", false,
                    "updatedAt", FieldValue.serverTimestamp()
                ).await()
            } catch (e: Exception) {
                android.util.Log.w("FirestoreServicesRepo", "Erro ao atualizar na cole√ß√£o p√∫blica: ${e.message}")
            }
            
            Result.success(Unit)
        } catch (e: Exception) {
            android.util.Log.e("FirestoreServicesRepo", "Erro ao deletar servi√ßo: ${e.message}", e)
            Result.failure(e)
        }
    }

    /**
     * Remove permanentemente um servi√ßo do Firestore
     * Remove tanto da subcole√ß√£o do usu√°rio quanto da cole√ß√£o p√∫blica
     */
    suspend fun permanentlyDeleteService(serviceId: String): Result<Unit> {
        return try {
            val currentUserId = authRepository.getCurrentUser()?.uid
                ?: return Result.failure(Exception("Usu√°rio n√£o autenticado"))
            
            // Primeiro, buscar o servi√ßo para verificar se pertence ao usu√°rio
            val service = getService(serviceId)
            if (service == null) {
                return Result.failure(Exception("Servi√ßo n√£o encontrado"))
            }
            
            if (service.providerId != currentUserId) {
                return Result.failure(Exception("N√£o √© poss√≠vel deletar servi√ßo de outro usu√°rio"))
            }
            
            // Deletar da subcole√ß√£o do usu√°rio
            val userServicesCollection = getUserServicesCollection(service.providerId)
            userServicesCollection.document(serviceId).delete().await()
            
            // Deletar tamb√©m da cole√ß√£o p√∫blica
            try {
                publicServicesCollection.document(serviceId).delete().await()
            } catch (e: Exception) {
                android.util.Log.w("FirestoreServicesRepo", "Erro ao deletar da cole√ß√£o p√∫blica: ${e.message}")
            }
            
            Result.success(Unit)
        } catch (e: Exception) {
            android.util.Log.e("FirestoreServicesRepo", "Erro ao deletar permanentemente servi√ßo: ${e.message}", e)
            Result.failure(e)
        }
    }
}


```

## [FRONTEND]: data/repository/FirestoreStoriesRepository.kt

```kotlin
package com.taskgoapp.taskgo.data.repository

import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.FieldValue
import com.google.firebase.firestore.ListenerRegistration
import com.google.firebase.firestore.Query
import com.taskgoapp.taskgo.core.model.Result
import com.taskgoapp.taskgo.core.model.Story
import com.taskgoapp.taskgo.core.model.StoryAnalytics
import com.taskgoapp.taskgo.core.model.StoryView
import com.taskgoapp.taskgo.core.model.StoryInteractions
import com.taskgoapp.taskgo.data.firestore.models.StoryFirestore
import com.taskgoapp.taskgo.data.firestore.models.UserFirestore
import com.taskgoapp.taskgo.data.mapper.StoryMapper
import com.taskgoapp.taskgo.domain.repository.StoriesRepository
import com.taskgoapp.taskgo.core.firebase.LocationHelper
import com.taskgoapp.taskgo.core.location.LocationStateManager
import com.taskgoapp.taskgo.core.location.LocationState
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flowOf
import kotlinx.coroutines.flow.flatMapLatest
import android.util.Log
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.firstOrNull
import kotlinx.coroutines.tasks.await
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.launch
import kotlinx.coroutines.delay
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withTimeoutOrNull
import kotlinx.coroutines.runBlocking as runBlockingKt
import java.util.Date
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class FirestoreStoriesRepository @Inject constructor(
    private val firestore: FirebaseFirestore,
    private val authRepository: FirebaseAuthRepository,
    private val functionsService: com.taskgoapp.taskgo.data.firebase.FirebaseFunctionsService,
    private val userRepository: com.taskgoapp.taskgo.domain.repository.UserRepository,
    private val locationStateManager: LocationStateManager
) : StoriesRepository {
    
    // DEBUG ONLY - Cole√ß√£o global mantida apenas para compatibilidade durante migra√ß√£o
    // REMOVER AP√ìS VALIDA√á√ÉO COMPLETA
    private val storiesCollectionGlobal = firestore.collection("stories")
    private val storyViewsCollection = firestore.collection("story_views")
    
    // Helper para obter subcole√ß√£o de stories do usu√°rio
    private fun getUserStoriesCollection(userId: String) = 
        firestore.collection("users").document(userId).collection("stories")
    
    override fun observeStories(
        currentUserId: String,
        radiusKm: Double,
        userLocation: Pair<Double, Double>?
    ): Flow<List<Story>> = locationStateManager.locationState
        .flatMapLatest { locationState ->
            when (locationState) {
                is LocationState.Loading -> {
                    Log.w("BLOCKED_QUERY", "Firestore query blocked: location not ready (Loading) - observeStories")
                    flowOf(emptyList())
                }
                is LocationState.Error -> {
                    Log.e("BLOCKED_QUERY", "Firestore query blocked: location error - ${locationState.reason} - observeStories")
                    flowOf(emptyList())
                }
                is LocationState.Ready -> {
                    // ‚úÖ Localiza√ß√£o pronta - fazer query Firestore
                    val locationId = locationState.locationId
                    
                    // üö® PROTE√á√ÉO: Nunca permitir "unknown" como locationId v√°lido
                    if (locationId == "unknown" || locationId.isBlank()) {
                        Log.e("FATAL_LOCATION", "Attempted Firestore query with invalid locationId: $locationId - observeStories")
                        flowOf(emptyList())
                    } else {
                        observeStoriesFromFirestore(locationState, currentUserId, radiusKm, userLocation)
                    }
                }
            }
        }
    
    private fun observeStoriesFromFirestore(
        locationState: LocationState.Ready,
        currentUserId: String,
        radiusKm: Double,
        userLocation: Pair<Double, Double>?
    ): Flow<List<Story>> = callbackFlow {
        try {
            // Timestamp de 24 horas atr√°s (stories n√£o expiradas)
            val twentyFourHoursAgo = Date(System.currentTimeMillis() - 24 * 60 * 60 * 1000)
            val timestamp = com.google.firebase.Timestamp(twentyFourHoursAgo)
            
            val collectionToUse = LocationHelper.getLocationCollection(
                firestore,
                "stories",
                locationState.city,
                locationState.state
            )
            
            Log.d("FirestoreStoriesRepository", """
                üìç Querying Firestore with location:
                City: ${locationState.city}
                State: ${locationState.state}
                LocationId: ${locationState.locationId}
                Firestore Path: locations/${locationState.locationId}/stories
            """.trimIndent())
            
            // Query: stories n√£o expiradas, ordenadas por data de cria√ß√£o (mais recentes primeiro)
            // Nota: Firestore requer √≠ndice composto para m√∫ltiplos orderBy, ent√£o usamos apenas createdAt
            val query = collectionToUse
                .whereGreaterThan("expiresAt", timestamp)
                .orderBy("createdAt", Query.Direction.DESCENDING)
                .limit(100) // Limitar para performance
            
            val listenerRegistration = query.addSnapshotListener { snapshot, error ->
                if (error != null) {
                    Log.e("FirestoreStoriesRepository", 
                        "‚ùå Erro ao observar stories: ${error.message}", error)
                    trySend(emptyList())
                    return@addSnapshotListener
                }
                
                if (snapshot == null) {
                    Log.w("FirestoreStoriesRepository", 
                        "‚ö†Ô∏è Snapshot vazio (sem stories encontradas)")
                    trySend(emptyList())
                    return@addSnapshotListener
                }
                
                Log.d("FirestoreStoriesRepository", 
                    "Snapshot recebido: size=${snapshot.size()}, collection=locations/${locationState.locationId}/stories")
                
                // üìç SNAPSHOT PROOF - Logar TUDO que vem do Firestore
                Log.d("FirestoreSnapshot", """
                    üìç FRONTEND SNAPSHOT PROOF
                    Collection path: ${collectionToUse.path}
                    Snapshot empty: ${snapshot.isEmpty}
                    Snapshot size: ${snapshot.size()}
                    Documents count: ${snapshot.documents.size}
                """.trimIndent())
                
                snapshot.documents.forEachIndexed { index, doc ->
                    Log.d("FirestoreSnapshot", """
                        üìç FRONTEND SNAPSHOT PROOF - Document $index
                        Doc ID: ${doc.id}
                        Doc data keys: ${doc.data?.keys?.joinToString(", ") ?: "null"}
                        Doc has expiresAt: ${doc.data?.containsKey("expiresAt")}
                        Doc has createdAt: ${doc.data?.containsKey("createdAt")}
                    """.trimIndent())
                }
                
                
                val storiesList = mutableListOf<Story>()
                snapshot?.documents?.forEach { doc ->
                    try {
                        val data = doc.data ?: return@forEach
                        val locationData = data["location"] as? Map<*, *>
                        
                        val locationFirestore = locationData?.let {
                            com.taskgoapp.taskgo.data.firestore.models.StoryLocationFirestore(
                                city = it["city"] as? String ?: "",
                                state = it["state"] as? String ?: "",
                                latitude = (it["latitude"] as? Number)?.toDouble() ?: 0.0,
                                longitude = (it["longitude"] as? Number)?.toDouble() ?: 0.0
                            )
                        }
                        
                        // Converter createdAt e expiresAt corretamente (pode vir como Long ou Timestamp)
                        val createdAtValue = data["createdAt"]
                        val createdAt = when (createdAtValue) {
                            is com.google.firebase.Timestamp -> createdAtValue
                            is Long -> com.google.firebase.Timestamp(createdAtValue / 1000, ((createdAtValue % 1000) * 1_000_000).toInt())
                            is java.util.Date -> com.google.firebase.Timestamp(createdAtValue)
                            else -> null
                        }
                        
                        val expiresAtValue = data["expiresAt"]
                        val expiresAt = when (expiresAtValue) {
                            is com.google.firebase.Timestamp -> expiresAtValue
                            is Long -> com.google.firebase.Timestamp(expiresAtValue / 1000, ((expiresAtValue % 1000) * 1_000_000).toInt())
                            is java.util.Date -> com.google.firebase.Timestamp(expiresAtValue)
                            else -> null
                        }
                        
                        val storyFirestore = StoryFirestore(
                            id = doc.id,
                            userId = data["userId"] as? String ?: "",
                            userName = data["userName"] as? String ?: "",
                            userAvatarUrl = data["userAvatarUrl"] as? String,
                            mediaUrl = data["mediaUrl"] as? String ?: "",
                            mediaType = data["mediaType"] as? String ?: "image",
                            thumbnailUrl = data["thumbnailUrl"] as? String,
                            caption = data["caption"] as? String,
                            createdAt = createdAt,
                            expiresAt = expiresAt,
                            viewsCount = (data["viewsCount"] as? Number)?.toInt() ?: 0,
                            location = locationFirestore
                        )
                        
                        kotlinx.coroutines.runBlocking {
                            val isViewed = checkIfStoryViewed(doc.id, currentUserId)
                            storiesList.add(with(StoryMapper) {
                                storyFirestore.toModel(isViewed)
                            })
                        }
                    } catch (e: Exception) {
                        android.util.Log.e("FirestoreStoriesRepository", "Erro ao processar story: ${e.message}", e)
                    }
                }
                
                val stories = storiesList
                
                // Filtrar stories do pr√≥prio usu√°rio (j√° que √© para o feed de outros)
                var filteredStories = stories.filter { it.userId != currentUserId }
                
                // Filtrar por dist√¢ncia usando GPS (raio de 100km)
                if (userLocation != null) {
                    val (userLat, userLng) = userLocation
                    filteredStories = filteredStories.filter { story ->
                        story.location?.let { storyLocation ->
                            if (storyLocation.latitude != 0.0 && storyLocation.longitude != 0.0) {
                                val distance = com.taskgoapp.taskgo.core.location.calculateDistance(
                                    userLat,
                                    userLng,
                                    storyLocation.latitude,
                                    storyLocation.longitude
                                )
                                distance <= radiusKm // Usar o raio fornecido (padr√£o 50km, mas pode ser 100km)
                            } else {
                                false // Se n√£o tem localiza√ß√£o GPS, n√£o mostrar
                            }
                        } ?: false // Se n√£o tem localiza√ß√£o, n√£o mostrar
                    }
                }
                
                trySend(filteredStories)
            }
            
            awaitClose { listenerRegistration.remove() }
        } catch (e: Exception) {
            android.util.Log.e("FirestoreStoriesRepository", "Erro ao observar stories: ${e.message}", e)
            trySend(emptyList())
            awaitClose { }
        }
    }
    
    override fun observeUserStories(userId: String, currentUserId: String): Flow<List<Story>> = callbackFlow {
        try {
            val twentyFourHoursAgo = Date(System.currentTimeMillis() - 24 * 60 * 60 * 1000)
            val timestamp = com.google.firebase.Timestamp(twentyFourHoursAgo)
            
            // CR√çTICO: Obter localiza√ß√£o do usu√°rio para buscar da cole√ß√£o correta
            var currentCity: String? = null
            var currentState: String = ""
            var collectionToUse: com.google.firebase.firestore.CollectionReference = storiesCollectionGlobal
            
            try {
                val user = withTimeoutOrNull(2000) {
                    userRepository.observeCurrentUser().firstOrNull()
                }
                currentCity = user?.city?.takeIf { it.isNotBlank() }
                currentState = user?.state?.takeIf { it.isNotBlank() } ?: ""
                
                if (currentCity != null && currentState.isNotBlank()) {
                    // Usar cole√ß√£o por localiza√ß√£o
                    collectionToUse = LocationHelper.getLocationCollection(firestore, "stories", currentCity!!, currentState)
                    android.util.Log.d("FirestoreStoriesRepository", "üîµ Usando cole√ß√£o por localiza√ß√£o para stories do usu√°rio: locations/${LocationHelper.normalizeLocationId(currentCity!!, currentState)}/stories")
                } else {
                    // Fallback: usar cole√ß√£o global
                    collectionToUse = storiesCollectionGlobal
                    android.util.Log.w("FirestoreStoriesRepository", "‚ö†Ô∏è Localiza√ß√£o n√£o dispon√≠vel para stories do usu√°rio, usando cole√ß√£o global")
                }
            } catch (e: Exception) {
                android.util.Log.w("FirestoreStoriesRepository", "Erro ao obter usu√°rio para localiza√ß√£o de stories: ${e.message}")
                collectionToUse = storiesCollectionGlobal
            }
            
            val listenerRegistration = collectionToUse
                .whereEqualTo("userId", userId)
                .whereGreaterThan("expiresAt", timestamp)
                .orderBy("createdAt", Query.Direction.DESCENDING)
                .addSnapshotListener { snapshot, error ->
                    if (error != null) {
                        android.util.Log.e("FirestoreStoriesRepository", "Erro ao observar stories do usu√°rio: ${error.message}", error)
                        trySend(emptyList())
                        return@addSnapshotListener
                    }
                    
                    val storiesList = mutableListOf<Story>()
                    snapshot?.documents?.forEach { doc ->
                        try {
                            val data = doc.data ?: return@forEach
                            val locationData = data["location"] as? Map<*, *>
                            
                            val locationFirestore = locationData?.let {
                                com.taskgoapp.taskgo.data.firestore.models.StoryLocationFirestore(
                                    city = it["city"] as? String ?: "",
                                    state = it["state"] as? String ?: "",
                                    latitude = (it["latitude"] as? Number)?.toDouble() ?: 0.0,
                                    longitude = (it["longitude"] as? Number)?.toDouble() ?: 0.0
                                )
                            }
                            
                            // Converter createdAt e expiresAt corretamente (pode vir como Long ou Timestamp)
                            val createdAtValue = data["createdAt"]
                            val createdAt = when (createdAtValue) {
                                is com.google.firebase.Timestamp -> createdAtValue
                                is Long -> com.google.firebase.Timestamp(createdAtValue / 1000, ((createdAtValue % 1000) * 1_000_000).toInt())
                                is java.util.Date -> com.google.firebase.Timestamp(createdAtValue)
                                else -> null
                            }
                            
                            val expiresAtValue = data["expiresAt"]
                            val expiresAt = when (expiresAtValue) {
                                is com.google.firebase.Timestamp -> expiresAtValue
                                is Long -> com.google.firebase.Timestamp(expiresAtValue / 1000, ((expiresAtValue % 1000) * 1_000_000).toInt())
                                is java.util.Date -> com.google.firebase.Timestamp(expiresAtValue)
                                else -> null
                            }
                            
                            val storyFirestore = StoryFirestore(
                                id = doc.id,
                                userId = data["userId"] as? String ?: "",
                                userName = data["userName"] as? String ?: "",
                                userAvatarUrl = data["userAvatarUrl"] as? String,
                                mediaUrl = data["mediaUrl"] as? String ?: "",
                                mediaType = data["mediaType"] as? String ?: "image",
                                thumbnailUrl = data["thumbnailUrl"] as? String,
                                caption = data["caption"] as? String,
                                createdAt = createdAt,
                                expiresAt = expiresAt,
                                viewsCount = (data["viewsCount"] as? Number)?.toInt() ?: 0,
                                location = locationFirestore
                            )
                            
                            kotlinx.coroutines.runBlocking {
                                val isViewed = checkIfStoryViewed(doc.id, currentUserId)
                                storiesList.add(with(StoryMapper) { storyFirestore.toModel(isViewed) })
                            }
                        } catch (e: Exception) {
                            android.util.Log.e("FirestoreStoriesRepository", "Erro ao processar story: ${e.message}", e)
                        }
                    }
                    
                    val stories = storiesList
                    
                    trySend(stories)
                }
            
            awaitClose { listenerRegistration.remove() }
        } catch (e: Exception) {
            android.util.Log.e("FirestoreStoriesRepository", "Erro ao observar stories do usu√°rio: ${e.message}", e)
            trySend(emptyList())
            awaitClose { }
        }
    }
    
    override suspend fun createStory(story: Story): Result<String> {
        return try {
            val currentUserId = authRepository.getCurrentUser()?.uid
                ?: return com.taskgoapp.taskgo.core.model.Result.Error(Exception("Usu√°rio n√£o autenticado"))
            
            // Validar que o userId da story corresponde ao usu√°rio autenticado
            if (story.userId != currentUserId) {
                return com.taskgoapp.taskgo.core.model.Result.Error(Exception("userId da story n√£o corresponde ao usu√°rio autenticado"))
            }
            
            // Preparar dados para Cloud Function
            val locationMap = story.location?.let { location ->
                mapOf(
                    "city" to location.city,
                    "state" to location.state,
                    "latitude" to location.latitude,
                    "longitude" to location.longitude
                )
            }
            
            // Usar Cloud Function createStory (backend como autoridade)
            val result = functionsService.createStory(
                mediaUrl = story.mediaUrl,
                mediaType = story.mediaType,
                caption = story.caption,
                thumbnailUrl = story.thumbnailUrl,
                location = locationMap,
                expiresAt = story.expiresAt.time
            )
            
            // Converter de kotlin.Result para com.taskgoapp.taskgo.core.model.Result
            return result.fold(
                onSuccess = { data ->
                    val storyId = data["storyId"] as? String
                        ?: return com.taskgoapp.taskgo.core.model.Result.Error(Exception("Story ID n√£o retornado pela Cloud Function"))
                    
                    android.util.Log.d("FirestoreStoriesRepository", "Story criada com sucesso via Cloud Function: $storyId")
                    com.taskgoapp.taskgo.core.model.Result.Success(storyId)
                },
                onFailure = { error ->
                    android.util.Log.e("FirestoreStoriesRepository", "Erro ao criar story via Cloud Function: ${error.message}", error)
                    com.taskgoapp.taskgo.core.model.Result.Error(error)
                }
            )
        } catch (e: Exception) {
            android.util.Log.e("FirestoreStoriesRepository", "Erro ao criar story: ${e.message}", e)
            com.taskgoapp.taskgo.core.model.Result.Error(e)
        }
    }
    
    override suspend fun markStoryAsViewed(storyId: String, userId: String): Result<Unit> {
        return try {
            // Verificar se j√° foi marcada como visualizada
            val viewDoc = storyViewsCollection
                .document(storyId)
                .collection("views")
                .document(userId)
                .get()
                .await()
            
            if (!viewDoc.exists()) {
                // Buscar informa√ß√µes do usu√°rio que est√° visualizando
                val userInfo = getUserInfo(userId)
                
                // Marcar como visualizada com informa√ß√µes do usu√°rio
                storyViewsCollection
                    .document(storyId)
                    .collection("views")
                    .document(userId)
                    .set(mapOf(
                        "viewedAt" to com.google.firebase.firestore.FieldValue.serverTimestamp(),
                        "userId" to userId,
                        "userName" to (userInfo?.displayName ?: "Usu√°rio"),
                        "userAvatarUrl" to (userInfo?.photoURL ?: "")
                    ))
                    .await()
                
                // Incrementar contador de visualiza√ß√µes na story
                storiesCollectionGlobal.document(storyId).update(
                    "viewsCount", FieldValue.increment(1)
                ).await()
            }
            
            com.taskgoapp.taskgo.core.model.Result.Success(Unit)
        } catch (e: Exception) {
            android.util.Log.e("FirestoreStoriesRepository", "Erro ao marcar story como visualizada: ${e.message}", e)
            com.taskgoapp.taskgo.core.model.Result.Error(e)
        }
    }
    
    override suspend fun deleteStory(storyId: String, userId: String): Result<Unit> {
        return try {
            val currentUserId = authRepository.getCurrentUser()?.uid
                ?: return com.taskgoapp.taskgo.core.model.Result.Error(Exception("Usu√°rio n√£o autenticado"))
            
            // Verificar na subcole√ß√£o do usu√°rio primeiro (fonte de verdade)
            val userStoriesCollection = getUserStoriesCollection(userId)
            val userStoryDoc = userStoriesCollection.document(storyId).get().await()
            
            // Se n√£o existe na subcole√ß√£o, verificar na cole√ß√£o p√∫blica
            if (!userStoryDoc.exists()) {
                val storyDoc = storiesCollectionGlobal.document(storyId).get().await()
                val story = storyDoc.toObject(StoryFirestore::class.java)
                
                // Verificar se o usu√°rio √© o dono da story
                if (!storyDoc.exists() || story?.userId != userId) {
                    return com.taskgoapp.taskgo.core.model.Result.Error(
                        Exception("Story n√£o encontrada ou voc√™ n√£o tem permiss√£o para deletar")
                    )
                }
                
                // Se existe apenas na cole√ß√£o p√∫blica, deletar apenas dela
                storiesCollectionGlobal.document(storyId).delete().await()
            } else {
                // Se existe na subcole√ß√£o do usu√°rio, deletar de ambas
                // Deletar da subcole√ß√£o primeiro (fonte de verdade)
                userStoriesCollection.document(storyId).delete().await()
                
                // Tamb√©m deletar da cole√ß√£o p√∫blica para garantir sincroniza√ß√£o imediata
                try {
                    storiesCollectionGlobal.document(storyId).delete().await()
                } catch (e: Exception) {
                    android.util.Log.w("FirestoreStoriesRepository", "Erro ao deletar story da cole√ß√£o p√∫blica: ${e.message}")
                    // N√£o falhar se p√∫blica falhar, a Cloud Function vai fazer a limpeza
                }
            }
            
            android.util.Log.d("FirestoreStoriesRepository", "Story deletada: $storyId")
            com.taskgoapp.taskgo.core.model.Result.Success(Unit)
        } catch (e: Exception) {
            android.util.Log.e("FirestoreStoriesRepository", "Erro ao deletar story: ${e.message}", e)
            com.taskgoapp.taskgo.core.model.Result.Error(e)
        }
    }
    
    override suspend fun getStoriesNearby(
        currentUserId: String,
        latitude: Double,
        longitude: Double,
        radiusKm: Double
    ): Result<List<Story>> {
        return try {
            // Por enquanto, retornar todas as stories n√£o expiradas
            // TODO: Implementar filtro geogr√°fico baseado em latitude/longitude
            val twentyFourHoursAgo = Date(System.currentTimeMillis() - 24 * 60 * 60 * 1000)
            val timestamp = com.google.firebase.Timestamp(twentyFourHoursAgo)
            
            val snapshot = storiesCollectionGlobal
                .whereGreaterThan("expiresAt", timestamp)
                .whereNotEqualTo("userId", currentUserId)
                .orderBy("createdAt", Query.Direction.DESCENDING)
                .limit(50)
                .get()
                .await()
            
            val stories = snapshot.documents.mapNotNull { doc ->
                try {
                    val data = doc.data ?: return@mapNotNull null
                    val locationData = data["location"] as? Map<*, *>
                    
                    val locationFirestore = locationData?.let {
                        com.taskgoapp.taskgo.data.firestore.models.StoryLocationFirestore(
                            city = it["city"] as? String ?: "",
                            state = it["state"] as? String ?: "",
                            latitude = (it["latitude"] as? Number)?.toDouble() ?: 0.0,
                            longitude = (it["longitude"] as? Number)?.toDouble() ?: 0.0
                        )
                    }
                    
                    // Converter createdAt e expiresAt corretamente (pode vir como Long ou Timestamp)
                    val createdAtValue = data["createdAt"]
                    val createdAt: com.google.firebase.Timestamp? = when (createdAtValue) {
                        is com.google.firebase.Timestamp -> createdAtValue
                        is Long -> com.google.firebase.Timestamp(createdAtValue / 1000, ((createdAtValue % 1000) * 1_000_000).toInt())
                        is java.util.Date -> com.google.firebase.Timestamp(createdAtValue)
                        else -> null
                    }
                    
                    val expiresAtValue = data["expiresAt"]
                    val expiresAt: com.google.firebase.Timestamp? = when (expiresAtValue) {
                        is com.google.firebase.Timestamp -> expiresAtValue
                        is Long -> com.google.firebase.Timestamp(expiresAtValue / 1000, ((expiresAtValue % 1000) * 1_000_000).toInt())
                        is java.util.Date -> com.google.firebase.Timestamp(expiresAtValue)
                        else -> null
                    }
                    
                    val storyFirestore = StoryFirestore(
                        id = doc.id,
                        userId = data["userId"] as? String ?: "",
                        userName = data["userName"] as? String ?: "",
                        userAvatarUrl = data["userAvatarUrl"] as? String,
                        mediaUrl = data["mediaUrl"] as? String ?: "",
                        mediaType = data["mediaType"] as? String ?: "image",
                        thumbnailUrl = data["thumbnailUrl"] as? String,
                        caption = data["caption"] as? String,
                        createdAt = createdAt,
                        expiresAt = expiresAt,
                        viewsCount = (data["viewsCount"] as? Number)?.toInt() ?: 0,
                        location = locationFirestore
                    )
                    
                    val isViewed = kotlinx.coroutines.runBlocking {
                        checkIfStoryViewed(doc.id, currentUserId)
                    }
                    with(StoryMapper) {
                        storyFirestore.toModel(isViewed)
                    }
                } catch (e: Exception) {
                    android.util.Log.e("FirestoreStoriesRepository", "Erro ao processar story: ${e.message}", e)
                    null
                }
            }
            
            com.taskgoapp.taskgo.core.model.Result.Success(stories)
        } catch (e: Exception) {
            android.util.Log.e("FirestoreStoriesRepository", "Erro ao buscar stories pr√≥ximas: ${e.message}", e)
            com.taskgoapp.taskgo.core.model.Result.Error(e)
        }
    }
    
    /**
     * Verifica se uma story foi visualizada por um usu√°rio
     */
    private suspend fun checkIfStoryViewed(storyId: String, userId: String): Boolean {
        return try {
            val viewDoc = storyViewsCollection
                .document(storyId)
                .collection("views")
                .document(userId)
                .get()
                .await()
            viewDoc.exists()
        } catch (e: Exception) {
            false
        }
    }
    
    override fun observeStoryAnalytics(storyId: String, ownerUserId: String): Flow<StoryAnalytics> = callbackFlow {
        try {
            // Verificar se a story pertence ao usu√°rio
            val storyDoc = storiesCollectionGlobal.document(storyId).get().await()
            val storyData = storyDoc.data
            if (storyData == null || storyData["userId"] != ownerUserId) {
                android.util.Log.w("FirestoreStoriesRepository", "Story n√£o encontrada ou usu√°rio n√£o √© o dono")
                trySend(StoryAnalytics(storyId = storyId, userId = ownerUserId))
                awaitClose { }
                return@callbackFlow
            }
            
            // Observar visualiza√ß√µes da story
            val viewsCollection = storyViewsCollection
                .document(storyId)
                .collection("views")
            
            val listenerRegistration = viewsCollection
                .orderBy("viewedAt", Query.Direction.DESCENDING)
                .addSnapshotListener { snapshot, error ->
                    if (error != null) {
                        android.util.Log.e("FirestoreStoriesRepository", "Erro ao observar views: ${error.message}", error)
                        trySend(StoryAnalytics(storyId = storyId, userId = ownerUserId))
                        return@addSnapshotListener
                    }
                    
                    val viewsList = mutableListOf<StoryView>()
                    snapshot?.documents?.forEach { viewDoc ->
                        try {
                            val viewData = viewDoc.data ?: return@forEach
                            val viewedAt = (viewData["viewedAt"] as? com.google.firebase.Timestamp)?.toDate()
                                ?: Date()
                            
                            // Buscar informa√ß√µes do usu√°rio que visualizou
                            val viewerUserId = viewDoc.id
                            val viewerUser = kotlinx.coroutines.runBlocking {
                                try {
                                    firestore.collection("users").document(viewerUserId).get().await()
                                        .toObject(com.taskgoapp.taskgo.data.firestore.models.UserFirestore::class.java)
                                } catch (e: Exception) {
                                    null
                                }
                            }
                            
                            viewsList.add(
                                StoryView(
                                    userId = viewerUserId,
                                    userName = viewData["userName"] as? String ?: viewerUser?.displayName ?: "Usu√°rio",
                                    userAvatarUrl = viewData["userAvatarUrl"] as? String ?: viewerUser?.photoURL,
                                    viewedAt = viewedAt,
                                    isFollower = false // TODO: Implementar sistema de followers
                                )
                            )
                        } catch (e: Exception) {
                            android.util.Log.e("FirestoreStoriesRepository", "Erro ao processar view: ${e.message}", e)
                        }
                    }
                    
                    // Buscar a√ß√µes e intera√ß√µes
                    kotlinx.coroutines.runBlocking {
                        try {
                            val actionsCollection = storyViewsCollection
                                .document(storyId)
                                .collection("actions")
                            
                            val actionsSnapshot = actionsCollection.get().await()
                            var navigation = 0
                            var back = 0
                            var alignments = 0
                            
                            actionsSnapshot.documents.forEach { actionDoc ->
                                val actionData = actionDoc.data ?: return@forEach
                                when (actionData["action"] as? String) {
                                    "navigation" -> navigation++
                                    "back" -> back++
                                    "swipe_up" -> alignments++
                                }
                            }
                            
                            val interactionsCollection = storyViewsCollection
                                .document(storyId)
                                .collection("interactions")
                            
                            val interactionsSnapshot = interactionsCollection.get().await()
                            val profileVisits = interactionsSnapshot.documents.count { doc ->
                                (doc.data?.get("type") as? String) == "profile_visit"
                            }
                            
                            val impressions = viewsList.size
                            val accountsReached = viewsList.map { it.userId }.distinct().size
                            val followers = viewsList.count { it.isFollower }
                            
                            val analytics = StoryAnalytics(
                                storyId = storyId,
                                userId = ownerUserId,
                                views = viewsList,
                                accountsReached = accountsReached,
                                impressions = impressions,
                                followers = followers,
                                navigation = navigation,
                                back = back,
                                alignments = alignments,
                                interactions = StoryInteractions(
                                    profileVisits = profileVisits,
                                    linkClicks = 0
                                )
                            )
                            
                            trySend(analytics)
                        } catch (e: Exception) {
                            android.util.Log.e("FirestoreStoriesRepository", "Erro ao buscar m√©tricas: ${e.message}", e)
                            // Enviar analytics b√°sico
                            val analytics = StoryAnalytics(
                                storyId = storyId,
                                userId = ownerUserId,
                                views = viewsList,
                                accountsReached = viewsList.map { it.userId }.distinct().size,
                                impressions = viewsList.size
                            )
                            trySend(analytics)
                        }
                    }
                }
            
            awaitClose { listenerRegistration.remove() }
        } catch (e: Exception) {
            android.util.Log.e("FirestoreStoriesRepository", "Erro ao observar analytics: ${e.message}", e)
            trySend(StoryAnalytics(storyId = storyId, userId = ownerUserId))
            awaitClose { }
        }
    }
    
    override suspend fun trackStoryAction(
        storyId: String,
        userId: String,
        action: String,
        metadata: Map<String, Any>?
    ): Result<Unit> {
        return try {
            val actionsCollection = storyViewsCollection
                .document(storyId)
                .collection("actions")
            
            val actionData = hashMapOf<String, Any>(
                "userId" to userId,
                "action" to action,
                "timestamp" to com.google.firebase.firestore.FieldValue.serverTimestamp()
            )
            
            metadata?.let { actionData.putAll(it) }
            
            actionsCollection.add(actionData).await()
            
            com.taskgoapp.taskgo.core.model.Result.Success(Unit)
        } catch (e: Exception) {
            android.util.Log.e("FirestoreStoriesRepository", "Erro ao rastrear a√ß√£o: ${e.message}", e)
            com.taskgoapp.taskgo.core.model.Result.Error(e)
        }
    }
    
    /**
     * Registra intera√ß√£o (visita ao perfil) a partir de uma story
     */
    suspend fun trackProfileVisit(storyId: String, userId: String): Result<Unit> {
        return try {
            val interactionsCollection = storyViewsCollection
                .document(storyId)
                .collection("interactions")
            
            interactionsCollection.add(mapOf(
                "userId" to userId,
                "type" to "profile_visit",
                "timestamp" to com.google.firebase.firestore.FieldValue.serverTimestamp()
            )).await()
            
            com.taskgoapp.taskgo.core.model.Result.Success(Unit)
        } catch (e: Exception) {
            android.util.Log.e("FirestoreStoriesRepository", "Erro ao rastrear visita ao perfil: ${e.message}", e)
            com.taskgoapp.taskgo.core.model.Result.Error(e)
        }
    }
    
    /**
     * Helper para buscar informa√ß√µes b√°sicas do usu√°rio
     */
    private suspend fun getUserInfo(userId: String): UserFirestore? {
        return try {
            firestore.collection("users").document(userId).get().await()
                .toObject(UserFirestore::class.java)
        } catch (e: Exception) {
            android.util.Log.e("FirestoreStoriesRepository", "Erro ao buscar usu√°rio: ${e.message}", e)
            null
        }
    }
}


```

## [FRONTEND]: data/repository/FirestoreTrackingRepository.kt

```kotlin
package com.taskgoapp.taskgo.data.repository

import com.taskgoapp.taskgo.core.model.TrackingEvent
import com.taskgoapp.taskgo.data.firestore.models.TrackingEventFirestore
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.ListenerRegistration
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.tasks.await
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class FirestoreTrackingRepository @Inject constructor(
    private val firestore: FirebaseFirestore
) {
    private val trackingCollection = firestore.collection("tracking_events")
    
    /**
     * Observa eventos de rastreamento de um pedido em tempo real
     */
    fun observeTrackingEvents(orderId: String): Flow<List<TrackingEvent>> = callbackFlow {
        val listenerRegistration = trackingCollection
            .whereEqualTo("orderId", orderId)
            .orderBy("timestamp")
            .addSnapshotListener { snapshot, error ->
                if (error != null) {
                    close(error)
                    return@addSnapshotListener
                }
                
                val events = snapshot?.documents?.mapNotNull { doc ->
                    val event = doc.toObject(TrackingEventFirestore::class.java)
                        ?.copy(id = doc.id)
                    event?.toModel()
                } ?: emptyList()
                
                trySend(events)
            }
        
        awaitClose { listenerRegistration.remove() }
    }
    
    /**
     * Cria um evento de rastreamento
     */
    suspend fun createTrackingEvent(
        orderId: String,
        type: String,
        description: String,
        location: com.taskgoapp.taskgo.data.firestore.models.TrackingLocation? = null,
        eventId: String? = null,
        done: Boolean = false
    ): String {
        val event = TrackingEventFirestore(
            id = eventId ?: "",
            orderId = orderId,
            type = type,
            description = description,
            location = location,
            timestamp = java.util.Date(),
            done = done
        )
        
        return if (eventId != null) {
            trackingCollection.document(eventId)
                .set(event.copy(id = eventId))
                .await()
            eventId
        } else {
            val docRef = trackingCollection.add(event).await()
            docRef.id
        }
    }
    
    /**
     * Atualiza status de um evento
     */
    suspend fun updateEventDone(eventId: String, done: Boolean) {
        trackingCollection.document(eventId).update("done", done).await()
    }
    
    /**
     * Gera c√≥digo de rastreamento √∫nico
     */
    fun generateTrackingCode(orderId: String): String {
        val prefix = "TG"
        val suffix = "BR"
        val middle = orderId.hashCode().toString().padStart(9, '0').take(9)
        return "$prefix$middle$suffix"
    }
}

// Extens√£o para converter TrackingEventFirestore para TrackingEvent
private fun TrackingEventFirestore.toModel(): TrackingEvent {
    return TrackingEvent(
        label = description,
        date = timestamp?.time ?: System.currentTimeMillis(),
        done = done
    )
}


```

## [FRONTEND]: data/repository/FirestoreTrackingRepositoryAdapter.kt

```kotlin
package com.taskgoapp.taskgo.data.repository

import com.taskgoapp.taskgo.core.model.TrackingEvent
import com.taskgoapp.taskgo.domain.repository.TrackingRepository
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import javax.inject.Inject

/**
 * Adapter que implementa TrackingRepository usando FirestoreTrackingRepository
 */
class FirestoreTrackingRepositoryAdapter @Inject constructor(
    private val firestoreTrackingRepository: FirestoreTrackingRepository
) : TrackingRepository {
    
    override fun observeTrackingEvents(orderId: String): Flow<List<TrackingEvent>> {
        return firestoreTrackingRepository.observeTrackingEvents(orderId)
    }
    
    override suspend fun seedTimeline(orderId: String) {
        val seeds = listOf(
            TrackingSeed(
                id = "created_$orderId",
                type = "ORDER_CREATED",
                description = "Pedido criado e aguardando confirma√ß√£o",
                done = true
            ),
            TrackingSeed(
                id = "payment_$orderId",
                type = "PAYMENT_CONFIRMED",
                description = "Pagamento confirmado",
                done = false
            ),
            TrackingSeed(
                id = "shipped_$orderId",
                type = "ORDER_SHIPPED",
                description = "Pedido enviado",
                done = false
            ),
            TrackingSeed(
                id = "transit_$orderId",
                type = "IN_TRANSIT",
                description = "Pedido em tr√¢nsito",
                done = false
            ),
            TrackingSeed(
                id = "delivery_$orderId",
                type = "OUT_FOR_DELIVERY",
                description = "Saiu para entrega",
                done = false
            ),
            TrackingSeed(
                id = "delivered_$orderId",
                type = "DELIVERED",
                description = "Pedido entregue",
                done = false
            )
        )
        
        seeds.forEach { seed ->
            firestoreTrackingRepository.createTrackingEvent(
                orderId = orderId,
                type = seed.type,
                description = seed.description,
                eventId = seed.id,
                done = seed.done
            )
        }
    }
    
    override suspend fun updateEventDone(eventId: String, done: Boolean) {
        firestoreTrackingRepository.updateEventDone(eventId, done)
    }
}

private data class TrackingSeed(
    val id: String,
    val type: String,
    val description: String,
    val done: Boolean
)


```

## [FRONTEND]: data/repository/FirestoreUserRepository.kt

```kotlin
package com.taskgoapp.taskgo.data.repository

import com.taskgoapp.taskgo.data.firestore.models.UserFirestore
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.FieldValue
import com.google.firebase.firestore.ListenerRegistration
import kotlinx.coroutines.tasks.await
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.channels.awaitClose
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class FirestoreUserRepository @Inject constructor(
    private val firestore: FirebaseFirestore
) {
    private val usersCollection = firestore.collection("users")

    suspend fun getUser(uid: String): UserFirestore? {
        return try {
            android.util.Log.d("FirestoreUserRepository", "Buscando usu√°rio no Firestore: uid=$uid")
            val document = usersCollection.document(uid).get().await()
            if (document.exists()) {
                val user = document.data?.let { mapUser(document.id, it) }
                android.util.Log.d("FirestoreUserRepository", "Usu√°rio encontrado: ${user?.displayName}, email: ${user?.email}, role: ${user?.role}")
                user
            } else {
                android.util.Log.d("FirestoreUserRepository", "Usu√°rio n√£o encontrado no Firestore: uid=$uid")
                null
            }
        } catch (e: Exception) {
            android.util.Log.e("FirestoreUserRepository", "Erro ao buscar usu√°rio: ${e.message}", e)
            null
        }
    }
    
    /**
     * Observa mudan√ßas do usu√°rio no Firestore em tempo real
     * CR√çTICO: N√£o falha se usu√°rio n√£o existe ainda (permite cria√ß√£o durante login)
     */
    fun observeUser(uid: String): Flow<UserFirestore?> = callbackFlow {
        try {
            val listenerRegistration = usersCollection.document(uid)
                .addSnapshotListener { snapshot, error ->
                    if (error != null) {
                        // Se for erro de permiss√£o, pode ser que o usu√°rio n√£o existe ainda
                        // N√£o fechar o channel, apenas logar e enviar null
                        if (error is com.google.firebase.firestore.FirebaseFirestoreException) {
                            val firestoreError = error as com.google.firebase.firestore.FirebaseFirestoreException
                            if (firestoreError.code == com.google.firebase.firestore.FirebaseFirestoreException.Code.PERMISSION_DENIED) {
                                android.util.Log.w("FirestoreUserRepository", "Permiss√£o negada ao observar usu√°rio (pode n√£o existir ainda): ${error.message}")
                                trySend(null)
                                return@addSnapshotListener
                            }
                        }
                        android.util.Log.e("FirestoreUserRepository", "Erro ao observar usu√°rio: ${error.message}", error)
                        trySend(null)
                        return@addSnapshotListener
                    }
                    
                    if (snapshot != null && snapshot.exists()) {
                        try {
                            val user = snapshot.data?.let { mapUser(snapshot.id, it) }
                            android.util.Log.d("FirestoreUserRepository", "Usu√°rio atualizado no Firestore: ${user?.displayName}, role: ${user?.role}")
                            trySend(user)
                        } catch (e: Exception) {
                            android.util.Log.e("FirestoreUserRepository", "Erro ao converter usu√°rio: ${e.message}", e)
                            trySend(null)
                        }
                    } else {
                        android.util.Log.d("FirestoreUserRepository", "Usu√°rio n√£o existe no Firestore ainda (ser√° criado)")
                        trySend(null)
                    }
                }
            
            awaitClose { listenerRegistration.remove() }
        } catch (e: Exception) {
            android.util.Log.e("FirestoreUserRepository", "Erro ao configurar listener de usu√°rio: ${e.message}", e)
            trySend(null)
            // N√£o fechar o channel imediatamente, permitir retry
        }
    }
    
    /**
     * Busca usu√°rios por localiza√ß√£o, role e categorias usando userIdentifier
     * @param role Role do usu√°rio (client, partner, etc.)
     * @param city Cidade (opcional)
     * @param state Estado (opcional)
     * @param latitude Latitude (opcional, usado se cidade/estado n√£o fornecidos)
     * @param longitude Longitude (opcional, usado se cidade/estado n√£o fornecidos)
     * @param categories Categorias de servi√ßos (opcional, apenas para partners)
     * @return Lista de usu√°rios encontrados
     */
    suspend fun findUsersByLocationAndRole(
        role: String,
        city: String? = null,
        state: String? = null,
        latitude: Double? = null,
        longitude: Double? = null,
        categories: List<String>? = null
    ): List<UserFirestore> {
        return try {
            val searchId = com.taskgoapp.taskgo.core.utils.UserIdentifier.generateSearchId(
                role = role,
                latitude = latitude,
                longitude = longitude,
                city = city,
                state = state,
                categories = categories
            )
            
            android.util.Log.d("FirestoreUserRepository", "Buscando usu√°rios com searchId: $searchId")
            
            // Buscar usu√°rios que correspondem ao searchId
            // Nota: Como userIdentifier √© um hash, precisamos buscar por componentes individuais
            // ou usar uma abordagem diferente. Por enquanto, vamos buscar por role e localiza√ß√£o.
            var query = usersCollection.whereEqualTo("role", role)
            
            // Se tiver cidade e estado, podemos filtrar por endere√ßo (requer √≠ndice composto)
            // Por enquanto, vamos buscar todos e filtrar em mem√≥ria
            val snapshot = query.get().await()
            
            snapshot.documents.mapNotNull { doc ->
                try {
                    val user = doc.toObject(UserFirestore::class.java)
                    if (user != null) {
                        // Verificar se corresponde aos crit√©rios de busca
                        val matchesLocation = when {
                            city != null && state != null -> {
                                user.address?.city?.equals(city, ignoreCase = true) == true &&
                                user.address?.state?.equals(state, ignoreCase = true) == true
                            }
                            latitude != null && longitude != null -> {
                                // Verificar se est√° dentro de um raio (ser√° feito em camada superior)
                                true // Por enquanto, retornar todos e filtrar depois
                            }
                            else -> true
                        }
                        
                        val matchesCategories = if (categories != null && (role == "partner" || role == "provider" || role == "seller")) {
                            user.preferredCategories?.any { cat -> 
                                categories.any { searchCat -> 
                                    cat.equals(searchCat, ignoreCase = true) 
                                }
                            } ?: false
                        } else {
                            true
                        }
                        
                        if (matchesLocation && matchesCategories) {
                            user
                        } else {
                            null
                        }
                    } else {
                        null
                    }
                } catch (e: Exception) {
                    android.util.Log.e("FirestoreUserRepository", "Erro ao converter documento: ${e.message}", e)
                    null
                }
            }
        } catch (e: Exception) {
            android.util.Log.e("FirestoreUserRepository", "Erro ao buscar usu√°rios: ${e.message}", e)
            emptyList()
        }
    }
    
    /**
     * Busca usu√°rio por CPF ou CNPJ
     * @param document CPF ou CNPJ (com ou sem formata√ß√£o)
     * @return UserFirestore se encontrado, null caso contr√°rio
     * 
     * CR√çTICO: Esta fun√ß√£o precisa buscar sem autentica√ß√£o, ent√£o tenta ambas as formas:
     * 1. Busca direta no Firestore (pode falhar por regras de seguran√ßa)
     * 2. Fallback: busca todos os documentos e filtra em mem√≥ria (menos eficiente, mas funciona)
     */
    suspend fun getUserByDocument(document: String): UserFirestore? {
        return try {
            // Remove formata√ß√£o do documento
            val cleanDocument = document.replace(Regex("[^0-9]"), "")
            android.util.Log.d("FirestoreUserRepository", "Buscando usu√°rio por documento: $cleanDocument (limpo)")
            
            // Tentar busca direta primeiro (mais eficiente se permitido pelas regras)
            try {
                // Buscar por CPF
                val cpfQuery = usersCollection
                    .whereEqualTo("cpf", cleanDocument)
                    .limit(1)
                    .get()
                    .await()
                
                if (!cpfQuery.isEmpty) {
                    val user = cpfQuery.documents[0].data?.let { mapUser(cpfQuery.documents[0].id, it) }
                    android.util.Log.d("FirestoreUserRepository", "‚úÖ Usu√°rio encontrado por CPF: ${user?.email}, role: ${user?.role}")
                    return user
                }
                
                // Buscar por CNPJ
                val cnpjQuery = usersCollection
                    .whereEqualTo("cnpj", cleanDocument)
                    .limit(1)
                    .get()
                    .await()
                
                if (!cnpjQuery.isEmpty) {
                    val user = cnpjQuery.documents[0].data?.let { mapUser(cnpjQuery.documents[0].id, it) }
                    android.util.Log.d("FirestoreUserRepository", "‚úÖ Usu√°rio encontrado por CNPJ: ${user?.email}, role: ${user?.role}")
                    return user
                }
            } catch (queryError: Exception) {
                // Se a query direta falhar (provavelmente por regras de seguran√ßa), usar fallback
                android.util.Log.w("FirestoreUserRepository", "Query direta falhou (provavelmente regras de seguran√ßa), usando fallback: ${queryError.message}")
            }
            
            // FALLBACK: Buscar todos os usu√°rios e filtrar em mem√≥ria
            // Isso √© necess√°rio porque as regras do Firestore podem bloquear queries n√£o autenticadas
            android.util.Log.d("FirestoreUserRepository", "Tentando busca por fallback (buscando todos e filtrando)...")
            try {
                // Buscar todos os usu√°rios (com limite razo√°vel)
                // Nota: Isso pode ser lento, mas funciona mesmo sem autentica√ß√£o
                val allUsersSnapshot = usersCollection
                    .limit(1000) // Limite razo√°vel para n√£o sobrecarregar
                    .get()
                    .await()
                
                android.util.Log.d("FirestoreUserRepository", "Buscando em ${allUsersSnapshot.size()} documentos...")
                
                // Filtrar em mem√≥ria por CPF ou CNPJ
                for (doc in allUsersSnapshot.documents) {
                    try {
                        val data = doc.data
                        val docCpf = (data?.get("cpf") as? String)?.replace(Regex("[^0-9]"), "")
                        val docCnpj = (data?.get("cnpj") as? String)?.replace(Regex("[^0-9]"), "")
                        
                        if ((docCpf != null && docCpf == cleanDocument) || 
                            (docCnpj != null && docCnpj == cleanDocument)) {
                            val user = mapUser(doc.id, data)
                            android.util.Log.d("FirestoreUserRepository", "‚úÖ Usu√°rio encontrado por fallback: ${user.email}, role: ${user.role}")
                            return user
                        }
                    } catch (e: Exception) {
                        android.util.Log.w("FirestoreUserRepository", "Erro ao processar documento ${doc.id}: ${e.message}")
                    }
                }
            } catch (fallbackError: Exception) {
                android.util.Log.e("FirestoreUserRepository", "Erro no fallback: ${fallbackError.message}", fallbackError)
            }
            
            android.util.Log.d("FirestoreUserRepository", "‚ùå Usu√°rio n√£o encontrado por documento: $cleanDocument")
            null
        } catch (e: Exception) {
            android.util.Log.e("FirestoreUserRepository", "Erro ao buscar usu√°rio por documento: ${e.message}", e)
            null
        }
    }

    private fun mapUser(id: String, data: Map<String, Any?>): UserFirestore {
        fun parseDate(value: Any?): java.util.Date? = when (value) {
            is java.util.Date -> value
            is com.google.firebase.Timestamp -> value.toDate()
            is Long -> java.util.Date(value)
            is Int -> java.util.Date(value.toLong())
            else -> null
        }

        return UserFirestore(
            uid = id,
            email = data["email"] as? String ?: "",
            displayName = data["displayName"] as? String,
            photoURL = data["photoURL"] as? String,
            phone = data["phone"] as? String,
            role = data["role"] as? String ?: "client",
            pendingAccountType = data["pendingAccountType"] as? Boolean ?: false,
            profileComplete = data["profileComplete"] as? Boolean ?: false,
            verified = data["verified"] as? Boolean ?: false,
            cpf = data["cpf"] as? String,
            rg = data["rg"] as? String,
            cnpj = data["cnpj"] as? String,
            birthDate = parseDate(data["birthDate"]),
            documentFront = data["documentFront"] as? String,
            documentBack = data["documentBack"] as? String,
            selfie = data["selfie"] as? String,
            address = (data["address"] as? Map<*, *>)?.let { addr ->
                com.taskgoapp.taskgo.core.model.Address(
                    id = addr["id"] as? String ?: "",
                    name = addr["name"] as? String ?: "",
                    phone = addr["phone"] as? String ?: "",
                    cep = addr["cep"] as? String ?: (addr["zipCode"] as? String ?: ""),
                    street = addr["street"] as? String ?: "",
                    district = addr["district"] as? String ?: "",
                    city = addr["city"] as? String ?: "",
                    state = addr["state"] as? String ?: "",
                    number = addr["number"] as? String ?: "",
                    complement = addr["complement"] as? String,
                    neighborhood = addr["neighborhood"] as? String ?: "",
                    zipCode = addr["zipCode"] as? String ?: "",
                    country = addr["country"] as? String ?: "Brasil"
                )
            },
            addressProof = data["addressProof"] as? String,
            verifiedAt = parseDate(data["verifiedAt"]),
            verifiedBy = data["verifiedBy"] as? String,
            biometricEnabled = data["biometricEnabled"] as? Boolean ?: false,
            twoFactorEnabled = data["twoFactorEnabled"] as? Boolean ?: false,
            twoFactorMethod = data["twoFactorMethod"] as? String,
            stripeAccountId = data["stripeAccountId"] as? String,
            stripeChargesEnabled = data["stripeChargesEnabled"] as? Boolean ?: false,
            stripePayoutsEnabled = data["stripePayoutsEnabled"] as? Boolean ?: false,
            stripeDetailsSubmitted = data["stripeDetailsSubmitted"] as? Boolean ?: false,
            documents = (data["documents"] as? List<*>)?.mapNotNull { it as? String },
            documentsApproved = data["documentsApproved"] as? Boolean ?: false,
            documentsApprovedAt = parseDate(data["documentsApprovedAt"]),
            documentsApprovedBy = data["documentsApprovedBy"] as? String,
            preferredCategories = (data["preferredCategories"] as? List<*>)?.mapNotNull { it as? String },
            userIdentifier = data["userIdentifier"] as? String,
            notificationSettings = (data["notificationSettings"] as? Map<*, *>)?.let {
                com.taskgoapp.taskgo.data.firestore.models.NotificationSettingsFirestore(
                    push = it["push"] as? Boolean ?: true,
                    promos = it["promos"] as? Boolean ?: true,
                    sound = it["sound"] as? Boolean ?: true,
                    lockscreen = it["lockscreen"] as? Boolean ?: true,
                    email = it["email"] as? Boolean ?: false,
                    sms = it["sms"] as? Boolean ?: false
                )
            },
            privacySettings = (data["privacySettings"] as? Map<*, *>)?.let {
                com.taskgoapp.taskgo.data.firestore.models.PrivacySettingsFirestore(
                    locationSharing = it["locationSharing"] as? Boolean ?: true,
                    profileVisible = it["profileVisible"] as? Boolean ?: true,
                    contactInfoSharing = it["contactInfoSharing"] as? Boolean ?: false,
                    analytics = it["analytics"] as? Boolean ?: true,
                    personalizedAds = it["personalizedAds"] as? Boolean ?: false,
                    dataCollection = it["dataCollection"] as? Boolean ?: true,
                    thirdPartySharing = it["thirdPartySharing"] as? Boolean ?: false
                )
            },
            language = data["language"] as? String ?: "pt",
            rating = (data["rating"] as? Number)?.toDouble(),
            createdAt = parseDate(data["createdAt"]),
            updatedAt = parseDate(data["updatedAt"])
        )
    }

    suspend fun updateUser(user: UserFirestore): Result<Unit> {
        return try {
            // Validar que uid n√£o est√° vazio
            if (user.uid.isBlank()) {
                android.util.Log.e("FirestoreUserRepository", "Erro: uid est√° vazio ao tentar salvar usu√°rio")
                return Result.failure(Exception("UID n√£o pode estar vazio"))
            }
            
            android.util.Log.d("FirestoreUserRepository", "Salvando usu√°rio no Firestore: uid=${user.uid}, email=${user.email}, displayName=${user.displayName}")
            
            // Calcular userIdentifier automaticamente
            val userIdentifier = com.taskgoapp.taskgo.core.utils.UserIdentifier.generateUserId(user)
            android.util.Log.d("FirestoreUserRepository", "UserIdentifier calculado: $userIdentifier para role=${user.role}")
            
            // Converter UserFirestore para Map, tratando Date corretamente
            val dataMap = mutableMapOf<String, Any?>(
                "uid" to user.uid,
                "email" to user.email,
                "displayName" to user.displayName,
                "photoURL" to user.photoURL,
                "phone" to user.phone,
                "role" to user.role,
                "pendingAccountType" to user.pendingAccountType,
                "profileComplete" to user.profileComplete,
                "verified" to user.verified,
                "cpf" to user.cpf,
                "rg" to user.rg,
                "cnpj" to user.cnpj,
                "birthDate" to (user.birthDate?.let { com.google.firebase.Timestamp(it) }),
                "documentFront" to user.documentFront,
                "documentBack" to user.documentBack,
                "selfie" to user.selfie,
                "addressProof" to user.addressProof,
                "verifiedAt" to (user.verifiedAt?.let { com.google.firebase.Timestamp(it) }),
                "verifiedBy" to user.verifiedBy,
                "biometricEnabled" to user.biometricEnabled,
                "twoFactorEnabled" to user.twoFactorEnabled,
                "twoFactorMethod" to user.twoFactorMethod,
                "stripeAccountId" to user.stripeAccountId,
                "stripeChargesEnabled" to user.stripeChargesEnabled,
                "stripePayoutsEnabled" to user.stripePayoutsEnabled,
                "stripeDetailsSubmitted" to user.stripeDetailsSubmitted,
                "documents" to user.documents,
                "documentsApproved" to user.documentsApproved,
                "documentsApprovedAt" to (user.documentsApprovedAt?.let { com.google.firebase.Timestamp(it) }),
                "documentsApprovedBy" to user.documentsApprovedBy,
                "preferredCategories" to user.preferredCategories,
                "userIdentifier" to userIdentifier,
                "notificationSettings" to user.notificationSettings?.let { settings ->
                    mapOf(
                        "push" to settings.push,
                        "promos" to settings.promos,
                        "sound" to settings.sound,
                        "lockscreen" to settings.lockscreen,
                        "email" to settings.email,
                        "sms" to settings.sms
                    )
                },
                "privacySettings" to user.privacySettings?.let { settings ->
                    mapOf(
                        "locationSharing" to settings.locationSharing,
                        "profileVisible" to settings.profileVisible,
                        "contactInfoSharing" to settings.contactInfoSharing,
                        "analytics" to settings.analytics,
                        "personalizedAds" to settings.personalizedAds,
                        "dataCollection" to settings.dataCollection,
                        "thirdPartySharing" to settings.thirdPartySharing
                    )
                },
                "language" to user.language,
                "rating" to user.rating,
                "updatedAt" to FieldValue.serverTimestamp()
            )
            
            // Adicionar createdAt apenas se n√£o existir (para n√£o sobrescrever)
            if (user.createdAt != null) {
                dataMap["createdAt"] = com.google.firebase.Timestamp(user.createdAt)
            }
            // Se createdAt for null, n√£o adicionar ao map - o merge n√£o vai sobrescrever se j√° existir
            
            // Remover campos null para n√£o sobrescrever dados existentes
            dataMap.entries.removeAll { it.value == null }
            
            // Converter Address se existir
            user.address?.let { address ->
                dataMap["address"] = mapOf(
                    "street" to (address.street ?: ""),
                    "number" to (address.number ?: ""),
                    "complement" to (address.complement ?: ""),
                    "neighborhood" to (address.neighborhood ?: ""),
                    "city" to (address.city ?: ""),
                    "state" to (address.state ?: ""),
                    "zipCode" to (address.zipCode ?: ""),
                    "country" to (address.country ?: "Brasil")
                )
            }
            
            // Usar set() com merge para n√£o sobrescrever campos existentes
            usersCollection.document(user.uid).set(dataMap, com.google.firebase.firestore.SetOptions.merge()).await()
            
            android.util.Log.d("FirestoreUserRepository", "Usu√°rio salvo com sucesso no Firestore: ${user.uid}")
            Result.success(Unit)
        } catch (e: kotlinx.coroutines.CancellationException) {
            android.util.Log.w("FirestoreUserRepository", "Opera√ß√£o de salvamento cancelada: ${e.message}")
            throw e // Re-lan√ßar CancellationException para propagar corretamente
        } catch (e: Exception) {
            android.util.Log.e("FirestoreUserRepository", "Erro ao salvar usu√°rio no Firestore: ${e.message}", e)
            Result.failure(e)
        }
    }

    suspend fun updateField(uid: String, field: String, value: Any): Result<Unit> {
        return try {
            usersCollection.document(uid)
                .update(field, value, "updatedAt", FieldValue.serverTimestamp())
                .await()
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    suspend fun promoteToProvider(uid: String): Result<Unit> {
        // Atualizar para "partner" em vez de "provider" (legacy)
        return updateField(uid, "role", "partner")
    }

    suspend fun approveDocuments(uid: String, documents: List<String>, approvedBy: String): Result<Unit> {
        return try {
            usersCollection.document(uid).update(
                "documents", documents,
                "documentsApproved", true,
                "documentsApprovedAt", FieldValue.serverTimestamp(),
                "documentsApprovedBy", approvedBy,
                "updatedAt", FieldValue.serverTimestamp()
            ).await()
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    suspend fun setStripeAccount(uid: String, accountId: String): Result<Unit> {
        return try {
            usersCollection.document(uid).update(
                "stripeAccountId", accountId,
                "updatedAt", FieldValue.serverTimestamp()
            ).await()
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}






```

## [FRONTEND]: data/repository/GoogleSignInHelper.kt

```kotlin
package com.taskgoapp.taskgo.data.repository

import android.content.Context
import android.util.Log
import com.google.android.gms.auth.api.signin.GoogleSignIn
import com.google.android.gms.auth.api.signin.GoogleSignInAccount
import com.google.android.gms.auth.api.signin.GoogleSignInClient
import com.google.android.gms.auth.api.signin.GoogleSignInOptions
import com.google.android.gms.common.api.ApiException

class GoogleSignInHelper(context: Context) {
    private val context: Context = context.applicationContext
    private val webClientId = "1093466748007-bk95o4ouk4966bvgqbm98n5h8js8m28v.apps.googleusercontent.com"
    
    private fun createGoogleSignInClient(): GoogleSignInClient {
        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)
            .requestIdToken(webClientId)
            .requestEmail()
            .build()
        return GoogleSignIn.getClient(context, gso)
    }

    /**
     * Obt√©m o Intent de sign-in, sempre fazendo signOut antes para garantir que o seletor de conta seja mostrado
     * Cria um novo client a cada vez para garantir que n√£o h√° cache de conta
     * 
     * IMPORTANTE: O signOut() √© ass√≠ncrono, mas como n√£o podemos tornar este m√©todo suspenso,
     * fazemos o signOut() e imediatamente retornamos o intent. O Google Sign-In mostrar√°
     * o seletor de conta mesmo se houver uma sess√£o ativa, desde que n√£o haja uma conta
     * em cache no dispositivo.
     */
    fun getSignInIntent(): android.content.Intent {
        // Criar um novo client a cada vez para evitar cache
        val client = createGoogleSignInClient()
        // Fazer signOut de forma ass√≠ncrona (n√£o bloqueia, mas limpa o cache)
        // O Google Sign-In mostrar√° o seletor mesmo com signOut em andamento
        client.signOut()
        // Retornar o intent imediatamente - o seletor ser√° mostrado
        return client.signInIntent
    }

    fun getSignInResultFromIntent(data: android.content.Intent?): GoogleSignInAccount? {
        return try {
            if (data == null) {
                Log.e("GoogleSignInHelper", "Intent data √© null")
                return null
            }
            val task = GoogleSignIn.getSignedInAccountFromIntent(data)
            val account = task.getResult(ApiException::class.java)
            Log.d("GoogleSignInHelper", "Conta Google obtida: ${account.email}, ID Token: ${account.idToken != null}")
            account
        } catch (e: ApiException) {
            Log.e("GoogleSignInHelper", "Erro ao obter conta do Google: ${e.message}", e)
            Log.e("GoogleSignInHelper", "C√≥digo de erro: ${e.statusCode}")
            null
        } catch (e: Exception) {
            Log.e("GoogleSignInHelper", "Erro inesperado: ${e.message}", e)
            null
        }
    }

    fun signOut() {
        val client = createGoogleSignInClient()
        client.signOut()
    }
}


```

## [FRONTEND]: data/repository/MessageRepositoryImpl.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.data.repository

import com.taskgoapp.taskgo.data.local.dao.MessageDao
import com.taskgoapp.taskgo.data.mapper.MessageMapper.toEntity
import com.taskgoapp.taskgo.data.mapper.MessageMapper.toModel
import com.taskgoapp.taskgo.domain.repository.MessageRepository
import com.taskgoapp.taskgo.core.model.MessageThread
import com.taskgoapp.taskgo.core.model.ChatMessage
import com.google.firebase.database.FirebaseDatabase
import com.google.firebase.database.DatabaseReference
import com.google.firebase.auth.FirebaseAuth
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.tasks.await
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class MessageRepositoryImpl @Inject constructor(
    private val messageDao: MessageDao,
    private val database: FirebaseDatabase,
    private val firebaseAuth: FirebaseAuth
) : MessageRepository {
    
    private val rootRef: DatabaseReference = database.reference
    private val messagesRef: DatabaseReference = rootRef.child("messages")
    private val threadsRef: DatabaseReference = rootRef.child("conversations")
    private val syncScope = CoroutineScope(SupervisorJob() + Dispatchers.IO)
    
    override fun observeThreads(): Flow<List<MessageThread>> = callbackFlow {
        val currentUserId = firebaseAuth.currentUser?.uid
        
        if (currentUserId == null) {
            // Se n√£o autenticado, retornar apenas cache local
            val cachedThreads = messageDao.observeThreads().map { entities ->
                entities.map { it.toModel() }
            }
            cachedThreads.collect { threads ->
                trySend(threads)
            }
            awaitClose { }
            return@callbackFlow
        }
        
        // Observar Firebase Realtime Database
        val listener = threadsRef
            .orderByChild("participants/$currentUserId")
            .equalTo(true)
            .addValueEventListener(object : com.google.firebase.database.ValueEventListener {
                override fun onDataChange(snapshot: com.google.firebase.database.DataSnapshot) {
                    val threads = mutableListOf<MessageThread>()
                    snapshot.children.forEach { threadSnapshot ->
                        val threadData = threadSnapshot.getValue(Map::class.java) as? Map<*, *>
                        threadData?.let { data ->
                            val thread = MessageThread(
                                id = threadSnapshot.key ?: "",
                                title = data["title"] as? String ?: "",
                                lastMessage = data["lastMessage"] as? String ?: "",
                                lastTime = (data["lastTime"] as? Long) ?: 0L
                            )
                            threads.add(thread)
                            // Salvar no cache local em background
                            syncScope.launch {
                                messageDao.upsertThread(thread.toEntity())
                            }
                        }
                    }
                    trySend(threads.sortedByDescending { it.lastTime })
                }
                
                override fun onCancelled(error: com.google.firebase.database.DatabaseError) {
                    android.util.Log.e("MessageRepo", "Erro ao observar threads: ${error.message}")
                    // Em caso de erro, tentar retornar cache local
                    syncScope.launch {
                        val cachedThreads = messageDao.observeThreads().map { entities ->
                            entities.map { it.toModel() }
                        }
                        cachedThreads.collect { threads ->
                            trySend(threads)
                        }
                    }
                }
            })
        
        awaitClose { threadsRef.removeEventListener(listener) }
    }

    override suspend fun getThread(id: String): MessageThread? {
        // 1. Tentar buscar do cache local primeiro
        val cached = messageDao.getThreadById(id)?.toModel()
        if (cached != null) return cached
        
        // 2. Buscar do Firebase
        return try {
            val snapshot = threadsRef.child(id).get().await()
            val data = snapshot.getValue(Map::class.java) as? Map<*, *>
            data?.let {
                val thread = MessageThread(
                    id = id,
                    title = it["title"] as? String ?: "",
                    lastMessage = it["lastMessage"] as? String ?: "",
                    lastTime = (it["lastTime"] as? Long) ?: 0L
                )
                // Salvar no cache
                messageDao.upsertThread(thread.toEntity())
                thread
            }
        } catch (e: Exception) {
            android.util.Log.e("MessageRepo", "Erro ao buscar thread: ${e.message}", e)
            null
        }
    }

    override fun observeMessages(threadId: String): Flow<List<ChatMessage>> = callbackFlow {
        val currentUserId = firebaseAuth.currentUser?.uid
        
        if (currentUserId == null) {
            // Se n√£o autenticado, retornar apenas cache local
            val cachedMessages = messageDao.observeMessages(threadId).map { entities ->
                entities.map { it.toModel() }
            }
            cachedMessages.collect { messages ->
                trySend(messages.sortedBy { it.time })
            }
            awaitClose { }
            return@callbackFlow
        }
        
        // Observar Firebase Realtime Database
        val listener = messagesRef
            .child(threadId)
            .orderByChild("time")
            .addValueEventListener(object : com.google.firebase.database.ValueEventListener {
                override fun onDataChange(snapshot: com.google.firebase.database.DataSnapshot) {
                    val messages = mutableListOf<ChatMessage>()
                    snapshot.children.forEach { messageSnapshot ->
                        val messageData = messageSnapshot.getValue(Map::class.java) as? Map<*, *>
                        messageData?.let { data ->
                            val senderId = data["senderId"] as? String ?: ""
                            val message = ChatMessage(
                                id = messageSnapshot.key ?: "",
                                threadId = threadId,
                                senderMe = senderId == currentUserId,
                                text = data["text"] as? String ?: "",
                                time = (data["time"] as? Long) ?: 0L
                            )
                            messages.add(message)
                            // Salvar no cache local em background
                            syncScope.launch {
                                messageDao.upsertMessage(message.toEntity())
                            }
                        }
                    }
                    trySend(messages.sortedBy { it.time })
                }
                
                override fun onCancelled(error: com.google.firebase.database.DatabaseError) {
                    android.util.Log.e("MessageRepo", "Erro ao observar mensagens: ${error.message}")
                    // Em caso de erro, tentar retornar cache local
                    syncScope.launch {
                        val cachedMessages = messageDao.observeMessages(threadId).map { entities ->
                            entities.map { it.toModel() }
                        }
                        cachedMessages.collect { messages ->
                            trySend(messages.sortedBy { it.time })
                        }
                    }
                }
            })
        
        awaitClose { messagesRef.child(threadId).removeEventListener(listener) }
    }

    override suspend fun sendMessage(threadId: String, text: String) {
        val currentUserId = firebaseAuth.currentUser?.uid
            ?: throw IllegalStateException("Usu√°rio n√£o autenticado")
        
        val messageId = generateMessageId()
        val timestamp = System.currentTimeMillis()
        
        val message = ChatMessage(
            id = messageId,
            threadId = threadId,
            senderMe = true,
            text = text,
            time = timestamp
        )
        
        // 1. Salvar no cache local primeiro (otimista)
        messageDao.upsertMessage(message.toEntity())
        
        // 2. Salvar no Firebase Realtime Database
        try {
            val messageData = mapOf(
                "senderId" to currentUserId,
                "text" to text,
                "time" to timestamp
            )
            messagesRef.child(threadId).child(messageId).setValue(messageData).await()
            
            // 3. Atualizar thread com √∫ltima mensagem
            val threadUpdate = mapOf(
                "lastMessage" to text,
                "lastTime" to timestamp
            )
            threadsRef.child(threadId).updateChildren(threadUpdate).await()
            
            // 4. Atualizar cache local da thread
            val thread = messageDao.getThreadById(threadId)
            if (thread != null) {
                val updatedThread = thread.copy(
                    lastMessage = text,
                    lastTime = timestamp
                )
                messageDao.upsertThread(updatedThread)
            }
        } catch (e: Exception) {
            android.util.Log.e("MessageRepo", "Erro ao enviar mensagem: ${e.message}", e)
            throw e
        }
    }

    override suspend fun createThread(title: String): String {
        val currentUserId = firebaseAuth.currentUser?.uid
            ?: throw IllegalStateException("Usu√°rio n√£o autenticado")
        
        val threadId = generateMessageId()
        val timestamp = System.currentTimeMillis()
        
        val thread = MessageThread(
            id = threadId,
            title = title,
            lastMessage = "",
            lastTime = timestamp
        )
        
        // 1. Salvar no cache local primeiro
        messageDao.upsertThread(thread.toEntity())
        
        // 2. Salvar no Firebase Realtime Database
        try {
            val threadData = mapOf(
                "title" to title,
                "lastMessage" to "",
                "lastTime" to timestamp,
                "participants" to mapOf(currentUserId to true),
                "createdAt" to timestamp
            )
            threadsRef.child(threadId).setValue(threadData).await()
        } catch (e: Exception) {
            android.util.Log.e("MessageRepo", "Erro ao criar thread: ${e.message}", e)
            throw e
        }
        
        return threadId
    }
    
    /**
     * Cria uma thread entre dois usu√°rios (para conversas de pedidos/propostas)
     */
    suspend fun createThreadBetweenUsers(userId1: String, userId2: String, title: String): String {
        val threadId = generateMessageId()
        val timestamp = System.currentTimeMillis()
        
        val thread = MessageThread(
            id = threadId,
            title = title,
            lastMessage = "",
            lastTime = timestamp
        )
        
        // 1. Salvar no cache local
        messageDao.upsertThread(thread.toEntity())
        
        // 2. Salvar no Firebase
        try {
            val threadData = mapOf(
                "title" to title,
                "lastMessage" to "",
                "lastTime" to timestamp,
                "participants" to mapOf(
                    userId1 to true,
                    userId2 to true
                ),
                "createdAt" to timestamp
            )
            threadsRef.child(threadId).setValue(threadData).await()
        } catch (e: Exception) {
            android.util.Log.e("MessageRepo", "Erro ao criar thread entre usu√°rios: ${e.message}", e)
            throw e
        }
        
        return threadId
    }
    
    /**
     * Busca ou cria uma thread baseada em orderId
     * Retorna o ID da thread existente ou cria uma nova
     */
    suspend fun getOrCreateThreadForOrder(
        orderId: String,
        orderRepository: com.taskgoapp.taskgo.data.repository.FirestoreOrderRepository,
        userRepository: com.taskgoapp.taskgo.data.repository.FirestoreUserRepository
    ): String {
        val currentUserId = firebaseAuth.currentUser?.uid ?: throw IllegalStateException("Usu√°rio n√£o autenticado")
        
        // 1. Buscar ordem para obter clientId e providerId
        val order = orderRepository.getOrder(orderId) ?: throw IllegalArgumentException("Ordem n√£o encontrada: $orderId")
        
        val otherUserId = if (order.clientId == currentUserId) {
            order.providerId ?: throw IllegalArgumentException("Ordem sem prestador")
        } else {
            order.clientId
        }
        
        // 2. Buscar nome do outro usu√°rio
        val otherUser = userRepository.getUser(otherUserId)
        val threadTitle = otherUser?.displayName ?: "Conversa"
        
        // 3. Buscar thread existente entre os dois usu√°rios
        val existingThread = try {
            val snapshot = threadsRef
                .orderByChild("participants/$currentUserId")
                .equalTo(true)
                .get()
                .await()
            
            snapshot.children.firstOrNull { threadSnapshot ->
                val threadData = threadSnapshot.getValue(Map::class.java) as? Map<*, *>
                val participants = threadData?.get("participants") as? Map<*, *>
                participants?.containsKey(otherUserId) == true && 
                (threadData["orderId"] as? String) == orderId
            }?.key
        } catch (e: Exception) {
            null
        }
        
        // 4. Se encontrou thread existente, retornar
        if (existingThread != null) {
            return existingThread
        }
        
        // 5. Criar nova thread
        return createThreadBetweenUsers(
            userId1 = currentUserId,
            userId2 = otherUserId,
            title = threadTitle
        ).also { threadId ->
            // Adicionar orderId √† thread
            try {
                threadsRef.child(threadId).updateChildren(mapOf("orderId" to orderId)).await()
            } catch (e: Exception) {
                android.util.Log.w("MessageRepo", "Erro ao adicionar orderId √† thread: ${e.message}")
            }
        }
    }
    
    /**
     * Busca ou cria uma thread baseada em providerId
     * Retorna o ID da thread existente ou cria uma nova
     */
    suspend fun getOrCreateThreadForProvider(
        providerId: String,
        userRepository: com.taskgoapp.taskgo.data.repository.FirestoreUserRepository
    ): String {
        val currentUserId = firebaseAuth.currentUser?.uid ?: throw IllegalStateException("Usu√°rio n√£o autenticado")
        
        if (providerId == currentUserId) {
            throw IllegalArgumentException("N√£o √© poss√≠vel criar thread consigo mesmo")
        }
        
        // 1. Buscar nome do prestador
        val provider = userRepository.getUser(providerId)
        val threadTitle = provider?.displayName ?: "Conversa"
        
        // 2. Buscar thread existente entre os dois usu√°rios
        val existingThread = try {
            val snapshot = threadsRef
                .orderByChild("participants/$currentUserId")
                .equalTo(true)
                .get()
                .await()
            
            snapshot.children.firstOrNull { threadSnapshot ->
                val threadData = threadSnapshot.getValue(Map::class.java) as? Map<*, *>
                val participants = threadData?.get("participants") as? Map<*, *>
                participants?.containsKey(providerId) == true
            }?.key
        } catch (e: Exception) {
            null
        }
        
        // 3. Se encontrou thread existente, retornar
        if (existingThread != null) {
            return existingThread
        }
        
        // 4. Criar nova thread
        return createThreadBetweenUsers(
            userId1 = currentUserId,
            userId2 = providerId,
            title = threadTitle
        )
    }

    private fun generateMessageId(): String {
        return "msg_${System.currentTimeMillis()}_${(1000..9999).random()}"
    }
}

```

## [FRONTEND]: data/repository/OrdersRepositoryImpl.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.data.repository

import com.taskgoapp.taskgo.data.local.dao.PurchaseOrderDao
import com.taskgoapp.taskgo.data.local.dao.CartDao
import com.taskgoapp.taskgo.data.mapper.OrderMapper.toEntity
import com.taskgoapp.taskgo.data.mapper.OrderMapper.toModel
import com.taskgoapp.taskgo.domain.repository.OrdersRepository
import com.taskgoapp.taskgo.core.model.PurchaseOrder
import com.taskgoapp.taskgo.core.model.OrderStatus
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class OrdersRepositoryImpl @Inject constructor(
    private val purchaseOrderDao: PurchaseOrderDao,
    private val cartDao: CartDao
) : OrdersRepository {

    override fun observeOrders(): Flow<List<PurchaseOrder>> {
        return purchaseOrderDao.observeAll().map { entities ->
            entities.map { entity ->
                val items = purchaseOrderDao.getItemsByOrderId(entity.id).map { it.toModel() }
                entity.toModel(items)
            }
        }
    }

    override fun observeOrdersByStatus(status: OrderStatus): Flow<List<PurchaseOrder>> {
        return purchaseOrderDao.observeByStatus(status.name).map { entities ->
            entities.map { entity ->
                val items = purchaseOrderDao.getItemsByOrderId(entity.id).map { it.toModel() }
                entity.toModel(items)
            }
        }
    }

    override suspend fun getOrder(id: String): PurchaseOrder? {
        val entity = purchaseOrderDao.getById(id) ?: return null
        val items = purchaseOrderDao.getItemsByOrderId(id).map { it.toModel() }
        return entity.toModel(items)
    }

    override suspend fun createOrder(
        cart: List<com.taskgoapp.taskgo.core.model.CartItem>,
        total: Double,
        paymentMethod: String,
        addressId: String
    ): String {
        val orderId = generateOrderId()
        val orderNumber = "TG${System.currentTimeMillis()}"
        // Use the provided total
        
        val order = PurchaseOrder(
            id = orderId,
            orderNumber = orderNumber,
            createdAt = System.currentTimeMillis(),
            total = total,
            subtotal = total,
            deliveryFee = 0.0,
            status = OrderStatus.EM_ANDAMENTO,
            items = emptyList(),
            paymentMethod = paymentMethod,
            deliveryAddress = addressId
        )
        
        purchaseOrderDao.upsert(order.toEntity())
        
        // Create order items
        val orderItems = cart.map { cartItem ->
            com.taskgoapp.taskgo.core.model.OrderItem(
                productId = cartItem.productId,
                price = 0.0, // Will be loaded from product
                quantity = cartItem.qty
            ).toEntity(orderId)
        }
        purchaseOrderDao.upsertItems(orderItems)
        
        // Clear cart after order creation
        cartDao.clearAll()
        
        return orderId
    }

    override suspend fun updateOrderStatus(orderId: String, status: OrderStatus) {
        purchaseOrderDao.updateStatus(orderId, status.name)
    }

    private fun generateOrderId(): String {
        return "order_${System.currentTimeMillis()}_${(1000..9999).random()}"
    }
}
```

## [FRONTEND]: data/repository/ProductsRepositoryImpl.kt

```kotlin
package com.taskgoapp.taskgo.data.repository

import com.taskgoapp.taskgo.data.local.dao.ProductDao
import com.taskgoapp.taskgo.data.local.dao.CartDao
import com.taskgoapp.taskgo.data.mapper.CartMapper.toEntity
import com.taskgoapp.taskgo.data.mapper.CartMapper.toModel
import com.taskgoapp.taskgo.domain.repository.ProductsRepository
import com.taskgoapp.taskgo.core.model.Product
import com.taskgoapp.taskgo.core.model.CartItem
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.emptyFlow
import kotlinx.coroutines.flow.map
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class ProductsRepositoryImpl @Inject constructor(
    private val productDao: ProductDao,
    private val cartDao: CartDao
) : ProductsRepository {

    // Cache local desabilitado para produtos; fonte = Firestore
    override fun observeProducts(): Flow<List<Product>> = emptyFlow()
    override fun observeProductErrors(): Flow<String> = emptyFlow()
    override suspend fun getProduct(id: String): Product? = null
    override suspend fun getMyProducts(): List<Product> = emptyList()
    override suspend fun upsertProduct(product: Product) { /* no-op */ }
    override suspend fun deleteProduct(id: String) { /* no-op */ }

    override suspend fun addToCart(productId: String, qtyDelta: Int) {
        val existing = cartDao.getByProductId(productId)
        if (existing != null) {
            val newQty = existing.qty + qtyDelta
            if (newQty <= 0) {
                cartDao.deleteByProductId(productId)
            } else {
                cartDao.upsert(existing.copy(qty = newQty))
            }
        } else if (qtyDelta > 0) {
            cartDao.upsert(CartItem(productId, qtyDelta).toEntity())
        }
    }

    override fun observeCart(): Flow<List<CartItem>> {
        return cartDao.observeAll().map { entities ->
            entities.map { it.toModel() }
        }
    }

    override suspend fun clearCart() {
        cartDao.clearAll()
    }

    override suspend fun removeFromCart(productId: String) {
        cartDao.deleteByProductId(productId)
    }

    private fun generateId(): String {
        return "product_${System.currentTimeMillis()}_${(1000..9999).random()}"
    }
}
```

## [FRONTEND]: data/repository/ServiceRepositoryImpl.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.data.repository

import com.taskgoapp.taskgo.data.local.dao.ServiceOrderDao
import com.taskgoapp.taskgo.data.local.dao.ProposalDao
import com.taskgoapp.taskgo.data.mapper.ServiceMapper.toEntity
import com.taskgoapp.taskgo.data.mapper.ServiceMapper.toModel
import com.taskgoapp.taskgo.domain.repository.ServiceRepository
import com.taskgoapp.taskgo.core.model.ServiceOrder
import com.taskgoapp.taskgo.core.model.Proposal
import com.taskgoapp.taskgo.data.firebase.FirebaseFunctionsService
import com.taskgoapp.taskgo.data.repository.FirestoreOrderRepository
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class ServiceRepositoryImpl @Inject constructor(
    private val serviceOrderDao: ServiceOrderDao,
    private val proposalDao: ProposalDao,
    private val functionsService: FirebaseFunctionsService,
    private val orderRepository: FirestoreOrderRepository
) : ServiceRepository {

    override fun observeServiceOrders(): Flow<List<ServiceOrder>> {
        return serviceOrderDao.observeAll().map { entities ->
            entities.map { it.toModel() }
        }
    }

    override suspend fun getServiceOrder(id: String): ServiceOrder? {
        return serviceOrderDao.getById(id)?.toModel()
    }

    override suspend fun upsertServiceOrder(order: ServiceOrder) {
        serviceOrderDao.upsert(order.toEntity())
    }

    override suspend fun deleteServiceOrder(id: String) {
        val entity = serviceOrderDao.getById(id) ?: return
        serviceOrderDao.delete(entity)
    }

    override fun observeProposals(orderId: String): Flow<List<Proposal>> {
        return proposalDao.observeByOrderId(orderId).map { entities ->
            entities.map { it.toModel() }
        }
    }

    override suspend fun getProposal(id: String): Proposal? {
        return proposalDao.getById(id)?.toModel()
    }

    override suspend fun upsertProposal(proposal: Proposal) {
        proposalDao.upsert(proposal.toEntity())
    }

    override suspend fun acceptProposal(proposalId: String) {
        // 1. Atualizar no cache local (otimista)
        proposalDao.updateAccepted(proposalId, true)
        
        // 2. Buscar proposta para obter orderId
        val proposal = proposalDao.getById(proposalId)?.toModel()
        val orderId = proposal?.orderId
        
        if (orderId != null) {
            // 3. Atualizar no Firestore via Cloud Function
            try {
                val result = functionsService.updateOrderStatus(
                    orderId = orderId,
                    status = "accepted",
                    proposalDetails = null
                )
                result.onSuccess {
                    android.util.Log.d("ServiceRepository", "Proposta aceita com sucesso: $proposalId")
                }.onFailure { exception ->
                    android.util.Log.e("ServiceRepository", "Erro ao aceitar proposta: ${exception.message}", exception)
                    // Reverter mudan√ßa local em caso de erro
                    proposalDao.updateAccepted(proposalId, false)
                    throw exception
                }
            } catch (e: Exception) {
                android.util.Log.e("ServiceRepository", "Erro ao aceitar proposta: ${e.message}", e)
                // Reverter mudan√ßa local
                proposalDao.updateAccepted(proposalId, false)
                throw e
            }
        }
    }
    
    /**
     * Rejeita uma proposta
     */
    override suspend fun rejectProposal(proposalId: String) {
        // 1. Buscar proposta para obter orderId
        val proposal = proposalDao.getById(proposalId)?.toModel()
        val orderId = proposal?.orderId
        
        if (orderId != null) {
            // 2. Atualizar status da ordem para cancelled via Cloud Function
            try {
                val result = functionsService.updateOrderStatus(
                    orderId = orderId,
                    status = "cancelled",
                    proposalDetails = null
                )
                result.onSuccess {
                    android.util.Log.d("ServiceRepository", "Proposta rejeitada com sucesso: $proposalId")
                }.onFailure { exception ->
                    android.util.Log.e("ServiceRepository", "Erro ao rejeitar proposta: ${exception.message}", exception)
                    throw exception
                }
            } catch (e: Exception) {
                android.util.Log.e("ServiceRepository", "Erro ao rejeitar proposta: ${e.message}", e)
                throw e
            }
        }
    }
}
```

## [FRONTEND]: data/repository/TrackingRepositoryImpl.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.data.repository

import com.taskgoapp.taskgo.data.local.dao.TrackingDao
import com.taskgoapp.taskgo.data.mapper.TrackingMapper.toEntity
import com.taskgoapp.taskgo.data.mapper.TrackingMapper.toModel
import com.taskgoapp.taskgo.domain.repository.TrackingRepository
import com.taskgoapp.taskgo.core.model.TrackingEvent
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class TrackingRepositoryImpl @Inject constructor(
    private val trackingDao: TrackingDao
) : TrackingRepository {

    override fun observeTrackingEvents(orderId: String): Flow<List<TrackingEvent>> {
        return trackingDao.observeByOrderId(orderId).map { entities ->
            entities.map { it.toModel() }
        }
    }

    override suspend fun seedTimeline(orderId: String) {
        val defaultEvents = listOf(
            TrackingEvent("Pedido confirmado", System.currentTimeMillis(), false),
            TrackingEvent("Preparando pedido", System.currentTimeMillis() + 3600000, false),
            TrackingEvent("Saiu para entrega", System.currentTimeMillis() + 7200000, false),
            TrackingEvent("Entregue", System.currentTimeMillis() + 10800000, false)
        )
        defaultEvents.forEach { event ->
            trackingDao.upsert(event.toEntity(orderId))
        }
    }

    override suspend fun updateEventDone(eventId: String, done: Boolean) {
        trackingDao.updateDone(eventId, done)
    }

    private fun generateId(): String {
        return "track_${System.currentTimeMillis()}_${(1000..9999).random()}"
    }
}
```

## [FRONTEND]: data/repository/UserRepositoryImpl.kt

```kotlin
package com.taskgoapp.taskgo.data.repository

import com.taskgoapp.taskgo.data.local.dao.UserProfileDao
import com.taskgoapp.taskgo.data.mapper.UserMapper.toEntity
import com.taskgoapp.taskgo.data.mapper.UserMapper.toModel
import com.taskgoapp.taskgo.domain.repository.UserRepository
import com.taskgoapp.taskgo.core.model.UserProfile
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.flowOn
import kotlinx.coroutines.flow.onStart
import kotlinx.coroutines.flow.distinctUntilChanged
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.SupervisorJob
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class UserRepositoryImpl @Inject constructor(
    private val userProfileDao: UserProfileDao,
    private val firestoreUserRepository: FirestoreUserRepository,
    private val syncManager: com.taskgoapp.taskgo.core.sync.SyncManager,
    private val authRepository: FirebaseAuthRepository
) : UserRepository {
    
    // Scope para observa√ß√£o do Firestore em background
    private val firestoreObserverScope = CoroutineScope(SupervisorJob() + Dispatchers.IO)

    override fun observeCurrentUser(): Flow<UserProfile?> {
        val currentUser = authRepository.getCurrentUser()
        val userId = currentUser?.uid
        
        // CR√çTICO: Se n√£o houver usu√°rio autenticado, retornar Flow vazio
        if (userId == null) {
            return kotlinx.coroutines.flow.flowOf(null)
        }
        
        // CR√çTICO: Limpar dados de outros usu√°rios do banco local
        firestoreObserverScope.launch {
            try {
                userProfileDao.clearOtherUsers(userId)
            } catch (e: Exception) {
                android.util.Log.e("UserRepositoryImpl", "Erro ao limpar dados de outros usu√°rios: ${e.message}", e)
            }
        }
        
        return userProfileDao.observeCurrent(userId)
            .flowOn(Dispatchers.IO)
            .map { entity ->
                // CR√çTICO: Verificar se o entity pertence ao usu√°rio atual
                if (entity != null && entity.id != userId) {
                    android.util.Log.w("UserRepositoryImpl", "Entity n√£o pertence ao usu√°rio atual: ${entity.id} != $userId")
                    null
                } else {
                    entity?.toModel()
                }
            }
            .onStart {
                // Quando o Flow √© coletado, iniciar observa√ß√£o do Firestore em background
                if (userId != null) {
                    firestoreObserverScope.launch {
                        try {
                            // CR√çTICO: Buscar diretamente do Firestore, n√£o usar cache local
                            val firestoreUser = firestoreUserRepository.getUser(userId)
                            if (firestoreUser != null) {
                                val userProfile = with(com.taskgoapp.taskgo.data.mapper.UserMapper) { firestoreUser.toModel() }
                                // Verificar se o perfil pertence ao usu√°rio atual antes de salvar
                                if (userProfile.id == userId) {
                                    userProfileDao.upsert(userProfile.toEntity())
                                    // Limpar dados de outros usu√°rios
                                    userProfileDao.clearOtherUsers(userId)
                                } else {
                                    android.util.Log.w("UserRepositoryImpl", "Perfil do Firestore n√£o pertence ao usu√°rio atual: ${userProfile.id} != $userId")
                                }
                            }
                            
                            // Observar mudan√ßas do Firestore
                            firestoreUserRepository.observeUser(userId)
                                .collect { firestoreUser ->
                                    firestoreUser?.let { user ->
                                        // CR√çTICO: Verificar se o usu√°rio do Firestore pertence ao usu√°rio atual
                                        if (user.uid == userId) {
                                            android.util.Log.d("UserRepositoryImpl", "üîÑ Usu√°rio atualizado no Firestore: role=${user.role}, pendingAccountType=${user.pendingAccountType}")
                                            
                                            // Converter UserFirestore para UserProfile usando o m√©todo de extens√£o
                                            val userProfile = with(com.taskgoapp.taskgo.data.mapper.UserMapper) { user.toModel() }
                                            
                                            // CR√çTICO: Verificar se o role mudou antes de atualizar
                                            val existingProfile = userProfileDao.getCurrent(userId)
                                            // Converter accountType do Entity (String) para AccountType (enum) para compara√ß√£o
                                            val existingAccountType = existingProfile?.let {
                                                // Mapear String para AccountType de forma segura (suporta valores legacy)
                                                when (it.accountType.uppercase()) {
                                                    "PRESTADOR" -> com.taskgoapp.taskgo.core.model.AccountType.PARCEIRO // Legacy
                                                    "VENDEDOR" -> com.taskgoapp.taskgo.core.model.AccountType.PARCEIRO // Legacy
                                                    "PARCEIRO" -> com.taskgoapp.taskgo.core.model.AccountType.PARCEIRO
                                                    "CLIENTE" -> com.taskgoapp.taskgo.core.model.AccountType.CLIENTE
                                                    else -> com.taskgoapp.taskgo.core.model.AccountType.CLIENTE // Default seguro
                                                }
                                            }
                                            val roleChanged = existingAccountType != userProfile.accountType
                                            
                                            if (roleChanged) {
                                                android.util.Log.d("UserRepositoryImpl", "üîµ Role mudou: ${existingProfile?.accountType} -> ${userProfile.accountType}")
                                            }
                                            
                                            // Salvar no Room apenas se pertencer ao usu√°rio atual
                                            if (userProfile.id == userId) {
                                                userProfileDao.upsert(userProfile.toEntity())
                                                // Limpar dados de outros usu√°rios
                                                userProfileDao.clearOtherUsers(userId)
                                                android.util.Log.d("UserRepositoryImpl", "‚úÖ Perfil atualizado no banco local: role=${userProfile.accountType}")
                                            }
                                        } else {
                                            android.util.Log.w("UserRepositoryImpl", "Usu√°rio do Firestore n√£o pertence ao usu√°rio atual: ${user.uid} != $userId")
                                        }
                                    }
                                }
                        } catch (e: Exception) {
                            android.util.Log.e("UserRepositoryImpl", "Erro ao observar usu√°rio do Firestore: ${e.message}", e)
                        }
                    }
                }
            }
    }

    override suspend fun updateUser(user: UserProfile) {
        val currentUser = authRepository.getCurrentUser()
        val userId = currentUser?.uid
        
        // CR√çTICO: Verificar se o usu√°rio pertence ao usu√°rio autenticado
        if (userId == null || user.id != userId) {
            android.util.Log.w("UserRepositoryImpl", "Tentativa de atualizar perfil de outro usu√°rio: ${user.id} != $userId")
            return
        }
        
        // CR√çTICO: Salvar diretamente no Firestore, n√£o usar cache local
        try {
            val existingUser = firestoreUserRepository.getUser(user.id)
            val role = when (user.accountType) {
                com.taskgoapp.taskgo.core.model.AccountType.PARCEIRO -> "partner" // Novo role unificado
                com.taskgoapp.taskgo.core.model.AccountType.PRESTADOR -> "partner" // Legacy - migrar para partner
                com.taskgoapp.taskgo.core.model.AccountType.VENDEDOR -> "partner" // Legacy - migrar para partner
                com.taskgoapp.taskgo.core.model.AccountType.CLIENTE -> "client"
            }
            
            val userFirestore = existingUser?.copy(
                displayName = user.name,
                email = user.email,
                phone = user.phone,
                role = role,
                photoURL = user.avatarUri,
                updatedAt = java.util.Date()
            ) ?: com.taskgoapp.taskgo.data.firestore.models.UserFirestore(
                uid = user.id,
                email = user.email,
                displayName = user.name,
                phone = user.phone,
                role = role,
                photoURL = user.avatarUri,
                profileComplete = true,
                verified = false,
                createdAt = java.util.Date(),
                updatedAt = java.util.Date()
            )
            
            firestoreUserRepository.updateUser(userFirestore)
            
            // CR√çTICO: Atualizar banco local apenas ap√≥s sucesso no Firestore
            // E apenas se o usu√°rio pertencer ao usu√°rio atual
            if (user.id == userId) {
                userProfileDao.upsert(user.toEntity())
                // Limpar dados de outros usu√°rios
                userProfileDao.clearOtherUsers(userId)
            }
        } catch (e: Exception) {
            android.util.Log.e("UserRepositoryImpl", "Erro ao atualizar usu√°rio no Firestore: ${e.message}", e)
            // Se falhar, agendar sync para depois
            val userData = mapOf(
                "uid" to user.id,
                "displayName" to user.name,
                "email" to user.email,
                "phone" to user.phone,
                "city" to (user.city ?: ""),
                "profession" to (user.profession ?: ""),
                "role" to when (user.accountType) {
                    com.taskgoapp.taskgo.core.model.AccountType.PARCEIRO -> "partner" // Novo role unificado
                    com.taskgoapp.taskgo.core.model.AccountType.PRESTADOR -> "partner" // Legacy - migrar para partner
                    com.taskgoapp.taskgo.core.model.AccountType.VENDEDOR -> "partner" // Legacy - migrar para partner
                    com.taskgoapp.taskgo.core.model.AccountType.CLIENTE -> "client"
                },
                "photoURL" to (user.avatarUri ?: ""),
                "rating" to (user.rating ?: 0.0)
            )
            
            syncManager.scheduleSync(
                syncType = "user_profile",
                entityId = user.id,
                operation = "update",
                data = userData
            )
        }
    }

    override suspend fun updateAvatar(avatarUri: String) {
        val currentUser = authRepository.getCurrentUser()
        val userId = currentUser?.uid
        if (userId == null) {
            android.util.Log.w("UserRepositoryImpl", "Usu√°rio n√£o autenticado ao atualizar avatar")
            return
        }
        
        val current = userProfileDao.getCurrent(userId)
        if (current != null && current.id == userId) {
            // CR√çTICO: Atualizar diretamente no Firestore, n√£o usar cache local
            try {
                val existingUser = firestoreUserRepository.getUser(userId)
                if (existingUser != null) {
                    val updatedUser = existingUser.copy(photoURL = avatarUri, updatedAt = java.util.Date())
                    firestoreUserRepository.updateUser(updatedUser)
                }
            } catch (e: Exception) {
                android.util.Log.e("UserRepositoryImpl", "Erro ao atualizar avatar no Firestore: ${e.message}", e)
                // Se falhar, agendar sync
                val updateData = mapOf(
                    "photoURL" to avatarUri
                )
                syncManager.scheduleSync(
                    syncType = "user_profile",
                    entityId = userId,
                    operation = "update",
                    data = updateData
                )
            }
        }
    }
}
```

# Dependency Injection


## [FRONTEND]: di/AIModule.kt

```kotlin
package com.taskgoapp.taskgo.di

import android.content.Context
import com.taskgoapp.taskgo.core.ai.AudioRecorderManager
import com.taskgoapp.taskgo.core.ai.GoogleCloudAIService
import com.taskgoapp.taskgo.core.ai.GoogleSpeechToTextService
import com.taskgoapp.taskgo.core.ai.GoogleTranslationService
import com.taskgoapp.taskgo.core.ai.TextToSpeechManager
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Named
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object AIModule {
    
    // API Key do Google Cloud
    private const val GOOGLE_CLOUD_API_KEY = "REDACTED_GOOGLE_CLOUD_API_KEY"
    
    @Provides
    @Singleton
    @Named("GoogleCloudAPIKey")
    fun provideGoogleCloudAPIKey(): String {
        return GOOGLE_CLOUD_API_KEY
    }
    
    @Provides
    @Singleton
    fun provideGoogleCloudAIService(
        @Named("GoogleCloudAPIKey") apiKey: String
    ): GoogleCloudAIService {
        return GoogleCloudAIService(apiKey)
    }
    
    @Provides
    @Singleton
    fun provideGoogleTranslationService(
        @Named("GoogleCloudAPIKey") apiKey: String
    ): GoogleTranslationService {
        return GoogleTranslationService(apiKey)
    }
    
    @Provides
    @Singleton
    fun provideGoogleSpeechToTextService(
        @Named("GoogleCloudAPIKey") apiKey: String,
        @ApplicationContext context: Context
    ): GoogleSpeechToTextService {
        return GoogleSpeechToTextService(apiKey, context)
    }
    
    @Provides
    @Singleton
    fun provideAudioRecorderManager(
        @ApplicationContext context: Context
    ): AudioRecorderManager {
        return AudioRecorderManager(context)
    }
    
    @Provides
    @Singleton
    fun provideTextToSpeechManager(
        @ApplicationContext context: Context
    ): TextToSpeechManager {
        return TextToSpeechManager(context)
    }
}



```

## [FRONTEND]: di/AppModule.kt

```kotlin
package com.taskgoapp.taskgo.di

import com.taskgoapp.taskgo.BuildConfig
import com.taskgoapp.taskgo.data.repository.*
import com.taskgoapp.taskgo.data.local.datastore.PreferencesManager
import com.taskgoapp.taskgo.data.local.TaskGoDatabase
import com.taskgoapp.taskgo.data.local.dao.*
import com.taskgoapp.taskgo.domain.repository.*
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import dagger.hilt.android.qualifiers.ApplicationContext
import android.content.Context
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.database.FirebaseDatabase
import com.google.firebase.storage.FirebaseStorage
import com.google.gson.Gson
import com.google.gson.GsonBuilder
import com.taskgoapp.taskgo.core.sync.SyncManager
import androidx.hilt.work.HiltWorkerFactory
import androidx.work.Configuration
import com.taskgoapp.taskgo.core.sync.InitialDataSyncManager
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object AppModule {

    @Provides
    @Singleton
    fun provideTaskGoDatabase(@ApplicationContext context: Context): TaskGoDatabase {
        return TaskGoDatabase.getDatabase(context)
    }

    @Provides
    @Singleton
    fun provideProductDao(database: TaskGoDatabase): ProductDao {
        return database.productDao()
    }

    @Provides
    @Singleton
    fun provideCartDao(database: TaskGoDatabase): CartDao {
        return database.cartDao()
    }

    @Provides
    @Singleton
    fun provideUserProfileDao(database: TaskGoDatabase): UserProfileDao {
        return database.userProfileDao()
    }

    @Provides
    @Singleton
    fun providePurchaseOrderDao(database: TaskGoDatabase): PurchaseOrderDao {
        return database.purchaseOrderDao()
    }

    @Provides
    @Singleton
    fun provideServiceOrderDao(database: TaskGoDatabase): ServiceOrderDao {
        return database.serviceOrderDao()
    }

    @Provides
    @Singleton
    fun provideProposalDao(database: TaskGoDatabase): ProposalDao {
        return database.proposalDao()
    }

    @Provides
    @Singleton
    fun provideMessageDao(database: TaskGoDatabase): MessageDao {
        return database.messageDao()
    }

    @Provides
    @Singleton
    fun provideAddressDao(database: TaskGoDatabase): AddressDao {
        return database.addressDao()
    }

    @Provides
    @Singleton
    fun provideTrackingDao(database: TaskGoDatabase): TrackingDao {
        return database.trackingDao()
    }

    @Provides
    @Singleton
    fun provideProductsRepository(
        firestore: FirebaseFirestore,
        firebaseAuth: FirebaseAuth,
        productDao: ProductDao,
        cartDao: CartDao,
        syncManager: SyncManager,
        realtimeRepository: com.taskgoapp.taskgo.data.realtime.RealtimeDatabaseRepository,
        userRepository: UserRepository,
        locationStateManager: com.taskgoapp.taskgo.core.location.LocationStateManager
    ): ProductsRepository {
        return if (BuildConfig.USE_FIREBASE) {
            FirestoreProductsRepositoryImpl(
                firestore = firestore,
                firebaseAuth = firebaseAuth,
                cartDao = cartDao,
                userRepository = userRepository,
                locationStateManager = locationStateManager
            )
        } else {
            ProductsRepositoryImpl(productDao, cartDao)
        }
    }

    @Provides
    @Singleton
    fun provideFirebaseAuthRepository(
        firebaseAuth: FirebaseAuth
    ): FirebaseAuthRepository {
        return FirebaseAuthRepository(firebaseAuth)
    }

    @Provides
    @Singleton
    fun provideUserRepository(
        userProfileDao: UserProfileDao,
        firestoreUserRepository: FirestoreUserRepository,
        syncManager: SyncManager,
        authRepository: FirebaseAuthRepository
    ): UserRepository {
        return UserRepositoryImpl(userProfileDao, firestoreUserRepository, syncManager, authRepository)
    }

    @Provides
    @Singleton
    fun provideOrdersRepository(
        firestore: FirebaseFirestore,
        firebaseAuth: FirebaseAuth,
        purchaseOrderDao: PurchaseOrderDao,
        cartDao: CartDao,
        syncManager: SyncManager,
        realtimeRepository: com.taskgoapp.taskgo.data.realtime.RealtimeDatabaseRepository
    ): OrdersRepository {
        return if (BuildConfig.USE_FIREBASE) {
            FirestoreOrdersRepositoryImpl(firestore, firebaseAuth, cartDao, purchaseOrderDao, syncManager, realtimeRepository)
        } else {
            OrdersRepositoryImpl(purchaseOrderDao, cartDao)
        }
    }

    @Provides
    @Singleton
    fun provideFirestoreOrderRepository(
        firestore: FirebaseFirestore,
        authRepository: FirebaseAuthRepository,
        locationStateManager: com.taskgoapp.taskgo.core.location.LocationStateManager
    ): com.taskgoapp.taskgo.data.repository.FirestoreOrderRepository {
        return com.taskgoapp.taskgo.data.repository.FirestoreOrderRepository(firestore, authRepository, locationStateManager)
    }
    
    @Provides
    @Singleton
    fun provideServiceRepository(
        serviceOrderDao: ServiceOrderDao,
        proposalDao: ProposalDao,
        functionsService: com.taskgoapp.taskgo.data.firebase.FirebaseFunctionsService,
        orderRepository: com.taskgoapp.taskgo.data.repository.FirestoreOrderRepository
    ): ServiceRepository {
        return ServiceRepositoryImpl(serviceOrderDao, proposalDao, functionsService, orderRepository)
    }

    @Provides
    @Singleton
    fun provideMessageRepository(
        messageDao: MessageDao,
        database: FirebaseDatabase,
        firebaseAuth: FirebaseAuth
    ): com.taskgoapp.taskgo.domain.repository.MessageRepository {
        return com.taskgoapp.taskgo.data.repository.MessageRepositoryImpl(messageDao, database, firebaseAuth)
    }

    @Provides
    @Singleton
    fun provideAddressRepository(
        addressDao: AddressDao,
        firestore: FirebaseFirestore,
        syncManager: SyncManager,
        authRepository: FirebaseAuthRepository
    ): AddressRepository {
        return AddressRepositoryImpl(addressDao, firestore, syncManager, authRepository)
    }

    @Provides
    @Singleton
    fun provideCardDao(database: TaskGoDatabase): CardDao {
        return database.cardDao()
    }

    @Provides
    @Singleton
    fun provideCardRepository(
        cardDao: CardDao,
        firestore: FirebaseFirestore,
        syncManager: SyncManager,
        authRepository: FirebaseAuthRepository
    ): CardRepository {
        return CardRepositoryImpl(cardDao, firestore, syncManager, authRepository)
    }

    @Provides
    @Singleton
    fun provideFirestoreTrackingRepository(
        firestore: FirebaseFirestore
    ): FirestoreTrackingRepository {
        return FirestoreTrackingRepository(firestore)
    }
    
    @Provides
    @Singleton
    fun provideTrackingRepository(
        firestoreTrackingRepository: FirestoreTrackingRepository
    ): TrackingRepository {
        return FirestoreTrackingRepositoryAdapter(firestoreTrackingRepository)
    }

    @Provides
    @Singleton
    fun provideHomeBannersRepository(
        firestore: FirebaseFirestore
    ): HomeBannersRepository {
        return FirestoreHomeBannersRepository(firestore)
    }

    @Provides
    @Singleton
    fun providePreferencesManager(
        @ApplicationContext context: Context
    ): PreferencesManager {
        return PreferencesManager(context)
    }

    @Provides
    @Singleton
    fun providePreferencesRepository(
        preferencesManager: PreferencesManager
    ): PreferencesRepository {
        return object : PreferencesRepository {
            override fun observePromosEnabled(): kotlinx.coroutines.flow.Flow<Boolean> = 
                preferencesManager.promosEnabled
            override fun observeSoundEnabled(): kotlinx.coroutines.flow.Flow<Boolean> = 
                preferencesManager.soundEnabled
            override fun observePushEnabled(): kotlinx.coroutines.flow.Flow<Boolean> = 
                preferencesManager.pushEnabled
            override fun observeLockscreenEnabled(): kotlinx.coroutines.flow.Flow<Boolean> = 
                preferencesManager.lockscreenEnabled
            override fun observeEmailNotificationsEnabled(): kotlinx.coroutines.flow.Flow<Boolean> =
                preferencesManager.emailNotificationsEnabled
            override fun observeSmsNotificationsEnabled(): kotlinx.coroutines.flow.Flow<Boolean> =
                preferencesManager.smsNotificationsEnabled
            override fun observeLanguage(): kotlinx.coroutines.flow.Flow<String> = 
                preferencesManager.language
            override fun observeTheme(): kotlinx.coroutines.flow.Flow<String> = 
                preferencesManager.theme
            override fun observeCategories(): kotlinx.coroutines.flow.Flow<String> = 
                preferencesManager.categories
            override fun observePrivacyLocationSharing(): kotlinx.coroutines.flow.Flow<Boolean> =
                preferencesManager.privacyLocationSharing
            override fun observePrivacyProfileVisible(): kotlinx.coroutines.flow.Flow<Boolean> =
                preferencesManager.privacyProfileVisible
            override fun observePrivacyContactInfo(): kotlinx.coroutines.flow.Flow<Boolean> =
                preferencesManager.privacyContactInfo
            override fun observePrivacyAnalytics(): kotlinx.coroutines.flow.Flow<Boolean> =
                preferencesManager.privacyAnalytics
            override fun observePrivacyPersonalizedAds(): kotlinx.coroutines.flow.Flow<Boolean> =
                preferencesManager.privacyPersonalizedAds
            override fun observePrivacyDataCollection(): kotlinx.coroutines.flow.Flow<Boolean> =
                preferencesManager.privacyDataCollection
            override fun observePrivacyThirdPartySharing(): kotlinx.coroutines.flow.Flow<Boolean> =
                preferencesManager.privacyThirdPartySharing
            
            override suspend fun updatePromosEnabled(enabled: Boolean) {
                preferencesManager.updatePromosEnabled(enabled)
            }
            override suspend fun updateSoundEnabled(enabled: Boolean) {
                preferencesManager.updateSoundEnabled(enabled)
            }
            override suspend fun updatePushEnabled(enabled: Boolean) {
                preferencesManager.updatePushEnabled(enabled)
            }
            override suspend fun updateLockscreenEnabled(enabled: Boolean) {
                preferencesManager.updateLockscreenEnabled(enabled)
            }
            override suspend fun updateEmailNotificationsEnabled(enabled: Boolean) {
                preferencesManager.updateEmailNotificationsEnabled(enabled)
            }
            override suspend fun updateSmsNotificationsEnabled(enabled: Boolean) {
                preferencesManager.updateSmsNotificationsEnabled(enabled)
            }
            override suspend fun updateLanguage(language: String) {
                preferencesManager.updateLanguage(language)
            }
            override suspend fun updateTheme(theme: String) {
                preferencesManager.updateTheme(theme)
            }
            override suspend fun updateCategories(categories: String) {
                preferencesManager.updateCategories(categories)
            }
            override suspend fun updatePrivacyLocationSharing(enabled: Boolean) {
                preferencesManager.updatePrivacyLocationSharing(enabled)
            }
            override suspend fun updatePrivacyProfileVisible(enabled: Boolean) {
                preferencesManager.updatePrivacyProfileVisible(enabled)
            }
            override suspend fun updatePrivacyContactInfo(enabled: Boolean) {
                preferencesManager.updatePrivacyContactInfo(enabled)
            }
            override suspend fun updatePrivacyAnalytics(enabled: Boolean) {
                preferencesManager.updatePrivacyAnalytics(enabled)
            }
            override suspend fun updatePrivacyPersonalizedAds(enabled: Boolean) {
                preferencesManager.updatePrivacyPersonalizedAds(enabled)
            }
            override suspend fun updatePrivacyDataCollection(enabled: Boolean) {
                preferencesManager.updatePrivacyDataCollection(enabled)
            }
            override suspend fun updatePrivacyThirdPartySharing(enabled: Boolean) {
                preferencesManager.updatePrivacyThirdPartySharing(enabled)
            }
        }
    }
    
    @Provides
    @Singleton
    fun provideCategoriesRepository(
        firestore: FirebaseFirestore
    ): CategoriesRepository {
        return FirestoreCategoriesRepository(firestore)
    }

    @Provides
    @Singleton
    fun provideFilterPreferencesManager(
        @ApplicationContext context: Context
    ): com.taskgoapp.taskgo.data.local.datastore.FilterPreferencesManager {
        return com.taskgoapp.taskgo.data.local.datastore.FilterPreferencesManager(context)
    }

    @Provides
    @Singleton
    fun provideReviewsRepository(
        firestore: FirebaseFirestore
    ): com.taskgoapp.taskgo.domain.repository.ReviewsRepository {
        return com.taskgoapp.taskgo.data.repository.FirestoreReviewsRepository(firestore)
    }
    
    @Provides
    @Singleton
    fun provideProvidersRepository(
        firestore: FirebaseFirestore
    ): com.taskgoapp.taskgo.data.repository.FirestoreProvidersRepository {
        return com.taskgoapp.taskgo.data.repository.FirestoreProvidersRepository(firestore)
    }
    
    @Provides
    @Singleton
    fun provideMapLocationsRepository(
        firestore: FirebaseFirestore,
        geocodingService: com.taskgoapp.taskgo.core.location.GeocodingService
    ): com.taskgoapp.taskgo.data.repository.FirestoreMapLocationsRepository {
        return com.taskgoapp.taskgo.data.repository.FirestoreMapLocationsRepository(firestore, geocodingService)
    }
    
    @Provides
    @Singleton
    fun provideRealtimeDatabaseRepository(
        database: FirebaseDatabase
    ): com.taskgoapp.taskgo.data.realtime.RealtimeDatabaseRepository {
        return com.taskgoapp.taskgo.data.realtime.RealtimeDatabaseRepository(database)
    }
    
    @Provides
    @Singleton
    fun provideServicesRepository(
        firestore: FirebaseFirestore,
        realtimeRepository: com.taskgoapp.taskgo.data.realtime.RealtimeDatabaseRepository,
        authRepository: FirebaseAuthRepository,
        functionsService: com.taskgoapp.taskgo.data.firebase.FirebaseFunctionsService,
        locationStateManager: com.taskgoapp.taskgo.core.location.LocationStateManager
    ): com.taskgoapp.taskgo.data.repository.FirestoreServicesRepository {
        return com.taskgoapp.taskgo.data.repository.FirestoreServicesRepository(
            firestore = firestore,
            realtimeRepository = realtimeRepository,
            authRepository = authRepository,
            functionsService = functionsService,
            locationStateManager = locationStateManager
        )
    }
    
    @Provides
    @Singleton
    fun provideFirestoreProductsRepository(
        firestore: FirebaseFirestore,
        authRepository: FirebaseAuthRepository
    ): com.taskgoapp.taskgo.data.repository.FirestoreProductsRepository {
        return com.taskgoapp.taskgo.data.repository.FirestoreProductsRepository(
            firestore,
            authRepository
        )
    }
    
    @Provides
    @Singleton
    fun provideFeedRepository(
        firestore: FirebaseFirestore,
        authRepository: FirebaseAuthRepository,
        locationStateManager: com.taskgoapp.taskgo.core.location.LocationStateManager
    ): com.taskgoapp.taskgo.domain.repository.FeedRepository {
        return com.taskgoapp.taskgo.data.repository.FirestoreFeedRepository(firestore, authRepository, locationStateManager)
    }
    
    @Provides
    @Singleton
    fun provideStoriesRepository(
        firestore: FirebaseFirestore,
        authRepository: FirebaseAuthRepository,
        functionsService: com.taskgoapp.taskgo.data.firebase.FirebaseFunctionsService,
        userRepository: UserRepository,
        locationStateManager: com.taskgoapp.taskgo.core.location.LocationStateManager
    ): com.taskgoapp.taskgo.domain.repository.StoriesRepository {
        return com.taskgoapp.taskgo.data.repository.FirestoreStoriesRepository(firestore, authRepository, functionsService, userRepository, locationStateManager)
    }
    
    @Provides
    @Singleton
    fun provideFeedMediaRepository(
        storage: FirebaseStorage,
        authRepository: FirebaseAuthRepository,
        @ApplicationContext context: Context
    ): com.taskgoapp.taskgo.data.repository.FeedMediaRepository {
        return com.taskgoapp.taskgo.data.repository.FeedMediaRepository(storage, authRepository, context)
    }
    
    @Provides
    @Singleton
    fun provideDocumentVerificationManager(
        firestoreUserRepository: FirestoreUserRepository,
        auth: FirebaseAuth
    ): com.taskgoapp.taskgo.core.security.DocumentVerificationManager {
        return com.taskgoapp.taskgo.core.security.DocumentVerificationManager(firestoreUserRepository, auth)
    }
    
    @Provides
    @Singleton
    fun provideLGPDComplianceManager(
        @ApplicationContext context: Context,
        firestore: FirebaseFirestore
    ): com.taskgoapp.taskgo.core.security.LGPDComplianceManager {
        return com.taskgoapp.taskgo.core.security.LGPDComplianceManager(context, firestore)
    }
    
    @Provides
    @Singleton
    fun provideSyncQueueDao(database: TaskGoDatabase): SyncQueueDao {
        return database.syncQueueDao()
    }
    
    @Provides
    @Singleton
    fun provideGson(): Gson {
        return GsonBuilder()
            .setLenient()
            .create()
    }
    
    @Provides
    @Singleton
    fun provideInitialDataSyncManager(
        firebaseAuth: FirebaseAuth,
        productsRepository: ProductsRepository,
        ordersRepository: OrdersRepository,
        addressRepository: AddressRepository,
        cardRepository: CardRepository,
        userRepository: UserRepository,
        firestoreUserRepository: FirestoreUserRepository,
        productDao: ProductDao,
        purchaseOrderDao: PurchaseOrderDao,
        addressDao: AddressDao,
        cardDao: CardDao,
        userProfileDao: UserProfileDao
    ): InitialDataSyncManager {
        return InitialDataSyncManager(
            firebaseAuth,
            productsRepository,
            ordersRepository,
            addressRepository,
            cardRepository,
            userRepository,
            firestoreUserRepository,
            productDao,
            purchaseOrderDao,
            addressDao,
            cardDao,
            userProfileDao
        )
    }
    
    @Provides
    @Singleton
    fun provideSyncManager(
        syncQueueDao: SyncQueueDao,
        firestore: FirebaseFirestore,
        gson: Gson
    ): SyncManager {
        val manager = SyncManager(syncQueueDao, firestore, gson)
        manager.startSync() // Inicia sincroniza√ß√£o automaticamente
        return manager
    }

}

```

## [FRONTEND]: di/AuthTokenProvider.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.di

interface AuthTokenProvider {
    fun getToken(): String?
}

class DefaultAuthTokenProvider : AuthTokenProvider {
    override fun getToken(): String? = null
}



```

## [FRONTEND]: di/BillingModule.kt

```kotlin
package com.taskgoapp.taskgo.di

import android.content.Context
import com.taskgoapp.taskgo.core.billing.BillingManager
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object BillingModule {

    @Provides
    @Singleton
    fun provideBillingManager(@ApplicationContext context: Context): BillingManager {
        return BillingManager(context)
    }
}



```

## [FRONTEND]: di/BiometricModule.kt

```kotlin
package com.taskgoapp.taskgo.di

import android.content.Context
import androidx.biometric.BiometricManager
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object BiometricModule {

    @Provides
    @Singleton
    fun provideBiometricManager(@ApplicationContext context: Context): BiometricManager {
        return BiometricManager.from(context)
    }
}



```

## [FRONTEND]: di/FirebaseModule.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.di

import com.taskgoapp.taskgo.BuildConfig
import com.google.firebase.FirebaseApp
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.functions.FirebaseFunctions
import com.google.firebase.storage.FirebaseStorage
import com.google.firebase.messaging.FirebaseMessaging
import com.google.firebase.database.FirebaseDatabase
import com.taskgoapp.taskgo.core.firebase.FirestoreHelper
import com.taskgoapp.taskgo.core.location.LocationStateManager
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object FirebaseModule {

    @Provides
    @Singleton
    fun provideFirebaseAuth(): FirebaseAuth {
        return if (BuildConfig.USE_EMULATOR) {
            // Emulator configuration
            FirebaseAuth.getInstance().apply {
                useEmulator("10.0.2.2", 9099)
            }
        } else {
            FirebaseAuth.getInstance()
        }
    }

    @Provides
    @Singleton
    fun provideFirebaseFirestore(): FirebaseFirestore {
        val firestore = if (BuildConfig.USE_EMULATOR) {
            // Emulator configuration
            FirebaseFirestore.getInstance().apply {
                useEmulator("10.0.2.2", 8080)
            }
        } else {
            // Production Firestore - usar database padrao '(default)'
            FirestoreHelper.getInstance()
        }
        
        // Configurar para melhor performance - cache offline e leitura r√°pida
        try {
            val settings = com.google.firebase.firestore.FirebaseFirestoreSettings.Builder()
                .setPersistenceEnabled(true) // Habilitar cache offline
                .setCacheSizeBytes(com.google.firebase.firestore.FirebaseFirestoreSettings.CACHE_SIZE_UNLIMITED) // Cache ilimitado
                .build()
            firestore.firestoreSettings = settings
        } catch (e: Exception) {
            // Se j√° foi configurado, ignora o erro
            android.util.Log.w("FirebaseModule", "Firestore settings j√° configurados: ${e.message}")
        }
        
        return firestore
    }

    @Provides
    @Singleton
    fun provideFirebaseFunctions(): FirebaseFunctions {
        return if (BuildConfig.USE_EMULATOR) {
            // Emulator configuration
            FirebaseFunctions.getInstance().apply {
                useEmulator("10.0.2.2", 5001)
            }
        } else {
            FirebaseFunctions.getInstance(
                FirebaseApp.getInstance(),
                BuildConfig.FIREBASE_FUNCTIONS_REGION
            )
        }
    }

    @Provides
    @Singleton
    fun provideFirebaseStorage(): FirebaseStorage {
        return if (BuildConfig.USE_EMULATOR) {
            // Emulator configuration
            FirebaseStorage.getInstance().apply {
                useEmulator("10.0.2.2", 9199)
            }
        } else {
            FirebaseStorage.getInstance()
        }
    }

    @Provides
    @Singleton
    fun provideFirebaseMessaging(): FirebaseMessaging {
        return FirebaseMessaging.getInstance()
    }

    @Provides
    @Singleton
    fun provideFirebaseDatabase(): FirebaseDatabase {
        val database = if (BuildConfig.USE_EMULATOR) {
            // Emulator configuration
            FirebaseDatabase.getInstance().apply {
                useEmulator("10.0.2.2", 9000)
            }
        } else {
            // Production - URL do Realtime Database
            FirebaseDatabase.getInstance("https://task-go-ee85f-default-rtdb.firebaseio.com/")
        }
        
        // Habilitar persist√™ncia offline
        database.setPersistenceEnabled(true)
        
        return database
    }
    
    @Provides
    @Singleton
    fun provideLocationStateManager(
        userRepository: com.taskgoapp.taskgo.domain.repository.UserRepository
    ): LocationStateManager {
        return LocationStateManager(userRepository)
    }
}






```

## [FRONTEND]: di/NetworkModule.kt

```kotlin
package com.taskgoapp.taskgo.di

import com.taskgoapp.taskgo.BuildConfig
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import dagger.hilt.android.qualifiers.ApplicationContext
import android.content.Context
import okhttp3.Interceptor
import okhttp3.OkHttpClient
import okhttp3.logging.HttpLoggingInterceptor
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object NetworkModule {

    @Provides
    @Singleton
    fun provideAuthTokenProvider(@ApplicationContext context: Context): AuthTokenProvider = object: AuthTokenProvider {
        override fun getToken(): String? {
            val prefs = context.getSharedPreferences("taskgo_prefs", Context.MODE_PRIVATE)
            return prefs.getString("auth_token", null)
        }
    }

    @Provides
    @Singleton
    fun provideAuthInterceptor(tokenProvider: AuthTokenProvider): Interceptor {
        return Interceptor { chain ->
            val token = tokenProvider.getToken().orEmpty()
            val req = if (token.isNotBlank()) {
                chain.request().newBuilder()
                    .addHeader("Authorization", "Bearer $token")
                    .build()
            } else chain.request()
            chain.proceed(req)
        }
    }

    @Provides
    @Singleton
    fun provideOkHttp(authInterceptor: Interceptor): OkHttpClient {
        val logging = HttpLoggingInterceptor().apply { level = HttpLoggingInterceptor.Level.BODY }
        return OkHttpClient.Builder()
            .addInterceptor(authInterceptor)
            .addInterceptor(logging)
            .build()
        }

    @Provides
    @Singleton
    fun provideRetrofit(client: OkHttpClient): Retrofit {
        return Retrofit.Builder()
            .baseUrl(BuildConfig.API_BASE_URL)
            .addConverterFactory(GsonConverterFactory.create())
            .client(client)
            .build()
    }
}



```

## [FRONTEND]: di/NotificationModule.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.di

import android.content.Context
import com.taskgoapp.taskgo.core.notifications.NotificationManager
import com.taskgoapp.taskgo.core.work.WorkManagerHelper
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object NotificationModule {

    @Provides
    @Singleton
    fun provideNotificationManager(@ApplicationContext context: Context): NotificationManager {
        return NotificationManager(context)
    }

    @Provides
    @Singleton
    fun provideWorkManagerHelper(@ApplicationContext context: Context): WorkManagerHelper {
        return WorkManagerHelper(context)
    }
}

```

## [FRONTEND]: di/PaymentModule.kt

```kotlin
package com.taskgoapp.taskgo.di

import android.content.Context
import com.taskgoapp.taskgo.core.payment.GooglePayManager
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object PaymentModule {

    @Provides
    @Singleton
    fun provideGooglePayManager(@ApplicationContext context: Context): GooglePayManager {
        return GooglePayManager(context)
    }
    
    @Provides
    @Singleton
    fun provideContext(@ApplicationContext context: Context): Context {
        return context
    }
}


```

## [FRONTEND]: di/PermissionModule.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.di

import android.content.Context
import com.taskgoapp.taskgo.core.location.LocationManager
import com.taskgoapp.taskgo.core.permissions.PermissionManager
import com.taskgoapp.taskgo.core.photo.PhotoPickerManager
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object PermissionModule {

    @Provides
    @Singleton
    fun providePermissionManager(@ApplicationContext context: Context): PermissionManager {
        return PermissionManager(context)
    }

    @Provides
    @Singleton
    fun providePhotoPickerManager(@ApplicationContext context: Context): PhotoPickerManager {
        return PhotoPickerManager(context)
    }
    
    @Provides
    @Singleton
    fun provideLocationManager(@ApplicationContext context: Context): LocationManager {
        return LocationManager(context)
    }
}

```

## [FRONTEND]: di/ValidationModule.kt

```kotlin
package com.taskgoapp.taskgo.di

import com.taskgoapp.taskgo.core.validation.CepService
import com.taskgoapp.taskgo.core.validation.DocumentValidator
import com.taskgoapp.taskgo.core.validation.GovernmentDocumentValidator
import com.taskgoapp.taskgo.core.location.GeocodingService
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object ValidationModule {

    @Provides
    @Singleton
    fun provideCepService(): CepService {
        return CepService()
    }

    @Provides
    @Singleton
    fun provideDocumentValidator(): DocumentValidator {
        return DocumentValidator()
    }
    
    @Provides
    @Singleton
    fun provideGovernmentDocumentValidator(): GovernmentDocumentValidator {
        return GovernmentDocumentValidator()
    }
    
    // GeocodingService usa @Inject constructor, n√£o precisa de provider
}


```

# Domain Layer


## [FRONTEND]: domain/repository/CategoriesRepository.kt

```kotlin
package com.taskgoapp.taskgo.domain.repository

import com.taskgoapp.taskgo.core.data.models.ServiceCategory
import kotlinx.coroutines.flow.Flow

interface CategoriesRepository {
    fun observeProductCategories(): Flow<List<String>>
    fun observeServiceCategories(): Flow<List<ServiceCategory>>
    suspend fun getProductCategories(): List<String>
    suspend fun getServiceCategories(): List<ServiceCategory>
}


```

## [FRONTEND]: domain/repository/FeedRepository.kt

```kotlin
package com.taskgoapp.taskgo.domain.repository

import com.taskgoapp.taskgo.core.model.Post
import com.taskgoapp.taskgo.core.model.PostLocation
import com.taskgoapp.taskgo.core.model.Result
import kotlinx.coroutines.flow.Flow

/**
 * Repository para opera√ß√µes do Feed
 */
interface FeedRepository {
    
    /**
     * Observa posts do feed filtrados por regi√£o (raio em km)
     */
    fun observeFeedPosts(
        userLatitude: Double,
        userLongitude: Double,
        radiusKm: Double
    ): Flow<List<Post>>
    
    /**
     * Observa posts de um usu√°rio espec√≠fico
     */
    fun observeUserPosts(userId: String): Flow<List<Post>>
    
    /**
     * Obt√©m um post espec√≠fico por ID
     */
    suspend fun getPostById(postId: String): Post?
    
    /**
     * Cria um novo post
     */
    suspend fun createPost(
        text: String,
        mediaUrls: List<String>,
        mediaTypes: List<String>,
        location: PostLocation
    ): Result<String>
    
    /**
     * Adiciona like em um post
     */
    suspend fun likePost(postId: String, userId: String): Result<Unit>
    
    /**
     * Remove like de um post
     */
    suspend fun unlikePost(postId: String, userId: String): Result<Unit>
    
    /**
     * Deleta um post (apenas pelo autor)
     */
    suspend fun deletePost(postId: String): Result<Unit>
    
    /**
     * Observa coment√°rios de um post
     */
    fun observePostComments(postId: String): Flow<List<com.taskgoapp.taskgo.feature.feed.presentation.components.CommentItem>>
    
    /**
     * Cria um novo coment√°rio em um post
     */
    suspend fun createComment(postId: String, text: String): Result<String>
    
    /**
     * Deleta um coment√°rio (apenas pelo autor)
     */
    suspend fun deleteComment(postId: String, commentId: String): Result<Unit>
    
    /**
     * Registra interesse em um post (Tenho interesse / N√£o tenho interesse)
     */
    suspend fun setPostInterest(postId: String, isInterested: Boolean): Result<Unit>
    
    /**
     * Remove interesse de um post
     */
    suspend fun removePostInterest(postId: String): Result<Unit>
    
    /**
     * Verifica se o usu√°rio tem interesse em um post
     */
    suspend fun getPostInterest(postId: String): Boolean?
    
    /**
     * Avalia um post (1-5 estrelas)
     */
    suspend fun ratePost(postId: String, rating: Int, comment: String?): Result<String>
    
    /**
     * Obt√©m avalia√ß√£o do usu√°rio atual para um post
     */
    suspend fun getUserPostRating(postId: String): com.taskgoapp.taskgo.core.model.PostRating?
    
    /**
     * Bloqueia um usu√°rio
     */
    suspend fun blockUser(userId: String): Result<Unit>
    
    /**
     * Desbloqueia um usu√°rio
     */
    suspend fun unblockUser(userId: String): Result<Unit>
    
    /**
     * Verifica se um usu√°rio est√° bloqueado
     */
    suspend fun isUserBlocked(userId: String): Boolean
    
    /**
     * Obt√©m lista de usu√°rios bloqueados
     */
    fun observeBlockedUsers(): Flow<List<com.taskgoapp.taskgo.core.model.BlockedUser>>
}

```

## [FRONTEND]: domain/repository/HomeBannersRepository.kt

```kotlin
package com.taskgoapp.taskgo.domain.repository

import com.taskgoapp.taskgo.core.model.HomeBanner
import kotlinx.coroutines.flow.Flow

interface HomeBannersRepository {
    fun observeHomeBanners(): Flow<List<HomeBanner>>
}


```

## [FRONTEND]: domain/repository/OrderRepository.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.domain.repository

import com.taskgoapp.taskgo.core.model.Order
import kotlinx.coroutines.flow.Flow

interface OrderRepository {
    fun observeOrders(): Flow<List<Order>>
}





```

## [FRONTEND]: domain/repository/Repositories.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.domain.repository

import com.taskgoapp.taskgo.core.model.*
import kotlinx.coroutines.flow.Flow

interface ProductsRepository {
    fun observeProducts(): Flow<List<Product>>
    fun observeProductErrors(): Flow<String>
    suspend fun getProduct(id: String): Product?
    suspend fun getMyProducts(): List<Product>
    suspend fun upsertProduct(product: Product)
    suspend fun deleteProduct(id: String)
    suspend fun addToCart(productId: String, qtyDelta: Int)
    suspend fun removeFromCart(productId: String)
    fun observeCart(): Flow<List<CartItem>>
    suspend fun clearCart()
}

interface ServiceRepository {
    fun observeServiceOrders(): Flow<List<ServiceOrder>>
    suspend fun getServiceOrder(id: String): ServiceOrder?
    suspend fun upsertServiceOrder(order: ServiceOrder)
    suspend fun deleteServiceOrder(id: String)
    fun observeProposals(orderId: String): Flow<List<Proposal>>
    suspend fun getProposal(id: String): Proposal?
    suspend fun upsertProposal(proposal: Proposal)
    suspend fun acceptProposal(proposalId: String)
    suspend fun rejectProposal(proposalId: String)
}

interface OrdersRepository {
    fun observeOrders(): Flow<List<PurchaseOrder>>
    fun observeOrdersByStatus(status: OrderStatus): Flow<List<PurchaseOrder>>
    suspend fun getOrder(id: String): PurchaseOrder?
    suspend fun createOrder(cart: List<CartItem>, total: Double, paymentMethod: String, addressId: String): String
    suspend fun updateOrderStatus(orderId: String, status: OrderStatus)
}

interface TrackingRepository {
    fun observeTrackingEvents(orderId: String): Flow<List<TrackingEvent>>
    suspend fun seedTimeline(orderId: String)
    suspend fun updateEventDone(eventId: String, done: Boolean)
}

interface MessageRepository {
    fun observeThreads(): Flow<List<MessageThread>>
    suspend fun getThread(id: String): MessageThread?
    fun observeMessages(threadId: String): Flow<List<ChatMessage>>
    suspend fun sendMessage(threadId: String, text: String)
    suspend fun createThread(title: String): String
}

interface AddressRepository {
    fun observeAddresses(): Flow<List<Address>>
    suspend fun getAddress(id: String): Address?
    suspend fun upsertAddress(address: Address)
    suspend fun deleteAddress(id: String)
}

interface CardRepository {
    fun observeCards(): Flow<List<Card>>
    suspend fun getCard(id: String): Card?
    suspend fun upsertCard(card: Card)
    suspend fun deleteCard(id: String)
}

interface UserRepository {
    fun observeCurrentUser(): Flow<UserProfile?>
    suspend fun updateUser(user: UserProfile)
    suspend fun updateAvatar(avatarUri: String)
}

interface NotificationRepository {
    fun observeNotifications(): Flow<List<NotificationItem>>
    suspend fun markAsRead(notificationId: String)
    suspend fun createNotification(type: NotificationType, title: String, message: String, actionRoute: String? = null)
}

interface PreferencesRepository {
    fun observePromosEnabled(): Flow<Boolean>
    fun observeSoundEnabled(): Flow<Boolean>
    fun observePushEnabled(): Flow<Boolean>
    fun observeLockscreenEnabled(): Flow<Boolean>
    fun observeEmailNotificationsEnabled(): Flow<Boolean>
    fun observeSmsNotificationsEnabled(): Flow<Boolean>
    fun observeLanguage(): Flow<String>
    fun observeTheme(): Flow<String>
    fun observeCategories(): Flow<String>
    fun observePrivacyLocationSharing(): Flow<Boolean>
    fun observePrivacyProfileVisible(): Flow<Boolean>
    fun observePrivacyContactInfo(): Flow<Boolean>
    fun observePrivacyAnalytics(): Flow<Boolean>
    fun observePrivacyPersonalizedAds(): Flow<Boolean>
    fun observePrivacyDataCollection(): Flow<Boolean>
    fun observePrivacyThirdPartySharing(): Flow<Boolean>
    
    suspend fun updatePromosEnabled(enabled: Boolean)
    suspend fun updateSoundEnabled(enabled: Boolean)
    suspend fun updatePushEnabled(enabled: Boolean)
    suspend fun updateLockscreenEnabled(enabled: Boolean)
    suspend fun updateEmailNotificationsEnabled(enabled: Boolean)
    suspend fun updateSmsNotificationsEnabled(enabled: Boolean)
    suspend fun updateLanguage(language: String)
    suspend fun updateTheme(theme: String)
    suspend fun updateCategories(categories: String)
    suspend fun updatePrivacyLocationSharing(enabled: Boolean)
    suspend fun updatePrivacyProfileVisible(enabled: Boolean)
    suspend fun updatePrivacyContactInfo(enabled: Boolean)
    suspend fun updatePrivacyAnalytics(enabled: Boolean)
    suspend fun updatePrivacyPersonalizedAds(enabled: Boolean)
    suspend fun updatePrivacyDataCollection(enabled: Boolean)
    suspend fun updatePrivacyThirdPartySharing(enabled: Boolean)
}

```

## [FRONTEND]: domain/repository/ReviewsRepository.kt

```kotlin
package com.taskgoapp.taskgo.domain.repository

import com.taskgoapp.taskgo.core.model.Review
import com.taskgoapp.taskgo.core.model.ReviewSummary
import com.taskgoapp.taskgo.core.model.ReviewType
import com.taskgoapp.taskgo.core.model.Result
import kotlinx.coroutines.flow.Flow

interface ReviewsRepository {
    fun observeReviews(targetId: String, type: ReviewType): Flow<List<Review>>
    suspend fun getReview(reviewId: String): Review?
    suspend fun createReview(review: Review): Result<String>
    suspend fun updateReview(reviewId: String, rating: Int?, comment: String?, photoUrls: List<String>?): Result<Unit>
    suspend fun deleteReview(reviewId: String): Result<Unit>
    suspend fun getReviewSummary(targetId: String, type: ReviewType): ReviewSummary
    suspend fun markReviewAsHelpful(reviewId: String): Result<Unit>
    suspend fun canUserReview(targetId: String, type: ReviewType, userId: String): Boolean
    
    // M√©todos para avalia√ß√µes do usu√°rio
    fun observeUserReviewsAsReviewer(userId: String): Flow<List<Review>> // Avalia√ß√µes que o usu√°rio fez
    fun observeUserReviewsAsTarget(userId: String): Flow<List<Review>> // Avalia√ß√µes sobre o usu√°rio (quando √© prestador/vendedor)
    suspend fun getUserReviewSummaryAsTarget(userId: String): ReviewSummary // Resumo das avalia√ß√µes sobre o usu√°rio
}


```

## [FRONTEND]: domain/repository/StoriesRepository.kt

```kotlin
package com.taskgoapp.taskgo.domain.repository

import com.taskgoapp.taskgo.core.model.Story
import com.taskgoapp.taskgo.core.model.Result
import com.taskgoapp.taskgo.core.model.StoryAnalytics
import kotlinx.coroutines.flow.Flow

/**
 * Reposit√≥rio para gerenciar Stories
 */
interface StoriesRepository {
    
    /**
     * Observa stories de usu√°rios seguidos/pr√≥ximos (para o feed)
     * Retorna apenas stories n√£o expiradas (menos de 24 horas)
     */
    fun observeStories(
        currentUserId: String,
        radiusKm: Double = 50.0,
        userLocation: Pair<Double, Double>? = null // latitude, longitude
    ): Flow<List<Story>>
    
    /**
     * Observa stories de um usu√°rio espec√≠fico
     */
    fun observeUserStories(userId: String, currentUserId: String): Flow<List<Story>>
    
    /**
     * Cria uma nova story
     */
    suspend fun createStory(story: Story): Result<String>
    
    /**
     * Marca uma story como visualizada
     */
    suspend fun markStoryAsViewed(storyId: String, userId: String): Result<Unit>
    
    /**
     * Deleta uma story
     */
    suspend fun deleteStory(storyId: String, userId: String): Result<Unit>
    
    /**
     * Busca stories de usu√°rios pr√≥ximos (dentro de um raio)
     */
    suspend fun getStoriesNearby(
        currentUserId: String,
        latitude: Double,
        longitude: Double,
        radiusKm: Double = 50.0
    ): Result<List<Story>>
    
    /**
     * Obt√©m analytics de uma story (visualiza√ß√µes, m√©tricas, etc.)
     * Apenas o dono da story pode ver os analytics
     */
    fun observeStoryAnalytics(storyId: String, ownerUserId: String): Flow<StoryAnalytics>
    
    /**
     * Registra uma a√ß√£o do usu√°rio na story (navega√ß√£o para perfil, voltar, swipe up)
     */
    suspend fun trackStoryAction(
        storyId: String,
        userId: String,
        action: String, // "navigation", "back", "swipe_up"
        metadata: Map<String, Any>? = null
    ): Result<Unit>
}


```

## [FRONTEND]: domain/usecase/CheckoutUseCase.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.domain.usecase

import com.taskgoapp.taskgo.core.model.CartItem
import com.taskgoapp.taskgo.core.work.WorkManagerHelper
import com.taskgoapp.taskgo.domain.repository.OrdersRepository
import com.taskgoapp.taskgo.domain.repository.ProductsRepository
import com.taskgoapp.taskgo.domain.repository.TrackingRepository
import kotlinx.coroutines.flow.first
import javax.inject.Inject

class CheckoutUseCase @Inject constructor(
    private val productsRepository: ProductsRepository,
    private val ordersRepository: OrdersRepository,
    private val trackingRepository: TrackingRepository,
    private val workManagerHelper: WorkManagerHelper
) {
    
    suspend operator fun invoke(
        paymentMethod: String,
        addressId: String
    ): Result<String> {
        return try {
            // Get current cart
            val cart = productsRepository.observeCart().first()
            if (cart.isEmpty()) {
                return Result.failure(Exception("Carrinho vazio"))
            }
            
            // Calculate total
            val total = calculateTotal(cart)
            
            // Create order
            val orderId = ordersRepository.createOrder(cart, total, paymentMethod, addressId)
            
            // Seed tracking timeline
            trackingRepository.seedTimeline(orderId)
            
            // Schedule order tracking notifications
            workManagerHelper.scheduleOrderTracking(orderId)
            
            Result.success(orderId)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    private suspend fun calculateTotal(cart: List<CartItem>): Double {
        var total = 0.0
        for (item in cart) {
            val product = productsRepository.getProduct(item.productId)
            if (product != null) {
                total += product.price * item.qty
            }
        }
        return total
    }
    
    suspend fun getOrderSummary(cart: List<CartItem>): OrderSummary {
        val subtotal = calculateTotal(cart)
        val shipping = if (subtotal > 100.0) 0.0 else 15.0 // Free shipping over R$ 100
        val total = subtotal + shipping
        
        return OrderSummary(
            subtotal = subtotal,
            shipping = shipping,
            total = total,
            itemCount = cart.sumOf { it.qty }
        )
    }
}

data class OrderSummary(
    val subtotal: Double,
    val shipping: Double,
    val total: Double,
    val itemCount: Int
)

```

## [FRONTEND]: domain/usecase/FeedUseCase.kt

```kotlin
package com.taskgoapp.taskgo.domain.usecase

import com.taskgoapp.taskgo.core.model.Post
import com.taskgoapp.taskgo.core.model.PostLocation
import com.taskgoapp.taskgo.core.model.Result
import com.taskgoapp.taskgo.domain.repository.FeedRepository
import kotlinx.coroutines.flow.Flow
import javax.inject.Inject

/**
 * Use cases para opera√ß√µes do Feed
 */
class CreatePostUseCase @Inject constructor(
    private val feedRepository: FeedRepository
) {
    suspend operator fun invoke(
        text: String,
        mediaUrls: List<String>,
        mediaTypes: List<String>,
        location: PostLocation
    ): Result<String> {
        return feedRepository.createPost(text, mediaUrls, mediaTypes, location)
    }
}

class GetFeedPostsUseCase @Inject constructor(
    private val feedRepository: FeedRepository
) {
    operator fun invoke(
        userLatitude: Double,
        userLongitude: Double,
        radiusKm: Double
    ): Flow<List<Post>> {
        return feedRepository.observeFeedPosts(userLatitude, userLongitude, radiusKm)
    }
}

class GetUserPostsUseCase @Inject constructor(
    private val feedRepository: FeedRepository
) {
    operator fun invoke(userId: String): Flow<List<Post>> {
        return feedRepository.observeUserPosts(userId)
    }
}

class LikePostUseCase @Inject constructor(
    private val feedRepository: FeedRepository
) {
    suspend operator fun invoke(postId: String, userId: String): Result<Unit> {
        return feedRepository.likePost(postId, userId)
    }
}

class UnlikePostUseCase @Inject constructor(
    private val feedRepository: FeedRepository
) {
    suspend operator fun invoke(postId: String, userId: String): Result<Unit> {
        return feedRepository.unlikePost(postId, userId)
    }
}

class DeletePostUseCase @Inject constructor(
    private val feedRepository: FeedRepository
) {
    suspend operator fun invoke(postId: String): Result<Unit> {
        return feedRepository.deletePost(postId)
    }
}

```

## [FRONTEND]: domain/usecase/PlaceOrderUseCase.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.domain.usecase

import com.taskgoapp.taskgo.domain.repository.OrdersRepository
import com.taskgoapp.taskgo.domain.repository.ProductsRepository
import com.taskgoapp.taskgo.domain.repository.TrackingRepository
import kotlinx.coroutines.flow.first
import javax.inject.Inject

class PlaceOrderUseCase @Inject constructor(
    private val productsRepo: ProductsRepository,
    private val ordersRepo: OrdersRepository,
    private val trackingRepo: TrackingRepository
) {
    suspend operator fun invoke(paymentMethod: String, addressId: String): String {
        val cart = productsRepo.observeCart().first()
        require(cart.isNotEmpty()) { "Carrinho vazio" }
        
        val total = cart.sumOf { item ->
            val product = productsRepo.getProduct(item.productId)
            (product?.price ?: 0.0) * item.qty
        }
        
        val orderId = ordersRepo.createOrder(cart, total, paymentMethod, addressId)
        trackingRepo.seedTimeline(orderId)
        
        return orderId
    }
}

```

## [FRONTEND]: domain/usecase/ProposalUseCase.kt

```kotlin
package com.taskgoapp.taskgo.domain.usecase

import com.taskgoapp.taskgo.data.firebase.FirebaseFunctionsService
import com.taskgoapp.taskgo.data.repository.FirestoreOrderRepository
import kotlinx.coroutines.flow.Flow
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class ProposalUseCase @Inject constructor(
    private val functionsService: FirebaseFunctionsService,
    private val orderRepository: FirestoreOrderRepository
) {
    /**
     * Aceita uma proposta de servi√ßo
     * Atualiza o status da ordem para "accepted"
     */
    suspend fun acceptProposal(orderId: String): Result<Unit> {
        return try {
            val result = functionsService.updateOrderStatus(
                orderId = orderId,
                status = "accepted",
                proposalDetails = null
            )
            result.map { Unit }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    /**
     * Rejeita uma proposta de servi√ßo
     * Atualiza o status da ordem para "cancelled"
     */
    suspend fun rejectProposal(orderId: String): Result<Unit> {
        return try {
            val result = functionsService.updateOrderStatus(
                orderId = orderId,
                status = "cancelled",
                proposalDetails = null
            )
            result.map { Unit }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}


```

## [FRONTEND]: domain/usecase/SettingsUseCase.kt

```kotlin
package com.taskgoapp.taskgo.domain.usecase

import android.util.Log
import com.google.gson.Gson
import com.taskgoapp.taskgo.data.firebase.FirebaseFunctionsService
import com.taskgoapp.taskgo.domain.repository.PreferencesRepository
import com.taskgoapp.taskgo.domain.repository.UserRepository
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.combine
import javax.inject.Inject

class SettingsUseCase @Inject constructor(
    private val preferencesRepository: PreferencesRepository,
    private val userRepository: UserRepository,
    private val firebaseFunctionsService: FirebaseFunctionsService,
    private val firestoreUserRepository: com.taskgoapp.taskgo.data.repository.FirestoreUserRepository,
    private val auth: com.google.firebase.auth.FirebaseAuth
) {
    
    fun observeSettings(): Flow<SettingsState> {
        return combine(
            preferencesRepository.observePromosEnabled(),
            preferencesRepository.observeSoundEnabled(),
            preferencesRepository.observePushEnabled(),
            preferencesRepository.observeLockscreenEnabled(),
            preferencesRepository.observeEmailNotificationsEnabled(),
            preferencesRepository.observeSmsNotificationsEnabled(),
            preferencesRepository.observeLanguage(),
            preferencesRepository.observeTheme(),
            preferencesRepository.observeCategories(),
            preferencesRepository.observePrivacyLocationSharing(),
            preferencesRepository.observePrivacyProfileVisible(),
            preferencesRepository.observePrivacyContactInfo(),
            preferencesRepository.observePrivacyAnalytics(),
            preferencesRepository.observePrivacyPersonalizedAds(),
            preferencesRepository.observePrivacyDataCollection(),
            preferencesRepository.observePrivacyThirdPartySharing(),
            userRepository.observeCurrentUser()
        ) { values ->
            SettingsState(
                promosEnabled = values[0] as Boolean,
                soundEnabled = values[1] as Boolean,
                pushEnabled = values[2] as Boolean,
                lockscreenEnabled = values[3] as Boolean,
                emailNotificationsEnabled = values[4] as Boolean,
                smsNotificationsEnabled = values[5] as Boolean,
                language = values[6] as String,
                theme = values[7] as String,
                categories = values[8] as String,
                locationSharingEnabled = values[9] as Boolean,
                profileVisible = values[10] as Boolean,
                contactInfoSharingEnabled = values[11] as Boolean,
                analyticsEnabled = values[12] as Boolean,
                personalizedAdsEnabled = values[13] as Boolean,
                dataCollectionEnabled = values[14] as Boolean,
                thirdPartySharingEnabled = values[15] as Boolean,
                currentUser = values[16] as com.taskgoapp.taskgo.core.model.UserProfile?
            )
        }
    }
    
    suspend fun updateNotificationSettings(
        promos: Boolean,
        sound: Boolean,
        push: Boolean,
        lockscreen: Boolean,
        email: Boolean,
        sms: Boolean
    ) {
        // Salvar localmente primeiro
        preferencesRepository.updatePromosEnabled(promos)
        preferencesRepository.updateSoundEnabled(sound)
        preferencesRepository.updatePushEnabled(push)
        preferencesRepository.updateLockscreenEnabled(lockscreen)
        preferencesRepository.updateEmailNotificationsEnabled(email)
        preferencesRepository.updateSmsNotificationsEnabled(sms)
        
        // Salvar diretamente no Firestore
        val currentUser = auth.currentUser
        if (currentUser != null) {
            try {
                val user = firestoreUserRepository.getUser(currentUser.uid)
                if (user != null) {
                    val notificationSettings = com.taskgoapp.taskgo.data.firestore.models.NotificationSettingsFirestore(
                        push = push,
                        promos = promos,
                        sound = sound,
                        lockscreen = lockscreen,
                        email = email,
                        sms = sms
                    )
                    val updatedUser = user.copy(notificationSettings = notificationSettings)
                    val updateResult = firestoreUserRepository.updateUser(updatedUser)
                    updateResult.fold(
                        onSuccess = {
                            Log.d("SettingsUseCase", "Configura√ß√µes de notifica√ß√£o salvas no Firestore")
                        },
                        onFailure = { error ->
                            Log.e("SettingsUseCase", "Erro ao salvar notifica√ß√µes no Firestore: ${error.message}", error)
                        }
                    )
                }
            } catch (e: kotlinx.coroutines.CancellationException) {
                Log.w("SettingsUseCase", "Opera√ß√£o de salvamento de notifica√ß√µes cancelada")
                throw e // Re-lan√ßar CancellationException para propagar corretamente
            } catch (e: Exception) {
                Log.e("SettingsUseCase", "Erro ao salvar notifica√ß√µes no Firestore: ${e.message}", e)
            }
        }
        
        // Sync with backend via Cloud Functions (fallback)
        try {
            val result = firebaseFunctionsService.updateNotificationSettings(
                mapOf(
                    "promos" to promos,
                    "sound" to sound,
                    "push" to push,
                    "lockscreen" to lockscreen,
                    "email" to email,
                    "sms" to sms
                )
            )
            result.onSuccess { data ->
                Log.d("SettingsUseCase", "Configura√ß√µes de notifica√ß√£o sincronizadas via Cloud Function: $data")
            }.onFailure { error ->
                Log.e("SettingsUseCase", "Erro ao sincronizar notifica√ß√µes via Cloud Function: ${error.message}", error)
                // Tratar erro espec√≠fico do Secure Token API bloqueado
                if (error.message?.contains("SecureToken") == true || error.message?.contains("securetoken") == true) {
                    Log.w("SettingsUseCase", "Firebase Secure Token API bloqueado. Verifique configura√ß√µes do Google Cloud.")
                }
            }
        } catch (e: Exception) {
            Log.e("SettingsUseCase", "Erro ao chamar fun√ß√£o de notifica√ß√µes: ${e.message}", e)
            if (e.message?.contains("SecureToken") == true || e.message?.contains("securetoken") == true) {
                Log.w("SettingsUseCase", "Firebase Secure Token API bloqueado. Verifique configura√ß√µes do Google Cloud.")
            }
        }
    }
    
    suspend fun updateLanguage(language: String) {
        preferencesRepository.updateLanguage(language)
        
        try {
            val result = firebaseFunctionsService.updateLanguagePreference(language)
            result.onFailure { error ->
                Log.e("SettingsUseCase", "Erro ao sincronizar idioma: ${error.message}", error)
            }
        } catch (e: Exception) {
            Log.e("SettingsUseCase", "Erro ao chamar fun√ß√£o de idioma: ${e.message}", e)
        }
    }
    
    suspend fun updateTheme(theme: String) {
        preferencesRepository.updateTheme(theme)
    }
    
    suspend fun updateCategories(categories: String) {
        // Save to local storage
        preferencesRepository.updateCategories(categories)
        
        // Sync to Firestore via Cloud Function
        try {
            // Parse JSON string to List<String>
            val categoriesList = try {
                val gson = Gson()
                val jsonArray = categories.removePrefix("[").removeSuffix("]")
                if (jsonArray.isBlank()) {
                    emptyList()
                } else {
                    jsonArray.split(",")
                        .map { it.trim().removeSurrounding("\"") }
                        .filter { it.isNotBlank() }
                }
            } catch (e: Exception) {
                Log.e("SettingsUseCase", "Error parsing categories JSON: ${e.message}", e)
                emptyList()
            }
            
            // Call Cloud Function to update preferences in Firestore
            val result = firebaseFunctionsService.updateUserPreferences(categoriesList)
            result.fold(
                onSuccess = {
                    Log.d("SettingsUseCase", "Preferences synced to Firestore successfully")
                },
                onFailure = { error ->
                    Log.e("SettingsUseCase", "Error syncing preferences to Firestore: ${error.message}", error)
                    // Don't throw - local save was successful, sync can fail silently
                }
            )
        } catch (e: Exception) {
            Log.e("SettingsUseCase", "Error syncing preferences: ${e.message}", e)
            // Don't throw - local save was successful
        }
    }
    
    suspend fun updatePrivacySettings(
        locationSharing: Boolean,
        profileVisible: Boolean,
        contactInfoSharing: Boolean,
        analytics: Boolean,
        personalizedAds: Boolean,
        dataCollection: Boolean,
        thirdPartySharing: Boolean
    ) {
        // Salvar localmente primeiro
        preferencesRepository.updatePrivacyLocationSharing(locationSharing)
        preferencesRepository.updatePrivacyProfileVisible(profileVisible)
        preferencesRepository.updatePrivacyContactInfo(contactInfoSharing)
        preferencesRepository.updatePrivacyAnalytics(analytics)
        preferencesRepository.updatePrivacyPersonalizedAds(personalizedAds)
        preferencesRepository.updatePrivacyDataCollection(dataCollection)
        preferencesRepository.updatePrivacyThirdPartySharing(thirdPartySharing)
        
        // Salvar diretamente no Firestore
        val currentUser = auth.currentUser
        if (currentUser != null) {
            try {
                val user = firestoreUserRepository.getUser(currentUser.uid)
                if (user != null) {
                    val privacySettings = com.taskgoapp.taskgo.data.firestore.models.PrivacySettingsFirestore(
                        locationSharing = locationSharing,
                        profileVisible = profileVisible,
                        contactInfoSharing = contactInfoSharing,
                        analytics = analytics,
                        personalizedAds = personalizedAds,
                        dataCollection = dataCollection,
                        thirdPartySharing = thirdPartySharing
                    )
                    val updatedUser = user.copy(privacySettings = privacySettings)
                    firestoreUserRepository.updateUser(updatedUser)
                    Log.d("SettingsUseCase", "Configura√ß√µes de privacidade salvas no Firestore")
                }
            } catch (e: Exception) {
                Log.e("SettingsUseCase", "Erro ao salvar privacidade no Firestore: ${e.message}", e)
            }
        }
        
        // Sync with backend via Cloud Functions (fallback)
        try {
            val result = firebaseFunctionsService.updatePrivacySettings(
                mapOf(
                    "locationSharing" to locationSharing,
                    "profileVisible" to profileVisible,
                    "contactInfoSharing" to contactInfoSharing,
                    "analytics" to analytics,
                    "personalizedAds" to personalizedAds,
                    "dataCollection" to dataCollection,
                    "thirdPartySharing" to thirdPartySharing
                )
            )
            result.onFailure { error ->
                Log.e("SettingsUseCase", "Erro ao sincronizar privacidade via Cloud Function: ${error.message}", error)
            }
        } catch (e: Exception) {
            Log.e("SettingsUseCase", "Erro ao chamar fun√ß√£o de privacidade: ${e.message}", e)
        }
    }
    
    suspend fun syncRemoteSettings() {
        try {
            val result = firebaseFunctionsService.getUserSettings()
            result.onSuccess { data ->
                val notificationSettings = data["notificationSettings"] as? Map<*, *>
                val privacySettings = data["privacySettings"] as? Map<*, *>
                val language = data["language"] as? String
                val preferredCategories = data["preferredCategories"] as? List<*>
                
                notificationSettings?.let { settings ->
                    (settings["promos"] as? Boolean)?.let { preferencesRepository.updatePromosEnabled(it) }
                    (settings["sound"] as? Boolean)?.let { preferencesRepository.updateSoundEnabled(it) }
                    (settings["push"] as? Boolean)?.let { preferencesRepository.updatePushEnabled(it) }
                    (settings["lockscreen"] as? Boolean)?.let { preferencesRepository.updateLockscreenEnabled(it) }
                    (settings["email"] as? Boolean)?.let { preferencesRepository.updateEmailNotificationsEnabled(it) }
                    (settings["sms"] as? Boolean)?.let { preferencesRepository.updateSmsNotificationsEnabled(it) }
                }
                
                privacySettings?.let { settings ->
                    (settings["locationSharing"] as? Boolean)?.let { preferencesRepository.updatePrivacyLocationSharing(it) }
                    (settings["profileVisible"] as? Boolean)?.let { preferencesRepository.updatePrivacyProfileVisible(it) }
                    (settings["contactInfoSharing"] as? Boolean)?.let { preferencesRepository.updatePrivacyContactInfo(it) }
                    (settings["analytics"] as? Boolean)?.let { preferencesRepository.updatePrivacyAnalytics(it) }
                    (settings["personalizedAds"] as? Boolean)?.let { preferencesRepository.updatePrivacyPersonalizedAds(it) }
                    (settings["dataCollection"] as? Boolean)?.let { preferencesRepository.updatePrivacyDataCollection(it) }
                    (settings["thirdPartySharing"] as? Boolean)?.let { preferencesRepository.updatePrivacyThirdPartySharing(it) }
                }
                
                language?.let { preferencesRepository.updateLanguage(it) }
                
                preferredCategories?.let { list ->
                    val json = list.filterIsInstance<String>()
                        .joinToString(prefix = "[", postfix = "]") { "\"$it\"" }
                    preferencesRepository.updateCategories(json)
                }
            }.onFailure { error ->
                Log.e("SettingsUseCase", "Erro ao buscar configura√ß√µes do usu√°rio: ${error.message}", error)
                // Tratar erro espec√≠fico do Secure Token API bloqueado
                if (error.message?.contains("SecureToken") == true || error.message?.contains("securetoken") == true) {
                    Log.w("SettingsUseCase", "Firebase Secure Token API bloqueado. Verifique configura√ß√µes do Google Cloud.")
                }
            }
        } catch (e: kotlinx.coroutines.CancellationException) {
            Log.w("SettingsUseCase", "Sincroniza√ß√£o de configura√ß√µes remotas cancelada")
            throw e // Re-lan√ßar CancellationException para propagar corretamente
        } catch (e: Exception) {
            Log.e("SettingsUseCase", "Erro ao sincronizar configura√ß√µes remotas: ${e.message}", e)
            if (e.message?.contains("SecureToken") == true || e.message?.contains("securetoken") == true) {
                Log.w("SettingsUseCase", "Firebase Secure Token API bloqueado. Verifique configura√ß√µes do Google Cloud.")
            }
        }
    }
    
    suspend fun updateUserProfile(user: com.taskgoapp.taskgo.core.model.UserProfile) {
        userRepository.updateUser(user)
    }
    
    suspend fun updateUserAvatar(avatarUri: String) {
        userRepository.updateAvatar(avatarUri)
    }
}

data class SettingsState(
    val promosEnabled: Boolean,
    val soundEnabled: Boolean,
    val pushEnabled: Boolean,
    val lockscreenEnabled: Boolean,
    val emailNotificationsEnabled: Boolean,
    val smsNotificationsEnabled: Boolean,
    val language: String,
    val theme: String,
    val categories: String,
    val locationSharingEnabled: Boolean,
    val profileVisible: Boolean,
    val contactInfoSharingEnabled: Boolean,
    val analyticsEnabled: Boolean,
    val personalizedAdsEnabled: Boolean,
    val dataCollectionEnabled: Boolean,
    val thirdPartySharingEnabled: Boolean,
    val currentUser: com.taskgoapp.taskgo.core.model.UserProfile?
)

```

## [FRONTEND]: domain/usecase/TrackingUseCase.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.domain.usecase

import com.taskgoapp.taskgo.core.model.TrackingEvent
import com.taskgoapp.taskgo.domain.repository.OrdersRepository
import com.taskgoapp.taskgo.domain.repository.TrackingRepository
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import javax.inject.Inject

class TrackingUseCase @Inject constructor(
    private val ordersRepository: OrdersRepository,
    private val trackingRepository: TrackingRepository
) {
    
    fun observeOrderTracking(orderId: String): Flow<OrderTrackingInfo> {
        return trackingRepository.observeTrackingEvents(orderId).map { events: List<TrackingEvent> ->
            val order = kotlinx.coroutines.runBlocking {
                ordersRepository.getOrder(orderId)
            }
            OrderTrackingInfo(
                order = order!!,
                events = events,
                trackingCode = generateTrackingCode(orderId),
                currentStatus = getCurrentStatus(events)
            )
        }
    }
    
    private fun generateTrackingCode(orderId: String): String {
        // Generate a tracking code like "LP123456789BR"
        val prefix = "LP"
        val suffix = "BR"
        val middle = orderId.hashCode().toString().padStart(9, '0').take(9)
        return "$prefix$middle$suffix"
    }
    
    private fun getCurrentStatus(events: List<TrackingEvent>): String {
        val completedEvents = events.filter { it.done }
        return when (completedEvents.size) {
            0 -> "Processando"
            1 -> "Postado"
            2 -> "Em tr√¢nsito"
            3 -> "Saiu para entrega"
            4 -> "Entregue"
            else -> "Processando"
        }
    }
    
    suspend fun updateTrackingStatus(orderId: String, eventId: String, done: Boolean) {
        trackingRepository.updateEventDone(eventId, done)
    }
}

data class OrderTrackingInfo(
    val order: com.taskgoapp.taskgo.core.model.PurchaseOrder,
    val events: List<TrackingEvent>,
    val trackingCode: String,
    val currentStatus: String
)

```

# Features - ads


## [FRONTEND]: feature/ads/presentation/AdsScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.ads.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.core.design.AppTopBar

@Composable
fun AdsScreen(
    onBackClick: () -> Unit
) {
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Divulgue no TaskGo",
                onBackClick = onBackClick
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            Text(
                text = "Anuncie seus servi√ßos e produtos",
                style = MaterialTheme.typography.headlineSmall,
                fontWeight = FontWeight.Bold
            )

            Text(
                text = "Alcance mais clientes com banners e posi√ß√µes em destaque.",
                style = MaterialTheme.typography.bodyMedium,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )

            Card(
                modifier = Modifier.fillMaxWidth(),
                colors = CardDefaults.cardColors(
                    containerColor = MaterialTheme.colorScheme.surfaceVariant
                )
            ) {
                Column(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(20.dp),
                    horizontalAlignment = Alignment.Start
                ) {
                    Text(
                        text = "Planos a partir de R$ 19,90/m√™s",
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.SemiBold
                    )
                    Spacer(modifier = Modifier.height(8.dp))
                    Text(
                        text = "Crie campanhas com or√ßamento flex√≠vel e acompanhe os resultados.",
                        style = MaterialTheme.typography.bodyMedium
                    )
                }
            }
        }
    }
}



```

## [FRONTEND]: feature/ads/presentation/AnuncioDetalheScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.ads.presentation

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.taskgoapp.taskgo.core.theme.TaskGoBackgroundWhite
import com.taskgoapp.taskgo.core.theme.TaskGoGreen
import com.taskgoapp.taskgo.core.theme.TaskGoTextBlack
import com.taskgoapp.taskgo.core.theme.TaskGoTextGray

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AnuncioDetalheScreen(
	onBackClick: () -> Unit,
	onComprarBanner: () -> Unit,
	variant: String? = null
) {
	Column(
		modifier = Modifier
			.fillMaxSize()
			.background(TaskGoBackgroundWhite)
	) {
		TopAppBar(
			title = {
				Text("An√∫ncio", color = TaskGoTextBlack, fontSize = 18.sp, fontWeight = FontWeight.Bold)
			},
			navigationIcon = {
                IconButton(onClick = onBackClick) {
                    Icon(imageVector = Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Voltar", tint = TaskGoTextBlack)
                }
			},
			colors = TopAppBarDefaults.topAppBarColors(containerColor = TaskGoBackgroundWhite)
		)

		Column(
			modifier = Modifier
				.fillMaxSize()
				.padding(16.dp),
			verticalArrangement = Arrangement.spacedBy(16.dp)
		) {
			Text("Divulgue seu trabalho!", color = TaskGoTextBlack, fontSize = 20.sp, fontWeight = FontWeight.Bold)
			Text(
				"Destaque seus servi√ßos nos banners da p√°gina inicial de TaskGo",
				color = TaskGoTextGray,
				fontSize = 14.sp
			)

			Card(colors = CardDefaults.cardColors(containerColor = Color.White)) {
				Column(Modifier.padding(16.dp), verticalArrangement = Arrangement.spacedBy(8.dp)) {
					Text("Planos", color = TaskGoTextBlack, fontWeight = FontWeight.SemiBold)
					Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween) {
						Text("Pequeno", color = TaskGoTextGray)
						Text("R$ 50/dia", color = TaskGoTextBlack, fontWeight = FontWeight.Bold)
					}
					Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween) {
						Text("Grande", color = TaskGoTextGray)
						Text("R$ 90/dia", color = TaskGoTextBlack, fontWeight = FontWeight.Bold)
					}
					Spacer(Modifier.height(8.dp))
					val comprarEnabled = variant != "disabled"
					Button(
						onClick = onComprarBanner,
						modifier = Modifier.fillMaxWidth().height(52.dp),
						enabled = comprarEnabled,
						colors = ButtonDefaults.buttonColors(containerColor = TaskGoGreen)
					) {
						Text("Comprar banner", color = Color.White, fontWeight = FontWeight.Bold)
					}
				}
			}
		}
	}
}


```

## [FRONTEND]: feature/ads/presentation/AnunciosScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.ads.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.VolumeUp
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.theme.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AnunciosScreen(
    onBackClick: () -> Unit,
    onComprarBanner: () -> Unit,
    onVerDetalhe: () -> Unit,
    variant: String? = null
) {
    var selectedPlan by remember { mutableStateOf("Pequeno") }

    Scaffold(
        topBar = {
            AppTopBar(
                title = "An√∫ncio",
                onBackClick = onBackClick
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.spacedBy(24.dp)
        ) {
            // Megaphone icon
            Icon(
                imageVector = Icons.AutoMirrored.Filled.VolumeUp,
                contentDescription = null,
                modifier = Modifier.size(80.dp),
                tint = TaskGoGreen
            )

            // Headline
            Text(
                text = "Divulgue seu trabalho!",
                style = FigmaTitleLarge,
                color = TaskGoTextBlack
            )

            // Description
            Text(
                text = "Destaque seus servi√ßos nos banners da p√°gina inicial de TaskGo",
                style = FigmaProductDescription,
                color = TaskGoTextGray,
                textAlign = androidx.compose.ui.text.style.TextAlign.Center
            )

            // Pricing cards
            if (variant == "empty") {
                Text(
                    text = "Nenhum plano dispon√≠vel no momento",
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            } else Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                // Pequeno card
                Card(
                    modifier = Modifier.weight(1f),
                    colors = CardDefaults.cardColors(
                        containerColor = if (selectedPlan == "Pequeno")
                            MaterialTheme.colorScheme.primaryContainer
                        else Color.White
                    ),
                    border = if (selectedPlan == "Pequeno") null else null
                ) {
                    Column(
                        modifier = Modifier.padding(16.dp),
                        horizontalAlignment = Alignment.CenterHorizontally
                    ) {
                        Text(
                            text = "Pequeno",
                            style = FigmaProductName,
                            color = TaskGoTextBlack
                        )
                        Text(
                            text = "R$ 50/dia",
                            style = FigmaProductDescription,
                            color = TaskGoTextGray
                        )
                    }
                }

                // Grande card
                Card(
                    modifier = Modifier.weight(1f),
                    colors = CardDefaults.cardColors(
                        containerColor = if (selectedPlan == "Grande")
                            MaterialTheme.colorScheme.primaryContainer
                        else Color.White
                    ),
                    border = if (selectedPlan == "Grande") null else null
                ) {
                    Column(
                        modifier = Modifier.padding(16.dp),
                        horizontalAlignment = Alignment.CenterHorizontally
                    ) {
                        Text(
                            text = "Grande",
                            style = FigmaProductName,
                            color = TaskGoTextBlack
                        )
                        Text(
                            text = "R$ 90/dia",
                            style = FigmaProductDescription,
                            color = TaskGoTextGray
                        )
                    }
                }
            }

            Spacer(modifier = Modifier.weight(1f))

            // Buy button
            Button(
                onClick = { onComprarBanner() },
                modifier = Modifier.fillMaxWidth(),
                colors = ButtonDefaults.buttonColors(
                    containerColor = TaskGoGreen
                )
            ) {
                Text(
                    text = "Comprar Banner",
                    style = FigmaButtonText,
                    color = Color.White
                )
            }

            if (variant == "cta_secondary") {
                OutlinedButton(
                    onClick = onVerDetalhe,
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Text("Ver detalhes")
                }
            }
        }
    }
}

```

## [FRONTEND]: feature/ads/presentation/ComprarBannerScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.ads.presentation

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.theme.TaskGoBackgroundWhite
import com.taskgoapp.taskgo.core.theme.TaskGoGreen
import com.taskgoapp.taskgo.core.theme.TaskGoTextBlack
import com.taskgoapp.taskgo.core.theme.TaskGoTextGray

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ComprarBannerScreen(
	onBackClick: () -> Unit,
	onConfirmarCompra: (String) -> Unit,
	variant: String? = null
) {
	var plano by remember { mutableStateOf("pequeno") }

	Scaffold(
		topBar = {
			AppTopBar(
				title = "Comprar Banner",
				onBackClick = onBackClick
			)
		}
	) { paddingValues ->

		Column(
			modifier = Modifier
				.fillMaxSize()
				.padding(paddingValues)
				.padding(16.dp),
			verticalArrangement = Arrangement.spacedBy(16.dp)
		) {
			Text(
				text = "Escolha seu plano de banner",
				color = TaskGoTextBlack,
				style = MaterialTheme.typography.headlineSmall,
				fontWeight = FontWeight.Bold
			)
			Card(colors = CardDefaults.cardColors(containerColor = Color.White)) {
				Column(Modifier.padding(16.dp), verticalArrangement = Arrangement.spacedBy(8.dp)) {
					Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween) {
						Text("Pequeno", color = TaskGoTextGray)
						Text("R$ 50/m√™s", color = TaskGoTextBlack, fontWeight = FontWeight.Bold)
					}
                    RadioButtonRow("pequeno", plano) { plano = it }
                    HorizontalDivider()
					Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween) {
						Text("Grande", color = TaskGoTextGray)
						Text("R$ 100/m√™s", color = TaskGoTextBlack, fontWeight = FontWeight.Bold)
					}
					RadioButtonRow("grande", plano) { plano = it }
				}
			}

			Spacer(Modifier.height(12.dp))
			Button(
				onClick = { onConfirmarCompra(plano) },
				modifier = Modifier.fillMaxWidth().height(56.dp),
				enabled = variant != "disabled",
				colors = ButtonDefaults.buttonColors(containerColor = TaskGoGreen)
			) {
				Text("Confirmar compra", color = Color.White, fontWeight = FontWeight.Bold)
			}
		}
	}
}

@Composable
private fun RadioButtonRow(value: String, selected: String, onSelect: (String) -> Unit) {
	Row(verticalAlignment = Alignment.CenterVertically) {
		RadioButton(selected = value == selected, onClick = { onSelect(value) }, colors = RadioButtonDefaults.colors(selectedColor = TaskGoGreen))
		Spacer(Modifier.width(8.dp))
		Text(text = if (value == "pequeno") "Pequeno" else "Grande", color = TaskGoTextBlack)
	}
}


```

# Features - auth


## [FRONTEND]: feature/auth/presentation/AuthViewModel.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.auth.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.taskgoapp.taskgo.data.repository.FirebaseAuthRepository
import com.google.firebase.auth.FirebaseUser
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.launch
import javax.inject.Inject

data class AuthUiState(
    val isLoading: Boolean = false,
    val isLoggedIn: Boolean = false,
    val user: FirebaseUser? = null,
    val error: String? = null
)

data class ChangePasswordUiState(
    val isLoading: Boolean = false,
    val error: String? = null,
    val success: Boolean = false
)

data class ForgotPasswordUiState(
    val isLoading: Boolean = false,
    val error: String? = null,
    val success: Boolean = false
)

@HiltViewModel
class AuthViewModel @Inject constructor(
    private val authRepository: FirebaseAuthRepository,
    private val addressRepository: com.taskgoapp.taskgo.domain.repository.AddressRepository,
    private val cardRepository: com.taskgoapp.taskgo.domain.repository.CardRepository,
    private val productsRepository: com.taskgoapp.taskgo.domain.repository.ProductsRepository,
    @dagger.hilt.android.qualifiers.ApplicationContext private val context: android.content.Context
) : ViewModel() {
    private val _uiState = MutableStateFlow(AuthUiState())
    val uiState: StateFlow<AuthUiState> = _uiState.asStateFlow()

    private val _changePasswordState = MutableStateFlow(ChangePasswordUiState())
    val changePasswordState: StateFlow<ChangePasswordUiState> = _changePasswordState.asStateFlow()

    private val _forgotPasswordState = MutableStateFlow(ForgotPasswordUiState())
    val forgotPasswordState: StateFlow<ForgotPasswordUiState> = _forgotPasswordState.asStateFlow()

    init {
        // Verificar se usu√°rio j√° est√° logado
        checkAuthState()
    }

    private fun checkAuthState() {
        authRepository.getCurrentUser()?.let { user ->
            _uiState.value = AuthUiState(
                isLoggedIn = true,
                user = user
            )
        }
    }

    // Social login pode ser implementado depois com Firebase Auth
    fun socialLogin(provider: String, idToken: String) {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoading = true, error = null)
            // TODO: Implementar social login com Firebase
            _uiState.value = _uiState.value.copy(
                isLoading = false,
                error = "Social login ainda n√£o implementado"
            )
        }
    }

    fun changePassword(currentPassword: String, newPassword: String) {
        viewModelScope.launch {
            _changePasswordState.value = ChangePasswordUiState(isLoading = true)
            // Primeiro reautenticar, depois atualizar senha
            authRepository.reauthenticate(currentPassword)
                .onSuccess {
                    authRepository.updatePassword(newPassword)
                        .onSuccess {
                            _changePasswordState.value = ChangePasswordUiState(success = true)
                        }
                        .onFailure { error ->
                            _changePasswordState.value = ChangePasswordUiState(error = error.message ?: "Erro ao alterar senha")
                        }
                }
                .onFailure { error ->
                    _changePasswordState.value = ChangePasswordUiState(error = error.message ?: "Senha atual incorreta")
                }
        }
    }

    fun clearChangePasswordState() {
        _changePasswordState.value = ChangePasswordUiState()
    }

    fun forgotPassword(email: String) {
        viewModelScope.launch {
            _forgotPasswordState.value = ForgotPasswordUiState(isLoading = true)
            authRepository.resetPassword(email)
                .onSuccess {
                    _forgotPasswordState.value = ForgotPasswordUiState(success = true)
                }
                .onFailure { error ->
                    _forgotPasswordState.value = ForgotPasswordUiState(error = error.message ?: "Erro ao enviar e-mail")
                }
        }
    }

    fun clearForgotPasswordState() {
        _forgotPasswordState.value = ForgotPasswordUiState()
    }

    fun login(email: String, password: String) {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoading = true, error = null)
            authRepository.signInWithEmail(email, password)
                .onSuccess { user ->
                    _uiState.value = _uiState.value.copy(
                        isLoading = false,
                        isLoggedIn = true,
                        user = user
                    )
                }
                .onFailure { error ->
                    _uiState.value = _uiState.value.copy(
                        isLoading = false,
                        error = error.message ?: "Erro no login"
                    )
                }
        }
    }

    fun signup(email: String, password: String, role: String? = null) {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoading = true, error = null)
            authRepository.signUpWithEmail(email, password)
                .onSuccess { user ->
                    _uiState.value = _uiState.value.copy(
                        isLoading = false,
                        isLoggedIn = true,
                        user = user
                    )
                }
                .onFailure { error ->
                    _uiState.value = _uiState.value.copy(
                        isLoading = false,
                        error = error.message ?: "Erro no cadastro"
                    )
                }
        }
    }

    fun logout() {
        viewModelScope.launch {
            // CR√çTICO: Limpar todos os dados locais antes de fazer logout para evitar mistura de dados entre usu√°rios
            try {
                // Limpar carrinho
                productsRepository.clearCart()
                
                // Limpar endere√ßos locais (ser√£o recarregados quando novo usu√°rio fizer login)
                addressRepository.observeAddresses().first().forEach { address ->
                    addressRepository.deleteAddress(address.id)
                }
                
                // Limpar cart√µes locais (ser√£o recarregados quando novo usu√°rio fizer login)
                cardRepository.observeCards().first().forEach { card ->
                    cardRepository.deleteCard(card.id)
                }
                
                // CR√çTICO: Limpar foto de perfil e dados do usu√°rio do PreferencesManager
                val preferencesManager = com.taskgoapp.taskgo.core.data.PreferencesManager(context)
                preferencesManager.saveUserAvatarUri("")
                preferencesManager.saveUserProfileImages(emptyList())
                preferencesManager.saveUserName("")
                preferencesManager.saveUserEmail("")
                preferencesManager.saveUserPhone("")
                preferencesManager.saveUserCpf("")
                preferencesManager.saveUserProfession("")
                android.util.Log.d("AuthViewModel", "Dados do usu√°rio limpos do PreferencesManager")
            } catch (e: Exception) {
                android.util.Log.e("AuthViewModel", "Erro ao limpar dados locais no logout: ${e.message}", e)
            }
            
            // Fazer logout
            authRepository.signOut()
            _uiState.value = AuthUiState()
        }
    }

    fun clearError() {
        _uiState.value = _uiState.value.copy(error = null)
    }
}

```

## [FRONTEND]: feature/auth/presentation/BiometricAuthScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.auth.presentation

import android.app.Activity
import android.util.Log
import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Visibility
import androidx.compose.material.icons.filled.VisibilityOff
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.PasswordVisualTransformation
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.taskgoapp.taskgo.core.biometric.BiometricManager
import com.taskgoapp.taskgo.core.biometric.BiometricStatus
import com.taskgoapp.taskgo.core.theme.TaskGoGreen
import com.taskgoapp.taskgo.core.theme.TaskGoTextDark
import com.taskgoapp.taskgo.core.theme.TaskGoTextGray

@Composable
fun BiometricAuthScreen(
    onAuthSuccess: () -> Unit,
    onAuthFailed: () -> Unit,
    modifier: Modifier = Modifier
) {
    val context = LocalContext.current
    val activity = context as? Activity
    val viewModel: BiometricAuthViewModel = hiltViewModel()
    val uiState by viewModel.uiState.collectAsState()
    
    val biometricManager = remember { BiometricManager(context) }
    val biometricStatus = remember { biometricManager.isBiometricAvailable() }
    val biometricAvailable = biometricStatus == BiometricStatus.AVAILABLE
    
    Log.d("BiometricAuthScreen", "=== Iniciando BiometricAuthScreen ===")
    Log.d("BiometricAuthScreen", "BiometricStatus: $biometricStatus, Available: $biometricAvailable")
    Log.d("BiometricAuthScreen", "UIState - isLoading: ${uiState.isLoading}, hasSavedCredentials: ${uiState.hasSavedCredentials}")
    
    // Tentar autentica√ß√£o biom√©trica automaticamente quando a tela aparecer
    LaunchedEffect(Unit) {
        Log.d("BiometricAuthScreen", "LaunchedEffect - Iniciando autentica√ß√£o autom√°tica")
        
        if (!uiState.hasSavedCredentials) {
            Log.d("BiometricAuthScreen", "Nenhuma credencial salva, navegando para login")
            onAuthFailed()
            return@LaunchedEffect
        }
        
        // Pequeno delay para garantir que a UI est√° pronta
        kotlinx.coroutines.delay(500)
        
        if (biometricAvailable && activity != null && !uiState.isLoading) {
            Log.d("BiometricAuthScreen", "Iniciando autentica√ß√£o biom√©trica automaticamente")
            viewModel.authenticateWithBiometric(activity, biometricManager) {
                Log.d("BiometricAuthScreen", "Autentica√ß√£o biom√©trica bem-sucedida")
                onAuthSuccess()
            }
        } else if (!biometricAvailable) {
            Log.d("BiometricAuthScreen", "Biometria n√£o dispon√≠vel, mostrando op√ß√£o de senha")
        }
    }
    
    // Observar mudan√ßas no estado de autentica√ß√£o
    LaunchedEffect(uiState.isAuthenticated) {
        if (uiState.isAuthenticated) {
            Log.d("BiometricAuthScreen", "Usu√°rio autenticado, navegando para home")
            onAuthSuccess()
        }
    }
    
    Box(
        modifier = modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Column(
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.spacedBy(24.dp),
            modifier = Modifier.padding(32.dp)
        ) {
            if (uiState.isLoading) {
                CircularProgressIndicator(
                    modifier = Modifier.size(64.dp),
                    color = TaskGoGreen
                )
                Spacer(modifier = Modifier.height(16.dp))
                Text(
                    text = "Autenticando...",
                    style = MaterialTheme.typography.titleMedium,
                    color = TaskGoTextDark
                )
            } else if (biometricAvailable && uiState.hasSavedCredentials) {
                // Mostrar instru√ß√µes para biometria
                Text(
                    text = "Autentica√ß√£o Biom√©trica",
                    style = MaterialTheme.typography.headlineMedium,
                    fontWeight = FontWeight.Bold,
                    color = TaskGoTextDark
                )
                Text(
                    text = "Use sua biometria ou senha para continuar",
                    style = MaterialTheme.typography.bodyMedium,
                    color = TaskGoTextGray
                )
                Spacer(modifier = Modifier.height(16.dp))
                
                // Bot√£o para tentar biometria novamente
                Button(
                    onClick = {
                        if (activity != null) {
                            viewModel.authenticateWithBiometric(activity, biometricManager) {
                                onAuthSuccess()
                            }
                        }
                    },
                    colors = ButtonDefaults.buttonColors(
                        containerColor = TaskGoGreen
                    ),
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Text("Tentar Biometria Novamente")
                }
                
                // Bot√£o para usar senha
                TextButton(
                    onClick = {
                        viewModel.showPasswordDialog()
                    },
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Text("Usar Senha")
                }
            } else if (!biometricAvailable && uiState.hasSavedCredentials) {
                // Mostrar op√ß√£o de senha se n√£o tiver biometria
                Text(
                    text = "Autentica√ß√£o",
                    style = MaterialTheme.typography.headlineMedium,
                    fontWeight = FontWeight.Bold,
                    color = TaskGoTextDark
                )
                Text(
                    text = "Digite sua senha para continuar",
                    style = MaterialTheme.typography.bodyMedium,
                    color = TaskGoTextGray
                )
                Spacer(modifier = Modifier.height(16.dp))
                
                Button(
                    onClick = {
                        viewModel.showPasswordDialog()
                    },
                    colors = ButtonDefaults.buttonColors(
                        containerColor = TaskGoGreen
                    ),
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Text("Digitar Senha")
                }
            }
            
            if (uiState.error != null) {
                Text(
                    text = uiState.error ?: "",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.error
                )
            }
        }
    }
    
    // Dialog de senha
    if (uiState.showPasswordDialog) {
        PasswordDialog(
            onDismiss = { viewModel.hidePasswordDialog() },
            onPasswordEntered = { password ->
                viewModel.authenticateWithPassword(password) {
                    onAuthSuccess()
                }
            },
            savedEmail = uiState.savedEmail
        )
    }
}

@Composable
private fun PasswordDialog(
    onDismiss: () -> Unit,
    onPasswordEntered: (String) -> Unit,
    savedEmail: String?
) {
    var password by remember { mutableStateOf("") }
    var showPassword by remember { mutableStateOf(false) }
    
    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Digite sua senha") },
        text = {
            Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
                if (savedEmail != null) {
                    Text(
                        text = "Email: $savedEmail",
                        style = MaterialTheme.typography.bodySmall,
                        color = TaskGoTextGray
                    )
                }
                OutlinedTextField(
                    value = password,
                    onValueChange = { password = it },
                    label = { Text("Senha") },
                    singleLine = true,
                    visualTransformation = if (showPassword) {
                        androidx.compose.ui.text.input.VisualTransformation.None
                    } else {
                        PasswordVisualTransformation()
                    },
                    trailingIcon = {
                        IconButton(onClick = { showPassword = !showPassword }) {
                            Icon(
                                imageVector = if (showPassword) {
                                    Icons.Default.VisibilityOff
                                } else {
                                    Icons.Default.Visibility
                                },
                                contentDescription = if (showPassword) "Ocultar senha" else "Mostrar senha"
                            )
                        }
                    },
                    modifier = Modifier.fillMaxWidth()
                )
            }
        },
        confirmButton = {
            Button(
                onClick = {
                    if (password.isNotBlank()) {
                        onPasswordEntered(password)
                    }
                },
                enabled = password.isNotBlank(),
                colors = ButtonDefaults.buttonColors(
                    containerColor = TaskGoGreen
                )
            ) {
                Text("Confirmar")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Cancelar")
            }
        }
    )
}


```

## [FRONTEND]: feature/auth/presentation/BiometricAuthViewModel.kt

```kotlin
package com.taskgoapp.taskgo.feature.auth.presentation

import android.app.Activity
import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.google.firebase.auth.FirebaseAuth
import com.taskgoapp.taskgo.core.biometric.BiometricManager
import com.taskgoapp.taskgo.data.local.datastore.PreferencesManager
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.launch
import javax.inject.Inject

data class BiometricAuthUiState(
    val isLoading: Boolean = false,
    val isAuthenticated: Boolean = false,
    val hasSavedCredentials: Boolean = false,
    val savedEmail: String? = null,
    val showPasswordDialog: Boolean = false,
    val error: String? = null
)

@HiltViewModel
class BiometricAuthViewModel @Inject constructor(
    private val preferencesManager: PreferencesManager,
    private val firebaseAuth: FirebaseAuth
) : ViewModel() {
    
    private val _uiState = MutableStateFlow(BiometricAuthUiState())
    val uiState: StateFlow<BiometricAuthUiState> = _uiState.asStateFlow()
    
    init {
        Log.d("BiometricAuthViewModel", "=== Inicializando BiometricAuthViewModel ===")
        checkSavedCredentials()
    }
    
    private fun checkSavedCredentials() {
        viewModelScope.launch {
            try {
                Log.d("BiometricAuthViewModel", "Verificando credenciais salvas")
                val savedEmail = preferencesManager.getEmailForBiometric()
                val biometricEnabled = preferencesManager.biometricEnabled.first()
                val currentUser = firebaseAuth.currentUser
                
                Log.d("BiometricAuthViewModel", "savedEmail: $savedEmail, biometricEnabled: $biometricEnabled, currentUser: ${currentUser?.email}")
                
                val hasCredentials = savedEmail != null && savedEmail.isNotBlank() && currentUser != null
                
                _uiState.value = _uiState.value.copy(
                    hasSavedCredentials = hasCredentials,
                    savedEmail = savedEmail,
                    isAuthenticated = currentUser != null && !hasCredentials // Se n√£o precisa autenticar, j√° est√° autenticado
                )
                
                Log.d("BiometricAuthViewModel", "Estado atualizado - hasSavedCredentials: $hasCredentials")
            } catch (e: Exception) {
                Log.e("BiometricAuthViewModel", "Erro ao verificar credenciais", e)
                _uiState.value = _uiState.value.copy(
                    error = "Erro ao verificar credenciais: ${e.message}"
                )
            }
        }
    }
    
    fun authenticateWithBiometric(
        activity: Activity,
        biometricManager: BiometricManager,
        onSuccess: () -> Unit
    ) {
        Log.d("BiometricAuthViewModel", "Iniciando autentica√ß√£o biom√©trica")
        _uiState.value = _uiState.value.copy(isLoading = true, error = null)
        
        biometricManager.authenticate(
            activity = activity,
            title = "Autentica√ß√£o Biom√©trica",
            subtitle = "Use sua biometria para acessar o app",
            negativeButtonText = "Cancelar",
            onSuccess = {
                Log.d("BiometricAuthViewModel", "Autentica√ß√£o biom√©trica bem-sucedida")
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    isAuthenticated = true
                )
                onSuccess()
            },
            onError = { error ->
                Log.e("BiometricAuthViewModel", "Erro na autentica√ß√£o biom√©trica: $error")
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = error
                )
            },
            onCancel = {
                Log.d("BiometricAuthViewModel", "Autentica√ß√£o biom√©trica cancelada")
                _uiState.value = _uiState.value.copy(isLoading = false)
            }
        )
    }
    
    fun authenticateWithPassword(
        password: String,
        onSuccess: () -> Unit
    ) {
        viewModelScope.launch {
            try {
                Log.d("BiometricAuthViewModel", "Iniciando autentica√ß√£o com senha")
                _uiState.value = _uiState.value.copy(isLoading = true, error = null)
                
                val email = _uiState.value.savedEmail
                if (email == null) {
                    _uiState.value = _uiState.value.copy(
                        isLoading = false,
                        error = "Email n√£o encontrado"
                    )
                    return@launch
                }
                
                // Reautenticar com Firebase
                val currentUser = firebaseAuth.currentUser
                if (currentUser == null) {
                    // Se n√£o estiver logado, fazer login
                    firebaseAuth.signInWithEmailAndPassword(email, password)
                        .addOnSuccessListener {
                            Log.d("BiometricAuthViewModel", "Login com senha bem-sucedido")
                            _uiState.value = _uiState.value.copy(
                                isLoading = false,
                                isAuthenticated = true
                            )
                            onSuccess()
                        }
                        .addOnFailureListener { e ->
                            Log.e("BiometricAuthViewModel", "Erro no login com senha", e)
                            _uiState.value = _uiState.value.copy(
                                isLoading = false,
                                error = "Senha incorreta"
                            )
                        }
                } else {
                    // Se j√° estiver logado, apenas verificar senha reautenticando
                    val credential = com.google.firebase.auth.EmailAuthProvider.getCredential(email, password)
                    currentUser.reauthenticate(credential)
                        .addOnSuccessListener {
                            Log.d("BiometricAuthViewModel", "Reautentica√ß√£o com senha bem-sucedida")
                            _uiState.value = _uiState.value.copy(
                                isLoading = false,
                                isAuthenticated = true
                            )
                            onSuccess()
                        }
                        .addOnFailureListener { e ->
                            Log.e("BiometricAuthViewModel", "Erro na reautentica√ß√£o", e)
                            _uiState.value = _uiState.value.copy(
                                isLoading = false,
                                error = "Senha incorreta"
                            )
                        }
                }
            } catch (e: Exception) {
                Log.e("BiometricAuthViewModel", "Erro ao autenticar com senha", e)
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = "Erro: ${e.message}"
                )
            }
        }
    }
    
    fun showPasswordDialog() {
        _uiState.value = _uiState.value.copy(showPasswordDialog = true)
    }
    
    fun hidePasswordDialog() {
        _uiState.value = _uiState.value.copy(showPasswordDialog = false, error = null)
    }
}


```

## [FRONTEND]: feature/auth/presentation/CadastroFinalizadoScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.auth.presentation

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Check
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp

@Composable
fun CadastroFinalizadoScreen(
    onContinue: () -> Unit
) {
    Box(
        modifier = Modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .padding(32.dp),
            colors = CardDefaults.cardColors(
                containerColor = Color.White
            )
        ) {
            Column(
                modifier = Modifier.padding(24.dp),
                horizontalAlignment = Alignment.CenterHorizontally,
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                // TaskGo logo
                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    Icon(
                        imageVector = Icons.Default.Check,
                        contentDescription = null,
                        tint = MaterialTheme.colorScheme.primary,
                        modifier = Modifier.size(24.dp)
                    )
                    Text(
                        text = "TaskGo",
                        style = MaterialTheme.typography.titleLarge,
                        fontWeight = FontWeight.Bold
                    )
                }

                // Success icon
                Box(
                    modifier = Modifier
                        .size(80.dp)
                        .background(
                            color = MaterialTheme.colorScheme.primary,
                            shape = CircleShape
                        ),
                    contentAlignment = Alignment.Center
                ) {
                    Icon(
                        imageVector = Icons.Default.Check,
                        contentDescription = null,
                        tint = Color.White,
                        modifier = Modifier.size(40.dp)
                    )
                }

                // Success message
                Text(
                    text = "Pagamento Confirmado",
                    style = MaterialTheme.typography.headlineSmall,
                    fontWeight = FontWeight.Bold
                )

                // OK button
                Button(
                    onClick = onContinue,
                    colors = ButtonDefaults.buttonColors(
                        containerColor = MaterialTheme.colorScheme.primary
                    )
                ) {
                    Text(
                        text = "OK",
                        fontWeight = FontWeight.Bold
                    )
                }
            }
        }
    }
}

```

## [FRONTEND]: feature/auth/presentation/CadastroScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.auth.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Check
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun CadastroScreen(
    onCadastrar: () -> Unit
) {
    var nome by remember { mutableStateOf("") }
    var email by remember { mutableStateOf("") }
    var telefone by remember { mutableStateOf("") }
    var senha by remember { mutableStateOf("") }
    var numeroCartao by remember { mutableStateOf("") }
    var validade by remember { mutableStateOf("") }
    var cvc by remember { mutableStateOf("") }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        // TaskGo logo
        Row(
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            Icon(
                imageVector = Icons.Default.Check,
                contentDescription = null,
                tint = MaterialTheme.colorScheme.primary,
                modifier = Modifier.size(24.dp)
            )
            Text(
                text = "TaskGo",
                style = MaterialTheme.typography.titleLarge,
                fontWeight = FontWeight.Bold
            )
        }

        Spacer(modifier = Modifier.height(32.dp))

        // Form fields
        OutlinedTextField(
            value = nome,
            onValueChange = { nome = it },
            placeholder = { Text("Nome") },
            modifier = Modifier.fillMaxWidth(),
            singleLine = true
        )

        OutlinedTextField(
            value = email,
            onValueChange = { email = it },
            placeholder = { Text("E-mail") },
            modifier = Modifier.fillMaxWidth(),
            singleLine = true
        )

        OutlinedTextField(
            value = telefone,
            onValueChange = { telefone = it },
            placeholder = { Text("Telefone") },
            modifier = Modifier.fillMaxWidth(),
            singleLine = true
        )

        OutlinedTextField(
            value = senha,
            onValueChange = { senha = it },
            placeholder = { Text("Senha") },
            modifier = Modifier.fillMaxWidth(),
            singleLine = true
        )

        OutlinedTextField(
            value = numeroCartao,
            onValueChange = { numeroCartao = it },
            placeholder = { Text("N√∫mero do cart√£o") },
            modifier = Modifier.fillMaxWidth(),
            singleLine = true
        )

        // Validade e CVC row
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            OutlinedTextField(
                value = validade,
                onValueChange = { validade = it },
                placeholder = { Text("Validade") },
                modifier = Modifier.weight(2f),
                singleLine = true
            )
            OutlinedTextField(
                value = cvc,
                onValueChange = { cvc = it },
                placeholder = { Text("CVC") },
                modifier = Modifier.weight(1f),
                singleLine = true
            )
        }

        // Plan info
        Text(
            text = "Plano Mensal de R$ 20,00 - Necess√°rio para ativar sua conta",
            style = MaterialTheme.typography.bodySmall,
            color = MaterialTheme.colorScheme.onSurfaceVariant,
            textAlign = androidx.compose.ui.text.style.TextAlign.Center
        )

        Spacer(modifier = Modifier.weight(1f))

        // Cadastrar button
        Button(
            onClick = onCadastrar,
            modifier = Modifier.fillMaxWidth(),
            colors = ButtonDefaults.buttonColors(
                containerColor = MaterialTheme.colorScheme.primary
            )
        ) {
            Text(
                text = "Cadastrar",
                fontWeight = FontWeight.Bold
            )
        }
    }
}

```

## [FRONTEND]: feature/auth/presentation/FacialVerificationScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.auth.presentation

import android.Manifest
import android.content.Context
import android.hardware.Sensor
import android.hardware.SensorEvent
import android.hardware.SensorEventListener
import android.hardware.SensorManager
import android.net.Uri
import androidx.camera.core.*
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.camera.view.PreviewView
import com.taskgoapp.taskgo.core.security.RealTimeFaceAnalyzer
import com.taskgoapp.taskgo.core.security.FaceDetectionResult
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.CameraAlt
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.collectAsState
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalLifecycleOwner
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.viewinterop.AndroidView
import androidx.core.content.ContextCompat
import androidx.hilt.navigation.compose.hiltViewModel
import com.google.accompanist.permissions.ExperimentalPermissionsApi
import com.google.accompanist.permissions.rememberPermissionState
import com.taskgoapp.taskgo.core.design.TGIcons
import com.taskgoapp.taskgo.core.theme.*
import kotlinx.coroutines.launch
import java.io.File
import java.text.SimpleDateFormat
import java.util.*

@OptIn(ExperimentalPermissionsApi::class, ExperimentalMaterial3Api::class)
@Composable
fun FacialVerificationScreen(
    onBackClick: () -> Unit,
    onVerificationComplete: () -> Unit,
    viewModel: IdentityVerificationViewModel = hiltViewModel()
) {
    val context = LocalContext.current
    val lifecycleOwner = LocalLifecycleOwner.current
    val scope = rememberCoroutineScope()
    
    // Permiss√µes
    val cameraPermission = rememberPermissionState(Manifest.permission.CAMERA)
    
    // Estados
    var faceDetectionResult by remember { mutableStateOf<FaceDetectionResult?>(null) }
    var isCapturing by remember { mutableStateOf(false) }
    var isVerifying by remember { mutableStateOf(false) }
    var verificationMessage by remember { mutableStateOf<String?>(null) }
    var cameraProvider: ProcessCameraProvider? by remember { mutableStateOf(null) }
    var imageCapture: ImageCapture? by remember { mutableStateOf(null) }
    var preview: Preview? by remember { mutableStateOf(null) }
    var imageAnalysis: ImageAnalysis? by remember { mutableStateOf(null) }
    
    // Simplificado: apenas verifica√ß√£o b√°sica de rosto
    var faceDetected by remember { mutableStateOf(false) }
    // Analisador de face em tempo real
    val faceAnalyzer = remember {
        RealTimeFaceAnalyzer { result ->
            faceDetectionResult = result
        }
    }
    
    // Limpar recursos ao sair
    DisposableEffect(Unit) {
        onDispose {
            faceAnalyzer.release()
        }
    }
    
    // Detectar rosto para habilitar bot√£o
    LaunchedEffect(faceDetectionResult) {
        val result = faceDetectionResult
        faceDetected = result?.hasFace == true && result.isCentered && result.isGoodSize
    }
    
    // Inicializar c√¢mera
    LaunchedEffect(cameraPermission.status) {
        if (cameraPermission.status is com.google.accompanist.permissions.PermissionStatus.Granted) {
            try {
                val provider = withContext(Dispatchers.Main) {
                    ProcessCameraProvider.getInstance(context).get()
                }
                cameraProvider = provider
                
                val previewBuilder = Preview.Builder()
                    .build()
                preview = previewBuilder
                
                imageCapture = ImageCapture.Builder()
                    .setCaptureMode(ImageCapture.CAPTURE_MODE_MINIMIZE_LATENCY)
                    .setFlashMode(ImageCapture.FLASH_MODE_OFF)
                    .build()
                
                // ImageAnalysis para detec√ß√£o facial em tempo real
                val analysisBuilder = ImageAnalysis.Builder()
                    .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)
                    .setOutputImageFormat(ImageAnalysis.OUTPUT_IMAGE_FORMAT_YUV_420_888)
                    .build()
                    .also { analysis ->
                        analysis.setAnalyzer(
                            ContextCompat.getMainExecutor(context),
                            faceAnalyzer
                        )
                    }
                imageAnalysis = analysisBuilder
                
                val cameraSelector = CameraSelector.DEFAULT_FRONT_CAMERA
                
                provider.unbindAll()
                provider.bindToLifecycle(
                    lifecycleOwner,
                    cameraSelector,
                    previewBuilder,
                    imageCapture,
                    analysisBuilder
                )
            } catch (e: Exception) {
                android.util.Log.e("FacialVerification", "Erro ao inicializar c√¢mera: ${e.message}", e)
            }
        } else {
            cameraPermission.launchPermissionRequest()
        }
    }
    
    val uiState by viewModel.uiState.collectAsState()
    
    // Tela de loading durante verifica√ß√£o
    if (isVerifying || uiState.isVerifyingFace) {
        Box(
            modifier = Modifier
                .fillMaxSize()
                .background(Color.Black),
            contentAlignment = Alignment.Center
        ) {
            Column(
                horizontalAlignment = Alignment.CenterHorizontally,
                verticalArrangement = Arrangement.spacedBy(24.dp)
            ) {
                CircularProgressIndicator(
                    color = TaskGoGreen,
                    modifier = Modifier.size(64.dp),
                    strokeWidth = 4.dp
                )
                Text(
                    text = verificationMessage ?: "Validando sua identidade...",
                    color = Color.White,
                    fontSize = 18.sp,
                    fontWeight = FontWeight.Medium
                )
                Text(
                    text = "Por favor, aguarde",
                    color = Color.White.copy(alpha = 0.7f),
                    fontSize = 14.sp
                )
            }
        }
        return // Retornar cedo para mostrar apenas o loading
    }
    
    Scaffold(
        topBar = {
            TopAppBar(
                title = { 
                    Text(
                        "Verifica√ß√£o Facial",
                        color = Color.White,
                        fontWeight = FontWeight.Bold
                    ) 
                },
                navigationIcon = {
                    IconButton(onClick = onBackClick) {
                        Icon(
                            painter = painterResource(id = com.taskgoapp.taskgo.core.design.TGIcons.Back),
                            contentDescription = "Voltar",
                            tint = Color.White
                        )
                    }
                },
                colors = TopAppBarDefaults.topAppBarColors(
                    containerColor = TaskGoGreen
                )
            )
        }
    ) { paddingValues ->
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .background(Color.Black)
        ) {
            // Preview da c√¢mera
            if (cameraPermission.status is com.google.accompanist.permissions.PermissionStatus.Granted && cameraProvider != null && preview != null) {
                AndroidView(
                    factory = { ctx ->
                        PreviewView(ctx).apply {
                            scaleType = PreviewView.ScaleType.FILL_CENTER
                        }
                    },
                    modifier = Modifier.fillMaxSize(),
                    update = { view ->
                        preview?.setSurfaceProvider(view.surfaceProvider)
                    }
                )
            } else {
                // Placeholder enquanto c√¢mera n√£o est√° pronta
                Box(
                    modifier = Modifier
                        .fillMaxSize()
                        .background(Color.Black),
                    contentAlignment = Alignment.Center
                ) {
                    if (cameraPermission.status !is com.google.accompanist.permissions.PermissionStatus.Granted) {
                        Column(
                            horizontalAlignment = Alignment.CenterHorizontally,
                            verticalArrangement = Arrangement.spacedBy(16.dp)
                        ) {
                            Text(
                                text = "Permiss√£o de c√¢mera necess√°ria",
                                color = Color.White,
                                fontSize = 16.sp
                            )
                            Button(
                                onClick = { cameraPermission.launchPermissionRequest() },
                                colors = ButtonDefaults.buttonColors(
                                    containerColor = TaskGoGreen
                                )
                            ) {
                                Text("Conceder Permiss√£o", color = Color.White)
                            }
                        }
                    } else {
                        CircularProgressIndicator(color = Color.White)
                    }
                }
            }
            
            // Overlay com oval guia (formato de rosto)
            Box(
                modifier = Modifier.fillMaxSize(),
                contentAlignment = Alignment.Center
            ) {
                // Oval guia (formato de rosto)
                Canvas(modifier = Modifier.size(width = 280.dp, height = 360.dp)) {
                    val center = Offset(size.width / 2, size.height / 2)
                    val width = size.width * 0.85f
                    val height = size.height * 0.85f
                    
                    val faceResult = faceDetectionResult
                    val isReady = faceDetected
                    
                    // Oval externo (guia)
                    drawOval(
                        color = when {
                            isReady -> TaskGoSuccessGreen
                            faceResult?.hasFace == true -> Color.Yellow.copy(alpha = 0.7f)
                            else -> Color.White.copy(alpha = 0.5f)
                        },
                        topLeft = Offset(center.x - width / 2, center.y - height / 2),
                        size = androidx.compose.ui.geometry.Size(width, height),
                        style = Stroke(width = if (isReady) 5.dp.toPx() else 4.dp.toPx())
                    )
                    
                    // Indicador de posi√ß√£o da face (se detectada)
                    faceResult?.let { result ->
                        if (result.hasFace) {
                            val faceX = center.x + (result.faceCenterX - 0.5f) * size.width
                            val faceY = center.y + (result.faceCenterY - 0.5f) * size.height
                            
                            // Desenhar ponto indicando posi√ß√£o da face
                            drawCircle(
                                color = if (result.isCentered) TaskGoSuccessGreen else Color.Red,
                                radius = 8.dp.toPx(),
                                center = Offset(faceX, faceY)
                            )
                        }
                    }
                    
                    // Oval interno (√°rea de detec√ß√£o)
                    val innerWidth = width * 0.85f
                    val innerHeight = height * 0.85f
                    drawOval(
                        color = Color.Transparent,
                        topLeft = Offset(center.x - innerWidth / 2, center.y - innerHeight / 2),
                        size = androidx.compose.ui.geometry.Size(innerWidth, innerHeight),
                        style = Stroke(width = 2.dp.toPx(), pathEffect = androidx.compose.ui.graphics.PathEffect.dashPathEffect(floatArrayOf(10f, 10f)))
                    )
                }
            }
            
            // Instru√ß√µes na parte inferior
            Column(
                modifier = Modifier
                    .align(Alignment.BottomCenter)
                    .fillMaxWidth()
                    .background(Color.Black.copy(alpha = 0.7f))
                    .padding(24.dp),
                horizontalAlignment = Alignment.CenterHorizontally,
                verticalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                val faceResult = faceDetectionResult
                
                Text(
                    text = when {
                        isVerifying -> verificationMessage ?: "Processando..."
                        isCapturing -> "Capturando imagem..."
                        faceResult == null || !faceResult.hasFace -> {
                            "Posicione seu rosto dentro do oval"
                        }
                        !faceResult.isCentered -> {
                            "Centralize seu rosto no oval"
                        }
                        !faceResult.isGoodSize -> {
                            if (faceResult.faceSize < 0.25f) {
                                "Aproxime-se um pouco mais"
                            } else {
                                "Afaste-se um pouco"
                            }
                        }
                        !faceResult.eyesOpen -> {
                            "Mantenha os olhos abertos"
                        }
                        !faceResult.isLookingAtCamera -> {
                            "Olhe diretamente para a c√¢mera"
                        }
                        else -> {
                            "Rosto detectado! Toque no bot√£o para capturar"
                        }
                    },
                    color = Color.White,
                    fontSize = 16.sp,
                    fontWeight = FontWeight.Medium
                )
                
                // Indicadores de status
                Row(
                    horizontalArrangement = Arrangement.spacedBy(8.dp),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    StatusIndicator(
                        label = "Rosto",
                        isActive = faceResult?.hasFace == true
                    )
                    StatusIndicator(
                        label = "Centralizado",
                        isActive = faceResult?.isCentered == true
                    )
                    StatusIndicator(
                        label = "Tamanho",
                        isActive = faceResult?.isGoodSize == true
                    )
                    StatusIndicator(
                        label = "Olhos",
                        isActive = faceResult?.eyesOpen == true
                    )
                    StatusIndicator(
                        label = "Olhando",
                        isActive = faceResult?.isLookingAtCamera == true
                    )
                }
                
                Spacer(modifier = Modifier.height(8.dp))
                
                // Bot√£o de captura manual simplificado
                Button(
                        onClick = {
                            if (faceDetected && !isCapturing && imageCapture != null) {
                                isCapturing = true
                                
                                captureImage(
                                    imageCapture = imageCapture,
                                    context = context,
                                    onImageCaptured = { uri ->
                                        isVerifying = true
                                        verificationMessage = "Validando sua identidade..."
                                        
                                        scope.launch {
                                            viewModel.setSelfie(uri)
                                            
                                            // CR√çTICO: Fazer upload dos documentos antes da verifica√ß√£o facial
                                            val uploadResult = viewModel.uploadDocumentsForVerification()
                                            if (uploadResult.isFailure) {
                                                verificationMessage = "Erro ao fazer upload dos documentos. Tente novamente."
                                                kotlinx.coroutines.delay(2000)
                                                isCapturing = false
                                                isVerifying = false
                                                return@launch
                                            }
                                            
                                            // Aguardar um pouco para o usu√°rio ver a tela de loading
                                            kotlinx.coroutines.delay(500)
                                            
                                            val matchOk = try {
                                                // Executar verifica√ß√£o facial
                                                val result = viewModel.verifyFaceMatch()
                                                
                                                // Aguardar atualiza√ß√£o do estado
                                                var attempts = 0
                                                while (attempts < 50 && viewModel.uiState.value.isVerifyingFace) {
                                                    kotlinx.coroutines.delay(100)
                                                    attempts++
                                                }
                                                
                                                // Verificar resultado final do estado
                                                val finalState = viewModel.uiState.value
                                                val success = finalState.faceVerificationSuccess == true
                                                
                                                if (success) {
                                                    verificationMessage = "Identidade verificada com sucesso!"
                                                    kotlinx.coroutines.delay(1500) // Dar tempo para o usu√°rio ver a mensagem
                                                } else {
                                                    verificationMessage = finalState.faceVerificationError ?: "Verifica√ß√£o falhou. Tente novamente."
                                                    kotlinx.coroutines.delay(2000) // Mostrar erro por mais tempo
                                                }
                                                
                                                success
                                            } catch (e: Exception) {
                                                android.util.Log.e("FacialVerification", "Erro na verifica√ß√£o facial: ${e.message}", e)
                                                verificationMessage = "Erro na verifica√ß√£o: ${e.message}"
                                                kotlinx.coroutines.delay(2000)
                                                false
                                            }
                                            
                                            isCapturing = false
                                            isVerifying = false
                                            
                                            // S√≥ redirecionar ap√≥s a verifica√ß√£o estar completa
                                            if (matchOk) {
                                                onVerificationComplete() // Volta para IdentityVerificationScreen
                                            } else {
                                                // Se falhou, voltar para a tela anterior e mostrar erro l√°
                                                onVerificationComplete() // Volta para IdentityVerificationScreen (vai mostrar dialog de erro)
                                            }
                                        }
                                    },
                                    onError = {
                                        isCapturing = false
                                        isVerifying = false
                                        // Erro na captura, n√£o precisa voltar
                                    }
                                )
                            }
                        },
                        enabled = faceDetected && !isCapturing,
                        modifier = Modifier
                            .fillMaxWidth()
                            .height(56.dp),
                        colors = ButtonDefaults.buttonColors(
                            containerColor = if (faceDetected) TaskGoGreen else Color.Gray
                        )
                    ) {
                        if (isCapturing) {
                            CircularProgressIndicator(
                                color = Color.White,
                                modifier = Modifier.size(20.dp)
                            )
                        } else {
                            Text(
                                text = if (faceDetected) "Confirmar e Capturar" else "Aguardando detec√ß√£o do rosto...",
                                color = Color.White,
                                fontSize = 16.sp,
                                fontWeight = FontWeight.Bold
                            )
                        }
                    }
            }
        }
    }
    
}

@Composable
private fun StatusIndicator(
    label: String,
    isActive: Boolean
) {
    Row(
        horizontalArrangement = Arrangement.spacedBy(4.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Box(
            modifier = Modifier
                .size(12.dp)
                .background(
                    color = if (isActive) TaskGoSuccessGreen else Color.Gray,
                    shape = CircleShape
                )
        )
        Text(
            text = label,
            color = Color.White,
            fontSize = 12.sp
        )
    }
}

private fun captureImage(
    imageCapture: ImageCapture?,
    context: Context,
    onImageCaptured: (Uri) -> Unit,
    onError: () -> Unit
) {
    if (imageCapture == null) {
        onError()
        return
    }
    
    val photoFile = File(
        context.getExternalFilesDir(null),
        SimpleDateFormat("yyyy-MM-dd-HH-mm-ss-SSS", Locale.US)
            .format(System.currentTimeMillis()) + ".jpg"
    )
    
    val outputFileOptions = ImageCapture.OutputFileOptions.Builder(photoFile).build()
    
    imageCapture.takePicture(
        outputFileOptions,
        ContextCompat.getMainExecutor(context),
        object : ImageCapture.OnImageSavedCallback {
            override fun onImageSaved(output: ImageCapture.OutputFileResults) {
                onImageCaptured(Uri.fromFile(photoFile))
            }
            
            override fun onError(exception: ImageCaptureException) {
                android.util.Log.e("FacialVerification", "Erro ao capturar imagem: ${exception.message}", exception)
                onError()
            }
        }
    )
}


```

## [FRONTEND]: feature/auth/presentation/ForgotPasswordScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.auth.presentation

import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.OutlinedTextFieldDefaults
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Snackbar
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.getValue
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.R
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.design.PrimaryButton
import com.taskgoapp.taskgo.core.design.EnhancedOutlinedTextField
import com.taskgoapp.taskgo.core.theme.TaskGoGreen

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ForgotPasswordScreen(
    onBackClick: () -> Unit,
    onResetSent: () -> Unit
) {
    var email by remember { mutableStateOf("") }
    var error by remember { mutableStateOf<String?>(null) }
    var sent by remember { mutableStateOf(false) }
    val context = LocalContext.current

    Scaffold(
        topBar = {
            AppTopBar(
                title = stringResource(R.string.forgot_password_title),
                onBackClick = onBackClick
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp)
        ) {
            Text(
                text = stringResource(R.string.forgot_password_subtitle),
                style = MaterialTheme.typography.bodyMedium,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )

            Spacer(modifier = Modifier.height(16.dp))

            EnhancedOutlinedTextField(
                value = email,
                onValueChange = { email = it; error = null },
                modifier = Modifier.fillMaxWidth(),
                singleLine = true,
                placeholder = { Text(stringResource(R.string.auth_email)) },
                isError = error != null,
                keyboardOptions = androidx.compose.foundation.text.KeyboardOptions(keyboardType = androidx.compose.ui.text.input.KeyboardType.Email)
            )

            if (error != null) {
                Spacer(modifier = Modifier.height(8.dp))
                Text(text = error!!, color = MaterialTheme.colorScheme.error)
            }

            Spacer(modifier = Modifier.height(24.dp))

            PrimaryButton(
                text = stringResource(R.string.forgot_password_send),
                onClick = {
                    if (email.isBlank() || !email.contains("@")) {
                        error = context.getString(R.string.forgot_password_invalid_email)
                    } else {
                        sent = true
                        onResetSent()
                    }
                },
                modifier = Modifier.fillMaxWidth()
            )

            if (sent) {
                Spacer(modifier = Modifier.height(12.dp))
                Snackbar { Text(stringResource(R.string.forgot_password_sent_success)) }
            }
        }
    }
}

```

## [FRONTEND]: feature/auth/presentation/IdentityVerificationScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.auth.presentation

import android.Manifest
import android.net.Uri
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.collectAsState
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.hilt.navigation.compose.hiltViewModel
import coil.compose.AsyncImage
import coil.request.ImageRequest
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.design.TGIcons
import com.taskgoapp.taskgo.core.permissions.PermissionHandler
import com.taskgoapp.taskgo.core.permissions.rememberImageReadPermissionLauncher
import com.taskgoapp.taskgo.core.theme.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun IdentityVerificationScreen(
    onBackClick: () -> Unit,
    onVerificationComplete: () -> Unit,
    onSkipVerification: () -> Unit = {},
    onNavigateToFacialVerification: () -> Unit = {},
    viewModel: IdentityVerificationViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    val context = LocalContext.current
    
    // Verificar permiss√£o de imagem
    val hasImagePermission = remember {
        PermissionHandler.hasImageReadPermission(context)
    }
    
    // Launcher para permiss√£o de imagem
    val imagePermissionLauncher = rememberImageReadPermissionLauncher(
        onPermissionGranted = {
            // Permiss√£o concedida, continuar com o launcher apropriado
        },
        onPermissionDenied = {
            // Mostrar mensagem de erro
        }
    )
    
    var pendingAction by remember { mutableStateOf<(() -> Unit)?>(null) }
    
    // Launchers para sele√ß√£o de imagens
    val documentFrontLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.GetContent()
    ) { uri: Uri? ->
        uri?.let { viewModel.setDocumentFront(it) }
    }
    
    val documentBackLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.GetContent()
    ) { uri: Uri? ->
        uri?.let { viewModel.setDocumentBack(it) }
    }
    
    val selfieLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.GetContent()
    ) { uri: Uri? ->
        uri?.let { viewModel.setSelfie(it) }
    }
    
    val addressProofLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.GetContent()
    ) { uri: Uri? ->
        uri?.let { viewModel.setAddressProof(it) }
    }
    
    // Fun√ß√£o helper para abrir seletor com verifica√ß√£o de permiss√£o
    fun openImageSelector(launcher: androidx.activity.result.ActivityResultLauncher<String>) {
        if (hasImagePermission) {
            launcher.launch("image/*")
        } else {
            pendingAction = { launcher.launch("image/*") }
            imagePermissionLauncher.launch(PermissionHandler.getImageReadPermission())
        }
    }
    
    // Executar a√ß√£o pendente ap√≥s permiss√£o concedida
    LaunchedEffect(hasImagePermission) {
        if (hasImagePermission && pendingAction != null) {
            pendingAction?.invoke()
            pendingAction = null
        }
    }
    
    // Navega√ß√£o ap√≥s sucesso
    LaunchedEffect(uiState.isSuccess) {
        if (uiState.isSuccess) {
            onVerificationComplete()
        }
    }
    
    // Dialog de erro da verifica√ß√£o facial
    var showFaceVerificationError by remember { mutableStateOf(false) }
    
    LaunchedEffect(uiState.faceVerificationSuccess) {
        if (uiState.faceVerificationSuccess == false) {
            showFaceVerificationError = true
        }
    }
    
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Verifica√ß√£o de Identidade",
                onBackClick = onBackClick
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .background(TaskGoBackgroundWhite)
                .verticalScroll(rememberScrollState())
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // Informa√ß√µes
            Card(
                modifier = Modifier.fillMaxWidth(),
                colors = CardDefaults.cardColors(
                    containerColor = Color(0xFFE3F2FD)
                )
            ) {
                Column(
                    modifier = Modifier.padding(16.dp)
                ) {
                    Row(
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Icon(
                            imageVector = Icons.Default.Info,
                            contentDescription = null,
                            tint = TaskGoGreen,
                            modifier = Modifier.size(24.dp)
                        )
                        Spacer(modifier = Modifier.width(8.dp))
                        Text(
                            text = "Documentos Necess√°rios",
                            style = MaterialTheme.typography.titleMedium,
                            fontWeight = FontWeight.Bold,
                            color = TaskGoTextBlack
                        )
                    }
                    Spacer(modifier = Modifier.height(8.dp))
                    Text(
                        text = "Para sua seguran√ßa, precisamos verificar sua identidade. Envie os documentos solicitados.",
                        style = MaterialTheme.typography.bodyMedium,
                        color = TaskGoTextGray
                    )
                }
            }
            
            // Documento Frente
            DocumentUploadSection(
                title = "Documento - Frente",
                description = "RG, CNH ou Passaporte",
                imageUri = uiState.documentFrontUri,
                onSelectImage = { openImageSelector(documentFrontLauncher) },
                required = true
            )
            
            // Documento Verso
            DocumentUploadSection(
                title = "Documento - Verso",
                description = "Verso do documento",
                imageUri = uiState.documentBackUri,
                onSelectImage = { openImageSelector(documentBackLauncher) },
                required = true
            )
            
            // Verifica√ß√£o Facial (substitui selfie)
            Card(
                modifier = Modifier.fillMaxWidth(),
                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
            ) {
                Column(
                    modifier = Modifier.padding(16.dp)
                ) {
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Column(modifier = Modifier.weight(1f)) {
                            Text(
                                text = "Verifica√ß√£o Facial",
                                style = MaterialTheme.typography.titleMedium,
                                fontWeight = FontWeight.Bold,
                                color = TaskGoTextBlack
                            )
                            Text(
                                text = "* Obrigat√≥rio",
                                style = MaterialTheme.typography.bodySmall,
                                color = MaterialTheme.colorScheme.error,
                                fontSize = 12.sp
                            )
                            Spacer(modifier = Modifier.height(4.dp))
                            Text(
                                text = "Verifica√ß√£o biom√©trica com c√¢mera e sensores",
                                style = MaterialTheme.typography.bodySmall,
                                color = TaskGoTextGray,
                                fontSize = 12.sp
                            )
                        }
                    }
                    
                    Spacer(modifier = Modifier.height(12.dp))
                    
                    // Indicador de sucesso da verifica√ß√£o facial
                    if (uiState.faceVerificationSuccess == true) {
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.Start,
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Icon(
                                imageVector = Icons.Default.Check,
                                contentDescription = "Verifica√ß√£o aprovada",
                                tint = TaskGoGreen,
                                modifier = Modifier.size(24.dp)
                            )
                            Spacer(modifier = Modifier.width(8.dp))
                            Text(
                                text = "Verifica√ß√£o facial aprovada",
                                color = TaskGoGreen,
                                fontSize = 14.sp,
                                fontWeight = FontWeight.Medium
                            )
                        }
                        Spacer(modifier = Modifier.height(12.dp))
                    }
                    
                    if (uiState.selfieUri != null) {
                        val context = LocalContext.current
                        Box(
                            modifier = Modifier
                                .fillMaxWidth()
                                .height(200.dp)
                                .background(
                                    Color(0xFFF5F5F5),
                                    RoundedCornerShape(8.dp)
                                ),
                            contentAlignment = Alignment.Center
                        ) {
                            coil.compose.AsyncImage(
                                model = coil.request.ImageRequest.Builder(context)
                                    .data(uiState.selfieUri)
                                    .crossfade(true)
                                    .build(),
                                contentDescription = "Selfie capturada",
                                modifier = Modifier
                                    .fillMaxSize()
                                    .padding(8.dp),
                                contentScale = androidx.compose.ui.layout.ContentScale.Crop
                            )
                        }
                    } else {
                        Button(
                            onClick = { onNavigateToFacialVerification() },
                            modifier = Modifier
                                .fillMaxWidth()
                                .height(56.dp),
                            colors = ButtonDefaults.buttonColors(
                                containerColor = TaskGoGreen
                            )
                        ) {
                            Icon(
                                imageVector = Icons.Default.CameraAlt,
                                contentDescription = null,
                                tint = Color.White,
                                modifier = Modifier.size(24.dp)
                            )
                            Spacer(modifier = Modifier.width(8.dp))
                            Text(
                                text = "Iniciar Verifica√ß√£o Facial",
                                color = Color.White,
                                fontSize = 16.sp,
                                fontWeight = FontWeight.Bold
                            )
                        }
                    }
                }
            }
            
            // Comprovante de Endere√ßo
            DocumentUploadSection(
                title = "Comprovante de Endere√ßo (Opcional)",
                description = "Conta de luz, √°gua ou telefone",
                imageUri = uiState.addressProofUri,
                onSelectImage = { openImageSelector(addressProofLauncher) },
                required = false
            )
            
            // Mensagem de erro
            uiState.errorMessage?.let { error ->
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    colors = CardDefaults.cardColors(
                        containerColor = MaterialTheme.colorScheme.errorContainer
                    )
                ) {
                    Text(
                        text = error,
                        modifier = Modifier.padding(16.dp),
                        color = MaterialTheme.colorScheme.onErrorContainer
                    )
                }
            }
            
            Spacer(modifier = Modifier.height(16.dp))
            
            // Bot√£o Enviar
            Button(
                onClick = { viewModel.submitVerification() },
                modifier = Modifier
                    .fillMaxWidth()
                    .height(56.dp),
                shape = RoundedCornerShape(8.dp),
                colors = ButtonDefaults.buttonColors(
                    containerColor = TaskGoGreen
                ),
                enabled = !uiState.isLoading &&
                         uiState.documentFrontUri != null &&
                         uiState.documentBackUri != null &&
                         uiState.selfieUri != null &&
                         uiState.faceVerificationSuccess == true // Verifica√ß√£o facial deve estar completa e aprovada
            ) {
                if (uiState.isLoading) {
                    CircularProgressIndicator(
                        color = Color.White,
                        modifier = Modifier.size(20.dp)
                    )
                } else {
                    Text(
                        text = "Confirmar Verifica√ß√£o",
                        color = Color.White,
                        fontSize = 16.sp,
                        fontWeight = FontWeight.Bold
                    )
                }
            }
            
            Spacer(modifier = Modifier.height(12.dp))
            
            // Bot√£o Cadastrar Depois
            OutlinedButton(
                onClick = { onSkipVerification() },
                modifier = Modifier
                    .fillMaxWidth()
                    .height(56.dp),
                shape = RoundedCornerShape(8.dp),
                colors = ButtonDefaults.outlinedButtonColors(
                    contentColor = TaskGoTextGray
                ),
                border = androidx.compose.foundation.BorderStroke(1.dp, Color(0xFFD9D9D9))
            ) {
                Text(
                    text = "Cadastrar Depois",
                    color = TaskGoTextGray,
                    fontSize = 16.sp,
                    fontWeight = FontWeight.Medium
                )
            }
            
            Spacer(modifier = Modifier.height(16.dp))
        }
    }
    
    // Dialog de erro da verifica√ß√£o facial (fora do Scaffold)
    if (showFaceVerificationError && uiState.faceVerificationError != null) {
        AlertDialog(
            onDismissRequest = { 
                showFaceVerificationError = false
                viewModel.clearFaceVerificationError()
            },
            title = {
                Text(
                    text = "Verifica√ß√£o Facial Falhou",
                    fontWeight = FontWeight.Bold
                )
            },
            text = {
                Text(uiState.faceVerificationError ?: "N√£o foi poss√≠vel validar a foto. Por favor, tente novamente.")
            },
            confirmButton = {
                Button(
                    onClick = {
                        showFaceVerificationError = false
                        viewModel.clearFaceVerificationError()
                        onNavigateToFacialVerification() // Navegar para tentar novamente
                    },
                    colors = ButtonDefaults.buttonColors(
                        containerColor = TaskGoGreen
                    )
                ) {
                    Text("Tentar Novamente", color = Color.White)
                }
            },
            dismissButton = {
                TextButton(
                    onClick = {
                        showFaceVerificationError = false
                        viewModel.clearFaceVerificationError()
                    }
                ) {
                    Text("Cancelar")
                }
            }
        )
    }
}

@Composable
private fun DocumentUploadSection(
    title: String,
    description: String,
    imageUri: Uri?,
    onSelectImage: () -> Unit,
    required: Boolean
) {
    val context = LocalContext.current
    
    Card(
        modifier = Modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Column(modifier = Modifier.weight(1f)) {
                    Text(
                        text = title,
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold,
                        color = TaskGoTextBlack
                    )
                    if (required) {
                        Text(
                            text = "* Obrigat√≥rio",
                            style = MaterialTheme.typography.bodySmall,
                            color = MaterialTheme.colorScheme.error,
                            fontSize = 12.sp
                        )
                    }
                    Spacer(modifier = Modifier.height(4.dp))
                    Text(
                        text = description,
                        style = MaterialTheme.typography.bodySmall,
                        color = TaskGoTextGray,
                        fontSize = 12.sp
                    )
                }
            }
            
            Spacer(modifier = Modifier.height(12.dp))
            
            Box(
                modifier = Modifier
                    .fillMaxWidth()
                    .height(200.dp)
                    .background(
                        Color(0xFFF5F5F5),
                        RoundedCornerShape(8.dp)
                    )
                    .clickable { onSelectImage() },
                contentAlignment = Alignment.Center
            ) {
                if (imageUri != null) {
                    AsyncImage(
                        model = ImageRequest.Builder(context)
                            .data(imageUri)
                            .crossfade(true)
                            .build(),
                        contentDescription = title,
                        modifier = Modifier
                            .fillMaxSize()
                            .padding(8.dp),
                        contentScale = ContentScale.Crop
                    )
                } else {
                    Column(
                        horizontalAlignment = Alignment.CenterHorizontally,
                        verticalArrangement = Arrangement.Center
                    ) {
                        Icon(
                            imageVector = Icons.Default.AddPhotoAlternate,
                            contentDescription = null,
                            modifier = Modifier.size(48.dp),
                            tint = TaskGoTextGray
                        )
                        Spacer(modifier = Modifier.height(8.dp))
                        Text(
                            text = "Toque para adicionar",
                            style = MaterialTheme.typography.bodyMedium,
                            color = TaskGoTextGray
                        )
                    }
                }
            }
        }
    }
}

```

## [FRONTEND]: feature/auth/presentation/IdentityVerificationViewModel.kt

```kotlin
package com.taskgoapp.taskgo.feature.auth.presentation

import android.content.Context
import android.net.Uri
import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.google.firebase.auth.FirebaseAuth
import com.taskgoapp.taskgo.core.security.FaceVerificationManager
import com.taskgoapp.taskgo.data.repository.FirebaseStorageRepository
import com.taskgoapp.taskgo.data.repository.FirestoreUserRepository
import com.taskgoapp.taskgo.data.firebase.FirebaseFunctionsService
import dagger.hilt.android.lifecycle.HiltViewModel
import dagger.hilt.android.qualifiers.ApplicationContext
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import java.util.Date
import javax.inject.Inject

data class IdentityVerificationUiState(
    val isLoading: Boolean = false,
    val errorMessage: String? = null,
    val isSuccess: Boolean = false,
    val documentFrontUri: Uri? = null,
    val documentBackUri: Uri? = null,
    val selfieUri: Uri? = null,
    val addressProofUri: Uri? = null,
    val documentFrontUrl: String? = null,
    val documentBackUrl: String? = null,
    val selfieUrl: String? = null,
    val addressProofUrl: String? = null,
    val faceVerificationResult: String? = null,
    val isVerifyingFace: Boolean = false,
    val faceVerificationSuccess: Boolean? = null, // null = n√£o verificado, true = sucesso, false = falha
    val faceVerificationError: String? = null // Mensagem de erro da verifica√ß√£o facial
)

@HiltViewModel
class IdentityVerificationViewModel @Inject constructor(
    private val storageRepository: FirebaseStorageRepository,
    private val firestoreRepository: FirestoreUserRepository,
    private val auth: FirebaseAuth,
    private val functionsService: FirebaseFunctionsService,
    @ApplicationContext private val context: Context
) : ViewModel() {
    
    private val _uiState = MutableStateFlow(IdentityVerificationUiState())
    val uiState: StateFlow<IdentityVerificationUiState> = _uiState
    
    private val faceVerificationManager = FaceVerificationManager(context)
    
    fun setDocumentFront(uri: Uri) {
        _uiState.value = _uiState.value.copy(documentFrontUri = uri)
    }
    
    fun setDocumentBack(uri: Uri) {
        _uiState.value = _uiState.value.copy(documentBackUri = uri)
    }
    
    fun setSelfie(uri: Uri) {
        _uiState.value = _uiState.value.copy(selfieUri = uri)
    }
    
    fun setAddressProof(uri: Uri) {
        _uiState.value = _uiState.value.copy(addressProofUri = uri)
    }
    
    /**
     * Faz upload dos documentos antes da verifica√ß√£o facial
     * CR√çTICO: Deve ser chamado antes de verifyFaceMatch() para garantir que os documentos estejam no servidor
     */
    suspend fun uploadDocumentsForVerification(): Result<Unit> {
        val currentUser = auth.currentUser ?: return Result.failure(Exception("Usu√°rio n√£o autenticado"))
        val state = _uiState.value
        
        return try {
            // Fazer upload de todos os documentos necess√°rios
            val documentFrontResult = if (state.documentFrontUri != null) {
                storageRepository.uploadDocument(currentUser.uid, "front", state.documentFrontUri!!)
            } else null
            
            val documentBackResult = if (state.documentBackUri != null) {
                storageRepository.uploadDocument(currentUser.uid, "back", state.documentBackUri!!)
            } else null
            
            val selfieResult = if (state.selfieUri != null) {
                storageRepository.uploadSelfie(currentUser.uid, state.selfieUri!!)
            } else null
            
            // Atualizar URLs no estado
            val documentFrontUrl = documentFrontResult?.getOrNull()
            val documentBackUrl = documentBackResult?.getOrNull()
            val selfieUrl = selfieResult?.getOrNull()
            
            _uiState.value = _uiState.value.copy(
                documentFrontUrl = documentFrontUrl,
                documentBackUrl = documentBackUrl,
                selfieUrl = selfieUrl
            )
            
            if (documentFrontUrl == null || selfieUrl == null) {
                Result.failure(Exception("Erro ao fazer upload dos documentos necess√°rios"))
            } else {
                Result.success(Unit)
            }
        } catch (e: Exception) {
            Log.e("IdentityVerificationViewModel", "Erro ao fazer upload dos documentos: ${e.message}", e)
            Result.failure(e)
        }
    }
    
    /**
     * Verifica se a selfie corresponde ao documento usando valida√ß√£o facial
     */
    suspend fun verifyFaceMatch(): Boolean {
        val state = _uiState.value
        // Garantir que temos URI do documento. Se n√£o, tentar baixar pela URL salva no Firestore
        val docUri = state.documentFrontUri ?: run {
            val url = state.documentFrontUrl ?: tryFetchUserDocumentFrontUrl() ?: run {
                _uiState.value = _uiState.value.copy(
                    faceVerificationSuccess = false,
                    faceVerificationError = "Documento n√£o encontrado. Por favor, fa√ßa upload do documento primeiro."
                )
                return false
            }
            val downloaded = tryDownloadToCache(url) ?: run {
                _uiState.value = _uiState.value.copy(
                    faceVerificationSuccess = false,
                    faceVerificationError = "Erro ao baixar documento para valida√ß√£o."
                )
                return false
            }
            _uiState.value = _uiState.value.copy(documentFrontUri = downloaded)
            downloaded
        }
        val selfie = state.selfieUri ?: run {
            _uiState.value = _uiState.value.copy(
                faceVerificationSuccess = false,
                faceVerificationError = "Selfie n√£o encontrada."
            )
            return false
        }

        return try {
            _uiState.value = state.copy(
                isVerifyingFace = true, 
                faceVerificationResult = null,
                faceVerificationSuccess = null,
                faceVerificationError = null
            )
            
            val result = faceVerificationManager.compareFaces(
                selfieUri = selfie,
                documentUri = docUri
            )
            
            _uiState.value = state.copy(
                isVerifyingFace = false,
                faceVerificationResult = result.message,
                faceVerificationSuccess = result.success,
                faceVerificationError = if (result.success) null else result.message
            )
            
            result.success
        } catch (e: Exception) {
            Log.e("IdentityVerificationViewModel", "Erro na verifica√ß√£o facial: ${e.message}", e)
            val errorMsg = "Erro na verifica√ß√£o facial: ${e.message}"
            _uiState.value = state.copy(
                isVerifyingFace = false,
                faceVerificationResult = errorMsg,
                faceVerificationSuccess = false,
                faceVerificationError = errorMsg
            )
            false
        }
    }
    
    /**
     * Limpa o estado de erro da verifica√ß√£o facial para permitir nova tentativa
     */
    fun clearFaceVerificationError() {
        _uiState.value = _uiState.value.copy(
            faceVerificationSuccess = null,
            faceVerificationError = null
        )
    }

    private suspend fun tryFetchUserDocumentFrontUrl(): String? {
        val currentUser = auth.currentUser ?: return null
        return try {
            val user = firestoreRepository.getUser(currentUser.uid)
            user?.documentFront
        } catch (e: Exception) {
            Log.e("IdentityVerificationViewModel", "Erro ao buscar URL do documento: ${e.message}", e)
            null
        }
    }

    private suspend fun tryDownloadToCache(url: String): Uri? {
        return try {
            kotlinx.coroutines.withContext(kotlinx.coroutines.Dispatchers.IO) {
                val input = java.net.URL(url).openStream()
                val file = java.io.File(context.cacheDir, "doc_front_${System.currentTimeMillis()}.jpg")
                file.outputStream().use { out -> input.copyTo(out) }
                Uri.fromFile(file)
            }
        } catch (e: Exception) {
            Log.e("IdentityVerificationViewModel", "Erro ao baixar documento: ${e.message}", e)
            null
        }
    }

    fun markIdentityVerified(onComplete: (Boolean) -> Unit = {}) {
        val currentUser = auth.currentUser ?: return onComplete(false)
        viewModelScope.launch {
            try {
                val user = firestoreRepository.getUser(currentUser.uid)
                if (user == null) {
                    onComplete(false); return@launch
                }
                val updated = user.copy(
                    verified = true,
                    updatedAt = Date()
                )
                firestoreRepository.updateUser(updated).fold(
                    onSuccess = {
                        onComplete(true)
                    },
                    onFailure = {
                        onComplete(false)
                    }
                )
            } catch (e: Exception) {
                Log.e("IdentityVerificationViewModel", "Erro ao marcar verificado: ${e.message}", e)
                onComplete(false)
            }
        }
    }
    
    fun submitVerification() {
        val currentUser = auth.currentUser ?: run {
            _uiState.value = _uiState.value.copy(
                errorMessage = "Usu√°rio n√£o autenticado"
            )
            return
        }
        
        val state = _uiState.value
        if (state.documentFrontUri == null || state.documentBackUri == null || state.selfieUri == null) {
            _uiState.value = state.copy(
                errorMessage = "Por favor, envie todos os documentos necess√°rios"
            )
            return
        }
        
        _uiState.value = state.copy(isLoading = true, errorMessage = null)
        
        viewModelScope.launch {
            try {
                // Verificar correspond√™ncia facial antes de fazer upload
                val faceMatch = verifyFaceMatch()
                if (!faceMatch) {
                    _uiState.value = _uiState.value.copy(
                        isLoading = false,
                        errorMessage = "A selfie n√£o corresponde ao documento. Por favor, tire uma nova selfie segurando seu documento."
                    )
                    return@launch
                }
                
                // Upload documentos
                val documentFrontResult = storageRepository.uploadDocument(
                    currentUser.uid,
                    "front",
                    state.documentFrontUri!!
                )
                
                val documentBackResult = storageRepository.uploadDocument(
                    currentUser.uid,
                    "back",
                    state.documentBackUri!!
                )
                
                val selfieResult = storageRepository.uploadSelfie(
                    currentUser.uid,
                    state.selfieUri!!
                )
                
                val addressProofResult = state.addressProofUri?.let {
                    storageRepository.uploadAddressProof(currentUser.uid, it)
                }
                
                // Verificar se todos os uploads foram bem-sucedidos
                val documentFrontUrl = documentFrontResult.getOrNull()
                val documentBackUrl = documentBackResult.getOrNull()
                val selfieUrl = selfieResult.getOrNull()
                val addressProofUrl = addressProofResult?.getOrNull()
                
                if (documentFrontUrl == null || documentBackUrl == null || selfieUrl == null) {
                    _uiState.value = _uiState.value.copy(
                        isLoading = false,
                        errorMessage = "Erro ao fazer upload dos documentos. Tente novamente."
                    )
                    return@launch
                }
                
                // Atualizar Firestore
                val user = firestoreRepository.getUser(currentUser.uid)
                val updatedUser = user?.copy(
                    documentFront = documentFrontUrl,
                    documentBack = documentBackUrl,
                    selfie = selfieUrl,
                    addressProof = addressProofUrl,
                    updatedAt = Date()
                ) ?: run {
                    _uiState.value = _uiState.value.copy(
                        isLoading = false,
                        errorMessage = "Usu√°rio n√£o encontrado"
                    )
                    return@launch
                }
                
                firestoreRepository.updateUser(updatedUser).fold(
                    onSuccess = {
                        // Chamar Cloud Function para processar verifica√ß√£o facial
                        val verificationResult = functionsService.startIdentityVerification(
                            documentFrontUrl = documentFrontUrl,
                            documentBackUrl = documentBackUrl,
                            selfieUrl = selfieUrl,
                            addressProofUrl = addressProofUrl
                        )
                        
                        verificationResult.fold(
                            onSuccess = { data ->
                                val success = data["success"] as? Boolean ?: false
                                _uiState.value = _uiState.value.copy(
                                    isLoading = false,
                                    isSuccess = success,
                                    documentFrontUrl = documentFrontUrl,
                                    documentBackUrl = documentBackUrl,
                                    selfieUrl = selfieUrl,
                                    addressProofUrl = addressProofUrl
                                )
                                Log.d("IdentityVerificationViewModel", "Verifica√ß√£o processada com sucesso")
                            },
                            onFailure = { exception ->
                                // Mesmo se a fun√ß√£o falhar, os documentos foram salvos
                                _uiState.value = _uiState.value.copy(
                                    isLoading = false,
                                    isSuccess = true, // Documentos salvos, verifica√ß√£o ser√° processada em background
                                    documentFrontUrl = documentFrontUrl,
                                    documentBackUrl = documentBackUrl,
                                    selfieUrl = selfieUrl,
                                    addressProofUrl = addressProofUrl,
                                    errorMessage = "Documentos salvos, mas verifica√ß√£o ser√° processada em background"
                                )
                                Log.w("IdentityVerificationViewModel", "Fun√ß√£o de verifica√ß√£o falhou, mas documentos foram salvos", exception)
                            }
                        )
                    },
                    onFailure = { exception ->
                        _uiState.value = _uiState.value.copy(
                            isLoading = false,
                            errorMessage = "Erro ao salvar documentos: ${exception.message}"
                        )
                        Log.e("IdentityVerificationViewModel", "Erro ao salvar documentos", exception)
                    }
                )
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    errorMessage = "Erro inesperado: ${e.message}"
                )
                Log.e("IdentityVerificationViewModel", "Erro inesperado", e)
            }
        }
    }
    
    override fun onCleared() {
        super.onCleared()
        faceVerificationManager.release()
    }
}



```

## [FRONTEND]: feature/auth/presentation/LoginPersonScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.auth.presentation

import android.content.Intent
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Visibility
import androidx.compose.material.icons.filled.VisibilityOff
import androidx.compose.material3.*
import android.util.Log
import androidx.compose.runtime.*
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.hilt.navigation.compose.hiltViewModel
import com.taskgoapp.taskgo.feature.auth.presentation.LoginViewModel
import com.taskgoapp.taskgo.data.repository.GoogleSignInHelper
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.input.PasswordVisualTransformation
import androidx.compose.ui.text.input.VisualTransformation
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.taskgoapp.taskgo.core.design.TGIcons
import com.taskgoapp.taskgo.core.theme.TaskGoGreen
import com.taskgoapp.taskgo.core.theme.TaskGoTextBlack
import com.taskgoapp.taskgo.core.theme.TaskGoTextGray
import com.taskgoapp.taskgo.core.theme.TaskGoBackgroundWhite
import com.taskgoapp.taskgo.core.theme.FigmaTitleLarge
import com.taskgoapp.taskgo.core.theme.FigmaProductDescription
import com.taskgoapp.taskgo.core.theme.FigmaButtonText
import com.taskgoapp.taskgo.core.biometric.BiometricManager
import com.taskgoapp.taskgo.core.design.AccountTypeSelectionDialog
import com.taskgoapp.taskgo.core.model.AccountType

@Composable
fun LoginPersonScreen(
    onNavigateToStoreLogin: () -> Unit,
    onNavigateToSignUp: () -> Unit,
    onNavigateToHome: () -> Unit,
    onNavigateToForgotPassword: () -> Unit,
    onNavigateToTwoFactor: () -> Unit = {},
    onNavigateToIdentityVerification: () -> Unit = {}
) {
    var email by remember { mutableStateOf("") }
    var password by remember { mutableStateOf("") }
    var passwordVisible by remember { mutableStateOf(false) }
    
    val loginViewModel: LoginViewModel = hiltViewModel()
    val loginUiState = loginViewModel.uiState.collectAsState()
    val context = LocalContext.current
    val activity = context as? androidx.fragment.app.FragmentActivity
    val biometricManager = remember { 
        BiometricManager(context)
    }
    val googleSignInHelper = remember { 
        GoogleSignInHelper(context.applicationContext)
    }
    
    // Verificar disponibilidade de biometria
    val biometricStatus = remember { 
        biometricManager.isBiometricAvailable()
    }
    val biometricAvailable = biometricStatus == com.taskgoapp.taskgo.core.biometric.BiometricStatus.AVAILABLE
    
    // Verificar se biometria est√° dispon√≠vel e se activity √© FragmentActivity
    val canUseBiometric = biometricAvailable && activity != null
    
    val googleSignInLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.StartActivityForResult()
    ) { result ->
        Log.d("LoginPersonScreen", "Resultado do Google Sign-In recebido")
        val account = googleSignInHelper.getSignInResultFromIntent(result.data)
        if (account != null) {
            Log.d("LoginPersonScreen", "Conta Google obtida: ${account.email}")
            account.idToken?.let { idToken ->
                Log.d("LoginPersonScreen", "ID Token obtido, iniciando login...")
                loginViewModel.signInWithGoogle(idToken)
            } ?: run {
                Log.e("LoginPersonScreen", "ID Token √© null")
                // Atualizar UI state com erro manualmente
                // Como o loginViewModel n√£o tem um m√©todo para setar erro diretamente,
                // vamos apenas logar o erro
            }
        } else {
            Log.e("LoginPersonScreen", "Falha ao obter conta do Google Sign-In")
        }
    }

    Box(
        modifier = Modifier
            .fillMaxSize()
            .background(TaskGoBackgroundWhite)
    ) {
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(24.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Spacer(modifier = Modifier.height(60.dp))
            
            // Logo TaskGo Horizontal
            Image(
                painter = painterResource(id = TGIcons.TaskGoLogoHorizontal),
                contentDescription = "TaskGo Logo",
                modifier = Modifier.size(120.dp, 40.dp)
            )
            
            Spacer(modifier = Modifier.height(40.dp))
            
            // T√≠tulo
            Text(
                text = "Login",
                style = FigmaTitleLarge,
                color = TaskGoTextBlack
            )
            
            Spacer(modifier = Modifier.height(40.dp))
            
            // Bot√£o de Biometria (se dispon√≠vel)
            if (canUseBiometric) {
                OutlinedButton(
                    onClick = {
                        if (activity != null) {
                            loginViewModel.loginWithBiometric(
                                biometricManager = biometricManager,
                                activity = activity,
                                onBiometricNotAvailable = {
                                    // N√£o h√° email salvo, mostrar mensagem
                                }
                            )
                        }
                    },
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(56.dp),
                    shape = RoundedCornerShape(8.dp),
                    colors = ButtonDefaults.outlinedButtonColors(
                        contentColor = TaskGoGreen
                    ),
                    border = ButtonDefaults.outlinedButtonBorder.copy(
                        width = 1.dp,
                        brush = androidx.compose.ui.graphics.SolidColor(TaskGoGreen)
                    )
                ) {
                    Icon(
                        painter = painterResource(TGIcons.Phone), // Usando √≠cone tempor√°rio, pode ser substitu√≠do
                        contentDescription = "Biometria",
                        tint = TaskGoGreen,
                        modifier = Modifier.size(24.dp)
                    )
                    Spacer(modifier = Modifier.width(12.dp))
                    Text(
                        text = "Entrar com Biometria",
                        style = FigmaButtonText,
                        color = TaskGoGreen
                    )
                }
                
                Spacer(modifier = Modifier.height(16.dp))
                
                // Divisor
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    HorizontalDivider(
                        modifier = Modifier.weight(1f),
                        color = Color(0xFFD9D9D9),
                        thickness = 1.dp
                    )
                    Text(
                        text = "ou",
                        style = FigmaProductDescription,
                        color = TaskGoTextGray,
                        modifier = Modifier.padding(horizontal = 16.dp)
                    )
                    HorizontalDivider(
                        modifier = Modifier.weight(1f),
                        color = Color(0xFFD9D9D9),
                        thickness = 1.dp
                    )
                }
                
                Spacer(modifier = Modifier.height(16.dp))
            }
            
            // Campo E-mail
            com.taskgoapp.taskgo.core.design.EnhancedOutlinedTextField(
                value = email,
                onValueChange = { email = it },
                label = { Text("E-mail", style = FigmaProductDescription, color = TaskGoTextGray) },
                modifier = Modifier
                    .fillMaxWidth()
                    .height(56.dp),
                keyboardType = KeyboardType.Email
            )
            
            Spacer(modifier = Modifier.height(16.dp))
            
            // Campo Senha
            OutlinedTextField(
                value = password,
                onValueChange = { password = it },
                label = { Text("Senha", style = FigmaProductDescription, color = TaskGoTextGray) },
                modifier = Modifier
                    .fillMaxWidth()
                    .height(56.dp),
                shape = RoundedCornerShape(8.dp),
                colors = OutlinedTextFieldDefaults.colors(
                    focusedBorderColor = TaskGoGreen,
                    unfocusedBorderColor = Color(0xFFD9D9D9),
                    focusedLabelColor = TaskGoTextGray,
                    unfocusedLabelColor = TaskGoTextGray,
                    cursorColor = TaskGoGreen
                ),
                visualTransformation = if (passwordVisible) VisualTransformation.None else PasswordVisualTransformation(),
                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Password),
                textStyle = androidx.compose.ui.text.TextStyle(
                    lineHeight = androidx.compose.ui.unit.TextUnit(24f, androidx.compose.ui.unit.TextUnitType.Sp)
                ),
                trailingIcon = {
                    IconButton(onClick = { passwordVisible = !passwordVisible }) {
                        Icon(
                            imageVector = if (passwordVisible) Icons.Filled.Visibility else Icons.Filled.VisibilityOff,
                            contentDescription = if (passwordVisible) "Ocultar senha" else "Mostrar senha",
                            tint = TaskGoTextGray
                        )
                    }
                }
            )
            
            Spacer(modifier = Modifier.height(8.dp))
            
            // Esqueci minha senha
            Text(
                text = "Esqueci minha senha",
                color = TaskGoGreen,
                fontSize = 14.sp,
                modifier = Modifier
                    .align(Alignment.End)
                    .clickable { onNavigateToForgotPassword() }
            )
            
            Spacer(modifier = Modifier.height(32.dp))
            
            // Bot√£o Entrar
            Button(
                onClick = { 
                    Log.d("LoginPersonScreen", "Bot√£o Entrar clicado para: $email")
                    loginViewModel.login(email, password)
                },
                modifier = Modifier
                    .fillMaxWidth()
                    .height(56.dp),
                shape = RoundedCornerShape(8.dp),
                colors = ButtonDefaults.buttonColors(
                    containerColor = TaskGoGreen
                ),
                enabled = !loginUiState.value.isLoading && email.isNotEmpty() && password.isNotEmpty()
            ) {
                if (loginUiState.value.isLoading) {
                    CircularProgressIndicator(
                        color = Color.White,
                        modifier = Modifier.size(20.dp)
                    )
                } else {
                    Text(
                        text = "Entrar",
                        color = Color.White,
                        fontSize = 16.sp,
                        fontWeight = FontWeight.Bold
                    )
                }
            }
            
            // Mensagem de erro
            loginUiState.value.errorMessage?.let { errorMsg ->
                Spacer(modifier = Modifier.height(12.dp))
                Text(
                    text = errorMsg,
                    color = MaterialTheme.colorScheme.error,
                    fontSize = 14.sp,
                    textAlign = TextAlign.Center,
                    modifier = Modifier.fillMaxWidth()
                )
            }
            
            // Dialog de sele√ß√£o de AccountType (para novo usu√°rio Google)
            if (loginUiState.value.showAccountTypeDialog) {
                AccountTypeSelectionDialog(
                    onAccountTypeSelected = { accountType ->
                        loginViewModel.createUserWithAccountType(accountType)
                    },
                    onDismiss = {
                        loginViewModel.cancelAccountTypeSelection()
                    }
                )
            }
            
            // Navega√ß√£o ap√≥s sucesso ou quando 2FA √© necess√°rio
            LaunchedEffect(loginUiState.value.isSuccess, loginUiState.value.requiresTwoFactor) {
                if (loginUiState.value.requiresTwoFactor) {
                    Log.d("LoginPersonScreen", "2FA necess√°rio, navegando para verifica√ß√£o...")
                    kotlinx.coroutines.delay(300)
                    onNavigateToTwoFactor()
                } else if (loginUiState.value.isSuccess) {
                    Log.d("LoginPersonScreen", "Login bem-sucedido, navegando para home...")
                    // Aguardar um pouco para garantir que tudo est√° sincronizado
                    kotlinx.coroutines.delay(300)
                    onNavigateToHome()
                }
            }
            
            Spacer(modifier = Modifier.height(24.dp))
            
            // Divisor
            Row(
                modifier = Modifier.fillMaxWidth(),
                verticalAlignment = Alignment.CenterVertically
            ) {
                HorizontalDivider(
                    modifier = Modifier.weight(1f),
                    color = Color(0xFFD9D9D9),
                    thickness = 1.dp
                )
                Text(
                    text = "ou",
                    style = FigmaProductDescription,
                    color = TaskGoTextGray,
                    modifier = Modifier.padding(horizontal = 16.dp)
                )
                HorizontalDivider(
                    modifier = Modifier.weight(1f),
                    color = Color(0xFFD9D9D9),
                    thickness = 1.dp
                )
            }
            
            Spacer(modifier = Modifier.height(24.dp))
            
            // Bot√£o Entrar com Google
            OutlinedButton(
                onClick = { 
                    googleSignInLauncher.launch(googleSignInHelper.getSignInIntent())
                },
                modifier = Modifier
                    .fillMaxWidth()
                    .height(56.dp),
                shape = RoundedCornerShape(8.dp),
                colors = ButtonDefaults.outlinedButtonColors(
                    contentColor = TaskGoTextBlack
                ),
                border = androidx.compose.foundation.BorderStroke(1.dp, Color(0xFFD9D9D9))
            ) {
                Icon(
                    painter = painterResource(TGIcons.Google),
                    contentDescription = "Google",
                    modifier = Modifier.size(24.dp),
                    tint = Color.Unspecified
                )
                Spacer(modifier = Modifier.width(12.dp))
                Text(
                    text = "Entrar com Google",
                    style = FigmaButtonText,
                    color = TaskGoTextBlack
                )
            }
            
            Spacer(modifier = Modifier.height(16.dp))
            
            // Bot√£o Criar Conta
            OutlinedButton(
                onClick = { onNavigateToSignUp() },
                modifier = Modifier
                    .fillMaxWidth()
                    .height(56.dp),
                shape = RoundedCornerShape(8.dp),
                colors = ButtonDefaults.outlinedButtonColors(
                    contentColor = TaskGoTextBlack
                ),
                border = ButtonDefaults.outlinedButtonBorder.copy(
                    width = 1.dp
                )
            ) {
                Text(
                    text = "Criar Conta",
                    style = FigmaButtonText
                )
            }
            
            Spacer(modifier = Modifier.height(32.dp))
            
            // Link para Login de Prestador
            Text(
                text = "Sou parceiro",
                color = TaskGoGreen,
                fontSize = 14.sp,
                modifier = Modifier.clickable { onNavigateToStoreLogin() }
            )
        }
    }
}

```

## [FRONTEND]: feature/auth/presentation/LoginStoreScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.auth.presentation

import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Visibility
import androidx.compose.material.icons.filled.VisibilityOff
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.hilt.navigation.compose.hiltViewModel
import com.taskgoapp.taskgo.feature.auth.presentation.LoginViewModel
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.input.PasswordVisualTransformation
import androidx.compose.ui.text.input.VisualTransformation
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import android.util.Log
import kotlinx.coroutines.delay
import com.taskgoapp.taskgo.core.design.TGIcons
import com.taskgoapp.taskgo.core.design.EnhancedOutlinedTextField
import com.taskgoapp.taskgo.core.theme.TaskGoGreen
import com.taskgoapp.taskgo.core.theme.TaskGoTextBlack
import com.taskgoapp.taskgo.core.theme.TaskGoTextGray
import com.taskgoapp.taskgo.core.theme.TaskGoBackgroundWhite
import com.taskgoapp.taskgo.core.theme.FigmaTitleLarge
import com.taskgoapp.taskgo.core.theme.FigmaProductDescription
import com.taskgoapp.taskgo.core.theme.FigmaButtonText

@Composable
fun LoginStoreScreen(
    onNavigateToPersonLogin: () -> Unit,
    onNavigateToSignUp: () -> Unit,
    onNavigateToHome: () -> Unit,
    onNavigateToForgotPassword: () -> Unit,
    onNavigateToTwoFactor: () -> Unit = {}
) {
    var email by remember { mutableStateOf("") }
    var password by remember { mutableStateOf("") }
    var passwordVisible by remember { mutableStateOf(false) }

    Box(
        modifier = Modifier
            .fillMaxSize()
            .background(TaskGoBackgroundWhite)
    ) {
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(24.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Spacer(modifier = Modifier.height(60.dp))
            
            // Logo TaskGo Horizontal
            Image(
                painter = painterResource(id = TGIcons.TaskGoLogoHorizontal),
                contentDescription = "TaskGo Logo",
                modifier = Modifier.size(120.dp, 40.dp)
            )
            
            Spacer(modifier = Modifier.height(40.dp))
            
            // T√≠tulo
            Text(
                text = "Sou parceiro",
                style = FigmaTitleLarge,
                color = TaskGoTextBlack
            )
            
            Spacer(modifier = Modifier.height(40.dp))
            
            // Campo CPF/CNPJ (em vez de email)
            var documentError by remember { mutableStateOf<String?>(null) }
            val documentValidator = remember { com.taskgoapp.taskgo.core.validation.DocumentValidator() }
            
            EnhancedOutlinedTextField(
                value = email, // Reutilizando vari√°vel email para CPF/CNPJ
                onValueChange = { newValue ->
                    // Remove caracteres n√£o num√©ricos
                    val cleanValue = newValue.replace(Regex("[^0-9]"), "")
                    if (cleanValue.length <= 14) {
                        email = cleanValue
                        // Formata e valida quando tiver tamanho completo
                        if (cleanValue.length == 11) {
                            email = documentValidator.formatCpf(cleanValue)
                            val validation = documentValidator.validateCpf(email)
                            documentError = if (validation is com.taskgoapp.taskgo.core.validation.ValidationResult.Invalid) validation.message else null
                        } else if (cleanValue.length == 14) {
                            email = documentValidator.formatCnpj(cleanValue)
                            val validation = documentValidator.validateCnpj(email)
                            documentError = if (validation is com.taskgoapp.taskgo.core.validation.ValidationResult.Invalid) validation.message else null
                        } else {
                            documentError = null
                        }
                    }
                },
                label = { Text("CPF ou CNPJ", style = FigmaProductDescription, color = TaskGoTextGray) },
                placeholder = { Text("000.000.000-00 ou 00.000.000/0000-00", color = TaskGoTextGray) },
                isError = documentError != null,
                supportingText = documentError?.let { { Text(it, color = MaterialTheme.colorScheme.error) } },
                modifier = Modifier
                    .fillMaxWidth(),
                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
                singleLine = false,
                maxLines = 3
            )
            
            Spacer(modifier = Modifier.height(16.dp))
            
            // Campo Senha
            OutlinedTextField(
                value = password,
                onValueChange = { password = it },
                label = { Text("Senha", style = FigmaProductDescription, color = TaskGoTextGray) },
                modifier = Modifier.fillMaxWidth(),
                shape = RoundedCornerShape(8.dp),
                colors = OutlinedTextFieldDefaults.colors(
                    focusedBorderColor = TaskGoGreen,
                    unfocusedBorderColor = Color(0xFFD9D9D9),
                    focusedLabelColor = TaskGoTextGray,
                    unfocusedLabelColor = TaskGoTextGray,
                    cursorColor = TaskGoGreen
                ),
                visualTransformation = if (passwordVisible) VisualTransformation.None else PasswordVisualTransformation(),
                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Password),
                textStyle = androidx.compose.ui.text.TextStyle(
                    lineHeight = androidx.compose.ui.unit.TextUnit(20f, androidx.compose.ui.unit.TextUnitType.Sp)
                ),
                trailingIcon = {
                    IconButton(onClick = { passwordVisible = !passwordVisible }) {
                        Icon(
                            imageVector = if (passwordVisible) Icons.Filled.Visibility else Icons.Filled.VisibilityOff,
                            contentDescription = if (passwordVisible) "Ocultar senha" else "Mostrar senha",
                            tint = TaskGoTextGray
                        )
                    }
                },
                singleLine = false,
                maxLines = 3
            )
            
            Spacer(modifier = Modifier.height(8.dp))
            
            // Esqueci minha senha
            Text(
                text = "Esqueci minha senha",
                color = TaskGoGreen,
                fontSize = 14.sp,
                modifier = Modifier
                    .align(Alignment.End)
                    .clickable { onNavigateToForgotPassword() }
            )
            
            Spacer(modifier = Modifier.height(32.dp))
            
            // Bot√£o Entrar
            val loginViewModel: LoginViewModel = hiltViewModel()
            val loginUiState = loginViewModel.uiState.collectAsState()
            
            Button(
                onClick = { 
                    // Validar CPF/CNPJ antes de fazer login
                    val cleanDocument = email.replace(Regex("[^0-9]"), "")
                    if (cleanDocument.length == 11 || cleanDocument.length == 14) {
                        loginViewModel.loginWithDocument(email, password)
                    } else {
                        // Se n√£o for CPF/CNPJ v√°lido, tentar como email (fallback)
                        loginViewModel.login(email, password)
                    }
                },
                modifier = Modifier
                    .fillMaxWidth()
                    .height(56.dp),
                shape = RoundedCornerShape(8.dp),
                colors = ButtonDefaults.buttonColors(
                    containerColor = TaskGoGreen
                ),
                enabled = !loginUiState.value.isLoading && email.isNotEmpty() && password.isNotEmpty()
            ) {
                if (loginUiState.value.isLoading) {
                    CircularProgressIndicator(
                        color = Color.White,
                        modifier = Modifier.size(20.dp)
                    )
                } else {
                    Text(
                        text = "Entrar",
                        color = Color.White,
                        fontSize = 16.sp,
                        fontWeight = FontWeight.Bold
                    )
                }
            }
            
            // Mensagem de erro
            loginUiState.value.errorMessage?.let { errorMsg ->
                Spacer(modifier = Modifier.height(12.dp))
                Text(
                    text = errorMsg,
                    color = MaterialTheme.colorScheme.error,
                    fontSize = 14.sp,
                    textAlign = androidx.compose.ui.text.style.TextAlign.Center,
                    modifier = Modifier.fillMaxWidth()
                )
            }
            
            // Navega√ß√£o ap√≥s sucesso ou quando 2FA √© necess√°rio
            LaunchedEffect(loginUiState.value.isSuccess, loginUiState.value.requiresTwoFactor) {
                if (loginUiState.value.requiresTwoFactor) {
                    Log.d("LoginStoreScreen", "2FA necess√°rio, navegando para verifica√ß√£o...")
                    kotlinx.coroutines.delay(300)
                    onNavigateToTwoFactor()
                } else if (loginUiState.value.isSuccess) {
                    Log.d("LoginStoreScreen", "Login bem-sucedido, navegando para home...")
                    kotlinx.coroutines.delay(300)
                    onNavigateToHome()
                }
            }
            
            Spacer(modifier = Modifier.height(24.dp))
            
            // Divisor
            Row(
                modifier = Modifier.fillMaxWidth(),
                verticalAlignment = Alignment.CenterVertically
            ) {
                HorizontalDivider(
                    modifier = Modifier.weight(1f),
                    color = Color(0xFFD9D9D9),
                    thickness = 1.dp
                )
                Text(
                    text = "ou",
                    style = FigmaProductDescription,
                    color = TaskGoTextGray,
                    modifier = Modifier.padding(horizontal = 16.dp)
                )
                HorizontalDivider(
                    modifier = Modifier.weight(1f),
                    color = Color(0xFFD9D9D9),
                    thickness = 1.dp
                )
            }
            
            Spacer(modifier = Modifier.height(24.dp))
            
            // Bot√£o Cadastrar
            OutlinedButton(
                onClick = { onNavigateToSignUp() },
                modifier = Modifier
                    .fillMaxWidth()
                    .height(56.dp),
                shape = RoundedCornerShape(8.dp),
                colors = ButtonDefaults.outlinedButtonColors(
                    contentColor = TaskGoTextBlack
                ),
                border = ButtonDefaults.outlinedButtonBorder.copy(
                    width = 1.dp
                )
            ) {
                Text(
                    text = "Cadastrar",
                    style = FigmaButtonText
                )
            }
            
            Spacer(modifier = Modifier.height(32.dp))
            
            // Link para Login de Cliente
            Text(
                text = "Sou cliente",
                color = TaskGoGreen,
                fontSize = 14.sp,
                modifier = Modifier.clickable { onNavigateToPersonLogin() }
            )
        }
    }
}
```

## [FRONTEND]: feature/auth/presentation/LoginViewModel.kt

```kotlin
package com.taskgoapp.taskgo.feature.auth.presentation

import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.taskgoapp.taskgo.data.repository.FirebaseAuthRepository
import com.taskgoapp.taskgo.data.repository.FirestoreUserRepository
import com.taskgoapp.taskgo.data.firestore.models.UserFirestore
import com.taskgoapp.taskgo.core.model.AccountType
import com.google.firebase.auth.GoogleAuthProvider
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.tasks.await
import java.util.Date

data class LoginUiState(
    val isLoading: Boolean = false,
    val errorMessage: String? = null,
    val isSuccess: Boolean = false,
    val requiresTwoFactor: Boolean = false,
    val showAccountTypeDialog: Boolean = false
)

@HiltViewModel
class LoginViewModel @Inject constructor(
    private val authRepository: FirebaseAuthRepository,
    private val firestoreUserRepository: FirestoreUserRepository,
    private val initialDataSyncManager: com.taskgoapp.taskgo.core.sync.InitialDataSyncManager,
    private val preferencesManager: com.taskgoapp.taskgo.data.local.datastore.PreferencesManager,
    private val firebaseFunctionsService: com.taskgoapp.taskgo.data.firebase.FirebaseFunctionsService
) : ViewModel() {

    private val _uiState = MutableStateFlow(LoginUiState())
    val uiState: StateFlow<LoginUiState> = _uiState
    
    // Armazenar temporariamente o firebaseUser quando mostrar dialog de AccountType
    private var pendingFirebaseUser: com.google.firebase.auth.FirebaseUser? = null

    /**
     * Login com CPF/CNPJ - busca o email associado ao documento e faz login
     * Apenas para parceiros (role = "partner" ou "provider" - legacy)
     */
    fun loginWithDocument(document: String, password: String) {
        if (_uiState.value.isLoading) {
            Log.d("LoginViewModel", "Login j√° em progresso, ignorando requisi√ß√£o")
            return
        }
        
        Log.d("LoginViewModel", "Iniciando login com documento: $document")
        _uiState.value = LoginUiState(isLoading = true, errorMessage = null, isSuccess = false, requiresTwoFactor = false)
        
        viewModelScope.launch {
            try {
                // CR√çTICO: Usar Cloud Function para buscar email por CPF/CNPJ
                // Isso permite busca sem autentica√ß√£o (necess√°rio para login)
                Log.d("LoginViewModel", "Buscando email por CPF/CNPJ via Cloud Function: $document")
                val result = firebaseFunctionsService.getUserEmailByDocument(document)
                
                result.fold(
                    onSuccess = { data ->
                        val email = data["email"] as? String
                        val role = data["role"] as? String
                        
                        if (email.isNullOrBlank()) {
                            _uiState.value = LoginUiState(
                                isLoading = false,
                                errorMessage = "CPF/CNPJ n√£o encontrado. Verifique se voc√™ j√° possui cadastro.",
                                isSuccess = false,
                                requiresTwoFactor = false
                            )
                            return@fold
                        }
                        
                        // Verificar se √© parceiro (j√° validado na Cloud Function, mas verificar novamente)
                        val userRole = role?.lowercase() ?: ""
                        if (userRole != "partner" && userRole != "provider") {
                            Log.w("LoginViewModel", "Tentativa de login com CPF para usu√°rio que n√£o √© parceiro. Role: $userRole")
                            _uiState.value = LoginUiState(
                                isLoading = false,
                                errorMessage = "Este CPF/CNPJ n√£o est√° cadastrado como parceiro. Use email e senha para fazer login.",
                                isSuccess = false,
                                requiresTwoFactor = false
                            )
                            return@fold
                        }
                        
                        // Fazer login com o email encontrado - o m√©todo login() j√° verifica 2FA
                        Log.d("LoginViewModel", "Email encontrado para documento: $email, Role: $role")
                        login(email, password)
                    },
                    onFailure = { exception ->
                        Log.e("LoginViewModel", "Erro ao buscar email por documento: ${exception.message}", exception)
                        val errorMessage = when (exception) {
                            is com.google.firebase.functions.FirebaseFunctionsException -> {
                                when (exception.code) {
                                    com.google.firebase.functions.FirebaseFunctionsException.Code.NOT_FOUND -> {
                                        "CPF/CNPJ n√£o encontrado. Verifique se voc√™ j√° possui cadastro."
                                    }
                                    com.google.firebase.functions.FirebaseFunctionsException.Code.FAILED_PRECONDITION -> {
                                        exception.message ?: "Este CPF/CNPJ n√£o est√° cadastrado como parceiro."
                                    }
                                    com.google.firebase.functions.FirebaseFunctionsException.Code.INVALID_ARGUMENT -> {
                                        exception.message ?: "CPF/CNPJ inv√°lido. Verifique o formato."
                                    }
                                    else -> {
                                        "Erro ao buscar usu√°rio. Tente novamente."
                                    }
                                }
                            }
                            else -> {
                                "Erro ao buscar usu√°rio. Tente novamente."
                            }
                        }
                        _uiState.value = LoginUiState(
                            isLoading = false,
                            errorMessage = errorMessage,
                            isSuccess = false,
                            requiresTwoFactor = false
                        )
                    }
                )
            } catch (e: Exception) {
                Log.e("LoginViewModel", "Erro inesperado ao buscar usu√°rio por documento: ${e.message}", e)
                _uiState.value = LoginUiState(
                    isLoading = false,
                    errorMessage = "Erro ao buscar usu√°rio. Tente novamente.",
                    isSuccess = false,
                    requiresTwoFactor = false
                )
            }
        }
    }
    
    fun login(email: String, password: String) {
        if (_uiState.value.isLoading) {
            Log.d("LoginViewModel", "Login j√° em progresso, ignorando requisi√ß√£o")
            return
        }
        
        Log.d("LoginViewModel", "Iniciando login para: $email")
        _uiState.value = LoginUiState(isLoading = true, errorMessage = null, isSuccess = false)
        
        viewModelScope.launch {
            try {
                // Garantir que Firebase Auth est√° inicializado
                val auth = com.google.firebase.auth.FirebaseAuth.getInstance()
                if (auth.app == null) {
                    Log.e("LoginViewModel", "Firebase Auth n√£o inicializado")
                    _uiState.value = LoginUiState(
                        isLoading = false,
                        errorMessage = "Erro de autentica√ß√£o. Reinicie o app e tente novamente.",
                        isSuccess = false
                    )
                    return@launch
                }
                
                val result = authRepository.signInWithEmail(email.trim(), password)
                result.fold(
                    onSuccess = { firebaseUser ->
                        Log.d("LoginViewModel", "Login bem-sucedido: ${firebaseUser.uid}")
                        
                        // Salvar email para biometria
                        preferencesManager.saveEmailForBiometric(email.trim())
                        
                        // Verificar e criar usu√°rio no Firestore se necess√°rio
                        // J√° estamos dentro de viewModelScope.launch, ent√£o fazer diretamente
                        try {
                            var userFirestore: com.taskgoapp.taskgo.data.firestore.models.UserFirestore? = null
                            
                            val existingUser = firestoreUserRepository.getUser(firebaseUser.uid)
                            if (existingUser == null) {
                                // Criar usu√°rio no Firestore se n√£o existir
                                Log.d("LoginViewModel", "Criando perfil no Firestore...")
                                val newUser = UserFirestore(
                                    uid = firebaseUser.uid,
                                    email = firebaseUser.email ?: email.trim(),
                                    displayName = firebaseUser.displayName,
                                    photoURL = firebaseUser.photoUrl?.toString(),
                                    role = "client",
                                    profileComplete = false,
                                    verified = firebaseUser.isEmailVerified,
                                    createdAt = Date(),
                                    updatedAt = Date(),
                                    twoFactorEnabled = false
                                )
                                
                                firestoreUserRepository.updateUser(newUser).fold(
                                    onSuccess = {
                                        Log.d("LoginViewModel", "Perfil criado com sucesso no Firestore")
                                        userFirestore = newUser
                                        checkTwoFactorAndNavigate(userFirestore, firebaseUser)
                                    },
                                    onFailure = { exception ->
                                        Log.e("LoginViewModel", "Erro ao criar perfil no Firestore: ${exception.message}", exception)
                                        // Mesmo com erro, permitir login mas sem 2FA
                                        checkTwoFactorAndNavigate(null, firebaseUser)
                                    }
                                )
                            } else {
                                Log.d("LoginViewModel", "Usu√°rio j√° existe no Firestore: ${existingUser.displayName}, Role: ${existingUser.role}, 2FA: ${existingUser.twoFactorEnabled}")
                                
                                // Verificar se √© parceiro tentando fazer login via email
                                val existingUserRole = existingUser.role?.lowercase() ?: ""
                                if (existingUserRole == "partner" || existingUserRole == "provider") {
                                    // Parceiros devem usar CPF/CNPJ para login
                                    authRepository.signOut()
                                    _uiState.value = LoginUiState(
                                        isLoading = false,
                                        errorMessage = "Parceiros devem fazer login com CPF/CNPJ na tela de login de parceiro.",
                                        isSuccess = false,
                                        requiresTwoFactor = false
                                    )
                                    return@fold
                                }
                                
                                userFirestore = existingUser
                                checkTwoFactorAndNavigate(userFirestore, firebaseUser)
                            }
                        } catch (e: Exception) {
                            Log.e("LoginViewModel", "Erro ao verificar/criar usu√°rio no Firestore: ${e.message}", e)
                            // Em caso de erro, permitir login mas sem 2FA
                            checkTwoFactorAndNavigate(null, firebaseUser)
                        }
                    },
                    onFailure = { exception ->
                        Log.e("LoginViewModel", "Erro ao fazer login: ${exception.message}", exception)
                        Log.e("LoginViewModel", "Tipo de exce√ß√£o: ${exception.javaClass.name}")
                        Log.e("LoginViewModel", "Stack trace completo:", exception)
                        
                        val errorMsg = when {
                            // Erros espec√≠ficos do Firebase Auth primeiro
                            exception is com.google.firebase.auth.FirebaseAuthException -> {
                                Log.e("LoginViewModel", "C√≥digo de erro Firebase: ${exception.errorCode}")
                                when (exception.errorCode) {
                                    "ERROR_WRONG_PASSWORD" -> "Senha incorreta"
                                    "ERROR_USER_NOT_FOUND" -> "Usu√°rio n√£o encontrado"
                                    "ERROR_INVALID_EMAIL" -> "Email inv√°lido"
                                    "ERROR_USER_DISABLED" -> "Esta conta foi desabilitada"
                                    "ERROR_TOO_MANY_REQUESTS" -> "Muitas tentativas. Tente novamente mais tarde"
                                    "ERROR_OPERATION_NOT_ALLOWED" -> "Opera√ß√£o n√£o permitida"
                                    "ERROR_NETWORK_REQUEST_FAILED" -> "Erro de conex√£o. Verifique sua internet"
                                    else -> {
                                        // Mostrar mensagem real do Firebase quando poss√≠vel
                                        val firebaseMsg = exception.message
                                        if (firebaseMsg != null && firebaseMsg.isNotBlank()) {
                                            firebaseMsg
                                        } else {
                                            "Erro ao fazer login (${exception.errorCode})"
                                        }
                                    }
                                }
                            }
                            // Erros de rede espec√≠ficos
                            exception is com.google.firebase.FirebaseNetworkException -> "Erro de conex√£o com o Firebase. Verifique sua internet"
                            exception is java.net.UnknownHostException -> "Erro de conex√£o. Verifique sua internet"
                            exception is java.net.ConnectException -> "Erro de conex√£o. Verifique sua internet"
                            exception is java.net.SocketTimeoutException -> "Tempo de conex√£o esgotado. Verifique sua internet"
                            // Verificar mensagem de erro apenas se n√£o for exce√ß√£o espec√≠fica
                            exception.message?.contains("wrong-password", ignoreCase = true) == true -> "Senha incorreta"
                            exception.message?.contains("user-not-found", ignoreCase = true) == true -> "Usu√°rio n√£o encontrado"
                            exception.message?.contains("invalid-email", ignoreCase = true) == true -> "Email inv√°lido"
                            exception.message?.contains("network", ignoreCase = true) == true -> "Erro de conex√£o. Verifique sua internet"
                            exception.message?.contains("timeout", ignoreCase = true) == true -> "Tempo de conex√£o esgotado. Verifique sua internet"
                            // √öltimo recurso: mostrar mensagem real do erro
                            else -> {
                                val message = exception.message ?: "Falha ao fazer login"
                                Log.e("LoginViewModel", "Mensagem de erro n√£o tratada: $message")
                                message
                            }
                        }
                        _uiState.value = LoginUiState(isLoading = false, errorMessage = errorMsg, isSuccess = false, requiresTwoFactor = false)
                    }
                )
            } catch (e: Exception) {
                Log.e("LoginViewModel", "Erro inesperado no login: ${e.message}", e)
                _uiState.value = LoginUiState(
                    isLoading = false,
                    errorMessage = "Erro inesperado: ${e.message}",
                    isSuccess = false,
                    requiresTwoFactor = false
                )
            }
        }
    }
    
    /**
     * Verifica se 2FA est√° ativado e navega adequadamente
     */
    private fun checkTwoFactorAndNavigate(userFirestore: com.taskgoapp.taskgo.data.firestore.models.UserFirestore?, firebaseUser: com.google.firebase.auth.FirebaseUser) {
        // Verificar se 2FA est√° ativado
        val twoFactorEnabled = userFirestore?.twoFactorEnabled == true
        Log.d("LoginViewModel", "Verificando 2FA: enabled=$twoFactorEnabled, userFirestore=${userFirestore?.uid}")
        
        if (twoFactorEnabled) {
            Log.d("LoginViewModel", "2FA ativado, requer verifica√ß√£o - navegando para tela de 2FA")
            _uiState.value = LoginUiState(
                isLoading = false,
                isSuccess = false,
                requiresTwoFactor = true,
                errorMessage = null
            )
        } else {
            Log.d("LoginViewModel", "2FA n√£o ativado, navegando para home")
            _uiState.value = LoginUiState(isLoading = false, isSuccess = true, errorMessage = null, requiresTwoFactor = false)
            
            // Sincronizar dados em background (n√£o bloqueia login)
            viewModelScope.launch {
                try {
                    initialDataSyncManager.syncAllUserData()
                    preferencesManager.setInitialSyncCompleted(firebaseUser.uid)
                } catch (e: Exception) {
                    Log.e("LoginViewModel", "Erro ao sincronizar dados iniciais: ${e.message}", e)
                }
            }
        }
    }

    fun signInWithGoogle(idToken: String) {
        if (_uiState.value.isLoading) return
        _uiState.value = LoginUiState(isLoading = true, requiresTwoFactor = false)
        
        viewModelScope.launch {
            try {
                Log.d("LoginViewModel", "Iniciando login com Google")
                
                // Garantir que Firebase Auth est√° inicializado
                val auth = com.google.firebase.auth.FirebaseAuth.getInstance()
                if (auth.app == null) {
                    Log.e("LoginViewModel", "Firebase Auth n√£o inicializado")
                    _uiState.value = LoginUiState(
                        isLoading = false,
                        errorMessage = "Erro de autentica√ß√£o. Reinicie o app e tente novamente.",
                        isSuccess = false
                    )
                    return@launch
                }
                
                val result = authRepository.signInWithGoogle(idToken)
                result.fold(
                    onSuccess = { firebaseUser ->
                        Log.d("LoginViewModel", "Login com Google bem-sucedido: ${firebaseUser.uid}")
                        
                        // Verificar se o usu√°rio existe no Firestore, se n√£o, criar
                        val existingUser = try {
                            firestoreUserRepository.getUser(firebaseUser.uid)
                        } catch (e: Exception) {
                            Log.e("LoginViewModel", "Erro ao buscar usu√°rio: ${e.message}", e)
                            null
                        }
                        
                        if (existingUser != null) {
                            // CR√çTICO: Verificar se o usu√°rio J√Å TEM role definido (partner ou client)
                            // Se j√° tem role definido, NUNCA mostrar dialog, mesmo que pendingAccountType seja true
                            val hasDefinedRole = existingUser.role != null && 
                                               existingUser.role.isNotBlank() && 
                                               (existingUser.role.lowercase() == "partner" || existingUser.role.lowercase() == "client")
                            
                            // Verificar se √© um usu√°rio "pendente" - APENAS no primeiro login ap√≥s cadastro
                            // Crit√©rio: pendingAccountType == true E (role == null OU role == "client" padr√£o) E profileComplete == false
                            // E N√ÉO tem role definido (hasDefinedRole == false)
                            val isPendingUser = !hasDefinedRole && 
                                             existingUser.pendingAccountType == true && 
                                             (existingUser.role == null || existingUser.role.lowercase() == "client") && 
                                             existingUser.profileComplete == false
                            
                            if (isPendingUser) {
                                // PRIMEIRO LOGIN AP√ìS CADASTRO - Usu√°rio foi criado pela Cloud Function mas ainda n√£o selecionou tipo de conta
                                Log.d("LoginViewModel", "PRIMEIRO LOGIN: Usu√°rio pendente detectado, mostrando dialog de sele√ß√£o de tipo de conta. Role atual: ${existingUser.role}, pendingAccountType: ${existingUser.pendingAccountType}")
                                pendingFirebaseUser = firebaseUser
                                _uiState.value = LoginUiState(
                                    isLoading = false,
                                    showAccountTypeDialog = true,
                                    isSuccess = false,
                                    requiresTwoFactor = false
                                )
                            } else {
                                // USU√ÅRIO J√Å TEM TIPO DE CONTA DEFINIDO - N√ÉO mostrar dialog NUNCA
                                val existingRole = existingUser.role?.lowercase() ?: "client"
                                Log.d("LoginViewModel", "LOGIN SUBSEQUENTE: Usu√°rio j√° tem tipo de conta definido. Role: $existingRole, pendingAccountType: ${existingUser.pendingAccountType}, profileComplete: ${existingUser.profileComplete}, hasDefinedRole: $hasDefinedRole")
                            
                                // Salvar email para biometria
                                preferencesManager.saveEmailForBiometric(firebaseUser.email ?: "")
                                
                                // Verificar 2FA e navegar
                                checkTwoFactorAndNavigate(existingUser, firebaseUser)
                            }
                        } else {
                            // NOVO USU√ÅRIO - Primeiro login, mostrar dialog de sele√ß√£o de tipo de conta
                            Log.d("LoginViewModel", "PRIMEIRO LOGIN: Novo usu√°rio Google (documento n√£o existe no Firestore), mostrando dialog de sele√ß√£o de tipo de conta")
                            pendingFirebaseUser = firebaseUser
                            _uiState.value = LoginUiState(
                                isLoading = false,
                                showAccountTypeDialog = true,
                                isSuccess = false,
                                requiresTwoFactor = false
                            )
                        }
                    },
                    onFailure = { exception ->
                        Log.e("LoginViewModel", "Erro ao fazer login com Google: ${exception.message}", exception)
                        val errorMsg = when {
                            exception is com.google.firebase.auth.FirebaseAuthException -> {
                                when (exception.errorCode) {
                                    "ERROR_NETWORK_REQUEST_FAILED" -> "Erro de conex√£o. Verifique sua internet"
                                    "ERROR_INVALID_CREDENTIAL" -> "Credenciais inv√°lidas"
                                    else -> exception.message ?: "Falha ao fazer login com Google"
                                }
                            }
                            exception.message?.contains("network", ignoreCase = true) == true -> "Erro de conex√£o. Verifique sua internet"
                            else -> exception.message ?: "Falha ao fazer login com Google"
                        }
                        _uiState.value = LoginUiState(isLoading = false, errorMessage = errorMsg, requiresTwoFactor = false)
                    }
                )
            } catch (e: Exception) {
                Log.e("LoginViewModel", "Erro inesperado: ${e.message}", e)
                _uiState.value = LoginUiState(
                    isLoading = false,
                    errorMessage = "Erro inesperado: ${e.message}",
                    requiresTwoFactor = false
                )
            }
        }
    }

    fun loginWithBiometric(
        biometricManager: com.taskgoapp.taskgo.core.biometric.BiometricManager,
        activity: android.app.Activity,
        onBiometricNotAvailable: () -> Unit
    ) {
        if (_uiState.value.isLoading) return
        
        viewModelScope.launch {
            val savedEmail = preferencesManager.getEmailForBiometric()
            if (savedEmail.isNullOrBlank()) {
                onBiometricNotAvailable()
                return@launch
            }

            _uiState.value = LoginUiState(isLoading = true, errorMessage = null, isSuccess = false, requiresTwoFactor = false)
            
            biometricManager.authenticate(
                activity = activity,
                title = "Login Biom√©trico",
                subtitle = "Use sua biometria para fazer login",
                onSuccess = {
                    // Biometria autenticada, buscar senha salva ou usar email apenas
                    // Por seguran√ßa, ainda precisamos validar com Firebase
                    // Por enquanto, vamos apenas mostrar que precisa inserir senha
                    _uiState.value = LoginUiState(
                        isLoading = false,
                        errorMessage = "Por favor, insira sua senha para completar o login",
                        isSuccess = false,
                        requiresTwoFactor = false
                    )
                },
                onError = { error ->
                    _uiState.value = LoginUiState(
                        isLoading = false,
                        errorMessage = error,
                        isSuccess = false
                    )
                },
                onCancel = {
                    _uiState.value = LoginUiState(isLoading = false, requiresTwoFactor = false)
                }
            )
        }
    }
    
    /**
     * Cria o usu√°rio no Firestore com o AccountType selecionado ap√≥s login com Google
     */
    fun createUserWithAccountType(accountType: com.taskgoapp.taskgo.core.model.AccountType) {
        val firebaseUser = pendingFirebaseUser ?: return
        pendingFirebaseUser = null
        
        _uiState.value = LoginUiState(isLoading = true, showAccountTypeDialog = false, requiresTwoFactor = false)
        
        viewModelScope.launch {
            try {
                val role = when (accountType) {
                    com.taskgoapp.taskgo.core.model.AccountType.PARCEIRO -> "partner"
                    com.taskgoapp.taskgo.core.model.AccountType.PRESTADOR -> "partner" // Legacy - migrar para partner
                    com.taskgoapp.taskgo.core.model.AccountType.VENDEDOR -> "partner" // Legacy - migrar para partner
                    com.taskgoapp.taskgo.core.model.AccountType.CLIENTE -> "client"
                }
                
                Log.d("LoginViewModel", "Criando/atualizando perfil no Firestore com AccountType: $accountType, role: $role")
                
                // CR√çTICO: Primeiro chamar setInitialUserRole Cloud Function para definir Custom Claims
                Log.d("LoginViewModel", "üîµ Chamando setInitialUserRole Cloud Function...")
                Log.d("LoginViewModel", "   Par√¢metros: role=$role, accountType=${accountType.name}, userId=${firebaseUser.uid}")
                val setRoleResult = firebaseFunctionsService.setInitialUserRole(role, accountType.name)
                
                setRoleResult.fold(
                    onSuccess = { result ->
                        Log.d("LoginViewModel", "‚úÖ setInitialUserRole bem-sucedido: $result")
                        val resultRole = result["role"] as? String ?: "n√£o encontrado"
                        Log.d("LoginViewModel", "   Role retornado pela CF: $resultRole")
                        
                        // CR√çTICO: Recarregar token para obter novos Custom Claims
                        Log.d("LoginViewModel", "Recarregando token para obter novos Custom Claims...")
                        try {
                            firebaseUser.getIdToken(true).await()
                            Log.d("LoginViewModel", "Token recarregado com sucesso")
                        } catch (e: Exception) {
                            Log.e("LoginViewModel", "Erro ao recarregar token: ${e.message}", e)
                        }
                        
                        // Verificar se o documento j√° existe antes de atualizar
                        val existingUser = try {
                            firestoreUserRepository.getUser(firebaseUser.uid)
                        } catch (e: Exception) {
                            Log.w("LoginViewModel", "Erro ao verificar usu√°rio existente: ${e.message}")
                            null
                        }
                        
                        // Preservar createdAt se o usu√°rio j√° existir
                        val createdAt = existingUser?.createdAt ?: Date()
                        
                        val userFirestore = UserFirestore(
                            uid = firebaseUser.uid,
                            email = firebaseUser.email ?: "",
                            displayName = firebaseUser.displayName,
                            photoURL = firebaseUser.photoUrl?.toString(),
                            role = role, // CR√çTICO: Definir role corretamente
                            pendingAccountType = false, // CR√çTICO: Remover flag para que dialog n√£o apare√ßa mais
                            profileComplete = existingUser?.profileComplete ?: false,
                            verified = firebaseUser.isEmailVerified,
                            createdAt = createdAt, // Preservar data de cria√ß√£o original
                            updatedAt = Date()
                        )
                        
                        Log.d("LoginViewModel", "Usu√°rio antes de atualizar: ${existingUser?.uid}, role: ${existingUser?.role}, pendingAccountType: ${existingUser?.pendingAccountType}")
                        Log.d("LoginViewModel", "Dados a serem salvos: role=$role, pendingAccountType=false")
                        
                        firestoreUserRepository.updateUser(userFirestore).fold(
                            onSuccess = {
                                Log.d("LoginViewModel", "‚úÖ Perfil atualizado com sucesso no Firestore. AccountType: $accountType, role: $role, pendingAccountType: false")
                                preferencesManager.saveEmailForBiometric(firebaseUser.email ?: "")
                                
                                // CR√çTICO: For√ßar sincroniza√ß√£o dos dados do usu√°rio ap√≥s atualizar role
                                Log.d("LoginViewModel", "üîÑ For√ßando sincroniza√ß√£o dos dados do usu√°rio ap√≥s atualiza√ß√£o de role...")
                                viewModelScope.launch {
                                    try {
                                        initialDataSyncManager.syncAllUserData()
                                        Log.d("LoginViewModel", "‚úÖ Sincroniza√ß√£o de dados conclu√≠da")
                                    } catch (e: Exception) {
                                        Log.e("LoginViewModel", "Erro ao sincronizar dados ap√≥s atualiza√ß√£o de role: ${e.message}", e)
                                    }
                                }
                                
                                // Verificar se o role foi salvo corretamente ap√≥s atualiza√ß√£o
                                kotlinx.coroutines.delay(500) // Aguardar para garantir que a atualiza√ß√£o foi processada
                                val verifyUser = try {
                                    firestoreUserRepository.getUser(firebaseUser.uid)
                                } catch (e: Exception) {
                                    Log.w("LoginViewModel", "Erro ao verificar usu√°rio ap√≥s atualiza√ß√£o: ${e.message}")
                                    null
                                }
                                val savedRole = verifyUser?.role?.lowercase() ?: "n√£o encontrado"
                                val savedPending = verifyUser?.pendingAccountType ?: false
                                Log.d("LoginViewModel", "üîç VERIFICA√á√ÉO CR√çTICA - role salvo: $savedRole (esperado: $role), pendingAccountType: $savedPending (esperado: false)")
                                
                                // Verificar 2FA e navegar
                                checkTwoFactorAndNavigate(verifyUser ?: userFirestore, firebaseUser)
                            },
                            onFailure = { exception ->
                                Log.e("LoginViewModel", "Erro ao atualizar perfil no Firestore: ${exception.message}", exception)
                                // Mesmo com erro no Firestore, o Custom Claim j√° foi definido, ent√£o permitir login
                                preferencesManager.saveEmailForBiometric(firebaseUser.email ?: "")
                                checkTwoFactorAndNavigate(existingUser ?: userFirestore, firebaseUser)
                            }
                        )
                    },
                    onFailure = { exception ->
                        Log.e("LoginViewModel", "‚ùå ERRO ao chamar setInitialUserRole: ${exception.message}", exception)
                        Log.e("LoginViewModel", "   Exception type: ${exception.javaClass.simpleName}")
                        Log.e("LoginViewModel", "   Stack trace:", exception)
                        // Se falhar, tentar salvar diretamente no Firestore (fallback)
                        val existingUser = try {
                            firestoreUserRepository.getUser(firebaseUser.uid)
                        } catch (e: Exception) {
                            Log.w("LoginViewModel", "Erro ao verificar usu√°rio existente: ${e.message}")
                            null
                        }
                        
                        val createdAt = existingUser?.createdAt ?: Date()
                        val userFirestore = UserFirestore(
                            uid = firebaseUser.uid,
                            email = firebaseUser.email ?: "",
                            displayName = firebaseUser.displayName,
                            photoURL = firebaseUser.photoUrl?.toString(),
                            role = role,
                            pendingAccountType = false,
                            profileComplete = existingUser?.profileComplete ?: false,
                            verified = firebaseUser.isEmailVerified,
                            createdAt = createdAt,
                            updatedAt = Date()
                        )
                        
                        firestoreUserRepository.updateUser(userFirestore).fold(
                            onSuccess = {
                                Log.d("LoginViewModel", "Perfil atualizado no Firestore (fallback)")
                                preferencesManager.saveEmailForBiometric(firebaseUser.email ?: "")
                                checkTwoFactorAndNavigate(userFirestore, firebaseUser)
                            },
                            onFailure = { e ->
                                Log.e("LoginViewModel", "Erro ao criar perfil (fallback): ${e.message}", e)
                                preferencesManager.saveEmailForBiometric(firebaseUser.email ?: "")
                                _uiState.value = LoginUiState(
                                    isLoading = false,
                                    errorMessage = "Erro ao criar perfil: ${e.message}",
                                    showAccountTypeDialog = false,
                                    requiresTwoFactor = false
                                )
                            }
                        )
                    }
                )
            } catch (e: Exception) {
                Log.e("LoginViewModel", "Erro ao criar usu√°rio com AccountType: ${e.message}", e)
                _uiState.value = LoginUiState(
                    isLoading = false,
                    errorMessage = "Erro ao criar perfil: ${e.message}",
                    showAccountTypeDialog = false,
                    requiresTwoFactor = false
                )
            }
        }
    }
    
    fun cancelAccountTypeSelection() {
        pendingFirebaseUser = null
        _uiState.value = LoginUiState(showAccountTypeDialog = false)
        // Fazer logout j√° que cancelou a sele√ß√£o
        viewModelScope.launch {
            authRepository.signOut()
        }
    }
}



```

## [FRONTEND]: feature/auth/presentation/SignUpScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.auth.presentation

import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Visibility
import androidx.compose.material.icons.filled.VisibilityOff
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.hilt.navigation.compose.hiltViewModel
import com.taskgoapp.taskgo.feature.auth.presentation.SignupViewModel
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.input.PasswordVisualTransformation
import androidx.compose.ui.text.input.VisualTransformation
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.text.input.TextFieldValue
import androidx.compose.ui.text.TextRange
import com.taskgoapp.taskgo.core.model.UserType
import com.taskgoapp.taskgo.core.model.AccountType
import com.taskgoapp.taskgo.core.design.TGIcons
import com.taskgoapp.taskgo.core.design.EnhancedOutlinedTextField
import com.taskgoapp.taskgo.core.design.OutlinedTextFieldWithValue
import com.taskgoapp.taskgo.core.theme.TaskGoGreen
import com.taskgoapp.taskgo.core.theme.TaskGoTextBlack
import com.taskgoapp.taskgo.core.theme.TaskGoTextGray
import com.taskgoapp.taskgo.core.theme.TaskGoBackgroundWhite
import com.taskgoapp.taskgo.core.theme.TaskGoSurface
import androidx.compose.foundation.BorderStroke
import androidx.compose.ui.res.stringResource
import com.taskgoapp.taskgo.R
import com.taskgoapp.taskgo.core.validation.CepService
import com.taskgoapp.taskgo.core.validation.DocumentValidator
import com.taskgoapp.taskgo.core.validation.ValidationResult
import kotlinx.coroutines.launch
import kotlinx.coroutines.delay

@Composable
fun SignUpScreen(
    onNavigateToLogin: () -> Unit,
    onNavigateToHome: () -> Unit,
    onNavigateToDocumentVerification: () -> Unit = {},
    onBackClick: () -> Unit
) {
    val viewModel: SignupViewModel = hiltViewModel()
    val uiState by viewModel.uiState.collectAsState()
    val scope = rememberCoroutineScope()
    
    // Injetar servi√ßos via Hilt (criar inst√¢ncias locais por enquanto)
    val cepService = remember { CepService() }
    val documentValidator = remember { DocumentValidator() }
    val governmentValidator = remember { com.taskgoapp.taskgo.core.validation.GovernmentDocumentValidator() }
    
    var name by remember { mutableStateOf("") }
    var email by remember { mutableStateOf("") }
    var phone by remember { mutableStateOf(androidx.compose.ui.text.input.TextFieldValue("")) }
    var password by remember { mutableStateOf("") }
    var confirmPassword by remember { mutableStateOf("") }
    var passwordVisible by remember { mutableStateOf(false) }
    var confirmPasswordVisible by remember { mutableStateOf(false) }
    var cpf by remember { mutableStateOf(TextFieldValue("")) }
    var cnpj by remember { mutableStateOf(TextFieldValue("")) }
    var rg by remember { mutableStateOf("") }
    var birthDate by remember { mutableStateOf(TextFieldValue("")) }
    var biometricEnabled by remember { mutableStateOf(false) }
    var twoFactorEnabled by remember { mutableStateOf(false) }
    var selectedAccountType by remember { mutableStateOf(AccountType.CLIENTE) }
    // Sele√ß√£o de tipo de documento para Parceiro (CPF ou CNPJ)
    var documentType by remember { mutableStateOf<String?>(null) } // "CPF" ou "CNPJ" ou null
    
    // Categorias de servi√ßo selecionadas para Parceiro
    var selectedServiceCategories by remember { mutableStateOf<Set<String>>(emptySet()) }
    
    // Observar categorias de servi√ßo do ViewModel
    val serviceCategories by viewModel.serviceCategories.collectAsState()
    
    // Campos de endere√ßo
    var zipCode by remember { mutableStateOf(TextFieldValue("")) }
    var street by remember { mutableStateOf("") }
    var number by remember { mutableStateOf("") }
    var complement by remember { mutableStateOf("") }
    var neighborhood by remember { mutableStateOf("") }
    var city by remember { mutableStateOf("") }
    var state by remember { mutableStateOf("") }
    var country by remember { mutableStateOf("Brasil") }
    
    // Estados de valida√ß√£o e loading
    var cpfError by remember { mutableStateOf<String?>(null) }
    var cnpjError by remember { mutableStateOf<String?>(null) }
    var rgError by remember { mutableStateOf<String?>(null) }
    var cepError by remember { mutableStateOf<String?>(null) }
    var isLoadingCep by remember { mutableStateOf(false) }
    var passwordError by remember { mutableStateOf<String?>(null) }
    var confirmPasswordError by remember { mutableStateOf<String?>(null) }
    
    // Validador de senha
    val passwordValidator = remember { com.taskgoapp.taskgo.core.validation.PasswordValidator() }

    val focusManager = androidx.compose.ui.platform.LocalFocusManager.current
    val keyboardController = androidx.compose.ui.platform.LocalSoftwareKeyboardController.current
    
    Box(
        modifier = Modifier
            .fillMaxSize()
            .background(TaskGoBackgroundWhite)
            .clickable(
                indication = null,
                interactionSource = remember { androidx.compose.foundation.interaction.MutableInteractionSource() }
            ) {
                focusManager.clearFocus()
                keyboardController?.hide()
            }
    ) {
        Column(
            modifier = Modifier
                .fillMaxSize()
                .verticalScroll(rememberScrollState())
                .padding(24.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Spacer(modifier = Modifier.height(40.dp))
            
            // Logo TaskGo Horizontal
            Image(
                painter = painterResource(id = TGIcons.TaskGoLogoHorizontal),
                contentDescription = "TaskGo Logo",
                modifier = Modifier.size(120.dp, 40.dp)
            )
            
            Spacer(modifier = Modifier.height(40.dp))
            
            // T√≠tulo
            Text(
                text = "Cadastro",
                style = MaterialTheme.typography.headlineMedium,
                color = TaskGoTextBlack,
                fontWeight = FontWeight.Bold,
                fontSize = 24.sp
            )
            
            Spacer(modifier = Modifier.height(40.dp))
            
            // Campo Nome
            com.taskgoapp.taskgo.core.design.EnhancedOutlinedTextField(
                value = name,
                onValueChange = { newValue -> name = newValue },
                label = { 
                    Text(
                        "Nome",
                        color = TaskGoTextGray,
                        fontSize = 14.sp
                    ) 
                },
                modifier = Modifier
                    .fillMaxWidth()
                    .heightIn(min = 72.dp),
                keyboardType = KeyboardType.Text
            )
            
            Spacer(modifier = Modifier.height(16.dp))
            
            // Campo E-mail
            com.taskgoapp.taskgo.core.design.EnhancedOutlinedTextField(
                value = email,
                onValueChange = { newValue -> email = newValue },
                label = { 
                    Text(
                        "E-mail",
                        color = TaskGoTextGray,
                        fontSize = 14.sp
                    ) 
                },
                modifier = Modifier
                    .fillMaxWidth()
                    .heightIn(min = 72.dp),
                keyboardType = KeyboardType.Email
            )
            
            Spacer(modifier = Modifier.height(16.dp))
            
            // Campo Telefone
            OutlinedTextFieldWithValue(
                value = phone,
                onValueChange = { newValue: TextFieldValue ->
                    val cleanValue = newValue.text.replace(Regex("[^0-9]"), "")
                    if (cleanValue.length <= 11) {
                        phone = com.taskgoapp.taskgo.core.utils.TextFormatters.formatPhoneWithCursor(newValue)
                    } else {
                        phone = newValue
                    }
                },
                label = { 
                    Text(
                        "Telefone",
                        color = TaskGoTextGray,
                        fontSize = 14.sp
                    ) 
                },
                modifier = Modifier
                    .fillMaxWidth()
                    .heightIn(min = 72.dp),
                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Phone),
                shape = RoundedCornerShape(8.dp),
                contentPadding = PaddingValues(horizontal = 16.dp, vertical = 20.dp),
                singleLine = true
            )
            
            Spacer(modifier = Modifier.height(16.dp))
            
            // Sele√ß√£o de Tipo de Conta
            Text(
                text = "Tipo de Conta",
                style = MaterialTheme.typography.titleMedium,
                color = TaskGoTextBlack,
                fontWeight = FontWeight.Bold,
                modifier = Modifier.fillMaxWidth()
            )
            
            Spacer(modifier = Modifier.height(8.dp))
            
            Column(
                modifier = Modifier.fillMaxWidth(),
                verticalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                Card(
                    modifier = Modifier
                        .fillMaxWidth()
                        .clickable { selectedAccountType = AccountType.PARCEIRO },
                    colors = CardDefaults.cardColors(
                        containerColor = if (selectedAccountType == AccountType.PARCEIRO) TaskGoGreen.copy(alpha = 0.1f) else TaskGoSurface
                    ),
                    border = if (selectedAccountType == AccountType.PARCEIRO) BorderStroke(2.dp, TaskGoGreen) else null
                ) {
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(16.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        RadioButton(
                            selected = selectedAccountType == AccountType.PARCEIRO,
                            onClick = { selectedAccountType = AccountType.PARCEIRO },
                            colors = RadioButtonDefaults.colors(
                                selectedColor = TaskGoGreen
                            )
                        )
                        Spacer(modifier = Modifier.width(12.dp))
                        Column(modifier = Modifier.weight(1f)) {
                            Text(
                                text = "Parceiro",
                                style = MaterialTheme.typography.bodyLarge,
                                color = TaskGoTextBlack,
                                fontWeight = FontWeight.Medium
                            )
                            Text(
                                text = "Oferecer servi√ßos e vender produtos",
                                style = MaterialTheme.typography.bodySmall,
                                color = TaskGoTextGray,
                                fontSize = 12.sp
                            )
                        }
                    }
                }
                
                Card(
                    modifier = Modifier
                        .fillMaxWidth()
                        .clickable { selectedAccountType = AccountType.CLIENTE },
                    colors = CardDefaults.cardColors(
                        containerColor = if (selectedAccountType == AccountType.CLIENTE) TaskGoGreen.copy(alpha = 0.1f) else TaskGoSurface
                    ),
                    border = if (selectedAccountType == AccountType.CLIENTE) BorderStroke(2.dp, TaskGoGreen) else null
                ) {
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(16.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        RadioButton(
                            selected = selectedAccountType == AccountType.CLIENTE,
                            onClick = { selectedAccountType = AccountType.CLIENTE },
                            colors = RadioButtonDefaults.colors(
                                selectedColor = TaskGoGreen
                            )
                        )
                        Spacer(modifier = Modifier.width(12.dp))
                        Column(modifier = Modifier.weight(1f)) {
                            Text(
                                text = "Cliente",
                                style = MaterialTheme.typography.bodyLarge,
                                color = TaskGoTextBlack,
                                fontWeight = FontWeight.Medium
                            )
                            Text(
                                text = "Contratar servi√ßos e comprar produtos",
                                style = MaterialTheme.typography.bodySmall,
                                color = TaskGoTextGray,
                                fontSize = 12.sp
                            )
                        }
                    }
                }
            }
            
            // Mostrar checkboxes de tipos de servi√ßo quando Parceiro for selecionado
            if (selectedAccountType == AccountType.PARCEIRO && serviceCategories.isNotEmpty()) {
                Spacer(modifier = Modifier.height(16.dp))
                
                Text(
                    text = "Selecione os tipos de servi√ßo que voc√™ oferece",
                    style = MaterialTheme.typography.titleSmall,
                    color = TaskGoTextBlack,
                    fontWeight = FontWeight.Medium,
                    modifier = Modifier.fillMaxWidth()
                )
                
                Spacer(modifier = Modifier.height(8.dp))
                
                Column(
                    modifier = Modifier.fillMaxWidth(),
                    verticalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    serviceCategories.forEach { category ->
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(vertical = 4.dp),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Checkbox(
                                checked = selectedServiceCategories.contains(category.name),
                                onCheckedChange = { checked ->
                                    selectedServiceCategories = if (checked) {
                                        selectedServiceCategories + category.name
                                    } else {
                                        selectedServiceCategories - category.name
                                    }
                                },
                                colors = CheckboxDefaults.colors(
                                    checkedColor = TaskGoGreen
                                )
                            )
                            Spacer(modifier = Modifier.width(8.dp))
                            Text(
                                text = category.name,
                                style = MaterialTheme.typography.bodyMedium,
                                color = TaskGoTextBlack,
                                modifier = Modifier.weight(1f)
                            )
                        }
                    }
                }
            }
            
            Spacer(modifier = Modifier.height(16.dp))
            
            // Para Parceiro: checkboxes para selecionar CPF ou CNPJ
            if (selectedAccountType == AccountType.PARCEIRO) {
                Text(
                    text = "Tipo de Documento",
                    style = MaterialTheme.typography.titleSmall,
                    color = TaskGoTextBlack,
                    fontWeight = FontWeight.Medium,
                    modifier = Modifier.fillMaxWidth()
                )
                
                Spacer(modifier = Modifier.height(8.dp))
                
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(16.dp)
                ) {
                    // Checkbox CPF
                    Row(
                        modifier = Modifier
                            .weight(1f)
                            .clickable { 
                                documentType = "CPF"
                                cnpj = TextFieldValue("") // Limpar CNPJ quando selecionar CPF
                            },
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Checkbox(
                            checked = documentType == "CPF",
                            onCheckedChange = { checked ->
                                if (checked) {
                                    documentType = "CPF"
                                    cnpj = TextFieldValue("") // Limpar CNPJ
                                } else {
                                    documentType = null
                                }
                            },
                            colors = CheckboxDefaults.colors(checkedColor = TaskGoGreen)
                        )
                        Spacer(modifier = Modifier.width(4.dp))
                        Text("CPF", style = MaterialTheme.typography.bodyMedium)
                    }
                    
                    // Checkbox CNPJ
                    Row(
                        modifier = Modifier
                            .weight(1f)
                            .clickable { 
                                documentType = "CNPJ"
                                cpf = TextFieldValue("") // Limpar CPF quando selecionar CNPJ
                            },
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Checkbox(
                            checked = documentType == "CNPJ",
                            onCheckedChange = { checked ->
                                if (checked) {
                                    documentType = "CNPJ"
                                    cpf = TextFieldValue("") // Limpar CPF
                                } else {
                                    documentType = null
                                }
                            },
                            colors = CheckboxDefaults.colors(checkedColor = TaskGoGreen)
                        )
                        Spacer(modifier = Modifier.width(4.dp))
                        Text("CNPJ", style = MaterialTheme.typography.bodyMedium)
                    }
                }
                
                Spacer(modifier = Modifier.height(16.dp))
            }
            
            // Campo CPF (apenas se Parceiro selecionou CPF ou se Cliente)
            if (selectedAccountType != AccountType.PARCEIRO || documentType == "CPF") {
                OutlinedTextFieldWithValue(
                    value = cpf,
                    onValueChange = { newValue ->
                        val cleanValue = newValue.text.replace(Regex("[^0-9]"), "")
                        if (cleanValue.length <= 11) {
                            cpfError = null // Limpar erro ao come√ßar a editar
                            
                            // Formata progressivamente preservando posi√ß√£o do cursor
                            cpf = com.taskgoapp.taskgo.core.utils.TextFormatters.formatCpfWithCursor(newValue)
                            
                            // Valida usando validador avan√ßado quando tiver 11 d√≠gitos
                            if (cleanValue.length == 11) {
                                scope.launch {
                                    val cpfText = cpf.text.replace(Regex("[^0-9]"), "")
                                    val validation = governmentValidator.validateCpfAdvanced(cpfText)
                                    cpfError = when (validation) {
                                        is com.taskgoapp.taskgo.core.validation.DocumentValidationResult.Invalid -> validation.message
                                        is com.taskgoapp.taskgo.core.validation.DocumentValidationResult.Suspicious -> validation.message
                                        is com.taskgoapp.taskgo.core.validation.DocumentValidationResult.Error -> validation.message
                                        else -> null
                                    }
                                }
                            }
                        }
                    },
                    label = { 
                        Row(verticalAlignment = Alignment.CenterVertically) {
                            Text(
                                "CPF",
                                color = TaskGoTextGray,
                                fontSize = 14.sp
                            )
                            Text(
                                " (Obrigat√≥rio)",
                                color = TaskGoTextGray,
                                fontSize = 14.sp,
                                fontWeight = FontWeight.Normal
                            )
                        }
                    },
                    placeholder = { Text("000.000.000-00", color = TaskGoTextGray) },
                    isError = cpfError != null,
                    supportingText = if (cpfError != null) {
                        { Text(cpfError ?: "", color = MaterialTheme.colorScheme.error) }
                    } else null,
                    enabled = true,
                    modifier = Modifier
                        .fillMaxWidth()
                        .heightIn(min = 72.dp),
                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
                    singleLine = true,
                    contentPadding = PaddingValues(horizontal = 16.dp, vertical = 20.dp)
                )
                
                Spacer(modifier = Modifier.height(16.dp))
            }
            
            // Campo CNPJ (apenas se Parceiro selecionou CNPJ)
            if (selectedAccountType == AccountType.PARCEIRO && documentType == "CNPJ") {
                OutlinedTextFieldWithValue(
                    value = cnpj,
                    onValueChange = { newValue ->
                        val cleanValue = newValue.text.replace(Regex("[^0-9]"), "")
                        if (cleanValue.length <= 14) {
                            cnpjError = null // Limpar erro ao come√ßar a editar
                            
                            // Formata progressivamente preservando posi√ß√£o do cursor
                            cnpj = com.taskgoapp.taskgo.core.utils.TextFormatters.formatCnpjWithCursor(newValue)
                            
                            // Valida quando tiver 14 d√≠gitos
                            if (cleanValue.length == 14) {
                                scope.launch {
                                    val cnpjText = cnpj.text.replace(Regex("[^0-9]"), "")
                                    val validation = documentValidator.validateCnpj(cnpjText)
                                    cnpjError = if (validation is ValidationResult.Invalid) validation.message else null
                                }
                            }
                        }
                    },
                    label = { 
                        Row(verticalAlignment = Alignment.CenterVertically) {
                            Text(
                                "CNPJ",
                                color = TaskGoTextGray,
                                fontSize = 14.sp
                            )
                            Text(
                                " (Obrigat√≥rio)",
                                color = TaskGoTextGray,
                                fontSize = 14.sp,
                                fontWeight = FontWeight.Normal
                            )
                        }
                    },
                    placeholder = { Text("00.000.000/0000-00", color = TaskGoTextGray) },
                    isError = cnpjError != null,
                    supportingText = if (cnpjError != null) {
                        { Text(cnpjError ?: "", color = MaterialTheme.colorScheme.error) }
                    } else null,
                    enabled = true,
                    modifier = Modifier
                        .fillMaxWidth()
                        .heightIn(min = 72.dp),
                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
                    singleLine = true,
                    contentPadding = PaddingValues(horizontal = 16.dp, vertical = 20.dp)
                )
                
                Spacer(modifier = Modifier.height(16.dp))
            }
            
            Spacer(modifier = Modifier.height(16.dp))
            
            // Campo RG com valida√ß√£o e formata√ß√£o
            var rgTextFieldValue by remember { mutableStateOf(TextFieldValue(rg)) }
            
            // Sincronizar rgTextFieldValue com rg quando rg mudar externamente
            LaunchedEffect(rg) {
                if (rgTextFieldValue.text.replace(Regex("[^0-9A-Za-z]"), "") != rg.replace(Regex("[^0-9A-Za-z]"), "")) {
                    rgTextFieldValue = TextFieldValue(rg)
                }
            }
            
            OutlinedTextFieldWithValue(
                value = rgTextFieldValue,
                onValueChange = { newValue ->
                    val cleanValue = newValue.text.replace(Regex("[^0-9A-Za-z]"), "")
                    // Permitir at√© 12 caracteres alfanum√©ricos (formato brasileiro permite at√© 12 d√≠gitos)
                    if (cleanValue.length <= 12) {
                        rgError = null // Limpar erro ao come√ßar a editar
                        
                        // Formata progressivamente preservando posi√ß√£o do cursor
                        rgTextFieldValue = com.taskgoapp.taskgo.core.utils.TextFormatters.formatRgWithCursor(newValue)
                        rg = rgTextFieldValue.text.replace(Regex("[^0-9A-Za-z]"), "").uppercase()
                        
                        // Valida quando tiver tamanho m√≠nimo (removendo formata√ß√£o para contar d√≠gitos)
                        val cleanRgDigits = rgTextFieldValue.text.replace(Regex("[^0-9A-Za-z]"), "")
                        if (cleanRgDigits.length >= 6) {
                            // Valida o RG formatado (com pontos e h√≠fen) ou sem formata√ß√£o
                            val rgToValidate = rgTextFieldValue.text.uppercase()
                            val validation = documentValidator.validateRg(rgToValidate, state.takeIf { it.isNotEmpty() })
                            rgError = if (validation is ValidationResult.Invalid) validation.message else null
                        } else {
                            rgError = null
                        }
                    }
                },
                label = { 
                    Row(verticalAlignment = Alignment.CenterVertically) {
                        Text(
                            "RG",
                            color = TaskGoTextGray,
                            fontSize = 14.sp
                        )
                        Text(
                            " (Obrigat√≥rio)",
                            color = TaskGoTextGray,
                            fontSize = 14.sp,
                            fontWeight = FontWeight.Normal
                        )
                    }
                },
                placeholder = { Text("00.000.000-0", color = TaskGoTextGray) },
                isError = rgError != null,
                supportingText = if (rgError != null) {
                    { Text(rgError ?: "", color = MaterialTheme.colorScheme.error) }
                } else null,
                modifier = Modifier
                    .fillMaxWidth()
                    .heightIn(min = 72.dp),
                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Text),
                contentPadding = PaddingValues(horizontal = 16.dp, vertical = 20.dp),
                singleLine = true
            )
            
            Spacer(modifier = Modifier.height(16.dp))
            
            // Se√ß√£o de Endere√ßo
            Row(
                modifier = Modifier.fillMaxWidth(),
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = "Endere√ßo",
                    style = MaterialTheme.typography.titleMedium,
                    color = TaskGoTextBlack,
                    fontWeight = FontWeight.Bold
                )
                Text(
                    text = " (Obrigat√≥rio)",
                    style = MaterialTheme.typography.titleMedium,
                    color = TaskGoTextBlack,
                    fontWeight = FontWeight.Normal
                )
            }
            
            Spacer(modifier = Modifier.height(8.dp))
            
            // Campo CEP com busca autom√°tica de endere√ßo
            OutlinedTextFieldWithValue(
                value = zipCode,
                onValueChange = { newValue: TextFieldValue ->
                    // Formata preservando cursor
                    zipCode = com.taskgoapp.taskgo.core.utils.TextFormatters.formatCepWithCursor(newValue)
                    val cleanValue = zipCode.text.replace(Regex("[^0-9]"), "")
                    
                    if (cleanValue.length <= 8) {
                        cepError = null
                        
                        // Busca endere√ßo quando tiver 8 d√≠gitos
                        if (cleanValue.length == 8) {
                            
                            // Busca endere√ßo automaticamente
                            scope.launch {
                                isLoadingCep = true
                                cepError = null
                                
                                delay(500) // Delay para evitar m√∫ltiplas requisi√ß√µes
                                
                                cepService.searchCep(cleanValue).fold(
                                    onSuccess = { cepResult ->
                                        street = cepResult.logradouro
                                        neighborhood = cepResult.bairro
                                        city = cepResult.localidade
                                        state = cepResult.uf
                                        cepResult.complemento?.let { complement = it }
                                        isLoadingCep = false
                                    },
                                    onFailure = { error ->
                                        cepError = error.message ?: "CEP n√£o encontrado"
                                        isLoadingCep = false
                                    }
                                )
                            }
                        }
                    }
                },
                label = { 
                    Text(
                        "CEP",
                        color = TaskGoTextGray,
                        fontSize = 14.sp
                    ) 
                },
                placeholder = { Text("00000-000", color = TaskGoTextGray) },
                singleLine = true,
                trailingIcon = {
                    if (isLoadingCep) {
                        CircularProgressIndicator(
                            modifier = Modifier.size(20.dp),
                            strokeWidth = 2.dp
                        )
                    }
                },
                isError = cepError != null,
                supportingText = if (cepError != null) {
                    { Text(cepError ?: "", color = MaterialTheme.colorScheme.error) }
                } else null,
                modifier = Modifier
                    .fillMaxWidth()
                    .heightIn(min = 72.dp),
                shape = RoundedCornerShape(8.dp),
                colors = OutlinedTextFieldDefaults.colors(
                    focusedBorderColor = if (cepError != null) MaterialTheme.colorScheme.error else TaskGoGreen,
                    unfocusedBorderColor = if (cepError != null) MaterialTheme.colorScheme.error else Color(0xFFD9D9D9),
                    focusedLabelColor = TaskGoTextGray,
                    unfocusedLabelColor = TaskGoTextGray,
                    cursorColor = TaskGoGreen
                ),
                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
                enabled = !isLoadingCep,
                contentPadding = PaddingValues(horizontal = 16.dp, vertical = 20.dp)
            )
            
            Spacer(modifier = Modifier.height(16.dp))
            
            // Campo Rua
            EnhancedOutlinedTextField(
                value = street,
                onValueChange = { newValue -> street = newValue },
                label = { 
                    Text(
                        "Rua",
                        color = TaskGoTextGray,
                        fontSize = 14.sp
                    ) 
                },
                modifier = Modifier
                    .fillMaxWidth()
                    .heightIn(min = 72.dp),
                keyboardType = KeyboardType.Text,
                minLines = 1,
                maxLines = 3
            )
            
            Spacer(modifier = Modifier.height(16.dp))
            
            // Campo N√∫mero e Complemento
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                EnhancedOutlinedTextField(
                    value = number,
                    onValueChange = { newValue -> number = newValue },
                    label = { 
                        Text(
                            "N√∫mero",
                            color = TaskGoTextGray,
                            fontSize = 14.sp
                        ) 
                    },
                    modifier = Modifier
                        .weight(1f)
                        .heightIn(min = 72.dp),
                    keyboardType = KeyboardType.Number
                )
                
                EnhancedOutlinedTextField(
                    value = complement,
                    onValueChange = { newValue -> complement = newValue },
                    label = { 
                        Text(
                            "Complemento",
                            color = TaskGoTextGray,
                            fontSize = 14.sp
                        ) 
                    },
                    placeholder = { Text("Apto, Bloco, etc.", color = TaskGoTextGray) },
                    modifier = Modifier
                        .weight(1f)
                        .heightIn(min = 72.dp),
                    keyboardType = KeyboardType.Text,
                    minLines = 1,
                    maxLines = 3
                )
            }
            
            Spacer(modifier = Modifier.height(16.dp))
            
            // Campo Bairro
            EnhancedOutlinedTextField(
                value = neighborhood,
                onValueChange = { newValue -> neighborhood = newValue },
                label = { 
                    Text(
                        "Bairro",
                        color = TaskGoTextGray,
                        fontSize = 14.sp
                    ) 
                },
                modifier = Modifier
                    .fillMaxWidth()
                    .heightIn(min = 72.dp),
                keyboardType = KeyboardType.Text,
                minLines = 1,
                maxLines = 3
            )
            
            Spacer(modifier = Modifier.height(16.dp))
            
            // Campo Cidade e Estado
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                EnhancedOutlinedTextField(
                    value = city,
                    onValueChange = { newValue -> city = newValue },
                    label = { 
                        Text(
                            "Cidade",
                            color = TaskGoTextGray,
                            fontSize = 14.sp
                        ) 
                    },
                    modifier = Modifier
                        .weight(2f)
                        .heightIn(min = 72.dp),
                    keyboardType = KeyboardType.Text,
                    minLines = 1,
                    maxLines = 3
                )
                
                EnhancedOutlinedTextField(
                    value = state,
                    onValueChange = { newValue -> state = newValue },
                    label = { 
                        Text(
                            "Estado",
                            color = TaskGoTextGray,
                            fontSize = 14.sp
                        ) 
                    },
                    placeholder = { Text("SP", color = TaskGoTextGray) },
                    modifier = Modifier
                        .weight(1f)
                        .heightIn(min = 72.dp),
                    keyboardType = KeyboardType.Text
                )
            }
            
            Spacer(modifier = Modifier.height(16.dp))
            OutlinedTextFieldWithValue(
                value = birthDate,
                onValueChange = { newValue: TextFieldValue ->
                    try {
                        val cleanValue = newValue.text
                        val cleanOnlyNumbers = cleanValue.replace(Regex("[^0-9]"), "")
                        
                        // Valida√ß√£o segura para evitar crash
                        if (cleanOnlyNumbers.isEmpty()) {
                            birthDate = TextFieldValue("")
                        } else if (cleanOnlyNumbers.length <= 8) {
                            // Valida antes de formatar
                            if (com.taskgoapp.taskgo.core.utils.TextFormatters.isValidDateInput(cleanOnlyNumbers)) {
                                birthDate = com.taskgoapp.taskgo.core.utils.TextFormatters.formatDateWithCursor(newValue)
                            } else {
                                // Se inv√°lido, mant√©m o valor anterior (n√£o atualiza)
                                // N√£o faz nada, previne crash
                            }
                        }
                    } catch (e: Exception) {
                        // Em caso de qualquer exce√ß√£o, mant√©m o valor anterior
                        android.util.Log.e("SignUpScreen", "Erro ao processar data: ${e.message}", e)
                        // N√£o atualiza birthDate, mant√©m valor anterior
                    }
                },
                label = { 
                    Text(
                        "Data de Nascimento (Opcional)",
                        color = TaskGoTextGray,
                        fontSize = 14.sp
                    ) 
                },
                placeholder = {
                    Text("DD/MM/AAAA", color = TaskGoTextGray)
                },
                modifier = Modifier
                    .fillMaxWidth()
                    .heightIn(min = 72.dp),
                shape = RoundedCornerShape(8.dp),
                colors = OutlinedTextFieldDefaults.colors(
                    focusedBorderColor = TaskGoGreen,
                    unfocusedBorderColor = Color(0xFFD9D9D9),
                    focusedLabelColor = TaskGoTextGray,
                    unfocusedLabelColor = TaskGoTextGray,
                    cursorColor = TaskGoGreen
                ),
                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
                contentPadding = PaddingValues(horizontal = 16.dp, vertical = 20.dp),
                singleLine = true
            )
            
            Spacer(modifier = Modifier.height(16.dp))
            
            // Checkbox: Habilitar Biometria
            Row(
                modifier = Modifier.fillMaxWidth(),
                verticalAlignment = Alignment.CenterVertically
            ) {
                Checkbox(
                    checked = biometricEnabled,
                    onCheckedChange = { biometricEnabled = it },
                    colors = CheckboxDefaults.colors(
                        checkedColor = TaskGoGreen
                    )
                )
                Spacer(modifier = Modifier.width(8.dp))
                Text(
                    text = "Habilitar login com biometria",
                    color = TaskGoTextBlack,
                    fontSize = 14.sp
                )
            }
            
            Spacer(modifier = Modifier.height(8.dp))
            
            // Checkbox: Habilitar 2FA
            Column(
                modifier = Modifier.fillMaxWidth()
            ) {
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Checkbox(
                        checked = twoFactorEnabled,
                        onCheckedChange = { twoFactorEnabled = it },
                        colors = CheckboxDefaults.colors(
                            checkedColor = TaskGoGreen
                        )
                    )
                    Spacer(modifier = Modifier.width(8.dp))
                    Text(
                        text = "Habilitar autentica√ß√£o de duas etapas",
                        color = TaskGoTextBlack,
                        fontSize = 14.sp
                    )
                }
                
                // Instru√ß√µes de senha abaixo do checkbox
                Spacer(modifier = Modifier.height(8.dp))
                Text(
                    text = "A senha deve conter:",
                    color = TaskGoTextGray,
                    fontSize = 12.sp,
                    fontWeight = FontWeight.Bold,
                    modifier = Modifier.padding(start = 48.dp)
                )
                Spacer(modifier = Modifier.height(4.dp))
                Column(
                    modifier = Modifier.padding(start = 48.dp)
                ) {
                    Text(
                        text = "‚Ä¢ M√≠nimo de 8 caracteres",
                        color = TaskGoTextGray,
                        fontSize = 12.sp
                    )
                    Text(
                        text = "‚Ä¢ Pelo menos 1 n√∫mero (0-9)",
                        color = TaskGoTextGray,
                        fontSize = 12.sp
                    )
                    Text(
                        text = "‚Ä¢ Pelo menos 1 letra mai√∫scula (A-Z)",
                        color = TaskGoTextGray,
                        fontSize = 12.sp
                    )
                    Text(
                        text = "‚Ä¢ Pelo menos 1 caractere especial (!@#$%&*()_+-=[]{}|;:,.<>?)",
                        color = TaskGoTextGray,
                        fontSize = 12.sp
                    )
                }
            }
            
            Spacer(modifier = Modifier.height(16.dp))
            
            // Campo Senha
            EnhancedOutlinedTextField(
                value = password,
                onValueChange = { newPassword ->
                    password = newPassword
                    passwordError = null // Limpar erro ao come√ßar a editar
                    
                    // Validar senha em tempo real
                    if (newPassword.isNotEmpty()) {
                        val validation = passwordValidator.validate(newPassword)
                        passwordError = when (validation) {
                            is ValidationResult.Invalid -> validation.message
                            else -> null
                        }
                    }
                    
                    // Se houver confirma√ß√£o de senha, validar novamente
                    if (confirmPassword.isNotEmpty() && confirmPassword != newPassword) {
                        confirmPasswordError = "As senhas n√£o coincidem"
                    } else if (confirmPassword.isNotEmpty() && confirmPassword == newPassword) {
                        confirmPasswordError = null
                    }
                },
                label = { 
                    Text(
                        "Senha",
                        color = TaskGoTextGray,
                        fontSize = 14.sp
                    ) 
                },
                modifier = Modifier
                    .fillMaxWidth()
                    .heightIn(min = 72.dp),
                keyboardOptions = KeyboardOptions(
                    keyboardType = KeyboardType.Password,
                    imeAction = androidx.compose.ui.text.input.ImeAction.Done
                ),
                isError = passwordError != null,
                supportingText = if (passwordError != null) {
                    { Text(passwordError ?: "", color = MaterialTheme.colorScheme.error) }
                } else null,
                visualTransformation = if (passwordVisible) VisualTransformation.None else PasswordVisualTransformation(),
                trailingIcon = {
                    IconButton(onClick = { passwordVisible = !passwordVisible }) {
                        Icon(
                            imageVector = if (passwordVisible) Icons.Filled.Visibility else Icons.Filled.VisibilityOff,
                            contentDescription = if (passwordVisible) "Ocultar senha" else "Mostrar senha",
                            tint = TaskGoTextGray
                        )
                    }
                }
            )
            
            // Indicador de for√ßa da senha
            if (password.isNotEmpty()) {
                Spacer(modifier = Modifier.height(8.dp))
                com.taskgoapp.taskgo.core.design.PasswordStrengthIndicator(
                    password = password,
                    modifier = Modifier.fillMaxWidth()
                )
            }
            
            Spacer(modifier = Modifier.height(16.dp))
            
            // Campo Confirmar Senha
            EnhancedOutlinedTextField(
                value = confirmPassword,
                onValueChange = { newConfirmPassword ->
                    confirmPassword = newConfirmPassword
                    
                    // Validar se as senhas coincidem
                    if (newConfirmPassword.isNotEmpty()) {
                        if (newConfirmPassword != password) {
                            confirmPasswordError = "As senhas n√£o coincidem"
                        } else {
                            confirmPasswordError = null
                        }
                    } else {
                        confirmPasswordError = null
                    }
                },
                label = { 
                    Text(
                        "Confirmar Senha",
                        color = TaskGoTextGray,
                        fontSize = 14.sp
                    ) 
                },
                modifier = Modifier
                    .fillMaxWidth()
                    .heightIn(min = 72.dp),
                keyboardOptions = KeyboardOptions(
                    keyboardType = KeyboardType.Password,
                    imeAction = androidx.compose.ui.text.input.ImeAction.Done
                ),
                isError = confirmPasswordError != null,
                supportingText = if (confirmPasswordError != null) {
                    { Text(confirmPasswordError ?: "", color = MaterialTheme.colorScheme.error) }
                } else null,
                visualTransformation = if (confirmPasswordVisible) VisualTransformation.None else PasswordVisualTransformation(),
                trailingIcon = {
                    IconButton(onClick = { confirmPasswordVisible = !confirmPasswordVisible }) {
                        Icon(
                            imageVector = if (confirmPasswordVisible) Icons.Filled.Visibility else Icons.Filled.VisibilityOff,
                            contentDescription = if (confirmPasswordVisible) "Ocultar senha" else "Mostrar senha",
                            tint = TaskGoTextGray
                        )
                    }
                }
            )
            
            Spacer(modifier = Modifier.height(32.dp))
            
            // Bot√£o Cadastrar (usar o viewModel j√° criado acima)
            
            // Vari√°veis para valida√ß√£o e submiss√£o
            val phoneText = phone.text
            val zipCodeText = zipCode.text
            val birthDateText = birthDate.text
            val cpfText = cpf.text.replace(Regex("[^0-9]"), "") // Remove formata√ß√£o do CPF
            val cnpjText = cnpj.text.replace(Regex("[^0-9]"), "") // Remove formata√ß√£o do CNPJ
            val rgText = rgTextFieldValue.text.replace(Regex("[^0-9A-Za-z]"), "") // Remove formata√ß√£o do RG
            val isAddressComplete = zipCodeText.isNotEmpty() && street.isNotEmpty() && 
                                   number.isNotEmpty() && neighborhood.isNotEmpty() && 
                                   city.isNotEmpty() && state.isNotEmpty()
            
            Button(
                onClick = { 
                    android.util.Log.d("SignUpScreen", "Bot√£o Cadastrar clicado")
                    
                    // Criar objeto Address (obrigat√≥rio)
                    val address = com.taskgoapp.taskgo.core.model.Address(
                        street = street,
                        number = number,
                        complement = complement.takeIf { it.isNotEmpty() },
                        neighborhood = neighborhood,
                        city = city,
                        state = state,
                        country = country,
                        zipCode = zipCodeText,
                        cep = zipCodeText
                    )
                    
                    // Parse birthDate se fornecido
                    val parsedBirthDate = try {
                        if (birthDateText.isNotEmpty()) {
                            val parts = birthDateText.split("/")
                            if (parts.size == 3) {
                                val day = parts[0].toInt()
                                val month = parts[1].toInt() - 1 // Calendar months are 0-based
                                val year = parts[2].toInt()
                                java.util.Calendar.getInstance().apply {
                                    set(year, month, day)
                                }.time
                            } else null
                        } else null
                    } catch (e: Exception) {
                        android.util.Log.e("SignUpScreen", "Erro ao parsear data de nascimento: ${e.message}", e)
                        null
                    }
                    
                    // Mapear AccountType para UserType (tempor√°rio, para compatibilidade)
                    val userType = when (selectedAccountType) {
                        AccountType.PARCEIRO -> com.taskgoapp.taskgo.core.model.UserType.PROVIDER // Parceiro mapeia para PROVIDER
                        AccountType.PRESTADOR -> com.taskgoapp.taskgo.core.model.UserType.PROVIDER // Legacy
                        AccountType.VENDEDOR -> com.taskgoapp.taskgo.core.model.UserType.PROVIDER // Legacy - agora √© provider tamb√©m
                        AccountType.CLIENTE -> com.taskgoapp.taskgo.core.model.UserType.CLIENT
                    }
                    
                    // Converter Set<String> para List<String> para preferredCategories
                    val preferredCategoriesList = if (selectedAccountType == AccountType.PARCEIRO && selectedServiceCategories.isNotEmpty()) {
                        selectedServiceCategories.toList()
                    } else null
                    
                    viewModel.signup(
                        name = name,
                        email = email,
                        phone = phoneText,
                        password = password,
                        userType = userType,
                        accountType = selectedAccountType,
                        cpf = if (selectedAccountType == AccountType.PARCEIRO && documentType == "CNPJ") null else cpfText.takeIf { it.isNotEmpty() },
                        cnpj = if (selectedAccountType == AccountType.PARCEIRO && documentType == "CNPJ") cnpjText.takeIf { it.isNotEmpty() } else null,
                        rg = rgTextFieldValue.text.uppercase(),
                        birthDate = parsedBirthDate,
                        address = address,
                        biometricEnabled = biometricEnabled,
                        twoFactorEnabled = twoFactorEnabled,
                        twoFactorMethod = if (twoFactorEnabled) "email" else null,
                        preferredCategories = preferredCategoriesList
                    )
                },
                modifier = Modifier
                    .fillMaxWidth()
                    .height(56.dp),
                shape = RoundedCornerShape(8.dp),
                colors = ButtonDefaults.buttonColors(
                    containerColor = TaskGoGreen
                ),
                enabled = !uiState.isLoading && 
                         name.isNotEmpty() && 
                         email.isNotEmpty() && 
                         phoneText.isNotEmpty() && 
                         cpfText.length == 11 &&
                         cpfError == null &&
                         rgText.length >= 6 &&
                         rgError == null &&
                         isAddressComplete &&
                         password.isNotEmpty() && 
                         confirmPassword.isNotEmpty() && 
                         password == confirmPassword &&
                         passwordError == null &&
                         confirmPasswordError == null &&
                         // Valida√ß√£o adicional: RG formatado deve ser v√°lido (XX.XXX.XXX-X = 9 d√≠gitos ou mais)
                         (rgText.isEmpty() || (rgText.length >= 6 && rgText.length <= 12))
            ) {
                if (uiState.isLoading) {
                    CircularProgressIndicator(
                        color = Color.White,
                        modifier = Modifier.size(20.dp)
                    )
                } else {
                    Text(
                        text = "Cadastrar",
                        color = Color.White,
                        fontSize = 16.sp,
                        fontWeight = FontWeight.Bold
                    )
                }
            }
            
            // Mensagem de erro
            uiState.errorMessage?.let { errorMsg ->
                Spacer(modifier = Modifier.height(12.dp))
                Text(
                    text = errorMsg,
                    color = MaterialTheme.colorScheme.error,
                    fontSize = 14.sp,
                    textAlign = TextAlign.Center,
                    modifier = Modifier.fillMaxWidth()
                )
            }
            
            // Navega√ß√£o ap√≥s sucesso - ir para tela de verifica√ß√£o de documentos
            LaunchedEffect(uiState.isSuccess) {
                if (uiState.isSuccess) {
                    android.util.Log.d("SignUpScreen", "Cadastro bem-sucedido, navegando para verifica√ß√£o de documentos...")
                    kotlinx.coroutines.delay(500) // Pequeno delay para garantir que tudo foi salvo
                    onNavigateToDocumentVerification() // Navega para identity_verification
                }
            }
            
            Spacer(modifier = Modifier.height(24.dp))
            
            // Divisor
            Row(
                modifier = Modifier.fillMaxWidth(),
                verticalAlignment = Alignment.CenterVertically
            ) {
                HorizontalDivider(
                    modifier = Modifier.weight(1f),
                    color = Color(0xFFD9D9D9),
                    thickness = 1.dp
                )
                Text(
                    text = "ou",
                    color = TaskGoTextGray,
                    fontSize = 14.sp,
                    modifier = Modifier.padding(horizontal = 16.dp)
                )
                HorizontalDivider(
                    modifier = Modifier.weight(1f),
                    color = Color(0xFFD9D9D9),
                    thickness = 1.dp
                )
            }
            
            Spacer(modifier = Modifier.height(24.dp))
            
            // Link para Login
            Text(
                text = "J√° tenho uma conta",
                color = TaskGoGreen,
                fontSize = 14.sp,
                modifier = Modifier.clickable { onNavigateToLogin() }
            )
            
            Spacer(modifier = Modifier.height(40.dp))
        }
    }
}


```

## [FRONTEND]: feature/auth/presentation/SignUpSuccessScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.auth.presentation

import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.CheckCircle
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.taskgoapp.taskgo.core.design.TGIcons
import com.taskgoapp.taskgo.core.theme.TaskGoGreen
import com.taskgoapp.taskgo.core.theme.TaskGoTextBlack
import com.taskgoapp.taskgo.core.theme.TaskGoTextGray
import com.taskgoapp.taskgo.core.theme.TaskGoBackgroundWhite
import kotlinx.coroutines.delay

@Composable
fun SignUpSuccessScreen(
    onNavigateToHome: () -> Unit,
    onNavigateToLogin: () -> Unit
) {
    var showSuccess by remember { mutableStateOf(false) }

    LaunchedEffect(Unit) {
        delay(1000) // Delay para mostrar a anima√ß√£o
        showSuccess = true
    }

    Box(
        modifier = Modifier
            .fillMaxSize()
            .background(TaskGoBackgroundWhite)
    ) {
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(24.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center
        ) {
            // Logo TaskGo Horizontal
            Image(
                painter = painterResource(id = TGIcons.TaskGoLogoHorizontal),
                contentDescription = "TaskGo Logo",
                modifier = Modifier.size(120.dp, 40.dp)
            )
            
            Spacer(modifier = Modifier.height(40.dp))
            
            // √çcone de sucesso
            Box(
                modifier = Modifier
                    .size(80.dp)
                    .background(
                        color = TaskGoGreen.copy(alpha = 0.1f),
                        shape = CircleShape
                    ),
                contentAlignment = Alignment.Center
            ) {
                Icon(
                    imageVector = Icons.Filled.CheckCircle,
                    contentDescription = "Sucesso",
                    modifier = Modifier.size(40.dp),
                    tint = TaskGoGreen
                )
            }
            
            Spacer(modifier = Modifier.height(24.dp))
            
            // T√≠tulo
            Text(
                text = "Cadastro Finalizado",
                style = MaterialTheme.typography.headlineMedium,
                color = TaskGoTextBlack,
                fontWeight = FontWeight.Bold,
                fontSize = 24.sp,
                textAlign = TextAlign.Center
            )
            
            Spacer(modifier = Modifier.height(16.dp))
            
            // Descri√ß√£o
            Text(
                text = "Seu cadastro foi realizado com sucesso!\nAgora voc√™ pode come√ßar a usar o TaskGo.",
                color = TaskGoTextGray,
                fontSize = 16.sp,
                textAlign = TextAlign.Center,
                lineHeight = 24.sp
            )
            
            Spacer(modifier = Modifier.height(40.dp))
            
            // Bot√£o Continuar
            Button(
                onClick = { onNavigateToHome() },
                modifier = Modifier
                    .fillMaxWidth()
                    .height(56.dp),
                shape = androidx.compose.foundation.shape.RoundedCornerShape(8.dp),
                colors = ButtonDefaults.buttonColors(
                    containerColor = TaskGoGreen
                )
            ) {
                Text(
                    text = "Continuar",
                    color = Color.White,
                    fontSize = 16.sp,
                    fontWeight = FontWeight.Bold
                )
            }
            
            Spacer(modifier = Modifier.height(16.dp))
            
            // Link para Login
            Text(
                text = "Fazer Login",
                color = TaskGoGreen,
                fontSize = 14.sp,
                modifier = Modifier.clickable { onNavigateToLogin() }
            )
        }
    }
}

```

## [FRONTEND]: feature/auth/presentation/SignupViewModel.kt

```kotlin
package com.taskgoapp.taskgo.feature.auth.presentation

import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.taskgoapp.taskgo.core.model.UserType
import com.taskgoapp.taskgo.core.model.AccountType
import com.taskgoapp.taskgo.core.data.models.ServiceCategory
import com.taskgoapp.taskgo.data.firestore.models.UserFirestore
import com.taskgoapp.taskgo.data.repository.FirebaseAuthRepository
import com.taskgoapp.taskgo.data.repository.FirestoreUserRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.launch
import kotlinx.coroutines.tasks.await
import java.util.Date

data class SignupUiState(
    val isLoading: Boolean = false,
    val errorMessage: String? = null,
    val isSuccess: Boolean = false
)

@HiltViewModel
class SignupViewModel @Inject constructor(
    private val authRepository: FirebaseAuthRepository,
    private val firestoreUserRepository: FirestoreUserRepository,
    private val preferencesManager: com.taskgoapp.taskgo.data.local.datastore.PreferencesManager,
    private val categoriesRepository: com.taskgoapp.taskgo.domain.repository.CategoriesRepository,
    private val firebaseFunctionsService: com.taskgoapp.taskgo.data.firebase.FirebaseFunctionsService,
    private val initialDataSyncManager: com.taskgoapp.taskgo.core.sync.InitialDataSyncManager
) : ViewModel() {

    private val _uiState = MutableStateFlow(SignupUiState())
    val uiState: StateFlow<SignupUiState> = _uiState
    
    // Observar categorias de servi√ßo para exibir checkboxes no cadastro de Parceiro
    val serviceCategories: StateFlow<List<ServiceCategory>> = 
        categoriesRepository.observeServiceCategories()
            .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyList())

    fun signup(
        name: String,
        email: String,
        phone: String,
        password: String,
        userType: UserType,
        accountType: AccountType? = null,
        cpf: String? = null,
        rg: String? = null,
        cnpj: String? = null,
        birthDate: Date? = null,
        address: com.taskgoapp.taskgo.core.model.Address? = null,
        biometricEnabled: Boolean = false,
        twoFactorEnabled: Boolean = false,
        twoFactorMethod: String? = null,
        preferredCategories: List<String>? = null // Categorias de servi√ßo selecionadas pelo Parceiro
    ) {
        if (_uiState.value.isLoading) return

        // Valida√ß√µes b√°sicas
        if (name.isBlank()) {
            _uiState.value = SignupUiState(errorMessage = "Nome √© obrigat√≥rio")
            return
        }

        if (email.isBlank() || !android.util.Patterns.EMAIL_ADDRESS.matcher(email).matches()) {
            _uiState.value = SignupUiState(errorMessage = "Email inv√°lido")
            return
        }

        // Validar senha usando PasswordValidator
        val passwordValidator = com.taskgoapp.taskgo.core.validation.PasswordValidator()
        val passwordValidation = passwordValidator.validate(password)
        if (passwordValidation is com.taskgoapp.taskgo.core.validation.ValidationResult.Invalid) {
            _uiState.value = SignupUiState(errorMessage = passwordValidation.message)
            return
        }

        _uiState.value = SignupUiState(isLoading = true, errorMessage = null, isSuccess = false)

        viewModelScope.launch {
            try {
                Log.d("SignupViewModel", "Iniciando cadastro para: $email")
                Log.d("SignupViewModel", "Dados: nome=$name, email=$email, telefone=$phone, userType=$userType")
                
                // 1. Criar usu√°rio no Firebase Auth
                val authResult = authRepository.signUpWithEmail(email.trim(), password)

                authResult.fold(
                    onSuccess = { firebaseUser ->
                        Log.d("SignupViewModel", "Usu√°rio criado no Firebase Auth: ${firebaseUser.uid}")
                        
                        // 2. Atualizar perfil do Firebase Auth com o nome
                        authRepository.updateProfile(name, null).fold(
                            onSuccess = {
                                Log.d("SignupViewModel", "Perfil do Firebase Auth atualizado")
                                
                                // 3. Criar/atualizar perfil no Firestore
                                // Priorizar accountType se fornecido, sen√£o usar userType
                                // Mapear AccountType para role string
                                val role = when (accountType) {
                                    AccountType.PARCEIRO -> "partner"
                                    AccountType.PRESTADOR -> "partner" // Legacy - migrar para partner
                                    AccountType.VENDEDOR -> "partner" // Legacy - migrar para partner
                                    AccountType.CLIENTE -> "client"
                                    null -> when (userType) {
                                        UserType.CLIENT -> "client"
                                        UserType.PROVIDER -> "partner" // Provider agora √© partner
                                    }
                                }

                                val userFirestore = UserFirestore(
                                    uid = firebaseUser.uid,
                                    email = firebaseUser.email ?: email,
                                    displayName = name,
                                    photoURL = firebaseUser.photoUrl?.toString(),
                                    role = role,
                                    profileComplete = false,
                                    verified = false,
                                    createdAt = Date(),
                                    updatedAt = Date(),
                                    phone = phone,
                                    cpf = cpf,
                                    rg = rg,
                                    cnpj = cnpj,
                                    birthDate = birthDate,
                                    address = address,
                                    biometricEnabled = biometricEnabled,
                                    twoFactorEnabled = twoFactorEnabled,
                                    twoFactorMethod = twoFactorMethod,
                                    preferredCategories = if (accountType == AccountType.PARCEIRO && preferredCategories != null && preferredCategories.isNotEmpty()) {
                                        preferredCategories
                                    } else null
                                )
                                
                                // Salvar prefer√™ncias de biometria e 2FA
                                viewModelScope.launch {
                                    preferencesManager.updateBiometricEnabled(biometricEnabled)
                                    preferencesManager.updateTwoFactorEnabled(twoFactorEnabled)
                                    if (twoFactorMethod != null) {
                                        preferencesManager.updateTwoFactorMethod(twoFactorMethod)
                                    }
                                    if (biometricEnabled) {
                                        preferencesManager.saveEmailForBiometric(email.trim())
                                    }
                                }

                                Log.d("SignupViewModel", "Verificando se usu√°rio existe no Firestore...")
                                
                                // CR√çTICO: Aguardar um pouco para garantir que a Cloud Function tenha executado
                                // Se a fun√ß√£o executar depois, ela n√£o vai sobrescrever o role (fun√ß√£o atualizada)
                                kotlinx.coroutines.delay(500)
                                
                                // Verificar se o documento j√° existe (criado pela Cloud Function)
                                val existingUser = try {
                                    firestoreUserRepository.getUser(firebaseUser.uid)
                                } catch (e: Exception) {
                                    Log.e("SignupViewModel", "Erro ao buscar usu√°rio: ${e.message}", e)
                                    null
                                }

                                // CR√çTICO: Primeiro chamar setInitialUserRole Cloud Function para definir Custom Claims
                                Log.d("SignupViewModel", "Chamando setInitialUserRole Cloud Function com role: $role")
                                val setRoleResult = firebaseFunctionsService.setInitialUserRole(
                                    role, 
                                    accountType?.name
                                )
                                
                                setRoleResult.fold(
                                    onSuccess = { result ->
                                        Log.d("SignupViewModel", "setInitialUserRole bem-sucedido: $result")
                                        
                                        // CR√çTICO: Recarregar token para obter novos Custom Claims
                                        Log.d("SignupViewModel", "Recarregando token para obter novos Custom Claims...")
                                        try {
                                            firebaseUser.getIdToken(true).await()
                                            Log.d("SignupViewModel", "Token recarregado com sucesso")
                                        } catch (e: Exception) {
                                            Log.e("SignupViewModel", "Erro ao recarregar token: ${e.message}", e)
                                        }
                                        
                                        // Agora salvar/atualizar no Firestore
                                        Log.d("SignupViewModel", "Salvando usu√°rio no Firestore com role: $role (accountType: $accountType)")
                                        
                                        if (existingUser != null) {
                                            Log.d("SignupViewModel", "Usu√°rio existente encontrado, atualizando com role: $role")
                                            Log.d("SignupViewModel", "Role anterior: '${existingUser.role}', novo role: '$role'")
                                            
                                            // Atualizar documento existente - CR√çTICO: sempre atualizar o role com o accountType selecionado
                                            val updatedUser = existingUser.copy(
                                                displayName = name,
                                                phone = phone,
                                                role = role, // CR√çTICO: Sempre usar o role baseado no accountType selecionado
                                                cpf = cpf,
                                                rg = rg,
                                                cnpj = cnpj,
                                                birthDate = birthDate,
                                                address = address,
                                                biometricEnabled = biometricEnabled,
                                                twoFactorEnabled = twoFactorEnabled,
                                                twoFactorMethod = twoFactorMethod,
                                                preferredCategories = if (accountType == AccountType.PARCEIRO && preferredCategories != null && preferredCategories.isNotEmpty()) {
                                                    preferredCategories
                                                } else existingUser.preferredCategories, // Preservar existente se n√£o fornecido
                                                pendingAccountType = false, // Remover flag de pend√™ncia
                                                updatedAt = Date()
                                            )
                                            firestoreUserRepository.updateUser(updatedUser).fold(
                                                onSuccess = {
                                                    Log.d("SignupViewModel", "‚úÖ Perfil atualizado com sucesso com role: $role")
                                                    
                                                    // CR√çTICO: For√ßar sincroniza√ß√£o dos dados do usu√°rio ap√≥s atualizar role
                                                    Log.d("SignupViewModel", "üîÑ For√ßando sincroniza√ß√£o dos dados do usu√°rio ap√≥s atualiza√ß√£o de role...")
                                                    viewModelScope.launch {
                                                        try {
                                                            initialDataSyncManager.syncAllUserData()
                                                            Log.d("SignupViewModel", "‚úÖ Sincroniza√ß√£o de dados conclu√≠da")
                                                        } catch (e: Exception) {
                                                            Log.e("SignupViewModel", "Erro ao sincronizar dados ap√≥s atualiza√ß√£o de role: ${e.message}", e)
                                                        }
                                                    }
                                                    
                                                    _uiState.value = SignupUiState(isLoading = false, isSuccess = true)
                                                },
                                                onFailure = { exception ->
                                                    Log.e("SignupViewModel", "Erro ao atualizar perfil: ${exception.message}", exception)
                                                    // Mesmo com erro no Firestore, o Custom Claim j√° foi definido, ent√£o permitir cadastro
                                                    _uiState.value = SignupUiState(isLoading = false, isSuccess = true)
                                                }
                                            )
                                        } else {
                                            Log.d("SignupViewModel", "Usu√°rio n√£o existe, criando novo documento com role: $role")
                                            // Criar novo documento com o role correto desde o in√≠cio
                                            val newUser = userFirestore.copy(
                                                pendingAccountType = false // Remover flag de pend√™ncia
                                            )
                                            firestoreUserRepository.updateUser(newUser).fold(
                                                onSuccess = {
                                                    Log.d("SignupViewModel", "‚úÖ Perfil criado com sucesso com role: $role")
                                                    
                                                    // CR√çTICO: For√ßar sincroniza√ß√£o dos dados do usu√°rio ap√≥s criar perfil
                                                    Log.d("SignupViewModel", "üîÑ For√ßando sincroniza√ß√£o dos dados do usu√°rio ap√≥s cria√ß√£o de perfil...")
                                                    viewModelScope.launch {
                                                        try {
                                                            initialDataSyncManager.syncAllUserData()
                                                            Log.d("SignupViewModel", "‚úÖ Sincroniza√ß√£o de dados conclu√≠da")
                                                        } catch (e: Exception) {
                                                            Log.e("SignupViewModel", "Erro ao sincronizar dados ap√≥s cria√ß√£o de perfil: ${e.message}", e)
                                                        }
                                                    }
                                                    
                                                    _uiState.value = SignupUiState(isLoading = false, isSuccess = true)
                                                },
                                                onFailure = { exception ->
                                                    Log.e("SignupViewModel", "Erro ao criar perfil: ${exception.message}", exception)
                                                    // Mesmo com erro no Firestore, o Custom Claim j√° foi definido, ent√£o permitir cadastro
                                                    _uiState.value = SignupUiState(isLoading = false, isSuccess = true)
                                                }
                                            )
                                        }
                                    },
                                    onFailure = { exception ->
                                        Log.e("SignupViewModel", "Erro ao chamar setInitialUserRole: ${exception.message}", exception)
                                        // Se falhar, tentar salvar diretamente no Firestore (fallback)
                                        Log.d("SignupViewModel", "Tentando salvar diretamente no Firestore (fallback)...")
                                        
                                        if (existingUser != null) {
                                            val updatedUser = existingUser.copy(
                                                displayName = name,
                                                phone = phone,
                                                role = role,
                                                cpf = cpf,
                                                rg = rg,
                                                cnpj = cnpj,
                                                birthDate = birthDate,
                                                address = address,
                                                biometricEnabled = biometricEnabled,
                                                twoFactorEnabled = twoFactorEnabled,
                                                twoFactorMethod = twoFactorMethod,
                                                preferredCategories = if (accountType == AccountType.PARCEIRO && preferredCategories != null && preferredCategories.isNotEmpty()) {
                                                    preferredCategories
                                                } else existingUser.preferredCategories,
                                                pendingAccountType = false,
                                                updatedAt = Date()
                                            )
                                            firestoreUserRepository.updateUser(updatedUser).fold(
                                                onSuccess = {
                                                    Log.d("SignupViewModel", "‚úÖ Perfil atualizado (fallback)")
                                                    _uiState.value = SignupUiState(isLoading = false, isSuccess = true)
                                                },
                                                onFailure = { e ->
                                                    Log.e("SignupViewModel", "Erro ao atualizar perfil (fallback): ${e.message}", e)
                                                    _uiState.value = SignupUiState(
                                                        isLoading = false,
                                                        errorMessage = "Erro ao criar perfil: ${e.message}"
                                                    )
                                                }
                                            )
                                        } else {
                                            val newUser = userFirestore.copy(pendingAccountType = false)
                                            firestoreUserRepository.updateUser(newUser).fold(
                                                onSuccess = {
                                                    Log.d("SignupViewModel", "‚úÖ Perfil criado (fallback)")
                                                    _uiState.value = SignupUiState(isLoading = false, isSuccess = true)
                                                },
                                                onFailure = { e ->
                                                    Log.e("SignupViewModel", "Erro ao criar perfil (fallback): ${e.message}", e)
                                                    _uiState.value = SignupUiState(
                                                        isLoading = false,
                                                        errorMessage = "Erro ao criar perfil: ${e.message}"
                                                    )
                                                }
                                            )
                                        }
                                    }
                                )
                            },
                            onFailure = { exception ->
                                Log.e("SignupViewModel", "Erro ao atualizar perfil Firebase Auth: ${exception.message}", exception)
                                _uiState.value = SignupUiState(
                                    isLoading = false,
                                    errorMessage = "Erro ao atualizar perfil: ${exception.message}"
                                )
                            }
                        )
                    },
                    onFailure = { exception ->
                        Log.e("SignupViewModel", "Erro ao criar usu√°rio: ${exception.message}", exception)
                        val errorMsg = when {
                            exception.message?.contains("email-already-in-use") == true -> "Este email j√° est√° cadastrado"
                            exception.message?.contains("invalid-email") == true -> "Email inv√°lido"
                            exception.message?.contains("weak-password") == true -> "Senha muito fraca. Use pelo menos 6 caracteres"
                            exception.message?.contains("network") == true -> "Erro de conex√£o. Verifique sua internet"
                            else -> exception.message ?: "Falha ao criar conta"
                        }
                        _uiState.value = SignupUiState(isLoading = false, errorMessage = errorMsg)
                    }
                )
            } catch (e: Exception) {
                Log.e("SignupViewModel", "Erro inesperado: ${e.message}", e)
                _uiState.value = SignupUiState(
                    isLoading = false,
                    errorMessage = "Erro inesperado: ${e.message}"
                )
            }
        }
    }
}



```

## [FRONTEND]: feature/auth/presentation/TwoFactorAuthScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.auth.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Lock
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.theme.*

/**
 * Tela de verifica√ß√£o de c√≥digo de autentica√ß√£o de duas etapas (2FA)
 * Exibida ap√≥s login quando o usu√°rio tem 2FA ativado
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun TwoFactorAuthScreen(
    onVerificationSuccess: () -> Unit,
    onVerificationFailed: () -> Unit,
    viewModel: TwoFactorAuthViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    var code by remember { mutableStateOf("") }
    var isResending by remember { mutableStateOf(false) }
    
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Verifica√ß√£o de C√≥digo",
                subtitle = "Digite o c√≥digo enviado para ${uiState.verificationMethod}",
                onBackClick = onVerificationFailed,
                backgroundColor = TaskGoGreen,
                titleColor = Color.White,
                subtitleColor = Color.White,
                backIconColor = Color.White
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(24.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.spacedBy(24.dp)
        ) {
            Spacer(modifier = Modifier.weight(1f))
            
            // √çcone de seguran√ßa
            Icon(
                imageVector = Icons.Default.Lock,
                contentDescription = null,
                modifier = Modifier.size(80.dp),
                tint = TaskGoGreen
            )
            
            Text(
                text = "Autentica√ß√£o de Duas Etapas",
                style = MaterialTheme.typography.headlineSmall,
                fontWeight = FontWeight.Bold,
                color = TaskGoTextBlack,
                textAlign = TextAlign.Center
            )
            
            Text(
                text = "Enviamos um c√≥digo de verifica√ß√£o de 6 d√≠gitos para:\n${uiState.verificationMethod}",
                style = MaterialTheme.typography.bodyMedium,
                color = TaskGoTextGray,
                textAlign = TextAlign.Center
            )
            
            // Campo de c√≥digo
            OutlinedTextField(
                value = code,
                onValueChange = { newValue ->
                    if (newValue.length <= 6 && newValue.all { it.isDigit() }) {
                        code = newValue
                        if (newValue.length == 6) {
                            viewModel.verifyCode(newValue)
                        }
                    }
                },
                modifier = Modifier.fillMaxWidth(),
                label = { Text("C√≥digo de verifica√ß√£o") },
                placeholder = { Text("000000") },
                keyboardOptions = androidx.compose.foundation.text.KeyboardOptions(
                    keyboardType = KeyboardType.Number
                ),
                singleLine = true,
                isError = uiState.error != null,
                supportingText = uiState.error?.let { { Text(it, color = MaterialTheme.colorScheme.error) } }
            )
            
            if (uiState.isLoading) {
                CircularProgressIndicator()
            }
            
            // Bot√£o de reenvio
            TextButton(
                onClick = {
                    isResending = true
                    viewModel.resendCode()
                },
                enabled = !isResending && !uiState.isLoading
            ) {
                Text(
                    text = if (isResending) "Reenviando..." else "Reenviar c√≥digo",
                    color = TaskGoGreen
                )
            }
            
            Spacer(modifier = Modifier.weight(1f))
            
            // Bot√£o de verificar
            Button(
                onClick = { viewModel.verifyCode(code) },
                modifier = Modifier
                    .fillMaxWidth()
                    .height(56.dp),
                enabled = code.length == 6 && !uiState.isLoading,
                colors = ButtonDefaults.buttonColors(
                    containerColor = TaskGoGreen
                )
            ) {
                Text(
                    text = "Verificar",
                    fontWeight = FontWeight.Bold
                )
            }
        }
    }
    
    // Navegar quando verifica√ß√£o for bem-sucedida
    LaunchedEffect(uiState.isVerified) {
        if (uiState.isVerified) {
            onVerificationSuccess()
        }
    }
}


```

## [FRONTEND]: feature/auth/presentation/TwoFactorAuthViewModel.kt

```kotlin
package com.taskgoapp.taskgo.feature.auth.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.firestore.FirebaseFirestore
import com.taskgoapp.taskgo.data.repository.FirestoreUserRepository
import com.taskgoapp.taskgo.data.firebase.FirebaseFunctionsService
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.tasks.await
import kotlinx.coroutines.launch
import javax.inject.Inject

data class TwoFactorAuthUiState(
    val verificationMethod: String = "",
    val isLoading: Boolean = false,
    val isVerified: Boolean = false,
    val error: String? = null,
    val codeSent: Boolean = false
)

@HiltViewModel
class TwoFactorAuthViewModel @Inject constructor(
    private val auth: FirebaseAuth,
    private val firestore: FirebaseFirestore,
    private val userRepository: FirestoreUserRepository,
    private val functionsService: FirebaseFunctionsService
) : ViewModel() {
    
    private val _uiState = MutableStateFlow(TwoFactorAuthUiState())
    val uiState: StateFlow<TwoFactorAuthUiState> = _uiState.asStateFlow()
    
    init {
        loadVerificationMethod()
        sendVerificationCode()
    }
    
    private fun loadVerificationMethod() {
        viewModelScope.launch {
            try {
                val currentUser = auth.currentUser ?: return@launch
                val user = userRepository.getUser(currentUser.uid)
                
                val method = when {
                    user?.phone != null -> "Telefone: ${maskPhone(user.phone)}"
                    user?.email != null -> "Email: ${maskEmail(user.email)}"
                    else -> "Email ou Telefone"
                }
                
                _uiState.value = _uiState.value.copy(verificationMethod = method)
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(error = "Erro ao carregar m√©todo de verifica√ß√£o")
            }
        }
    }
    
    fun sendVerificationCode() {
        viewModelScope.launch {
            try {
                _uiState.value = _uiState.value.copy(isLoading = true, error = null)
                
                val currentUser = auth.currentUser ?: run {
                    _uiState.value = _uiState.value.copy(
                        isLoading = false,
                        error = "Usu√°rio n√£o autenticado"
                    )
                    return@launch
                }
                
                // Chamar Cloud Function para enviar c√≥digo
                val result = functionsService.sendTwoFactorCode()
                
                result.fold(
                    onSuccess = { data ->
                        val method = data["method"] as? String ?: "email"
                        val message = data["message"] as? String ?: "C√≥digo enviado"
                        
                        _uiState.value = _uiState.value.copy(
                            isLoading = false,
                            codeSent = true,
                            verificationMethod = message
                        )
                    },
                    onFailure = { exception ->
                        _uiState.value = _uiState.value.copy(
                            isLoading = false,
                            error = "Erro ao enviar c√≥digo: ${exception.message}"
                        )
                    }
                )
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = "Erro: ${e.message}"
                )
            }
        }
    }
    
    fun resendCode() {
        sendVerificationCode()
    }
    
    fun verifyCode(code: String) {
        viewModelScope.launch {
            try {
                _uiState.value = _uiState.value.copy(isLoading = true, error = null)
                
                val currentUser = auth.currentUser ?: run {
                    _uiState.value = _uiState.value.copy(
                        isLoading = false,
                        error = "Usu√°rio n√£o autenticado"
                    )
                    return@launch
                }
                
                // Chamar Cloud Function para verificar c√≥digo
                val result = functionsService.verifyTwoFactorCode(code)
                
                result.fold(
                    onSuccess = { data ->
                        val verified = data["verified"] as? Boolean ?: false
                        if (verified) {
                            _uiState.value = _uiState.value.copy(
                                isLoading = false,
                                isVerified = true
                            )
                        } else {
                            _uiState.value = _uiState.value.copy(
                                isLoading = false,
                                error = "C√≥digo inv√°lido"
                            )
                        }
                    },
                    onFailure = { exception ->
                        _uiState.value = _uiState.value.copy(
                            isLoading = false,
                            error = when {
                                exception.message?.contains("expirado") == true -> "C√≥digo expirado. Solicite um novo c√≥digo."
                                exception.message?.contains("inv√°lido") == true -> "C√≥digo inv√°lido. Tente novamente."
                                else -> "Erro ao verificar c√≥digo: ${exception.message}"
                            }
                        )
                    }
                )
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = "Erro: ${e.message}"
                )
            }
        }
    }
    
    
    private fun maskEmail(email: String): String {
        val parts = email.split("@")
        if (parts.size != 2) return email
        val username = parts[0]
        val domain = parts[1]
        val maskedUsername = if (username.length > 2) {
            "${username.take(2)}***"
        } else {
            "***"
        }
        return "$maskedUsername@$domain"
    }
    
    private fun maskPhone(phone: String): String {
        return if (phone.length > 4) {
            "***${phone.takeLast(4)}"
        } else {
            "***"
        }
    }
}


```

# Features - chatai


## [FRONTEND]: feature/chatai/data/ChatAttachment.kt

```kotlin
package com.taskgoapp.taskgo.feature.chatai.data

import android.net.Uri

data class ChatAttachment(
    val id: String,
    val uri: Uri,
    val type: AttachmentType,
    val fileName: String? = null,
    val mimeType: String? = null
) {
    // Para serializa√ß√£o, converter Uri para String
    fun toSerializable(): SerializableAttachment {
        return SerializableAttachment(
            id = id,
            uriString = uri.toString(),
            type = type,
            fileName = fileName,
            mimeType = mimeType
        )
    }
    
    companion object {
        fun fromSerializable(serializable: SerializableAttachment): ChatAttachment? {
            return try {
                ChatAttachment(
                    id = serializable.id,
                    uri = Uri.parse(serializable.uriString),
                    type = serializable.type,
                    fileName = serializable.fileName,
                    mimeType = serializable.mimeType
                )
            } catch (e: Exception) {
                null
            }
        }
    }
}

data class SerializableAttachment(
    val id: String,
    val uriString: String,
    val type: AttachmentType,
    val fileName: String? = null,
    val mimeType: String? = null
)

enum class AttachmentType {
    IMAGE,
    DOCUMENT
}


```

## [FRONTEND]: feature/chatai/data/ChatSession.kt

```kotlin
package com.taskgoapp.taskgo.feature.chatai.data

data class ChatSession(
    val id: String,
    val title: String,
    val lastMessage: String? = null,
    val timestamp: Long,
    val messageCount: Int = 0
)


```

## [FRONTEND]: feature/chatai/data/ChatStorage.kt

```kotlin
package com.taskgoapp.taskgo.feature.chatai.data

import android.content.Context
import android.content.SharedPreferences
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import com.taskgoapp.taskgo.feature.chatai.presentation.AiMessage
import dagger.hilt.android.qualifiers.ApplicationContext
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class ChatStorage @Inject constructor(
    @ApplicationContext private val context: Context
) {
    private val prefs: SharedPreferences = context.getSharedPreferences("taskgo_ai_chats", Context.MODE_PRIVATE)
    private val gson = Gson()
    
    fun saveMessages(chatId: String, messages: List<AiMessage>) {
        val messagesJson = gson.toJson(messages)
        prefs.edit().putString("chat_messages_$chatId", messagesJson).apply()
    }
    
    fun loadMessages(chatId: String): List<AiMessage> {
        val messagesJson = prefs.getString("chat_messages_$chatId", null)
        return if (messagesJson != null) {
            try {
                val type = object : TypeToken<List<AiMessage>>() {}.type
                gson.fromJson<List<AiMessage>>(messagesJson, type) ?: emptyList()
            } catch (e: Exception) {
                emptyList()
            }
        } else {
            emptyList()
        }
    }
    
    fun deleteMessages(chatId: String) {
        prefs.edit().remove("chat_messages_$chatId").apply()
    }
    
    fun generateTitleFromMessage(message: String): String {
        // Limitar a 50 caracteres e remover quebras de linha
        val cleaned = message
            .replace("\n", " ")
            .replace("\r", " ")
            .trim()
        
        return if (cleaned.length > 50) {
            cleaned.take(47) + "..."
        } else {
            cleaned.ifEmpty { "Nova conversa" }
        }
    }
}


```

## [FRONTEND]: feature/chatai/presentation/AiSupportScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.chatai.presentation

import android.Manifest
import android.content.Context
import androidx.compose.foundation.Image
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.lazy.rememberLazyListState
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material.icons.automirrored.filled.Send
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.collectAsState
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import coil.compose.rememberAsyncImagePainter
import androidx.hilt.navigation.compose.hiltViewModel
import com.google.accompanist.permissions.ExperimentalPermissionsApi
import com.google.accompanist.permissions.PermissionStatus
import com.google.accompanist.permissions.rememberPermissionState
import com.taskgoapp.taskgo.core.design.*
import com.taskgoapp.taskgo.core.theme.*
import com.taskgoapp.taskgo.feature.chatai.presentation.AttachmentPreview
import com.taskgoapp.taskgo.feature.chatai.presentation.AttachmentSelectionDialog
import java.text.SimpleDateFormat
import java.util.*

@OptIn(ExperimentalMaterial3Api::class, ExperimentalPermissionsApi::class)
@Composable
fun AiSupportScreen(
    chatId: String,
    onBackClick: () -> Unit,
    onChatUpdated: ((String, String, Boolean) -> Unit)? = null, // chatId, lastMessage, isFirstMessage
    viewModel: ChatAIViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    val listState = rememberLazyListState()
    val context = LocalContext.current
    val recordAudioPermission = rememberPermissionState(Manifest.permission.RECORD_AUDIO)
    
    var showLanguageMenu by remember { mutableStateOf(false) }
    var showVoiceChat by remember { mutableStateOf(false) }
    
    // Inicializar chat quando o chatId mudar
    LaunchedEffect(chatId) {
        viewModel.initializeChat(chatId)
    }
    
    LaunchedEffect(uiState.messages.size) {
        if (uiState.messages.isNotEmpty()) {
            listState.animateScrollToItem(uiState.messages.size - 1)
        }
    }
    
    Scaffold(
        topBar = {
            AppTopBar(
                title = "AI TaskGo",
                onBackClick = onBackClick,
                actions = {
                    IconButton(onClick = { showLanguageMenu = true }) {
                        Icon(
                            imageVector = Icons.Default.Translate,
                            contentDescription = "Traduzir",
                            tint = TaskGoBackgroundWhite
                        )
                    }
                }
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            // Messages List
            LazyColumn(
                modifier = Modifier
                    .weight(1f)
                    .padding(16.dp),
                state = listState,
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                items(uiState.messages) { message ->
                    AiMessageBubble(
                        message = message,
                        onTranslate = { viewModel.translateMessage(message, uiState.targetLanguage) }
                    )
                }
                
                if (uiState.isLoading) {
                    item {
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.Start
                        ) {
                            Surface(
                                color = MaterialTheme.colorScheme.surfaceVariant,
                                shape = MaterialTheme.shapes.medium,
                                modifier = Modifier.widthIn(max = 280.dp)
                            ) {
                                Row(
                                    modifier = Modifier.padding(12.dp),
                                    verticalAlignment = Alignment.CenterVertically
                                ) {
                                    CircularProgressIndicator(
                                        modifier = Modifier.size(16.dp),
                                        strokeWidth = 2.dp
                                    )
                                    Spacer(modifier = Modifier.width(8.dp))
                                    Text(
                                        text = "AI est√° digitando...",
                                        style = MaterialTheme.typography.bodyMedium
                                    )
                                }
                            }
                        }
                    }
                }
            }
            
            // Error message
            uiState.error?.let { error ->
                Card(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(horizontal = 16.dp),
                    colors = CardDefaults.cardColors(
                        containerColor = MaterialTheme.colorScheme.errorContainer
                    )
                ) {
                    Text(
                        text = error,
                        color = MaterialTheme.colorScheme.onErrorContainer,
                        modifier = Modifier.padding(12.dp)
                    )
                }
            }
            
            // Input Area
            EnhancedInputMessage(
                onSend = { text, attachments -> 
                    val isFirstMessage = uiState.messages.isEmpty()
                    viewModel.sendMessage(text, attachments) { title ->
                        // Quando a primeira mensagem for enviada, atualizar o t√≠tulo do chat
                        onChatUpdated?.invoke(chatId, text, isFirstMessage)
                    }
                },
                onMicClick = {
                    if (recordAudioPermission.status is PermissionStatus.Granted) {
                        if (uiState.isRecording) {
                            // Parar grava√ß√£o e enviar
                            viewModel.stopAudioRecordingAndSend()
                        } else {
                            // Iniciar grava√ß√£o
                            viewModel.startAudioRecording()
                        }
                    } else {
                        recordAudioPermission.launchPermissionRequest()
                    }
                },
                onVoiceChatClick = {
                    // Abrir tela de conversa√ß√£o por voz
                    showVoiceChat = true
                },
                isRecording = uiState.isRecording,
                modifier = Modifier.padding(16.dp)
            )
        }
    }
    
    // Language selection menu
    if (showLanguageMenu) {
        AlertDialog(
            onDismissRequest = { showLanguageMenu = false },
            title = { Text("Selecionar Idioma") },
            text = {
                Column {
                    listOf("pt" to "Portugu√™s", "en" to "Ingl√™s", "es" to "Espanhol").forEach { (code, name) ->
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(vertical = 8.dp)
                                .clickable {
                                    viewModel.setTargetLanguage(code)
                                    showLanguageMenu = false
                                }
                        ) {
                            RadioButton(
                                selected = uiState.targetLanguage == code,
                                onClick = {
                                    viewModel.setTargetLanguage(code)
                                    showLanguageMenu = false
                                }
                            )
                            Spacer(modifier = Modifier.width(8.dp))
                            Text(name)
                        }
                    }
                }
            },
            confirmButton = {
                TextButton(onClick = { showLanguageMenu = false }) {
                    Text("Fechar")
                }
            }
        )
    }
    
    // Voice Chat Screen (conversa√ß√£o por voz)
    if (showVoiceChat) {
        VoiceChatScreen(
            chatId = chatId,
            onDismiss = { showVoiceChat = false }
        )
    }
}

@Composable
fun AiMessageBubble(
    message: AiMessage,
    onTranslate: () -> Unit = {},
    modifier: Modifier = Modifier
) {
    val dateFormat = remember { SimpleDateFormat("HH:mm", Locale("pt", "BR")) }
    
    Column(
        modifier = modifier.fillMaxWidth(),
        horizontalAlignment = if (message.isFromAi) Alignment.Start else Alignment.End
    ) {
        Surface(
            color = if (message.isFromAi) 
                MaterialTheme.colorScheme.surfaceVariant 
            else 
                MaterialTheme.colorScheme.primary,
            shape = MaterialTheme.shapes.medium,
            modifier = Modifier.widthIn(max = 280.dp)
        ) {
            Column(
                modifier = Modifier.padding(12.dp)
            ) {
                if (message.isFromAi) {
                    Row(
                        verticalAlignment = Alignment.CenterVertically,
                        modifier = Modifier.padding(bottom = 4.dp)
                    ) {
                        Icon(
                            imageVector = Icons.Default.SmartToy,
                            contentDescription = null,
                            modifier = Modifier.size(16.dp),
                            tint = MaterialTheme.colorScheme.primary
                        )
                        Spacer(modifier = Modifier.width(4.dp))
                        Text(
                            text = "AI TaskGo",
                            style = MaterialTheme.typography.labelSmall,
                            fontWeight = FontWeight.Bold,
                            color = MaterialTheme.colorScheme.primary
                        )
                    }
                }
                
                // Exibir anexos
                if (message.attachments.isNotEmpty()) {
                    Column(
                        modifier = Modifier.padding(bottom = if (message.text.isNotBlank()) 8.dp else 0.dp),
                        verticalArrangement = Arrangement.spacedBy(4.dp)
                    ) {
                        message.attachments.forEach { attachment ->
                            when (attachment.type) {
                                com.taskgoapp.taskgo.feature.chatai.data.AttachmentType.IMAGE -> {
                                    Image(
                                        painter = rememberAsyncImagePainter(attachment.uri),
                                        contentDescription = "Imagem",
                                        modifier = Modifier
                                            .fillMaxWidth()
                                            .heightIn(max = 200.dp)
                                            .clip(MaterialTheme.shapes.small),
                                        contentScale = ContentScale.Fit
                                    )
                                }
                                com.taskgoapp.taskgo.feature.chatai.data.AttachmentType.DOCUMENT -> {
                                    Row(
                                        modifier = Modifier
                                            .fillMaxWidth()
                                            .padding(8.dp),
                                        verticalAlignment = Alignment.CenterVertically
                                    ) {
                                        Icon(
                                            imageVector = Icons.Default.Description,
                                            contentDescription = null,
                                            tint = if (message.isFromAi) 
                                                MaterialTheme.colorScheme.onSurfaceVariant 
                                            else 
                                                MaterialTheme.colorScheme.onPrimary
                                        )
                                        Spacer(modifier = Modifier.width(8.dp))
                                        Text(
                                            text = attachment.fileName ?: "Documento",
                                            style = MaterialTheme.typography.bodySmall,
                                            color = if (message.isFromAi) 
                                                MaterialTheme.colorScheme.onSurfaceVariant 
                                            else 
                                                MaterialTheme.colorScheme.onPrimary
                                        )
                                    }
                                }
                            }
                        }
                    }
                }
                
                if (message.text.isNotBlank()) {
                    Text(
                        text = message.text,
                        style = MaterialTheme.typography.bodyMedium,
                        color = if (message.isFromAi) 
                            MaterialTheme.colorScheme.onSurfaceVariant 
                        else 
                            MaterialTheme.colorScheme.onPrimary
                    )
                }
                
                if (message.isFromAi) {
                    Spacer(modifier = Modifier.height(4.dp))
                    TextButton(
                        onClick = onTranslate,
                        modifier = Modifier.padding(0.dp)
                    ) {
                        Icon(
                            imageVector = Icons.Default.Translate,
                            contentDescription = null,
                            modifier = Modifier.size(16.dp)
                        )
                        Spacer(modifier = Modifier.width(4.dp))
                        Text("Traduzir", style = MaterialTheme.typography.labelSmall)
                    }
                }
            }
        }
        
        Spacer(modifier = Modifier.height(4.dp))
        
        Text(
            text = dateFormat.format(Date(message.timestamp)),
            style = MaterialTheme.typography.bodySmall,
            color = MaterialTheme.colorScheme.onSurfaceVariant,
            modifier = Modifier.padding(horizontal = 4.dp)
        )
    }
}

@Composable
fun EnhancedInputMessage(
    onSend: (String, List<com.taskgoapp.taskgo.feature.chatai.data.ChatAttachment>) -> Unit,
    onMicClick: () -> Unit,
    onVoiceChatClick: (() -> Unit)? = null,
    isRecording: Boolean,
    modifier: Modifier = Modifier
) {
    var text by remember { mutableStateOf("") }
    var attachments by remember { mutableStateOf<List<com.taskgoapp.taskgo.feature.chatai.data.ChatAttachment>>(emptyList()) }
    var showAttachmentMenu by remember { mutableStateOf(false) }
    val context = LocalContext.current
    
    Column(modifier = modifier) {
        // Preview de anexos
        if (attachments.isNotEmpty()) {
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(bottom = 8.dp),
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                attachments.forEach { attachment ->
                    AttachmentPreview(
                        attachment = attachment,
                        onRemove = {
                            attachments = attachments.filter { it.id != attachment.id }
                        }
                    )
                }
            }
        }
        
        Row(
            modifier = Modifier.fillMaxWidth(),
            verticalAlignment = Alignment.Bottom
        ) {
            // Bot√£o de microfone (grava√ß√£o de √°udio para texto)
            IconButton(
                onClick = onMicClick,
                modifier = Modifier.size(48.dp)
            ) {
                Icon(
                    imageVector = if (isRecording) Icons.Default.Stop else Icons.Default.Mic,
                    contentDescription = "Gravar √°udio",
                    tint = if (isRecording) MaterialTheme.colorScheme.error else MaterialTheme.colorScheme.primary,
                    modifier = Modifier.size(24.dp)
                )
            }
            
            // Bot√£o de conversa√ß√£o por voz (Speech - igual ChatGPT)
            if (onVoiceChatClick != null) {
                IconButton(
                    onClick = onVoiceChatClick,
                    modifier = Modifier.size(48.dp)
                ) {
                    // √çcone de speech/voice (conversa√ß√£o por voz)
                    Icon(
                        imageVector = Icons.Default.VolumeUp,
                        contentDescription = "Conversa√ß√£o por voz",
                        tint = MaterialTheme.colorScheme.primary,
                        modifier = Modifier.size(24.dp)
                    )
                }
            }
            
            // Bot√£o de anexar
            IconButton(onClick = { showAttachmentMenu = true }) {
                Icon(
                    imageVector = Icons.Default.AttachFile,
                    contentDescription = "Anexar",
                    tint = MaterialTheme.colorScheme.primary
                )
            }
            
            OutlinedTextField(
                value = text,
                onValueChange = { text = it },
                placeholder = { Text("Digite sua mensagem...") },
                maxLines = Int.MAX_VALUE,
                singleLine = false,
                shape = MaterialTheme.shapes.medium,
                colors = OutlinedTextFieldDefaults.colors(
                    focusedBorderColor = TaskGoGreen,
                    unfocusedBorderColor = TaskGoBorder,
                    cursorColor = TaskGoGreen
                ),
                modifier = Modifier.weight(1f)
            )
            
            Spacer(modifier = Modifier.width(8.dp))
            
            FloatingActionButton(
                onClick = {
                    if (text.isNotBlank() || attachments.isNotEmpty()) {
                        onSend(text, attachments)
                        text = ""
                        attachments = emptyList()
                    }
                },
                containerColor = TaskGoGreen
            ) {
                Icon(
                    imageVector = Icons.AutoMirrored.Filled.Send,
                    contentDescription = "Enviar",
                    tint = androidx.compose.ui.graphics.Color.White
                )
            }
        }
    }
    
    // Menu de sele√ß√£o de anexos
    if (showAttachmentMenu) {
        AttachmentSelectionDialog(
            onDismiss = { showAttachmentMenu = false },
            onImageSelected = { uri, mimeType ->
                val attachment = com.taskgoapp.taskgo.feature.chatai.data.ChatAttachment(
                    id = System.currentTimeMillis().toString(),
                    uri = uri,
                    type = com.taskgoapp.taskgo.feature.chatai.data.AttachmentType.IMAGE,
                    mimeType = mimeType
                )
                attachments = attachments + attachment
                showAttachmentMenu = false
            },
            onDocumentSelected = { uri, fileName, mimeType ->
                val attachment = com.taskgoapp.taskgo.feature.chatai.data.ChatAttachment(
                    id = System.currentTimeMillis().toString(),
                    uri = uri,
                    type = com.taskgoapp.taskgo.feature.chatai.data.AttachmentType.DOCUMENT,
                    fileName = fileName,
                    mimeType = mimeType
                )
                attachments = attachments + attachment
                showAttachmentMenu = false
            }
        )
    }
}

data class AiMessage(
    val id: Long,
    val text: String,
    val isFromAi: Boolean,
    val timestamp: Long,
    val attachments: List<com.taskgoapp.taskgo.feature.chatai.data.ChatAttachment> = emptyList()
)

```

## [FRONTEND]: feature/chatai/presentation/AttachmentComponents.kt

```kotlin
package com.taskgoapp.taskgo.feature.chatai.presentation

import android.net.Uri
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.Image
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import coil.compose.rememberAsyncImagePainter
import com.taskgoapp.taskgo.core.theme.TaskGoGreen
import com.taskgoapp.taskgo.core.theme.TaskGoTextGray
import com.taskgoapp.taskgo.feature.chatai.data.AttachmentType
import com.taskgoapp.taskgo.feature.chatai.data.ChatAttachment

@Composable
fun AttachmentPreview(
    attachment: ChatAttachment,
    onRemove: () -> Unit
) {
    Card(
        modifier = Modifier.size(80.dp),
        shape = RoundedCornerShape(8.dp)
    ) {
        Box {
            when (attachment.type) {
                AttachmentType.IMAGE -> {
                    Image(
                        painter = rememberAsyncImagePainter(attachment.uri),
                        contentDescription = "Imagem anexada",
                        modifier = Modifier.fillMaxSize(),
                        contentScale = ContentScale.Crop
                    )
                }
                AttachmentType.DOCUMENT -> {
                    Column(
                        modifier = Modifier
                            .fillMaxSize()
                            .padding(8.dp),
                        horizontalAlignment = Alignment.CenterHorizontally,
                        verticalArrangement = Arrangement.Center
                    ) {
                        Icon(
                            imageVector = Icons.Default.Description,
                            contentDescription = null,
                            modifier = Modifier.size(32.dp),
                            tint = TaskGoTextGray
                        )
                        Spacer(modifier = Modifier.height(4.dp))
                        Text(
                            text = attachment.fileName?.take(10) ?: "Doc",
                            style = MaterialTheme.typography.labelSmall,
                            maxLines = 1
                        )
                    }
                }
            }
            
            IconButton(
                onClick = onRemove,
                modifier = Modifier.align(Alignment.TopEnd)
            ) {
                Icon(
                    imageVector = Icons.Default.Close,
                    contentDescription = "Remover",
                    tint = MaterialTheme.colorScheme.onSurface,
                    modifier = Modifier.size(20.dp)
                )
            }
        }
    }
}

@Composable
fun AttachmentSelectionDialog(
    onDismiss: () -> Unit,
    onImageSelected: (Uri, String) -> Unit,
    onDocumentSelected: (Uri, String, String) -> Unit
) {
    val context = LocalContext.current
    
    val imagePickerLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.GetContent()
    ) { uri: Uri? ->
        uri?.let {
            val mimeType = context.contentResolver.getType(it) ?: "image/*"
            onImageSelected(it, mimeType)
        }
    }
    
    val documentPickerLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.GetContent()
    ) { uri: Uri? ->
        uri?.let {
            val mimeType = context.contentResolver.getType(it) ?: "application/*"
            val fileName = getFileName(context, it)
            onDocumentSelected(it, fileName, mimeType)
        }
    }
    
    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Selecionar anexo") },
        text = {
            Column(
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .clickable {
                            imagePickerLauncher.launch("image/*")
                        }
                        .padding(16.dp),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Icon(
                        imageVector = Icons.Default.Image,
                        contentDescription = null,
                        tint = TaskGoGreen,
                        modifier = Modifier.size(32.dp)
                    )
                    Spacer(modifier = Modifier.width(16.dp))
                    Text("Selecionar imagem")
                }
                
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .clickable {
                            documentPickerLauncher.launch("*/*")
                        }
                        .padding(16.dp),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Icon(
                        imageVector = Icons.Default.Description,
                        contentDescription = null,
                        tint = TaskGoGreen,
                        modifier = Modifier.size(32.dp)
                    )
                    Spacer(modifier = Modifier.width(16.dp))
                    Text("Selecionar documento")
                }
            }
        },
        confirmButton = {
            TextButton(onClick = onDismiss) {
                Text("Cancelar")
            }
        }
    )
}

private fun getFileName(context: android.content.Context, uri: Uri): String {
    var result: String? = null
    if (uri.scheme == "content") {
        val cursor = context.contentResolver.query(uri, null, null, null, null)
        cursor?.use {
            if (it.moveToFirst()) {
                val nameIndex = it.getColumnIndex(android.provider.OpenableColumns.DISPLAY_NAME)
                if (nameIndex >= 0) {
                    result = it.getString(nameIndex)
                }
            }
        }
    }
    if (result == null) {
        result = uri.path
        val cut = result?.lastIndexOf('/')
        if (cut != null && cut != -1) {
            result = result?.substring(cut + 1)
        }
    }
    return result ?: "documento"
}


```

## [FRONTEND]: feature/chatai/presentation/ChatAIViewModel.kt

```kotlin
package com.taskgoapp.taskgo.feature.chatai.presentation

import android.content.Context
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.net.Uri
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.taskgoapp.taskgo.core.ai.AppSystemPrompt
import com.taskgoapp.taskgo.core.ai.AudioRecorderManager
import com.taskgoapp.taskgo.core.ai.GoogleCloudAIService
import com.taskgoapp.taskgo.core.ai.GoogleSpeechToTextService
import com.taskgoapp.taskgo.core.ai.GoogleTranslationService
import com.taskgoapp.taskgo.core.ai.ImageData
import com.taskgoapp.taskgo.core.ai.TextToSpeechManager
import com.taskgoapp.taskgo.feature.chatai.data.ChatAttachment
import com.taskgoapp.taskgo.feature.chatai.data.ChatStorage
import dagger.hilt.android.lifecycle.HiltViewModel
import dagger.hilt.android.qualifiers.ApplicationContext
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.ByteArrayOutputStream
import android.util.Base64 as AndroidBase64
import javax.inject.Inject

/**
 * M√°quina de estados para o fluxo de voz
 * Baseado no padr√£o de chat_voice_widget.py (VoiceState enum)
 */
enum class VoiceState {
    IDLE,           // Estado inicial, pronto para gravar
    RECORDING,      // Gravando √°udio do usu√°rio
    PROCESSING,     // Processando transcri√ß√£o ou resposta da AI
    SPEAKING        // Reproduzindo resposta da AI em voz
}

data class ChatUiState(
    val chatId: String? = null,
    val messages: List<AiMessage> = emptyList(),
    val isLoading: Boolean = false,
    val error: String? = null,
    val isRecording: Boolean = false,
    val isSpeaking: Boolean = false,
    val voiceState: VoiceState = VoiceState.IDLE, // M√°quina de estados para voz
    val sourceLanguage: String = "pt",
    val targetLanguage: String = "pt"
)

@HiltViewModel
class ChatAIViewModel @Inject constructor(
    private val aiService: GoogleCloudAIService,
    private val translationService: GoogleTranslationService,
    private val speechToTextService: GoogleSpeechToTextService,
    private val audioRecorderManager: AudioRecorderManager,
    private val textToSpeechManager: TextToSpeechManager,
    private val chatStorage: ChatStorage,
    private val functionsService: com.taskgoapp.taskgo.data.firebase.FirebaseFunctionsService,
    @ApplicationContext private val context: Context
) : ViewModel() {
    
    private val _uiState = MutableStateFlow(ChatUiState())
    val uiState: StateFlow<ChatUiState> = _uiState.asStateFlow()
    
    fun initializeChat(chatId: String) {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(chatId = chatId)
            // Carregar mensagens salvas do storage local
            val savedMessages = chatStorage.loadMessages(chatId)
            _uiState.value = _uiState.value.copy(messages = savedMessages)
            
            // Tentar carregar do Firestore tamb√©m (se existir)
            try {
                val historyResult = functionsService.getConversationHistory(chatId)
                historyResult.fold(
                    onSuccess = { data ->
                        // Se houver mensagens no Firestore, usar elas (mais atualizadas)
                        val firestoreMessages = (data["messages"] as? List<Map<String, Any>>)?.mapNotNull { msgData ->
                            try {
                                val role = msgData["role"] as? String ?: return@mapNotNull null
                                val content = msgData["content"] as? String ?: return@mapNotNull null
                                val timestamp = (msgData["timestamp"] as? Map<String, Any>)?.let {
                                    // Converter Firestore Timestamp para Long
                                    val seconds = (it["_seconds"] as? Number)?.toLong() ?: 0L
                                    val nanos = (it["_nanoseconds"] as? Number)?.toLong() ?: 0L
                                    seconds * 1000 + nanos / 1_000_000
                                } ?: System.currentTimeMillis()
                                
                                AiMessage(
                                    id = timestamp,
                                    text = content,
                                    isFromAi = role == "assistant",
                                    timestamp = timestamp
                                )
                            } catch (e: Exception) {
                                null
                            }
                        } ?: emptyList()
                        
                        if (firestoreMessages.isNotEmpty()) {
                            _uiState.value = _uiState.value.copy(messages = firestoreMessages)
                            // Sincronizar com storage local
                            chatStorage.saveMessages(chatId, firestoreMessages)
                        }
                    },
                    onFailure = {
                        // Se n√£o encontrar no Firestore, usar mensagens locais
                        android.util.Log.d("ChatAIViewModel", "Conversa n√£o encontrada no Firestore, usando mensagens locais")
                    }
                )
            } catch (e: Exception) {
                android.util.Log.e("ChatAIViewModel", "Erro ao carregar hist√≥rico do Firestore: ${e.message}", e)
            }
        }
    }
    
    fun sendMessage(text: String, attachments: List<ChatAttachment> = emptyList(), onFirstMessageSent: ((String) -> Unit)? = null) {
        if (text.isBlank() && attachments.isEmpty()) return
        
        val isFirstMessage = _uiState.value.messages.isEmpty()
        
        val userMessage = AiMessage(
            id = System.currentTimeMillis(),
            text = text,
            isFromAi = false,
            timestamp = System.currentTimeMillis(),
            attachments = attachments
        )
        
        val updatedMessages = _uiState.value.messages + userMessage
        _uiState.value = _uiState.value.copy(
            messages = updatedMessages,
            isLoading = true,
            error = null
        )
        
        // Se for a primeira mensagem, gerar t√≠tulo e notificar
        if (isFirstMessage && text.isNotBlank()) {
            val title = chatStorage.generateTitleFromMessage(text)
            onFirstMessageSent?.invoke(title)
        }
        
        // Salvar mensagem do usu√°rio imediatamente
        _uiState.value.chatId?.let { chatId ->
            chatStorage.saveMessages(chatId, updatedMessages)
        }
        
        viewModelScope.launch {
            try {
                // Criar ou obter conversationId - OBRIGAT√ìRIO antes de enviar mensagem
                var conversationId = _uiState.value.chatId
                if (conversationId == null) {
                    // Criar nova conversa no Firestore - BLOQUEAR se falhar
                    val createResult = functionsService.createConversation()
                    createResult.fold(
                        onSuccess = { data ->
                            conversationId = data["conversationId"] as? String
                            if (conversationId != null) {
                                _uiState.value = _uiState.value.copy(chatId = conversationId)
                                android.util.Log.d("ChatAIViewModel", "Conversa criada com sucesso: $conversationId")
                            } else {
                                throw IllegalStateException("Conversa criada mas conversationId √© null")
                            }
                        },
                        onFailure = { error ->
                            android.util.Log.e("ChatAIViewModel", "Erro ao criar conversa no Firestore: ${error.message}", error)
                            _uiState.value = _uiState.value.copy(
                                isLoading = false,
                                error = "Erro ao criar conversa: ${error.message ?: "Erro desconhecido"}"
                            )
                            return@launch // Bloquear envio se n√£o conseguir criar conversa
                        }
                    )
                }
                
                // Garantir que conversationId n√£o √© null antes de enviar
                if (conversationId == null) {
                    _uiState.value = _uiState.value.copy(
                        isLoading = false,
                        error = "N√£o foi poss√≠vel criar a conversa. Tente novamente."
                    )
                    return@launch
                }
                
                // Usar Cloud Function aiChatProxy que salva automaticamente no Firestore
                val chatResult = functionsService.aiChatProxy(text, conversationId)
                chatResult.fold(
                    onSuccess = { data ->
                        val responseText = data["response"] as? String ?: ""
                        val returnedConversationId = data["conversationId"] as? String
                        
                        // Atualizar conversationId se foi criado
                        if (returnedConversationId != null && _uiState.value.chatId == null) {
                            _uiState.value = _uiState.value.copy(chatId = returnedConversationId)
                        }
                        
                        val aiMessage = AiMessage(
                            id = System.currentTimeMillis(),
                            text = responseText,
                            isFromAi = true,
                            timestamp = System.currentTimeMillis()
                        )
                        val updatedMessages = _uiState.value.messages + aiMessage
                        _uiState.value = _uiState.value.copy(
                            messages = updatedMessages,
                            isLoading = false
                        )
                        
                        // Salvar mensagens no storage local tamb√©m (para cache offline)
                        _uiState.value.chatId?.let { chatId ->
                            chatStorage.saveMessages(chatId, updatedMessages)
                        }
                        
                        android.util.Log.d("ChatAIViewModel", "Resposta da AI recebida com sucesso e salva no Firestore")
                    },
                    onFailure = { error ->
                        _uiState.value = _uiState.value.copy(
                            isLoading = false,
                            error = error.message ?: "Erro ao processar mensagem"
                        )
                    }
                )
            } catch (e: Exception) {
                android.util.Log.e("ChatAIViewModel", "Erro ao enviar mensagem: ${e.message}", e)
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = e.message ?: "Erro desconhecido"
                )
            }
        }
    }
    
    fun translateMessage(message: AiMessage, targetLanguage: String) {
        viewModelScope.launch {
            try {
                val result = translationService.translateText(message.text, targetLanguage)
                result.fold(
                    onSuccess = { translatedText ->
                        val translatedMessage = message.copy(text = translatedText)
                        val updatedMessages = _uiState.value.messages.map {
                            if (it.id == message.id) translatedMessage else it
                        }
                        _uiState.value = _uiState.value.copy(messages = updatedMessages)
                    },
                    onFailure = { error ->
                        _uiState.value = _uiState.value.copy(
                            error = error.message ?: "Erro ao traduzir"
                        )
                    }
                )
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    error = e.message ?: "Erro ao traduzir"
                )
            }
        }
    }
    
    /**
     * Atualiza o estado da voz (m√°quina de estados)
     * Baseado no padr√£o de chat_voice_widget.py (_set_state)
     */
    private fun setVoiceState(newState: VoiceState) {
        val currentState = _uiState.value.voiceState
        if (currentState == newState) return
        
        android.util.Log.d("ChatAIViewModel", "[STATE_MACHINE] Mudando de ${currentState.name} para ${newState.name}")
        _uiState.value = _uiState.value.copy(
            voiceState = newState,
            isRecording = newState == VoiceState.RECORDING,
            isLoading = newState == VoiceState.PROCESSING
        )
    }
    
    fun setRecording(isRecording: Boolean) {
        val newState = if (isRecording) VoiceState.RECORDING else VoiceState.IDLE
        setVoiceState(newState)
    }
    
    /**
     * Inicia a grava√ß√£o de √°udio
     * Baseado no padr√£o de chat_voice_widget.py (_on_main_button_action)
     */
    fun startAudioRecording() {
        if (_uiState.value.voiceState != VoiceState.IDLE) {
            android.util.Log.w("ChatAIViewModel", "Tentativa de iniciar grava√ß√£o em estado inv√°lido: ${_uiState.value.voiceState}")
            return
        }
        
        viewModelScope.launch {
            try {
                setVoiceState(VoiceState.RECORDING)
                val result = audioRecorderManager.startRecording()
                result.fold(
                    onSuccess = { file ->
                        // Grava√ß√£o iniciada com sucesso
                        android.util.Log.d("ChatAIViewModel", "Grava√ß√£o iniciada: ${file.absolutePath}")
                    },
                    onFailure = { error ->
                        android.util.Log.e("ChatAIViewModel", "Erro ao iniciar grava√ß√£o: ${error.message}", error)
                        setVoiceState(VoiceState.IDLE)
                        _uiState.value = _uiState.value.copy(
                            error = "Erro ao iniciar grava√ß√£o: ${error.message}"
                        )
                    }
                )
            } catch (e: Exception) {
                android.util.Log.e("ChatAIViewModel", "Erro ao iniciar grava√ß√£o: ${e.message}", e)
                setVoiceState(VoiceState.IDLE)
                _uiState.value = _uiState.value.copy(
                    error = "Erro ao iniciar grava√ß√£o: ${e.message}"
                )
            }
        }
    }
    
    /**
     * Para a grava√ß√£o de √°udio e converte para texto
     * Baseado no padr√£o de chat_voice_widget.py (_on_transcribed_text)
     */
    fun stopAudioRecordingAndSend() {
        if (_uiState.value.voiceState != VoiceState.RECORDING) {
            android.util.Log.w("ChatAIViewModel", "Tentativa de parar grava√ß√£o em estado inv√°lido: ${_uiState.value.voiceState}")
            return
        }
        
        viewModelScope.launch {
            try {
                setVoiceState(VoiceState.PROCESSING)
                
                val result = audioRecorderManager.stopRecording()
                result.fold(
                    onSuccess = { audioFile ->
                        if (audioFile != null && audioFile.exists()) {
                            // Converter √°udio para texto
                            android.util.Log.d("ChatAIViewModel", "Convertendo √°udio para texto: ${audioFile.absolutePath}")
                            val speechResult = speechToTextService.recognizeSpeech(audioFile)
                            
                            speechResult.fold(
                                onSuccess = { transcript ->
                                    android.util.Log.d("ChatAIViewModel", "Transcri√ß√£o: $transcript")
                                    // Enviar mensagem como texto
                                    if (transcript.isNotBlank()) {
                                        // Enviar mensagem (que j√° gerencia o estado de loading)
                                        sendMessage(transcript.trim())
                                        // Voltar para IDLE ap√≥s enviar
                                        setVoiceState(VoiceState.IDLE)
                                    } else {
                                        setVoiceState(VoiceState.IDLE)
                                        _uiState.value = _uiState.value.copy(
                                            error = "N√£o foi poss√≠vel reconhecer a fala. Tente novamente."
                                        )
                                    }
                                    // Deletar arquivo tempor√°rio ap√≥s processar
                                    audioFile.delete()
                                },
                                onFailure = { error ->
                                    android.util.Log.e("ChatAIViewModel", "Erro ao converter √°udio: ${error.message}", error)
                                    setVoiceState(VoiceState.IDLE)
                                    _uiState.value = _uiState.value.copy(
                                        error = "Erro ao converter √°udio para texto: ${error.message}"
                                    )
                                    // Deletar arquivo tempor√°rio em caso de erro
                                    audioFile.delete()
                                }
                            )
                        } else {
                            setVoiceState(VoiceState.IDLE)
                            _uiState.value = _uiState.value.copy(
                                error = "Nenhum √°udio foi gravado"
                            )
                        }
                    },
                    onFailure = { error ->
                        android.util.Log.e("ChatAIViewModel", "Erro ao parar grava√ß√£o: ${error.message}", error)
                        setVoiceState(VoiceState.IDLE)
                        _uiState.value = _uiState.value.copy(
                            error = "Erro ao parar grava√ß√£o: ${error.message}"
                        )
                    }
                )
            } catch (e: Exception) {
                android.util.Log.e("ChatAIViewModel", "Erro ao parar grava√ß√£o: ${e.message}", e)
                setVoiceState(VoiceState.IDLE)
                _uiState.value = _uiState.value.copy(
                    error = "Erro ao parar grava√ß√£o: ${e.message}"
                )
            }
        }
    }
    
    /**
     * Cancela a grava√ß√£o atual
     * Baseado no padr√£o de chat_voice_widget.py (_exit_voice_mode)
     */
    fun cancelAudioRecording() {
        viewModelScope.launch {
            try {
                audioRecorderManager.cancelRecording()
                setVoiceState(VoiceState.IDLE)
                _uiState.value = _uiState.value.copy(error = null)
            } catch (e: Exception) {
                android.util.Log.e("ChatAIViewModel", "Erro ao cancelar grava√ß√£o: ${e.message}", e)
                setVoiceState(VoiceState.IDLE)
                _uiState.value = _uiState.value.copy(
                    error = "Erro ao cancelar grava√ß√£o: ${e.message}"
                )
            }
        }
    }
    
    /**
     * Fala uma resposta em voz alta (Text-to-Speech)
     * Baseado no padr√£o de chat_voice_widget.py (_tts_speak)
     */
    fun speakResponse(text: String) {
        if (_uiState.value.voiceState == VoiceState.RECORDING) {
            android.util.Log.w("ChatAIViewModel", "N√£o √© poss√≠vel falar enquanto est√° gravando")
            return
        }
        
        viewModelScope.launch {
            try {
                setVoiceState(VoiceState.SPEAKING)
                val result = textToSpeechManager.speak(text)
                result.fold(
                    onSuccess = {
                        android.util.Log.d("ChatAIViewModel", "Texto sendo falado: $text")
                    },
                    onFailure = { error ->
                        android.util.Log.e("ChatAIViewModel", "Erro ao falar resposta: ${error.message}", error)
                        setVoiceState(VoiceState.IDLE)
                        _uiState.value = _uiState.value.copy(
                            error = "Erro ao falar resposta: ${error.message}"
                        )
                    }
                )
            } catch (e: Exception) {
                android.util.Log.e("ChatAIViewModel", "Erro ao falar resposta: ${e.message}", e)
                setVoiceState(VoiceState.IDLE)
                _uiState.value = _uiState.value.copy(
                    error = "Erro ao falar resposta: ${e.message}"
                )
            }
        }
    }
    
    /**
     * Para a fala atual
     * Baseado no padr√£o de chat_voice_widget.py (_on_tts_finished)
     */
    fun stopSpeaking() {
        viewModelScope.launch {
            textToSpeechManager.stop()
            setVoiceState(VoiceState.IDLE)
        }
    }
    
    // Observar estado do TTS e atualizar m√°quina de estados
    // Baseado no padr√£o de chat_voice_widget.py (monitoramento de estado)
    init {
        viewModelScope.launch {
            while (true) {
                val isSpeaking = textToSpeechManager.isSpeaking()
                if (isSpeaking && _uiState.value.voiceState != VoiceState.SPEAKING) {
                    setVoiceState(VoiceState.SPEAKING)
                } else if (!isSpeaking && _uiState.value.voiceState == VoiceState.SPEAKING) {
                    setVoiceState(VoiceState.IDLE)
                }
                kotlinx.coroutines.delay(200) // Verificar a cada 200ms
            }
        }
    }
    
    /**
     * Obt√©m a amplitude do √°udio para anima√ß√£o visual
     */
    fun getAudioAmplitude(): Double {
        return audioRecorderManager.getAmplitude()
    }
    
    fun setTargetLanguage(language: String) {
        _uiState.value = _uiState.value.copy(targetLanguage = language)
    }
    
    fun clearError() {
        _uiState.value = _uiState.value.copy(error = null)
    }
    
    private suspend fun convertImageToBase64(uri: Uri, mimeType: String?): ImageData? = withContext(Dispatchers.IO) {
        try {
            // Usa BitmapUtils para carregar e redimensionar a imagem
            val bitmap = com.taskgoapp.taskgo.core.utils.BitmapUtils.loadAndResizeBitmap(
                context, 
                uri,
                maxDimension = 1024 // Limita a 1024px para envio via API
            ) ?: return@withContext null
            
            val outputStream = ByteArrayOutputStream()
            val format = when (mimeType) {
                "image/png" -> Bitmap.CompressFormat.PNG
                "image/jpeg", "image/jpg" -> Bitmap.CompressFormat.JPEG
                "image/webp" -> Bitmap.CompressFormat.WEBP
                else -> Bitmap.CompressFormat.JPEG
            }
            
            bitmap.compress(format, 85, outputStream)
            val byteArray = outputStream.toByteArray()
            val base64 = AndroidBase64.encodeToString(byteArray, AndroidBase64.NO_WRAP)
            
            // Libera mem√≥ria do bitmap
            bitmap.recycle()
            
            ImageData(
                mimeType = mimeType ?: "image/jpeg",
                base64Data = base64
            )
        } catch (e: Exception) {
            null
        }
    }
}

```

## [FRONTEND]: feature/chatai/presentation/ChatListScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.chatai.presentation

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.collectAsState
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.theme.TaskGoBackgroundWhite
import com.taskgoapp.taskgo.core.theme.TaskGoGreen
import com.taskgoapp.taskgo.core.theme.TaskGoTextGray
import com.taskgoapp.taskgo.core.theme.TaskGoTextGrayLight
import com.taskgoapp.taskgo.feature.chatai.presentation.SearchBar
import java.text.SimpleDateFormat
import java.util.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ChatListScreen(
    onBackClick: () -> Unit,
    onChatClick: (String) -> Unit,
    viewModel: ChatListViewModel
) {
    val uiState by viewModel.uiState.collectAsState()
    var showDeleteDialog by remember { mutableStateOf<String?>(null) }
    
    // Recarregar lista sempre que a tela abre para refletir novas conversas/mensagens
    LaunchedEffect(Unit) {
        viewModel.loadChats()
    }
    
    Scaffold(
        topBar = {
            Column {
                AppTopBar(
                    title = "AI TaskGo",
                    onBackClick = onBackClick
                )
                // Campo de busca
                if (uiState.chats.isNotEmpty()) {
                    SearchBar(
                        query = uiState.searchQuery,
                        onQueryChange = { viewModel.updateSearchQuery(it) },
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(horizontal = 16.dp, vertical = 8.dp)
                    )
                }
            }
        },
        floatingActionButton = {
            FloatingActionButton(
                onClick = {
                    val chatId = viewModel.createNewChat()
                    onChatClick(chatId)
                },
                containerColor = TaskGoGreen,
                modifier = Modifier.padding(16.dp)
            ) {
                Icon(
                    imageVector = Icons.Default.Add,
                    contentDescription = "Novo chat",
                    tint = Color.White
                )
            }
        }
    ) { paddingValues ->
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .background(TaskGoBackgroundWhite)
        ) {
            when {
                uiState.isLoading -> {
                    Box(
                        modifier = Modifier.fillMaxSize(),
                        contentAlignment = Alignment.Center
                    ) {
                        CircularProgressIndicator(color = TaskGoGreen)
                    }
                }
                uiState.chats.isEmpty() -> {
                    EmptyChatList(
                        onCreateNewChat = {
                            val chatId = viewModel.createNewChat()
                            onChatClick(chatId)
                        }
                    )
                }
                else -> {
                    if (uiState.filteredChats.isEmpty() && uiState.searchQuery.isNotEmpty()) {
                        Box(
                            modifier = Modifier.fillMaxSize(),
                            contentAlignment = Alignment.Center
                        ) {
                            Column(
                                horizontalAlignment = Alignment.CenterHorizontally,
                                verticalArrangement = Arrangement.spacedBy(8.dp)
                            ) {
                                Icon(
                                    imageVector = Icons.Default.Search,
                                    contentDescription = null,
                                    tint = TaskGoTextGrayLight,
                                    modifier = Modifier.size(48.dp)
                                )
                                Text(
                                    text = "Nenhuma conversa encontrada",
                                    style = MaterialTheme.typography.bodyLarge,
                                    color = TaskGoTextGray
                                )
                            }
                        }
                    } else {
                        LazyColumn(
                            modifier = Modifier.fillMaxSize(),
                            contentPadding = PaddingValues(vertical = 8.dp)
                        ) {
                            items(
                                items = uiState.filteredChats,
                                key = { it.id }
                            ) { chat ->
                                ChatListItem(
                                    chat = chat,
                                    onClick = { onChatClick(chat.id) },
                                    onDelete = { showDeleteDialog = chat.id },
                                    modifier = Modifier.fillMaxWidth()
                                )
                                HorizontalDivider(
                                    modifier = Modifier.padding(horizontal = 16.dp),
                                    color = Color(0xFFE5E5E5),
                                    thickness = 0.5.dp
                                )
                            }
                        }
                    }
                }
            }
        }
    }
    
    // Dialog de confirma√ß√£o de exclus√£o
    showDeleteDialog?.let { chatId ->
        AlertDialog(
            onDismissRequest = { showDeleteDialog = null },
            title = { Text("Excluir conversa") },
            text = { Text("Tem certeza que deseja excluir esta conversa? Esta a√ß√£o n√£o pode ser desfeita.") },
            confirmButton = {
                TextButton(
                    onClick = {
                        viewModel.deleteChat(chatId)
                        showDeleteDialog = null
                    }
                ) {
                    Text("Excluir", color = MaterialTheme.colorScheme.error)
                }
            },
            dismissButton = {
                TextButton(onClick = { showDeleteDialog = null }) {
                    Text("Cancelar")
                }
            }
        )
    }
}

@Composable
fun ChatListItem(
    chat: com.taskgoapp.taskgo.feature.chatai.data.ChatSession,
    onClick: () -> Unit,
    onDelete: () -> Unit,
    modifier: Modifier = Modifier
) {
    val dateFormat = remember { 
        SimpleDateFormat("dd/MM/yyyy", Locale("pt", "BR"))
    }
    val timeFormat = remember { 
        SimpleDateFormat("HH:mm", Locale("pt", "BR"))
    }
    
    val isToday = remember(chat.timestamp) {
        val today = Calendar.getInstance()
        val chatDate = Calendar.getInstance().apply {
            timeInMillis = chat.timestamp
        }
        today.get(Calendar.YEAR) == chatDate.get(Calendar.YEAR) &&
        today.get(Calendar.DAY_OF_YEAR) == chatDate.get(Calendar.DAY_OF_YEAR)
    }
    
    val displayTime = remember(chat.timestamp, isToday) {
        if (isToday) {
            timeFormat.format(Date(chat.timestamp))
        } else {
            dateFormat.format(Date(chat.timestamp))
        }
    }
    
    Row(
        modifier = modifier
            .clickable(onClick = onClick)
            .padding(horizontal = 16.dp, vertical = 12.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        // Avatar circular com √≠cone de IA
        Box(
            modifier = Modifier
                .size(48.dp)
                .clip(CircleShape)
                .background(TaskGoGreen.copy(alpha = 0.1f)),
            contentAlignment = Alignment.Center
        ) {
            Icon(
                imageVector = Icons.Default.SmartToy,
                contentDescription = null,
                tint = TaskGoGreen,
                modifier = Modifier.size(24.dp)
            )
        }
        
        Spacer(modifier = Modifier.width(16.dp))
        
        // Conte√∫do do chat
        Column(
            modifier = Modifier.weight(1f)
        ) {
            Text(
                text = chat.title,
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.SemiBold,
                color = Color.Black,
                maxLines = 1,
                overflow = TextOverflow.Ellipsis
            )
            
            Spacer(modifier = Modifier.height(4.dp))
            
            if (chat.lastMessage != null) {
                Text(
                    text = chat.lastMessage,
                    style = MaterialTheme.typography.bodyMedium,
                    color = TaskGoTextGray,
                    maxLines = 2,
                    overflow = TextOverflow.Ellipsis
                )
            } else {
                Text(
                    text = "Nova conversa",
                    style = MaterialTheme.typography.bodyMedium,
                    color = TaskGoTextGrayLight,
                    fontStyle = androidx.compose.ui.text.font.FontStyle.Italic
                )
            }
        }
        
        Spacer(modifier = Modifier.width(12.dp))
        
        // Timestamp e bot√£o de deletar
        Column(
            horizontalAlignment = Alignment.End,
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            Text(
                text = displayTime,
                style = MaterialTheme.typography.bodySmall,
                color = TaskGoTextGrayLight
            )
            
            IconButton(
                onClick = onDelete,
                modifier = Modifier.size(32.dp)
            ) {
                Icon(
                    imageVector = Icons.Default.Delete,
                    contentDescription = "Excluir",
                    tint = TaskGoTextGrayLight,
                    modifier = Modifier.size(18.dp)
                )
            }
        }
    }
}

@Composable
fun EmptyChatList(
    onCreateNewChat: () -> Unit
) {
    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(32.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        Box(
            modifier = Modifier
                .size(80.dp)
                .clip(CircleShape)
                .background(TaskGoGreen.copy(alpha = 0.1f)),
            contentAlignment = Alignment.Center
        ) {
            Icon(
                imageVector = Icons.Default.SmartToy,
                contentDescription = null,
                tint = TaskGoGreen,
                modifier = Modifier.size(40.dp)
            )
        }
        
        Spacer(modifier = Modifier.height(24.dp))
        
        Text(
            text = "Nenhuma conversa ainda",
            style = MaterialTheme.typography.headlineSmall,
            fontWeight = FontWeight.Bold,
            color = Color.Black
        )
        
        Spacer(modifier = Modifier.height(8.dp))
        
        Text(
            text = "Comece uma nova conversa com a IA para come√ßar",
            style = MaterialTheme.typography.bodyLarge,
            color = TaskGoTextGray,
            textAlign = androidx.compose.ui.text.style.TextAlign.Center
        )
        
        Spacer(modifier = Modifier.height(32.dp))
        
        Button(
            onClick = onCreateNewChat,
            colors = ButtonDefaults.buttonColors(
                containerColor = TaskGoGreen
            ),
            modifier = Modifier
                .fillMaxWidth()
                .height(48.dp),
            shape = RoundedCornerShape(12.dp)
        ) {
            Icon(
                imageVector = Icons.Default.Add,
                contentDescription = null,
                tint = Color.White
            )
            Spacer(modifier = Modifier.width(8.dp))
            Text(
                text = "Nova conversa",
                fontWeight = FontWeight.SemiBold
            )
        }
    }
}


```

## [FRONTEND]: feature/chatai/presentation/ChatListViewModel.kt

```kotlin
package com.taskgoapp.taskgo.feature.chatai.presentation

import android.content.Context
import android.content.SharedPreferences
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.google.firebase.Timestamp
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import com.taskgoapp.taskgo.feature.chatai.data.ChatSession
import com.taskgoapp.taskgo.feature.chatai.data.ChatStorage
import dagger.hilt.android.lifecycle.HiltViewModel
import dagger.hilt.android.qualifiers.ApplicationContext
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject
import java.util.UUID

data class ChatListUiState(
    val chats: List<ChatSession> = emptyList(),
    val filteredChats: List<ChatSession> = emptyList(),
    val searchQuery: String = "",
    val isLoading: Boolean = false,
    val error: String? = null
)

@HiltViewModel
class ChatListViewModel @Inject constructor(
    @ApplicationContext private val context: Context,
    private val chatStorage: ChatStorage,
    private val functionsService: com.taskgoapp.taskgo.data.firebase.FirebaseFunctionsService
) : ViewModel() {
    
    private val _uiState = MutableStateFlow(ChatListUiState())
    val uiState: StateFlow<ChatListUiState> = _uiState.asStateFlow()
    
    private val prefs: SharedPreferences = context.getSharedPreferences("taskgo_ai_chats", Context.MODE_PRIVATE)
    private val gson = Gson()
    private val CHATS_KEY = "ai_chats_list"
    
    init {
        loadChats()
    }
    
    fun loadChats() {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoading = true)
            try {
                // Carregar do storage local primeiro (para exibi√ß√£o r√°pida)
                val localChats = getChatsFromStorage()
                
                // Tentar carregar do Firestore (conversas salvas via Cloud Functions)
                val firestoreChats = try {
                    val result = functionsService.listConversations(limit = 50)
                    result.fold(
                        onSuccess = { data ->
                            val conversations = data["conversations"] as? List<Map<String, Any>> ?: emptyList()
                            conversations.mapNotNull { conv ->
                                val id = conv["id"] as? String ?: return@mapNotNull null
                                val lastMessage = conv["lastMessage"] as? String
                                val updatedAtValue = conv["updatedAt"]
                                val updatedAt = when (updatedAtValue) {
                                    is Timestamp -> updatedAtValue.toDate()?.time
                                    is Long -> updatedAtValue
                                    else -> null
                                } ?: System.currentTimeMillis()
                                
                                ChatSession(
                                    id = id,
                                    title = lastMessage?.take(30) ?: "Nova conversa",
                                    lastMessage = lastMessage,
                                    timestamp = updatedAt
                                )
                            }
                        },
                        onFailure = {
                            android.util.Log.w("ChatListViewModel", "Erro ao carregar conversas do Firestore: ${it.message}")
                            emptyList()
                        }
                    )
                } catch (e: Exception) {
                    android.util.Log.e("ChatListViewModel", "Erro ao buscar conversas: ${e.message}", e)
                    emptyList()
                }
                
                // Combinar chats locais e do Firestore, priorizando Firestore
                val allChats = (firestoreChats + localChats).distinctBy { it.id }
                    .sortedByDescending { it.timestamp }
                
                _uiState.value = _uiState.value.copy(
                    chats = allChats,
                    filteredChats = filterChats(allChats, _uiState.value.searchQuery),
                    isLoading = false
                )
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = e.message
                )
            }
        }
    }
    
    fun createNewChat(): String {
        val newChatId = UUID.randomUUID().toString()
        val newChat = ChatSession(
            id = newChatId,
            title = "Nova conversa",
            timestamp = System.currentTimeMillis()
        )
        
        val updatedChats = listOf(newChat) + _uiState.value.chats
        _uiState.value = _uiState.value.copy(
            chats = updatedChats,
            filteredChats = filterChats(updatedChats, _uiState.value.searchQuery)
        )
        saveChatsToStorage(updatedChats)
        
        return newChatId
    }
    
    fun deleteChat(chatId: String) {
        val updatedChats = _uiState.value.chats.filter { it.id != chatId }
        _uiState.value = _uiState.value.copy(
            chats = updatedChats,
            filteredChats = filterChats(updatedChats, _uiState.value.searchQuery)
        )
        saveChatsToStorage(updatedChats)
        // Deletar mensagens do chat tamb√©m
        chatStorage.deleteMessages(chatId)
    }
    
    fun updateChatLastMessage(chatId: String, lastMessage: String, isFirstMessage: Boolean = false) {
        val updatedChats = _uiState.value.chats.map { chat ->
            if (chat.id == chatId) {
                val newTitle = if (isFirstMessage && (chat.title == "Nova conversa" || chat.title.isBlank())) {
                    chatStorage.generateTitleFromMessage(lastMessage)
                } else {
                    chat.title
                }
                chat.copy(
                    title = newTitle,
                    lastMessage = lastMessage,
                    timestamp = System.currentTimeMillis(),
                    messageCount = chat.messageCount + 1
                )
            } else chat
        }.sortedByDescending { it.timestamp }
        
        _uiState.value = _uiState.value.copy(
            chats = updatedChats,
            filteredChats = filterChats(updatedChats, _uiState.value.searchQuery)
        )
        saveChatsToStorage(updatedChats)
    }
    
    fun updateChatTitle(chatId: String, title: String) {
        val updatedChats = _uiState.value.chats.map { chat ->
            if (chat.id == chatId) {
                chat.copy(title = title)
            } else chat
        }
        _uiState.value = _uiState.value.copy(
            chats = updatedChats,
            filteredChats = filterChats(updatedChats, _uiState.value.searchQuery)
        )
        saveChatsToStorage(updatedChats)
    }
    
    fun updateSearchQuery(query: String) {
        _uiState.value = _uiState.value.copy(
            searchQuery = query,
            filteredChats = filterChats(_uiState.value.chats, query)
        )
    }
    
    private fun filterChats(chats: List<ChatSession>, query: String): List<ChatSession> {
        if (query.isBlank()) return chats
        val lowerQuery = query.lowercase()
        return chats.filter { chat ->
            chat.title.lowercase().contains(lowerQuery) ||
            chat.lastMessage?.lowercase()?.contains(lowerQuery) == true
        }
    }
    
    private fun getChatsFromStorage(): List<ChatSession> {
        val chatsJson = prefs.getString(CHATS_KEY, null)
        return if (chatsJson != null) {
            try {
                val type = object : TypeToken<List<ChatSession>>() {}.type
                gson.fromJson<List<ChatSession>>(chatsJson, type) ?: emptyList()
            } catch (e: Exception) {
                emptyList()
            }
        } else {
            emptyList()
        }
    }
    
    private fun saveChatsToStorage(chats: List<ChatSession>) {
        val chatsJson = gson.toJson(chats)
        prefs.edit().putString(CHATS_KEY, chatsJson).apply()
    }
}


```

## [FRONTEND]: feature/chatai/presentation/SearchBar.kt

```kotlin
package com.taskgoapp.taskgo.feature.chatai.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Clear
import androidx.compose.material.icons.filled.Search
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.core.theme.TaskGoBorder
import com.taskgoapp.taskgo.core.theme.TaskGoGreen
import com.taskgoapp.taskgo.core.theme.TaskGoTextGray

@Composable
fun SearchBar(
    query: String,
    onQueryChange: (String) -> Unit,
    modifier: Modifier = Modifier
) {
    OutlinedTextField(
        value = query,
        onValueChange = onQueryChange,
        modifier = modifier.fillMaxWidth(),
        placeholder = {
            Text(
                text = "Buscar conversas...",
                color = TaskGoTextGray
            )
        },
        leadingIcon = {
            Icon(
                imageVector = Icons.Default.Search,
                contentDescription = "Buscar",
                tint = TaskGoTextGray
            )
        },
        trailingIcon = {
            if (query.isNotEmpty()) {
                IconButton(onClick = { onQueryChange("") }) {
                    Icon(
                        imageVector = Icons.Default.Clear,
                        contentDescription = "Limpar",
                        tint = TaskGoTextGray
                    )
                }
            }
        },
        singleLine = true,
        colors = OutlinedTextFieldDefaults.colors(
            focusedBorderColor = TaskGoGreen,
            unfocusedBorderColor = TaskGoBorder,
            cursorColor = TaskGoGreen
        ),
        shape = MaterialTheme.shapes.medium
    )
}


```

## [FRONTEND]: feature/chatai/presentation/VoiceChatScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.chatai.presentation

import android.Manifest
import androidx.compose.animation.core.*
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Close
import androidx.compose.material.icons.filled.Mic
import androidx.compose.material.icons.filled.Stop
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.rotate
import androidx.compose.ui.draw.scale
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.window.Dialog
import androidx.compose.ui.window.DialogProperties
import androidx.hilt.navigation.compose.hiltViewModel
import com.google.accompanist.permissions.ExperimentalPermissionsApi
import com.google.accompanist.permissions.PermissionStatus
import com.google.accompanist.permissions.rememberPermissionState
import com.taskgoapp.taskgo.core.theme.*
import kotlinx.coroutines.delay

/**
 * Tela de conversa√ß√£o por voz similar ao ChatGPT
 * Permite gravar √°udio, converter para texto, enviar para AI e receber resposta em voz
 */
@OptIn(ExperimentalMaterial3Api::class, ExperimentalPermissionsApi::class)
@Composable
fun VoiceChatScreen(
    chatId: String,
    onDismiss: () -> Unit,
    viewModel: ChatAIViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    val recordAudioPermission = rememberPermissionState(Manifest.permission.RECORD_AUDIO)
    
    // Inicializar chat quando a tela abrir
    LaunchedEffect(chatId) {
        viewModel.initializeChat(chatId)
    }
    
    // Atualizar amplitude do √°udio para anima√ß√£o
    val amplitude by produceState(initialValue = 0.0) {
        while (true) {
            if (uiState.isRecording) {
                value = viewModel.getAudioAmplitude()
            }
            delay(50) // Atualizar a cada 50ms para anima√ß√£o suave
        }
    }
    
    Dialog(
        onDismissRequest = onDismiss,
        properties = DialogProperties(
            usePlatformDefaultWidth = false,
            dismissOnBackPress = true,
            dismissOnClickOutside = true
        )
    ) {
        Box(
            modifier = Modifier
                .fillMaxSize()
                .background(Color.Black.copy(alpha = 0.95f))
        ) {
            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(24.dp),
                horizontalAlignment = Alignment.CenterHorizontally,
                verticalArrangement = Arrangement.SpaceBetween
            ) {
                // TOP BAR - Fechar
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.End
                ) {
                    IconButton(
                        onClick = onDismiss,
                        modifier = Modifier
                            .size(48.dp)
                            .background(Color.White.copy(alpha = 0.2f), CircleShape)
                    ) {
                        Icon(
                            imageVector = Icons.Default.Close,
                            contentDescription = "Fechar",
                            tint = Color.White,
                            modifier = Modifier.size(24.dp)
                        )
                    }
                }
                
                Spacer(modifier = Modifier.weight(1f))
                
                // T√≠tulo
                Text(
                    text = "Conversa√ß√£o por Voz",
                    style = MaterialTheme.typography.headlineMedium,
                    color = Color.White,
                    fontWeight = FontWeight.Bold,
                    textAlign = TextAlign.Center
                )
                
                Spacer(modifier = Modifier.height(8.dp))
                
                Text(
                    text = "Grave uma mensagem e receba a resposta em voz",
                    style = MaterialTheme.typography.bodyMedium,
                    color = Color.White.copy(alpha = 0.8f),
                    textAlign = TextAlign.Center
                )
                
                Spacer(modifier = Modifier.weight(1f))
                
                // Status da grava√ß√£o/fala
                when {
                    uiState.isLoading && !uiState.isRecording -> {
                        // Processando/IA est√° respondendo
                        Column(
                            horizontalAlignment = Alignment.CenterHorizontally,
                            verticalArrangement = Arrangement.spacedBy(16.dp)
                        ) {
                            CircularProgressIndicator(
                                modifier = Modifier.size(48.dp),
                                color = Color.White,
                                strokeWidth = 3.dp
                            )
                            Text(
                                text = "AI est√° processando...",
                                style = MaterialTheme.typography.bodyLarge,
                                color = Color.White
                            )
                        }
                    }
                    uiState.isSpeaking -> {
                        // AI est√° falando
                        Column(
                            horizontalAlignment = Alignment.CenterHorizontally,
                            verticalArrangement = Arrangement.spacedBy(16.dp)
                        ) {
                            // Anima√ß√£o de ondas sonoras
                            WaveformAnimation(
                                modifier = Modifier.size(120.dp)
                            )
                            Text(
                                text = "AI est√° falando...",
                                style = MaterialTheme.typography.bodyLarge,
                                color = Color.White
                            )
                        }
                    }
                    uiState.messages.isNotEmpty() -> {
                        // Mostrar √∫ltima mensagem
                        val lastMessage = uiState.messages.last()
                        Column(
                            horizontalAlignment = Alignment.CenterHorizontally,
                            verticalArrangement = Arrangement.spacedBy(8.dp),
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(horizontal = 32.dp)
                        ) {
                            if (lastMessage.isFromAi) {
                                Text(
                                    text = "Resposta:",
                                    style = MaterialTheme.typography.labelMedium,
                                    color = Color.White.copy(alpha = 0.7f)
                                )
                                Surface(
                                    color = Color.White.copy(alpha = 0.15f),
                                    shape = MaterialTheme.shapes.medium,
                                    modifier = Modifier.fillMaxWidth()
                                ) {
                                    Text(
                                        text = lastMessage.text,
                                        style = MaterialTheme.typography.bodyLarge,
                                        color = Color.White,
                                        modifier = Modifier.padding(16.dp),
                                        textAlign = TextAlign.Center
                                    )
                                }
                            } else {
                                Text(
                                    text = "Voc√™ disse:",
                                    style = MaterialTheme.typography.labelMedium,
                                    color = Color.White.copy(alpha = 0.7f)
                                )
                                Surface(
                                    color = TaskGoGreen.copy(alpha = 0.3f),
                                    shape = MaterialTheme.shapes.medium,
                                    modifier = Modifier.fillMaxWidth()
                                ) {
                                    Text(
                                        text = lastMessage.text,
                                        style = MaterialTheme.typography.bodyLarge,
                                        color = Color.White,
                                        modifier = Modifier.padding(16.dp),
                                        textAlign = TextAlign.Center
                                    )
                                }
                            }
                        }
                    }
                }
                
                Spacer(modifier = Modifier.weight(1f))
                
                // Mensagens da conversa√ß√£o (hist√≥rico)
                if (uiState.messages.size > 1) {
                    Column(
                        modifier = Modifier
                            .fillMaxWidth()
                            .weight(1f, fill = false)
                            .heightIn(max = 200.dp),
                        verticalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        uiState.messages.takeLast(3).forEach { message ->
                            Text(
                                text = if (message.isFromAi) "AI: ${message.text.take(50)}..." else "Voc√™: ${message.text.take(50)}...",
                                style = MaterialTheme.typography.bodySmall,
                                color = Color.White.copy(alpha = 0.6f),
                                maxLines = 1
                            )
                        }
                    }
                }
                
                Spacer(modifier = Modifier.height(32.dp))
                
                // Bot√£o de grava√ß√£o principal (grande, central)
                VoiceRecordButton(
                    isRecording = uiState.isRecording,
                    amplitude = amplitude.toFloat(),
                    onRecordClick = {
                        if (recordAudioPermission.status is PermissionStatus.Granted) {
                            if (uiState.isRecording) {
                                // Parar grava√ß√£o e processar
                                viewModel.stopAudioRecordingAndSend()
                            } else {
                                // Iniciar grava√ß√£o
                                viewModel.startAudioRecording()
                            }
                        } else {
                            recordAudioPermission.launchPermissionRequest()
                        }
                    },
                    modifier = Modifier.size(120.dp)
                )
                
                Spacer(modifier = Modifier.height(16.dp))
                
                // Instru√ß√µes
                Text(
                    text = if (uiState.isRecording) {
                        "Gravando... Toque novamente para enviar"
                    } else if (uiState.isSpeaking) {
                        "Toque no bot√£o para interromper"
                    } else if (uiState.messages.isEmpty()) {
                        "Toque no bot√£o para come√ßar a gravar"
                    } else {
                        "Toque para gravar uma nova mensagem"
                    },
                    style = MaterialTheme.typography.bodySmall,
                    color = Color.White.copy(alpha = 0.7f),
                    textAlign = TextAlign.Center
                )
                
                Spacer(modifier = Modifier.height(32.dp))
            }
        }
    }
    
    // Quando receber resposta da AI, falar automaticamente
    LaunchedEffect(uiState.messages.size) {
        val lastMessage = uiState.messages.lastOrNull()
        if (lastMessage != null && lastMessage.isFromAi && !uiState.isSpeaking && !uiState.isLoading) {
            // Aguardar um pouco antes de falar
            delay(500)
            viewModel.speakResponse(lastMessage.text)
        }
    }
    
    // Mostrar erro se houver
    uiState.error?.let { error ->
        LaunchedEffect(error) {
            delay(3000)
            viewModel.clearError()
        }
        
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            colors = CardDefaults.cardColors(
                containerColor = MaterialTheme.colorScheme.errorContainer
            )
        ) {
            Text(
                text = error,
                color = MaterialTheme.colorScheme.onErrorContainer,
                modifier = Modifier.padding(12.dp),
                style = MaterialTheme.typography.bodySmall
            )
        }
    }
}

/**
 * Bot√£o de grava√ß√£o animado (similar ao ChatGPT)
 */
@Composable
private fun VoiceRecordButton(
    isRecording: Boolean,
    amplitude: Float,
    onRecordClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    // Anima√ß√£o de pulso quando est√° gravando
    val infiniteTransition = rememberInfiniteTransition(label = "pulse")
    val scale by infiniteTransition.animateFloat(
        initialValue = 1f,
        targetValue = if (isRecording) 1.2f else 1f,
        animationSpec = infiniteRepeatable(
            animation = tween(1000, easing = FastOutSlowInEasing),
            repeatMode = RepeatMode.Reverse
        ),
        label = "scale"
    )
    
    // Anima√ß√£o de rota√ß√£o suave
    val rotation by infiniteTransition.animateFloat(
        initialValue = 0f,
        targetValue = if (isRecording) 360f else 0f,
        animationSpec = infiniteRepeatable(
            animation = tween(2000, easing = LinearEasing),
            repeatMode = RepeatMode.Restart
        ),
        label = "rotation"
    )
    
    Box(
        modifier = modifier,
        contentAlignment = Alignment.Center
    ) {
        // C√≠rculo externo pulsante (quando est√° gravando)
        if (isRecording) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .scale(scale)
                    .clip(CircleShape)
                    .background(Color.Red.copy(alpha = 0.3f))
            )
        }
        
        // C√≠rculo do bot√£o
        Box(
            modifier = Modifier
                .fillMaxSize()
                .clip(CircleShape)
                .background(
                    if (isRecording) Color.Red else TaskGoGreen
                )
                .clickable(onClick = onRecordClick),
            contentAlignment = Alignment.Center
        ) {
            // √çcone interno
            Icon(
                imageVector = if (isRecording) Icons.Default.Stop else Icons.Default.Mic,
                contentDescription = if (isRecording) "Parar grava√ß√£o" else "Gravar √°udio",
                tint = Color.White,
                modifier = Modifier
                    .size(48.dp)
                    .then(
                        if (isRecording) {
                            Modifier.rotate(rotation * 0.1f) // Rota√ß√£o suave
                        } else {
                            Modifier
                        }
                    )
            )
        }
        
        // Indicador de amplitude quando est√° gravando
        if (isRecording && amplitude > 0.1f) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .scale(1f + (amplitude * 0.3f)) // Escala baseada na amplitude
                    .clip(CircleShape)
                    .background(
                        Color.White.copy(alpha = amplitude * 0.4f)
                    )
            )
        }
    }
}

/**
 * Anima√ß√£o de ondas sonoras (quando AI est√° falando)
 */
@Composable
private fun WaveformAnimation(modifier: Modifier = Modifier) {
    val infiniteTransition = rememberInfiniteTransition(label = "waveform")
    
    val wave1 by infiniteTransition.animateFloat(
        initialValue = 0.5f,
        targetValue = 1f,
        animationSpec = infiniteRepeatable(
            animation = tween(600, easing = FastOutSlowInEasing),
            repeatMode = RepeatMode.Reverse
        ),
        label = "wave1"
    )
    
    val wave2 by infiniteTransition.animateFloat(
        initialValue = 0.7f,
        targetValue = 1f,
        animationSpec = infiniteRepeatable(
            animation = tween(800, easing = FastOutSlowInEasing),
            repeatMode = RepeatMode.Reverse
        ),
        label = "wave2"
    )
    
    val wave3 by infiniteTransition.animateFloat(
        initialValue = 0.6f,
        targetValue = 1f,
        animationSpec = infiniteRepeatable(
            animation = tween(700, easing = FastOutSlowInEasing),
            repeatMode = RepeatMode.Reverse
        ),
        label = "wave3"
    )
    
    Row(
        modifier = modifier,
        horizontalArrangement = Arrangement.spacedBy(8.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        repeat(5) { index ->
            val scale = when (index) {
                0, 4 -> wave1
                1, 3 -> wave2
                else -> wave3
            }
            Box(
                modifier = Modifier
                    .weight(1f)
                    .height(60.dp)
                    .scale(scaleX = 1f, scaleY = scale)
                    .clip(MaterialTheme.shapes.small)
                    .background(Color.White.copy(alpha = 0.8f))
            )
        }
    }
}

```

# Features - checkout


## [FRONTEND]: feature/checkout/presentation/AddressBookScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.checkout.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.ui.unit.dp
import androidx.compose.foundation.layout.size
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import kotlinx.coroutines.launch
import kotlinx.coroutines.delay
import androidx.compose.runtime.rememberCoroutineScope
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.design.PrimaryButton
import com.taskgoapp.taskgo.core.model.Address
import com.taskgoapp.taskgo.core.theme.*

@Composable
fun AddressBookScreen(
    onNavigateBack: () -> Unit,
    onAddressSelected: (String) -> Unit,
    onAddAddress: () -> Unit = {},
    viewModel: CheckoutViewModel
) {
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()
    val scope = rememberCoroutineScope()
    
    // Inicializar com o endere√ßo j√° selecionado, se houver
    var selectedAddressId by remember { 
        mutableStateOf<String?>(uiState.selectedAddress?.id) 
    }
    
    val addresses = uiState.availableAddresses
    
    // Atualizar sele√ß√£o quando o ViewModel mudar
    LaunchedEffect(uiState.selectedAddress?.id) {
        uiState.selectedAddress?.id?.let { selectedAddressId = it }
    }
    
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Endere√ßos",
                onBackClick = onNavigateBack
            )
        },
        floatingActionButton = {
            FloatingActionButton(
                onClick = onAddAddress
            ) {
                Icon(Icons.Default.Add, contentDescription = "Adicionar endere√ßo")
            }
        }
    ) { padding ->
        LazyColumn(
            modifier = Modifier
                .fillMaxSize()
                .padding(padding)
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            item {
                Text(
                    text = "Escolha o endere√ßo de entrega",
                    style = FigmaProductName,
                    color = TaskGoTextBlack
                )
                Spacer(modifier = Modifier.height(16.dp))
            }
            
            if (addresses.isEmpty()) {
                item {
                    Card(
                        modifier = Modifier.fillMaxWidth(),
                        colors = CardDefaults.cardColors(
                            containerColor = TaskGoSurface
                        )
                    ) {
                        Column(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(24.dp),
                            horizontalAlignment = Alignment.CenterHorizontally,
                            verticalArrangement = Arrangement.spacedBy(16.dp)
                        ) {
                            Icon(
                                imageVector = Icons.Default.LocationOn,
                                contentDescription = null,
                                modifier = Modifier.size(64.dp),
                                tint = TaskGoTextGray
                            )
                            Text(
                                text = "Nenhum endere√ßo cadastrado",
                                style = FigmaProductName,
                                color = TaskGoTextBlack
                            )
                            Text(
                                text = "Adicione um endere√ßo para continuar com a compra",
                                style = FigmaProductDescription,
                                color = TaskGoTextGray
                            )
                        }
                    }
                }
            }
            
            items(addresses) { address ->
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    onClick = {
                        selectedAddressId = address.id
                    }
                ) {
                    Column(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(16.dp)
                    ) {
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Text(
                                text = address.name,
                                style = FigmaProductName,
                                color = TaskGoTextBlack
                            )
                            Spacer(modifier = Modifier.weight(1f))
                            RadioButton(
                                selected = selectedAddressId == address.id,
                                onClick = { selectedAddressId = address.id }
                            )
                        }
                        
                        Spacer(modifier = Modifier.height(8.dp))
                        Text(
                            text = "${address.street}, ${address.number}",
                            style = FigmaProductDescription,
                            color = TaskGoTextGray
                        )
                        if (!address.complement.isNullOrEmpty()) {
                            Text(
                                text = address.complement,
                                style = FigmaProductDescription,
                                color = TaskGoTextGray
                            )
                        }
                        Text(
                            text = "${address.neighborhood.ifEmpty { address.district }}, ${address.city} - ${address.state}",
                            style = FigmaProductDescription,
                            color = TaskGoTextGray
                        )
                        Text(
                            text = "CEP: ${address.zipCode.ifEmpty { address.cep }}",
                            style = FigmaProductDescription,
                            color = TaskGoTextGray
                        )
                    }
                }
            }
            
            item {
                Spacer(modifier = Modifier.height(24.dp))
                PrimaryButton(
                    text = "Continuar",
                    onClick = {
                        selectedAddressId?.let { addressId ->
                            // Salva a sele√ß√£o no ViewModel ANTES de navegar
                            addresses.firstOrNull { it.id == addressId }?.let { address ->
                                viewModel.selectAddress(address)
                                // Pequeno delay para garantir que o estado seja atualizado
                                scope.launch {
                                    delay(100)
                                    onAddressSelected(addressId)
                                }
                            } ?: run {
                                onAddressSelected(addressId)
                            }
                        }
                    },
                    enabled = selectedAddressId != null && addresses.isNotEmpty(),
                    modifier = Modifier.fillMaxWidth()
                )
            }
        }
    }
}


```

## [FRONTEND]: feature/checkout/presentation/AddressFormViewModel.kt

```kotlin
package com.taskgoapp.taskgo.feature.checkout.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.taskgoapp.taskgo.core.model.Address
import com.taskgoapp.taskgo.domain.repository.AddressRepository
import com.taskgoapp.taskgo.data.repository.FirebaseAuthRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

data class AddressFormUiState(
    val isLoading: Boolean = false,
    val error: String? = null,
    val success: Boolean = false
)

@HiltViewModel
class AddressFormViewModel @Inject constructor(
    private val addressRepository: AddressRepository,
    private val authRepository: FirebaseAuthRepository
) : ViewModel() {

    private val _uiState = MutableStateFlow(AddressFormUiState())
    val uiState: StateFlow<AddressFormUiState> = _uiState.asStateFlow()

    fun saveAddress(
        name: String,
        street: String,
        number: String,
        complement: String?,
        neighborhood: String,
        district: String,
        city: String,
        state: String,
        cep: String,
        zipCode: String,
        phone: String = ""
    ) {
        if (street.isEmpty() || number.isEmpty() || city.isEmpty() || state.isEmpty() || cep.isEmpty()) {
            _uiState.value = _uiState.value.copy(error = "Preencha todos os campos obrigat√≥rios")
            return
        }

        _uiState.value = _uiState.value.copy(isLoading = true, error = null)

        viewModelScope.launch {
            try {
                val userId = authRepository.getCurrentUser()?.uid
                    ?: throw IllegalStateException("Usu√°rio n√£o autenticado. Fa√ßa login novamente.")

                val address = Address(
                    id = "", // Novo endere√ßo
                    name = name.ifEmpty { "Endere√ßo ${System.currentTimeMillis()}" },
                    phone = phone,
                    street = street,
                    number = number,
                    complement = complement,
                    neighborhood = neighborhood,
                    district = district,
                    city = city,
                    state = state,
                    cep = cep,
                    zipCode = zipCode.ifEmpty { cep }
                )

                addressRepository.upsertAddress(address)
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    success = true,
                    error = null
                )
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = e.message ?: "Erro ao salvar endere√ßo"
                )
            }
        }
    }

    fun resetState() {
        _uiState.value = AddressFormUiState()
    }
}


```

## [FRONTEND]: feature/checkout/presentation/CadastrarEnderecoScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.checkout.presentation

import android.Manifest
import android.location.Address
import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.LocationOn
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.compose.ui.graphics.Color
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import com.taskgoapp.taskgo.core.location.LocationManager
import com.taskgoapp.taskgo.core.permissions.PermissionHandler
import com.taskgoapp.taskgo.core.permissions.rememberMultiplePermissionsLauncher
import com.taskgoapp.taskgo.core.theme.*
import com.taskgoapp.taskgo.core.validation.CepService
import com.taskgoapp.taskgo.core.validation.DocumentValidator
import kotlinx.coroutines.launch
import kotlinx.coroutines.delay
import androidx.compose.runtime.LaunchedEffect
import javax.inject.Inject

@Composable
fun CadastrarEnderecoScreen(
    onBackClick: () -> Unit,
    onSave: () -> Unit,
    variant: String? = null,
    viewModel: AddressFormViewModel = hiltViewModel()
) {
    val context = LocalContext.current
    val scope = rememberCoroutineScope()
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()
    
    // Observar sucesso e navegar de volta
    LaunchedEffect(uiState.success) {
        if (uiState.success) {
            onSave()
        }
    }
    
    // Servi√ßos de valida√ß√£o e busca
    val cepService = remember { CepService() }
    val documentValidator = remember { DocumentValidator() }
    
    var rua by remember { mutableStateOf("") }
    var numero by remember { mutableStateOf("") }
    var bairro by remember { mutableStateOf("") }
    var cidade by remember { mutableStateOf("") }
    var estado by remember { mutableStateOf("") }
    var cep by remember { mutableStateOf("") }
    var complemento by remember { mutableStateOf("") }
    var nomeEndereco by remember { mutableStateOf("") }
    var isLoadingLocation by remember { mutableStateOf(false) }
    var locationError by remember { mutableStateOf<String?>(null) }
    var cepError by remember { mutableStateOf<String?>(null) }
    var isLoadingCep by remember { mutableStateOf(false) }
    
    val isError = variant == "invalid"
    val isEmpty = variant == "empty"
    
    // LocationManager via Hilt (precisamos injetar diretamente via contexto por enquanto)
    val locationManager = remember {
        LocationManager(context)
    }
    
    // Verificar permiss√£o de localiza√ß√£o
    val hasLocationPermission = remember {
        PermissionHandler.hasLocationPermission(context)
    }
    
    // Launcher para permiss√£o de localiza√ß√£o
    val locationPermissionLauncher = rememberMultiplePermissionsLauncher(
        onAllPermissionsGranted = {
            isLoadingLocation = true
            locationError = null
            scope.launch {
                try {
                    // Verificar permiss√£o antes de usar
                    if (PermissionHandler.hasLocationPermission(context)) {
                    val address = locationManager.getCurrentAddress()
                    address?.let {
                        rua = it.thoroughfare ?: ""
                        numero = it.subThoroughfare ?: ""
                        bairro = it.subLocality ?: it.featureName ?: ""
                        cidade = it.locality ?: ""
                        estado = it.adminArea ?: ""
                        cep = it.postalCode ?: ""
                        locationError = null
                    } ?: run {
                        locationError = "N√£o foi poss√≠vel obter o endere√ßo da localiza√ß√£o"
                    }
                    } else {
                        locationError = "Permiss√£o de localiza√ß√£o n√£o concedida"
                    }
                } catch (e: SecurityException) {
                    locationError = "Permiss√£o de localiza√ß√£o negada"
                } catch (e: Exception) {
                    locationError = "Erro ao obter localiza√ß√£o: ${e.message}"
                } finally {
                    isLoadingLocation = false
                }
            }
        },
        onPermissionDenied = {
            locationError = "Permiss√£o de localiza√ß√£o negada"
            isLoadingLocation = false
        }
    )
    
    fun loadCurrentLocation() {
        if (hasLocationPermission) {
            isLoadingLocation = true
            locationError = null
            scope.launch {
                try {
                    // Verificar permiss√£o antes de usar
                    if (PermissionHandler.hasLocationPermission(context)) {
                    val address = locationManager.getCurrentAddress()
                    address?.let {
                        rua = it.thoroughfare ?: ""
                        numero = it.subThoroughfare ?: ""
                        bairro = it.subLocality ?: it.featureName ?: ""
                        cidade = it.locality ?: ""
                        estado = it.adminArea ?: ""
                        cep = it.postalCode ?: ""
                        locationError = null
                    } ?: run {
                        locationError = "N√£o foi poss√≠vel obter o endere√ßo da localiza√ß√£o"
                    }
                    } else {
                        locationError = "Permiss√£o de localiza√ß√£o n√£o concedida"
                    }
                } catch (e: SecurityException) {
                    locationError = "Permiss√£o de localiza√ß√£o negada"
                } catch (e: Exception) {
                    locationError = "Erro ao obter localiza√ß√£o: ${e.message}"
                } finally {
                    isLoadingLocation = false
                }
            }
        } else {
            locationPermissionLauncher.launch(
                arrayOf(
                    Manifest.permission.ACCESS_FINE_LOCATION,
                    Manifest.permission.ACCESS_COARSE_LOCATION
                )
            )
        }
    }

    Column(
        Modifier
            .fillMaxSize()
            .padding(32.dp),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text(
            "Cadastrar Endere√ßo",
            style = FigmaSectionTitle,
            color = TaskGoTextBlack
        )
        
        Spacer(Modifier.height(18.dp))
        
        // Bot√£o para usar localiza√ß√£o atual
        OutlinedButton(
            onClick = { loadCurrentLocation() },
            modifier = Modifier.fillMaxWidth(),
            enabled = !isLoadingLocation
        ) {
            if (isLoadingLocation) {
                CircularProgressIndicator(
                    modifier = Modifier.size(20.dp),
                    strokeWidth = 2.dp
                )
                Spacer(Modifier.width(8.dp))
                Text("Obtendo localiza√ß√£o...")
            } else {
                Icon(
                    imageVector = Icons.Default.LocationOn,
                    contentDescription = null,
                    modifier = Modifier.size(18.dp)
                )
                Spacer(Modifier.width(8.dp))
                Text("Usar localiza√ß√£o atual")
            }
        }
        
        locationError?.let { error ->
            Spacer(Modifier.height(8.dp))
            Text(
                text = error,
                color = MaterialTheme.colorScheme.error,
                style = MaterialTheme.typography.bodySmall
            )
        }
        
        Spacer(Modifier.height(16.dp))
        
        OutlinedTextField(
            value = nomeEndereco,
            onValueChange = { nomeEndereco = it },
            label = { Text("Nome do endere√ßo (ex: Casa, Trabalho)") },
            placeholder = { Text("Casa") },
            modifier = Modifier.fillMaxWidth()
        )
        
        OutlinedTextField(
            value = rua,
            onValueChange = { rua = it },
            label = { Text("Rua*") },
            isError = isEmpty && rua.isEmpty() || isError && rua == "" || false,
            modifier = Modifier.fillMaxWidth()
        )
        OutlinedTextField(
            value = numero,
            onValueChange = { numero = it },
            label = { Text("N√∫mero*") },
            isError = isEmpty && numero.isEmpty(),
            modifier = Modifier.fillMaxWidth()
        )
        
        OutlinedTextField(
            value = complemento,
            onValueChange = { complemento = it },
            label = { Text("Complemento") },
            placeholder = { Text("Apto, Bloco, etc.") },
            modifier = Modifier.fillMaxWidth()
        )
        
        OutlinedTextField(
            value = bairro,
            onValueChange = { bairro = it },
            label = { Text("Bairro*") },
            isError = isEmpty && bairro.isEmpty(),
            modifier = Modifier.fillMaxWidth()
        )
        OutlinedTextField(
            value = cidade,
            onValueChange = { cidade = it },
            label = { Text("Cidade*") },
            isError = isEmpty && cidade.isEmpty(),
            modifier = Modifier.fillMaxWidth()
        )
        OutlinedTextField(
            value = estado,
            onValueChange = { estado = it },
            label = { Text("Estado*") },
            isError = isEmpty && estado.isEmpty(),
            modifier = Modifier.fillMaxWidth()
        )
        OutlinedTextField(
            value = cep,
            onValueChange = { newValue ->
                val cleanValue = newValue.replace(Regex("[^0-9]"), "")
                if (cleanValue.length <= 8) {
                    cep = cleanValue
                    cepError = null
                    
                    if (cleanValue.length == 8) {
                        cep = documentValidator.formatCep(cleanValue)
                        
                        scope.launch {
                            isLoadingCep = true
                            cepError = null
                            
                            delay(500)
                            
                            cepService.searchCep(cleanValue).fold(
                                onSuccess = { cepResult ->
                                    rua = cepResult.logradouro
                                    bairro = cepResult.bairro
                                    cidade = cepResult.localidade
                                    estado = cepResult.uf
                                    isLoadingCep = false
                                },
                                onFailure = { error ->
                                    cepError = error.message ?: "CEP n√£o encontrado"
                                    isLoadingCep = false
                                }
                            )
                        }
                    }
                }
            },
            label = { Text("CEP*") },
            placeholder = { Text("00000-000") },
            trailingIcon = {
                if (isLoadingCep) {
                    CircularProgressIndicator(
                        modifier = Modifier.size(20.dp),
                        strokeWidth = 2.dp
                    )
                }
            },
            isError = (isEmpty && cep.isEmpty()) || (isError && cep == "30100-000") || cepError != null,
            supportingText = {
                when {
                    cepError != null -> Text(cepError!!, color = MaterialTheme.colorScheme.error)
                    isError -> Text("CEP inv√°lido", color = MaterialTheme.colorScheme.error)
                    else -> null
                }
            },
            enabled = !isLoadingCep,
            modifier = Modifier.fillMaxWidth()
        )
        // Mostrar erro do ViewModel
        uiState.error?.let { error ->
            Spacer(Modifier.height(8.dp))
            Text(
                text = error,
                color = MaterialTheme.colorScheme.error,
                style = MaterialTheme.typography.bodySmall
            )
        }
        
        Spacer(Modifier.height(24.dp))
        Button(
            onClick = {
                viewModel.saveAddress(
                    name = nomeEndereco.ifEmpty { "Endere√ßo" },
                    street = rua,
                    number = numero,
                    complement = complemento.takeIf { it.isNotEmpty() },
                    neighborhood = bairro,
                    district = bairro,
                    city = cidade,
                    state = estado,
                    cep = cep.replace(Regex("[^0-9]"), ""),
                    zipCode = cep.replace(Regex("[^0-9]"), "")
                )
            },
            enabled = !uiState.isLoading && rua.isNotEmpty() && numero.isNotEmpty() && 
                     cidade.isNotEmpty() && estado.isNotEmpty() && cep.isNotEmpty(),
            modifier = Modifier.fillMaxWidth()
        ) {
            if (uiState.isLoading) {
                CircularProgressIndicator(
                    modifier = Modifier.size(20.dp),
                    color = Color.White,
                    strokeWidth = 2.dp
                )
                Spacer(Modifier.width(8.dp))
                Text("Salvando...")
            } else {
                Text("Salvar")
            }
        }
        OutlinedButton(
            onClick = onBackClick,
            modifier = Modifier.fillMaxWidth()
        ) {
            Text("Cancelar")
        }
    }
}

```

## [FRONTEND]: feature/checkout/presentation/CardDetailsScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.checkout.presentation

import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.design.PrimaryButton
import com.taskgoapp.taskgo.core.theme.FigmaProductDescription
import com.taskgoapp.taskgo.core.theme.FigmaProductName
import com.taskgoapp.taskgo.core.theme.TaskGoTextBlack
import com.taskgoapp.taskgo.core.theme.TaskGoTextGray

@Composable
fun CardDetailsScreen(
    onPaymentSuccess: () -> Unit,
    onBackClick: () -> Unit
) {
    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        AppTopBar(title = "Dados do Cart√£o", onBackClick = onBackClick)

        Spacer(modifier = Modifier.height(16.dp))

        Text(text = "Digite os dados do cart√£o", style = FigmaProductName, color = TaskGoTextBlack)
        Spacer(modifier = Modifier.height(8.dp))
        Text(text = "N√∫mero, nome, validade e CVV", style = FigmaProductDescription, color = TaskGoTextGray)

        Spacer(modifier = Modifier.height(24.dp))

        PrimaryButton(
            text = "Pagar com cart√£o",
            onClick = onPaymentSuccess,
            modifier = Modifier.fillMaxWidth()
        )
    }
}


```

## [FRONTEND]: feature/checkout/presentation/CardFormViewModel.kt

```kotlin
package com.taskgoapp.taskgo.feature.checkout.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.taskgoapp.taskgo.core.model.Card
import com.taskgoapp.taskgo.domain.repository.CardRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

data class CardFormUiState(
    val isLoading: Boolean = false,
    val error: String? = null,
    val success: Boolean = false
)

@HiltViewModel
class CardFormViewModel @Inject constructor(
    private val cardRepository: CardRepository
) : ViewModel() {

    private val _uiState = MutableStateFlow(CardFormUiState())
    val uiState: StateFlow<CardFormUiState> = _uiState.asStateFlow()

    fun saveCard(
        holder: String,
        cardNumber: String,
        expMonth: Int,
        expYear: Int,
        cvc: String,
        type: String // "Cr√©dito" ou "D√©bito"
    ) {
        if (holder.isEmpty() || cardNumber.isEmpty() || cvc.isEmpty()) {
            _uiState.value = _uiState.value.copy(error = "Preencha todos os campos")
            return
        }

        // Validar n√∫mero do cart√£o (deve ter pelo menos 13 d√≠gitos)
        val cleanNumber = cardNumber.replace(Regex("[^0-9]"), "")
        if (cleanNumber.length < 13 || cleanNumber.length > 19) {
            _uiState.value = _uiState.value.copy(error = "N√∫mero do cart√£o inv√°lido")
            return
        }

        // Validar CVC (deve ter 3 ou 4 d√≠gitos)
        val cleanCvc = cvc.replace(Regex("[^0-9]"), "")
        if (cleanCvc.length < 3 || cleanCvc.length > 4) {
            _uiState.value = _uiState.value.copy(error = "CVC inv√°lido")
            return
        }

        // Validar validade
        if (expMonth < 1 || expMonth > 12) {
            _uiState.value = _uiState.value.copy(error = "M√™s inv√°lido")
            return
        }

        if (expYear < 2024) {
            _uiState.value = _uiState.value.copy(error = "Ano inv√°lido")
            return
        }

        _uiState.value = _uiState.value.copy(isLoading = true, error = null)

        viewModelScope.launch {
            try {
                // Detectar bandeira do cart√£o (heur√≠stica simples)
                val brand = detectCardBrand(cleanNumber)

                // Mascarar n√∫mero do cart√£o (mostrar apenas √∫ltimos 4 d√≠gitos)
                val maskedNumber = "**** **** **** ${cleanNumber.takeLast(4)}"

                val card = Card(
                    id = "", // Novo cart√£o
                    holder = holder,
                    numberMasked = maskedNumber,
                    brand = brand,
                    expMonth = expMonth,
                    expYear = expYear,
                    type = type
                )

                cardRepository.upsertCard(card)
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    success = true,
                    error = null
                )
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = e.message ?: "Erro ao salvar cart√£o"
                )
            }
        }
    }

    private fun detectCardBrand(cardNumber: String): String {
        return when {
            cardNumber.startsWith("4") -> "Visa"
            cardNumber.startsWith("5") || cardNumber.startsWith("2") -> "Mastercard"
            cardNumber.startsWith("3") -> "American Express"
            cardNumber.startsWith("6") -> "Discover"
            else -> "Desconhecida"
        }
    }

    fun resetState() {
        _uiState.value = CardFormUiState()
    }
}


```

## [FRONTEND]: feature/checkout/presentation/CartaoCreditoScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.checkout.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.graphics.Color
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.theme.*
import androidx.compose.ui.unit.size

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun CartaoCreditoScreen(
    onBackClick: () -> Unit,
    isAlt: Boolean = false,
    viewModel: CardFormViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()
    
    var nome by remember { mutableStateOf("") }
    var numeroCartao by remember { mutableStateOf("") }
    var validade by remember { mutableStateOf("") }
    var cvc by remember { mutableStateOf("") }
    
    // Observar sucesso e navegar de volta
    LaunchedEffect(uiState.success) {
        if (uiState.success) {
            onBackClick()
        }
    }

    Scaffold(
        topBar = {
            AppTopBar(
                title = if (isAlt) "Cart√£o (Cr√©dito)" else "Cart√£o de Cr√©dito",
                onBackClick = onBackClick
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            val fieldContainer: @Composable (@Composable () -> Unit) -> Unit = { content ->
                if (isAlt) {
                    Card { Column(Modifier.padding(16.dp)) { content() } }
                } else {
                    Column { content() }
                }
            }

            // Nome
            fieldContainer {
                Text(
                    text = if (isAlt) "NOME COMPLETO" else "Nome",
                    style = FigmaProductDescription,
                    color = TaskGoTextGray
                )
                Spacer(modifier = Modifier.height(8.dp))
                OutlinedTextField(
                    value = nome,
                    onValueChange = { nome = it },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = true
                )
            }

            // Detalhes do cart√£o
            fieldContainer {
                Text(
                    text = if (isAlt) "DADOS DO CART√ÉO" else "Detalhes do cart√£o",
                    style = FigmaProductDescription,
                    color = TaskGoTextGray
                )
                Spacer(modifier = Modifier.height(8.dp))
                
                // N√∫mero
                OutlinedTextField(
                    value = numeroCartao,
                    onValueChange = { 
                        // Formatar n√∫mero do cart√£o (adicionar espa√ßos a cada 4 d√≠gitos)
                        val cleanValue = it.replace(Regex("[^0-9]"), "")
                        numeroCartao = cleanValue.chunked(4).joinToString(" ")
                    },
                    placeholder = { Text("0000 0000 0000 0000") },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = true
                )
                
                Spacer(modifier = Modifier.height(8.dp))
                
                // Validade e CVC row
                Row(
                    horizontalArrangement = Arrangement.spacedBy(16.dp)
                ) {
                    OutlinedTextField(
                        value = validade,
                        onValueChange = { 
                            // Formatar validade (MM/AA)
                            val cleanValue = it.replace(Regex("[^0-9]"), "")
                            validade = when {
                                cleanValue.length <= 2 -> cleanValue
                                else -> "${cleanValue.take(2)}/${cleanValue.drop(2).take(2)}"
                            }
                        },
                        placeholder = { Text("MM/AA") },
                        modifier = Modifier.weight(1f),
                        singleLine = true
                    )
                    OutlinedTextField(
                        value = cvc,
                        onValueChange = { 
                            // Limitar CVC a 3-4 d√≠gitos
                            val cleanValue = it.replace(Regex("[^0-9]"), "")
                            cvc = cleanValue.take(4)
                        },
                        placeholder = { Text("CVC") },
                        modifier = Modifier.weight(1f),
                        singleLine = true
                    )
                }
            }

            // Mostrar erro do ViewModel
            uiState.error?.let { error ->
                Text(
                    text = error,
                    color = MaterialTheme.colorScheme.error,
                    style = MaterialTheme.typography.bodySmall
                )
            }
            
            Spacer(modifier = Modifier.weight(1f))

            // Save button
            Button(
                onClick = {
                    // Parse validade (MM/AA)
                    val validadeParts = validade.split("/")
                    val expMonth = validadeParts.getOrNull(0)?.toIntOrNull() ?: 0
                    val expYear = if (validadeParts.getOrNull(1)?.length == 2) {
                        2000 + (validadeParts[1].toIntOrNull() ?: 0)
                    } else {
                        validadeParts.getOrNull(1)?.toIntOrNull() ?: 0
                    }
                    
                    viewModel.saveCard(
                        holder = nome,
                        cardNumber = numeroCartao.replace(Regex("[^0-9]"), ""),
                        expMonth = expMonth,
                        expYear = expYear,
                        cvc = cvc,
                        type = "Cr√©dito"
                    )
                },
                enabled = !uiState.isLoading && nome.isNotEmpty() && 
                         numeroCartao.replace(Regex("[^0-9]"), "").length >= 13 &&
                         validade.length >= 5 && cvc.length >= 3,
                modifier = Modifier.fillMaxWidth(),
                colors = ButtonDefaults.buttonColors(
                    containerColor = TaskGoGreen
                )
            ) {
                if (uiState.isLoading) {
                    CircularProgressIndicator(
                        modifier = Modifier.size(20.dp),
                        color = Color.White,
                        strokeWidth = 2.dp
                    )
                    Spacer(modifier = Modifier.width(8.dp))
                    Text("Salvando...", style = FigmaButtonText, color = Color.White)
                } else {
                    Text(
                        text = if (isAlt) "Salvar Cart√£o" else "Salvar",
                        style = FigmaButtonText,
                        color = Color.White
                    )
                }
            }
        }
    }
}


```

## [FRONTEND]: feature/checkout/presentation/CartaoDebitoScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.checkout.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.input.VisualTransformation
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import com.taskgoapp.taskgo.core.theme.*

@Composable
fun CartaoDebitoScreen(
    onBackClick: () -> Unit,
    isAlt: Boolean = false,
    viewModel: CardFormViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()
    
    var nome by remember { mutableStateOf("") }
    var numero by remember { mutableStateOf("") }
    var validade by remember { mutableStateOf("") }
    var cvv by remember { mutableStateOf("") }
    
    // Observar sucesso e navegar de volta
    LaunchedEffect(uiState.success) {
        if (uiState.success) {
            onBackClick()
        }
    }
    
    val enabled = nome.isNotBlank() && numero.replace(Regex("[^0-9]"), "").length >= 13 && 
                 validade.length >= 5 && cvv.length >= 3
    val bg = if(isAlt) TaskGoSurfaceGrayBg else TaskGoSurface
    Column(
        Modifier.fillMaxSize().padding(24.dp), horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text(if(isAlt)"Adicionar cart√£o de d√©bito" else "Cart√£o de d√©bito", style = FigmaSectionTitle)
        Spacer(Modifier.height(14.dp))
        Card(Modifier.fillMaxWidth(), shape = RoundedCornerShape(14.dp), colors=CardDefaults.cardColors(containerColor = bg)) {
            Column(Modifier.padding(14.dp)) {
                OutlinedTextField(
                    value = nome,
                    onValueChange = { nome = it },
                    label = { Text("Nome no cart√£o") },
                    singleLine = true,
                    modifier = Modifier.fillMaxWidth()
                )
                OutlinedTextField(
                    value = numero,
                    onValueChange = {
                        val cleanValue = it.replace(Regex("[^0-9]"), "")
                        numero = cleanValue.chunked(4).joinToString(" ")
                    },
                    label = { Text("N√∫mero do cart√£o") },
                    placeholder = { Text("0000 0000 0000 0000") },
                    singleLine = true,
                    visualTransformation = VisualTransformation.None,
                    modifier = Modifier.fillMaxWidth()
                )
                Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(8.dp)) {
                    OutlinedTextField(
                        value = validade,
                        onValueChange = {
                            val cleanValue = it.replace(Regex("[^0-9]"), "")
                            validade = when {
                                cleanValue.length <= 2 -> cleanValue
                                else -> "${cleanValue.take(2)}/${cleanValue.drop(2).take(2)}"
                            }
                        },
                        label = { Text("Validade (MM/AA)") },
                        placeholder = { Text("MM/AA") },
                        singleLine = true,
                        modifier = Modifier.weight(1f)
                    )
                    OutlinedTextField(
                        value = cvv,
                        onValueChange = {
                            if(it.length <= 3) cvv = it.filter { ch -> ch.isDigit() }
                        },
                        label = { Text("CVV") },
                        singleLine = true,
                        visualTransformation = VisualTransformation.None,
                        modifier = Modifier.weight(1f)
                    )
                }
            }
        }
        // Mostrar erro do ViewModel
        uiState.error?.let { error ->
            Spacer(Modifier.height(8.dp))
            Text(
                text = error,
                color = TaskGoError,
                style = FigmaProductDescription
            )
        }
        
        Spacer(Modifier.height(28.dp))
        Button(
            onClick = {
                val validadeParts = validade.split("/")
                val expMonth = validadeParts.getOrNull(0)?.toIntOrNull() ?: 0
                val expYear = if (validadeParts.getOrNull(1)?.length == 2) {
                    2000 + (validadeParts[1].toIntOrNull() ?: 0)
                } else {
                    validadeParts.getOrNull(1)?.toIntOrNull() ?: 0
                }
                
                viewModel.saveCard(
                    holder = nome,
                    cardNumber = numero.replace(Regex("[^0-9]"), ""),
                    expMonth = expMonth,
                    expYear = expYear,
                    cvc = cvv,
                    type = "D√©bito"
                )
            },
            enabled = enabled && !uiState.isLoading,
            modifier = Modifier.fillMaxWidth()
        ) {
            if (uiState.isLoading) {
                CircularProgressIndicator(
                    modifier = Modifier.size(20.dp),
                    strokeWidth = 2.dp
                )
                Spacer(Modifier.width(8.dp))
                Text("Salvando...")
            } else {
                Text("Confirmar")
            }
        }
        OutlinedButton(onClick=onBackClick, modifier=Modifier.fillMaxWidth()) { Text("Voltar") }
    }
}

```

## [FRONTEND]: feature/checkout/presentation/CheckoutScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.checkout.presentation

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.CreditCard
import androidx.compose.material.icons.filled.LocationOn
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.model.PaymentType
import com.taskgoapp.taskgo.feature.checkout.presentation.CheckoutProcessState.Error
import com.taskgoapp.taskgo.feature.checkout.presentation.CheckoutProcessState.Processing
import com.taskgoapp.taskgo.feature.checkout.presentation.components.CheckoutBottomBar
import com.taskgoapp.taskgo.feature.checkout.presentation.components.CheckoutCartItemRow
import com.taskgoapp.taskgo.feature.checkout.presentation.components.EmptyCheckoutState
import com.taskgoapp.taskgo.feature.checkout.presentation.components.SelectedFieldCard
import com.taskgoapp.taskgo.feature.checkout.presentation.components.SummaryCard

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun CheckoutScreen(
    onBackClick: () -> Unit,
    onAddressSelection: () -> Unit,
    onPaymentMethodSelection: () -> Unit,
    onOrderSummary: (String, PaymentType) -> Unit,
    viewModel: CheckoutViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()
    val selectedAddress = uiState.selectedAddress
    val selectedPaymentMethod = uiState.selectedPaymentMethod
    
    // Garantir que PIX esteja sempre dispon√≠vel como m√©todo padr√£o
    LaunchedEffect(uiState.availablePaymentMethods, uiState.selectedPaymentMethod) {
        if (uiState.availablePaymentMethods.isNotEmpty() && 
            uiState.selectedPaymentMethod == null) {
            // Selecionar PIX automaticamente se dispon√≠vel
            val pixMethod = uiState.availablePaymentMethods.firstOrNull { it.type == PaymentType.PIX }
            pixMethod?.let { viewModel.selectPaymentMethod(it) }
        }
    }
    
    // Preservar sele√ß√µes quando voltar das telas de sele√ß√£o
    LaunchedEffect(Unit) {
        // Garantir que sele√ß√µes sejam preservadas
        // O ViewModel j√° mant√©m o estado, mas vamos garantir que esteja sincronizado
    }
    val canContinue = uiState.cartItems.isNotEmpty() &&
        selectedAddress != null &&
        selectedPaymentMethod != null &&
        uiState.checkoutProcess !is Processing

    Scaffold(
        topBar = {
            AppTopBar(
                title = "Finalizar compra",
                onBackClick = onBackClick
            )
        },
        bottomBar = {
            CheckoutBottomBar(
                total = uiState.total,
                enabled = canContinue,
                isLoading = uiState.checkoutProcess is Processing,
                onCheckout = {
                    if (selectedAddress != null && selectedPaymentMethod != null) {
                        onOrderSummary(selectedAddress.id, selectedPaymentMethod.type)
                    }
                }
            )
        }
    ) { paddingValues ->
        when {
            uiState.isLoading -> {
                Box(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(paddingValues),
                    contentAlignment = Alignment.Center
                ) {
                    CircularProgressIndicator()
                }
            }

            uiState.cartItems.isEmpty() -> {
                EmptyCheckoutState(modifier = Modifier.padding(paddingValues))
            }

            else -> {
                Column(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(paddingValues)
                        .verticalScroll(rememberScrollState())
                        .padding(horizontal = 16.dp, vertical = 12.dp),
                    verticalArrangement = Arrangement.spacedBy(16.dp)
                ) {
                    SelectedFieldCard(
                        title = "Endere√ßo de entrega",
                        value = selectedAddress?.name ?: "Selecione um endere√ßo",
                        subtitle = selectedAddress?.let { "${it.city} - ${it.state}" }
                            ?: if (uiState.availableAddresses.isEmpty()) {
                                "Nenhum endere√ßo cadastrado"
                            } else {
                                "Nenhum endere√ßo selecionado"
                            },
                        icon = Icons.Default.LocationOn,
                        onAction = onAddressSelection
                    )

                    SelectedFieldCard(
                        title = "Forma de pagamento",
                        value = selectedPaymentMethod?.let { 
                            if (it.type == PaymentType.PIX) "PIX" else "‚Ä¢‚Ä¢‚Ä¢‚Ä¢ ${it.lastFourDigits}"
                        } ?: "Selecione um m√©todo",
                        subtitle = selectedPaymentMethod?.let {
                            when (it.type) {
                                PaymentType.CREDIT_CARD -> "Cart√£o de cr√©dito${if (it.cardholderName.isNotEmpty()) " (${it.cardholderName})" else ""}"
                                PaymentType.DEBIT_CARD -> "Cart√£o de d√©bito${if (it.cardholderName.isNotEmpty()) " (${it.cardholderName})" else ""}"
                                PaymentType.PIX -> "PIX - Pagamento instant√¢neo"
                            }
                        } ?: if (uiState.availablePaymentMethods.isEmpty()) {
                            "Nenhum m√©todo dispon√≠vel"
                        } else {
                            "Nenhum m√©todo selecionado"
                        },
                        icon = Icons.Default.CreditCard,
                        onAction = onPaymentMethodSelection
                    )

                    SummaryCard(
                        subtotal = uiState.subtotal,
                        shipping = uiState.shipping,
                        total = uiState.total
                    )

                    HorizontalDivider()

                    uiState.cartItems.forEach { item ->
                        CheckoutCartItemRow(item = item)
                        HorizontalDivider()
                    }

                    Spacer(modifier = Modifier.height(32.dp))
                }
            }
        }
    }

    if (uiState.checkoutProcess is Error) {
        AlertDialog(
            onDismissRequest = { viewModel.resetCheckoutProcess() },
            confirmButton = {
                TextButton(onClick = { viewModel.resetCheckoutProcess() }) {
                    Text("Entendi")
                }
            },
            title = { Text("N√£o foi poss√≠vel continuar") },
            text = { Text((uiState.checkoutProcess as Error).message) }
        )
    }
}


```

## [FRONTEND]: feature/checkout/presentation/CheckoutViewModel.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.checkout.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.taskgoapp.taskgo.core.model.Address
import com.taskgoapp.taskgo.core.model.Card
import com.taskgoapp.taskgo.core.model.PaymentMethod
import com.taskgoapp.taskgo.core.model.PaymentType
import com.taskgoapp.taskgo.core.payment.PaymentGateway
import com.taskgoapp.taskgo.core.payment.PaymentGatewayRequest
import com.taskgoapp.taskgo.domain.repository.AddressRepository
import com.taskgoapp.taskgo.domain.repository.CardRepository
import com.taskgoapp.taskgo.domain.repository.ProductsRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.Job
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import javax.inject.Inject

data class CheckoutCartItem(
    val productId: String,
    val title: String,
    val quantity: Int,
    val price: Double,
    val imageUrl: String?
)

sealed interface CheckoutProcessState {
    object Idle : CheckoutProcessState
    object Processing : CheckoutProcessState
    data class PaymentSheetReady(val clientSecret: String, val orderId: String) : CheckoutProcessState
    data class Success(val orderId: String, val trackingCode: String) : CheckoutProcessState
    data class Error(val message: String) : CheckoutProcessState
}

data class CheckoutUiState(
    val isLoading: Boolean = true,
    val error: String? = null,
    val cartItems: List<CheckoutCartItem> = emptyList(),
    val subtotal: Double = 0.0,
    val shipping: Double = 0.0,
    val total: Double = 0.0,
    val availableAddresses: List<Address> = emptyList(),
    val selectedAddress: Address? = null,
    val availablePaymentMethods: List<PaymentMethod> = emptyList(),
    val selectedPaymentMethod: PaymentMethod? = null,
    val checkoutProcess: CheckoutProcessState = CheckoutProcessState.Idle,
    val paymentIntentClientSecret: String? = null // Para PaymentSheet
)

@HiltViewModel
class CheckoutViewModel @Inject constructor(
    private val productsRepository: ProductsRepository,
    private val addressRepository: AddressRepository,
    private val cardRepository: CardRepository,
    private val paymentGateway: PaymentGateway
) : ViewModel() {

    private val _uiState = MutableStateFlow(CheckoutUiState())
    val uiState: StateFlow<CheckoutUiState> = _uiState.asStateFlow()

    private var cartJob: Job? = null
    private var addressJob: Job? = null
    private var paymentJob: Job? = null

    init {
        observeCart()
        observeAddresses()
        observePaymentMethods()
    }

    private fun observeCart() {
        cartJob?.cancel()
        cartJob = viewModelScope.launch {
            productsRepository.observeCart().collect { cart ->
                val details = cart.mapNotNull { cartItem ->
                    val product = productsRepository.getProduct(cartItem.productId)
                    product?.let {
                        CheckoutCartItem(
                            productId = cartItem.productId,
                            title = it.title,
                            quantity = cartItem.qty,
                            price = it.price,
                            imageUrl = it.imageUris.firstOrNull()
                        )
                    }
                }
                val subtotal = details.sumOf { it.price * it.quantity }
                val shipping = if (subtotal == 0.0 || subtotal >= 150.0) 0.0 else 19.9
                val total = subtotal + shipping
                _uiState.update {
                    it.copy(
                        cartItems = details,
                        subtotal = subtotal,
                        shipping = shipping,
                        total = total,
                        isLoading = false
                    )
                }
            }
        }
    }

    private fun observeAddresses() {
        addressJob?.cancel()
        addressJob = viewModelScope.launch {
            addressRepository.observeAddresses().collect { addresses ->
                val selected = when {
                    addresses.isEmpty() -> null
                    _uiState.value.selectedAddress == null -> addresses.firstOrNull()
                    addresses.any { it.id == _uiState.value.selectedAddress?.id } -> _uiState.value.selectedAddress
                    else -> addresses.firstOrNull()
                }
                _uiState.update {
                    it.copy(
                        availableAddresses = addresses,
                        selectedAddress = selected
                    )
                }
            }
        }
    }

    private fun observePaymentMethods() {
        paymentJob?.cancel()
        paymentJob = viewModelScope.launch {
            cardRepository.observeCards().collect { cards ->
                // Sempre incluir PIX como op√ß√£o dispon√≠vel
                val pixMethod = PaymentMethod(
                    id = 0L,
                    type = PaymentType.PIX,
                    lastFourDigits = "PIX",
                    cardholderName = "",
                    expiryDate = "",
                    isDefault = false
                )
                
                val cardMethods = cards.map { card ->
                    PaymentMethod(
                        id = card.id.toLongOrNull() ?: 0L,
                        type = if (card.type.contains("Cr√©dito", ignoreCase = true)) {
                            PaymentType.CREDIT_CARD
                        } else {
                            PaymentType.DEBIT_CARD
                        },
                        lastFourDigits = card.numberMasked.takeLast(4),
                        cardholderName = card.holder,
                        expiryDate = "${card.expMonth.toString().padStart(2, '0')}/${card.expYear}",
                        isDefault = false
                    )
                }
                
                // PIX sempre primeiro, depois cart√µes
                val methods = listOf(pixMethod) + cardMethods
                
                val selected = when {
                    _uiState.value.selectedPaymentMethod == null -> pixMethod // PIX como padr√£o
                    methods.any { it.type == _uiState.value.selectedPaymentMethod?.type && 
                                 (it.type != PaymentType.PIX || it.id == _uiState.value.selectedPaymentMethod?.id) } -> 
                        _uiState.value.selectedPaymentMethod
                    else -> pixMethod // Fallback para PIX
                }
                _uiState.update {
                    it.copy(
                        availablePaymentMethods = methods,
                        selectedPaymentMethod = selected
                    )
                }
            }
        }
    }

    fun selectAddress(address: Address) {
        _uiState.update { it.copy(selectedAddress = address) }
    }

    fun selectPaymentMethod(paymentMethod: PaymentMethod) {
        _uiState.update { it.copy(selectedPaymentMethod = paymentMethod) }
    }

    fun applySelection(addressId: String?, paymentType: PaymentType?) {
        viewModelScope.launch {
            if (!addressId.isNullOrBlank()) {
                addressRepository.getAddress(addressId)?.let { address ->
                    _uiState.update { it.copy(selectedAddress = address) }
                }
            }
            if (paymentType != null) {
                val method = _uiState.value.availablePaymentMethods.firstOrNull { it.type == paymentType }
                method?.let { selected ->
                    _uiState.update { it.copy(selectedPaymentMethod = selected) }
                }
            }
        }
    }

    fun finalizeOrder(addressId: String?, paymentType: PaymentType) {
        val resolvedAddressId = addressId?.takeIf { it.isNotBlank() }
            ?: _uiState.value.selectedAddress?.id
        if (resolvedAddressId.isNullOrBlank()) {
            _uiState.update {
                it.copy(checkoutProcess = CheckoutProcessState.Error("Selecione um endere√ßo para continuar"))
            }
            return
        }

        _uiState.update { it.copy(checkoutProcess = CheckoutProcessState.Processing, error = null) }

        viewModelScope.launch {
            val result = paymentGateway.process(
                PaymentGatewayRequest(
                    paymentType = paymentType,
                    addressId = resolvedAddressId
                )
            )
            result
                .onSuccess { gatewayResult ->
                    // Se for cart√£o, precisamos apresentar o PaymentSheet
                    // Se for PIX, j√° est√° pronto para mostrar a tela de PIX
                    if (paymentType == PaymentType.CREDIT_CARD || paymentType == PaymentType.DEBIT_CARD) {
                        val clientSecret = gatewayResult.clientSecret
                        if (clientSecret != null) {
                            _uiState.update {
                                it.copy(
                                    checkoutProcess = CheckoutProcessState.PaymentSheetReady(
                                        clientSecret = clientSecret,
                                        orderId = gatewayResult.orderId
                                    ),
                                    paymentIntentClientSecret = clientSecret
                                )
                            }
                        } else {
                            _uiState.update {
                                it.copy(
                                    checkoutProcess = CheckoutProcessState.Error(
                                        "Erro: clientSecret n√£o retornado pelo servidor"
                                    )
                                )
                            }
                        }
                    } else {
                        // PIX - j√° est√° pronto
                        _uiState.update {
                            it.copy(
                                checkoutProcess = CheckoutProcessState.Success(
                                    orderId = gatewayResult.orderId,
                                    trackingCode = gatewayResult.trackingCode
                                )
                            )
                        }
                    }
                }
                .onFailure { throwable ->
                    _uiState.update {
                        it.copy(
                            checkoutProcess = CheckoutProcessState.Error(
                                throwable.message ?: "Erro ao processar pagamento"
                            )
                        )
                    }
                }
        }
    }

    fun resetCheckoutProcess() {
        _uiState.update { it.copy(checkoutProcess = CheckoutProcessState.Idle) }
    }

    fun clearError() {
        _uiState.update { it.copy(error = null) }
    }
    
    /**
     * Called when PaymentSheet payment is completed successfully
     */
    fun onPaymentSheetSuccess(orderId: String, trackingCode: String) {
        _uiState.update {
            it.copy(
                checkoutProcess = CheckoutProcessState.Success(
                    orderId = orderId,
                    trackingCode = trackingCode
                ),
                paymentIntentClientSecret = null
            )
        }
    }
    
    /**
     * Called when PaymentSheet payment fails or is canceled
     */
    fun onPaymentSheetError(error: String) {
        _uiState.update {
            it.copy(
                checkoutProcess = CheckoutProcessState.Error(error),
                paymentIntentClientSecret = null
            )
        }
    }
}


```

## [FRONTEND]: feature/checkout/presentation/components/CheckoutComponents.kt

```kotlin
package com.taskgoapp.taskgo.feature.checkout.presentation.components

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ShoppingCart
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.Icon
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.core.design.PrimaryButton
import com.taskgoapp.taskgo.core.theme.FigmaPrice
import com.taskgoapp.taskgo.core.theme.FigmaProductDescription
import com.taskgoapp.taskgo.core.theme.FigmaProductName
import com.taskgoapp.taskgo.core.theme.FigmaStatusText
import com.taskgoapp.taskgo.core.theme.TaskGoGreen
import com.taskgoapp.taskgo.core.theme.TaskGoTextBlack
import com.taskgoapp.taskgo.core.theme.TaskGoTextGray
import com.taskgoapp.taskgo.feature.checkout.presentation.CheckoutCartItem

@Composable
fun SelectedFieldCard(
    title: String,
    value: String,
    subtitle: String,
    icon: ImageVector,
    onAction: () -> Unit
) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp),
        shape = RoundedCornerShape(12.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(text = title, style = FigmaProductName, color = TaskGoTextBlack)
                TextButton(onClick = onAction) {
                    Text("Alterar")
                }
            }
            Spacer(modifier = Modifier.height(12.dp))
            Row(verticalAlignment = Alignment.CenterVertically) {
                Icon(
                    imageVector = icon,
                    contentDescription = null,
                    tint = TaskGoGreen,
                    modifier = Modifier.size(20.dp)
                )
                Spacer(modifier = Modifier.width(12.dp))
                Column {
                    Text(text = value, style = FigmaProductName, color = TaskGoTextBlack)
                    Text(text = subtitle, style = FigmaProductDescription, color = TaskGoTextGray)
                }
            }
        }
    }
}

@Composable
fun SummaryCard(
    subtotal: Double,
    shipping: Double,
    total: Double
) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp),
        shape = RoundedCornerShape(12.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            Text("Resumo do pedido", style = FigmaProductName, color = TaskGoTextBlack)
            SummaryRow("Subtotal", subtotal)
            SummaryRow("Frete", shipping, highlightFree = true)
            HorizontalDivider()
            SummaryRow("Total", total, prominent = true)
        }
    }
}

@Composable
fun SummaryRow(
    label: String,
    value: Double,
    highlightFree: Boolean = false,
    prominent: Boolean = false
) {
    Row(
        modifier = Modifier.fillMaxWidth(),
        horizontalArrangement = Arrangement.SpaceBetween
    ) {
        Text(
            text = label,
            style = if (prominent) FigmaProductName else FigmaProductDescription,
            color = TaskGoTextGray
        )
        Text(
            text = if (highlightFree && value == 0.0) "Gr√°tis" else "R$ %.2f".format(value),
            style = if (prominent) FigmaPrice else FigmaProductDescription,
            color = when {
                prominent -> TaskGoTextBlack
                highlightFree && value == 0.0 -> TaskGoGreen
                else -> TaskGoTextBlack
            },
            fontWeight = if (prominent) FontWeight.Bold else FontWeight.Normal
        )
    }
}

@Composable
fun CheckoutCartItemRow(item: CheckoutCartItem) {
    Row(
        modifier = Modifier.fillMaxWidth(),
        horizontalArrangement = Arrangement.SpaceBetween,
        verticalAlignment = Alignment.CenterVertically
    ) {
        Column(modifier = Modifier.weight(1f)) {
            Text(
                text = item.title,
                style = FigmaProductDescription,
                color = TaskGoTextBlack
            )
            Text(
                text = "Qtd: ${item.quantity}",
                style = FigmaStatusText,
                color = TaskGoTextGray
            )
        }
        Text(
            text = "R$ %.2f".format(item.price * item.quantity),
            style = FigmaProductDescription,
            color = TaskGoTextBlack,
            fontWeight = FontWeight.Medium
        )
    }
}

@Composable
fun EmptyCheckoutState(modifier: Modifier = Modifier) {
    Box(
        modifier = modifier.fillMaxWidth(),
        contentAlignment = Alignment.Center
    ) {
        Column(horizontalAlignment = Alignment.CenterHorizontally) {
            Icon(
                imageVector = Icons.Default.ShoppingCart,
                contentDescription = null,
                tint = TaskGoTextGray,
                modifier = Modifier.size(64.dp)
            )
            Spacer(modifier = Modifier.height(12.dp))
            Text(
                text = "Seu carrinho est√° vazio",
                style = FigmaProductName,
                color = TaskGoTextGray
            )
        }
    }
}

@Composable
fun CheckoutBottomBar(
    total: Double,
    enabled: Boolean,
    isLoading: Boolean,
    onCheckout: () -> Unit
) {
    Surface(
        tonalElevation = 8.dp,
        shadowElevation = 8.dp
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Column(modifier = Modifier.weight(1f)) {
                Text("Total", style = FigmaProductDescription, color = TaskGoTextGray)
                Text(
                    text = "R$ %.2f".format(total),
                    style = FigmaProductName,
                    color = TaskGoTextBlack,
                    fontWeight = FontWeight.Bold
                )
            }
            PrimaryButton(
                text = if (isLoading) "Processando..." else "Continuar",
                enabled = enabled && !isLoading,
                onClick = onCheckout,
                modifier = Modifier.height(48.dp)
            )
        }
    }
}


```

## [FRONTEND]: feature/checkout/presentation/ConfirmacaoPixScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.checkout.presentation

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Check
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.core.theme.*

@Composable
fun ConfirmacaoPixScreen(
    onContinue: () -> Unit
) {
    Box(
        modifier = Modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .padding(32.dp),
            colors = CardDefaults.cardColors(
                containerColor = Color.White
            )
        ) {
            Column(
                modifier = Modifier.padding(24.dp),
                horizontalAlignment = Alignment.CenterHorizontally,
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                // TaskGo logo
                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    Icon(
                        imageVector = Icons.Default.Check,
                        contentDescription = null,
                        tint = TaskGoGreen,
                        modifier = Modifier.size(24.dp)
                    )
                    Text(
                        text = "TaskGo",
                        style = FigmaProductName,
                        color = TaskGoTextBlack
                    )
                }

                // Success icon
                Box(
                    modifier = Modifier
                        .size(80.dp)
                        .background(
                            color = TaskGoGreen,
                            shape = CircleShape
                        ),
                    contentAlignment = Alignment.Center
                ) {
                    Icon(
                        imageVector = Icons.Default.Check,
                        contentDescription = null,
                        tint = Color.White,
                        modifier = Modifier.size(40.dp)
                    )
                }

                // Success message
                Text(
                    text = "Pagamento Confirmado",
                    style = FigmaSectionTitle,
                    color = TaskGoTextBlack
                )

                // OK button
                Button(
                    onClick = onContinue,
                    colors = ButtonDefaults.buttonColors(
                        containerColor = TaskGoGreen
                    )
                ) {
                    Text(
                        text = "OK",
                        style = FigmaButtonText,
                        color = Color.White
                    )
                }
            }
        }
    }
}


```

## [FRONTEND]: feature/checkout/presentation/FinalizarPedidoScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.checkout.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.CheckCircle
import androidx.compose.material.icons.filled.ErrorOutline
import androidx.compose.material.icons.filled.HourglassEmpty
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import com.taskgoapp.taskgo.core.theme.*
import java.text.NumberFormat
import java.util.Locale

@Composable
fun FinalizarPedidoScreen(
    onBackClick: () -> Unit,
    onFinalizar: () -> Unit,
    variant: String? = null,
    viewModel: CheckoutViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()
    val currencyFormat = NumberFormat.getCurrencyInstance(Locale("pt", "BR"))
    
    LaunchedEffect(uiState.checkoutProcess) {
        when (val process = uiState.checkoutProcess) {
            is CheckoutProcessState.Success -> {
                onFinalizar()
            }
            is CheckoutProcessState.Error -> {
                // Erro ser√° tratado na UI
            }
            else -> {}
        }
    }
    
    Column(
        Modifier.fillMaxSize().padding(32.dp), 
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        when(variant) {
            "payment_error" -> {
                Icon(Icons.Default.ErrorOutline, contentDescription = null, tint = TaskGoError, modifier = Modifier.size(64.dp))
                Spacer(Modifier.height(12.dp))
                Text("Erro no pagamento", style = FigmaTitleLarge, color = TaskGoError)
                Text(
                    uiState.checkoutProcess.let { 
                        if (it is CheckoutProcessState.Error) it.message else "Houve um problema ao processar o pagamento. Revise seus dados ou tente novamente."
                    },
                    style = FigmaProductDescription, 
                    color = TaskGoTextGray, 
                    modifier = Modifier.padding(8.dp)
                )
            }
            "pending" -> {
                Icon(Icons.Default.HourglassEmpty, null, tint = TaskGoWarning, modifier = Modifier.size(64.dp))
                Spacer(Modifier.height(12.dp))
                Text("Pedido em processamento", style = FigmaTitleLarge, color = TaskGoWarning)
                Text("Aguardando confirma√ß√£o do pagamento.", style = FigmaProductDescription, color = TaskGoTextGray, modifier = Modifier.padding(8.dp))
            }
            "success" -> {
                Icon(Icons.Default.CheckCircle, null, tint = TaskGoSuccess, modifier = Modifier.size(64.dp))
                Spacer(Modifier.height(12.dp))
                Text("Pedido realizado com sucesso!", style = FigmaTitleLarge, color = TaskGoSuccess)
                Text("Seu pedido est√° sendo preparado para envio.", style = FigmaProductDescription, color = TaskGoTextGray, modifier = Modifier.padding(8.dp))
            }
            else -> {
                Text("Finalizar Pedido", style = FigmaSectionTitle, color = TaskGoTextBlack)
                Spacer(Modifier.height(12.dp))
                
                // Endere√ßo selecionado
                val addressText = uiState.selectedAddress?.let { 
                    "${it.street}, ${it.number}${it.complement?.let { " - $it" } ?: ""}\n${it.district.ifEmpty { it.neighborhood }}, ${it.city} - ${it.state}\nCEP: ${it.zipCode.ifEmpty { it.cep }}"
                } ?: "Nenhum endere√ßo selecionado"
                Text("Endere√ßo de entrega:", style = FigmaProductName, color = TaskGoTextBlack)
                Text(addressText, color = TaskGoTextGray, style = FigmaProductDescription)
                
                Spacer(Modifier.height(12.dp))
                
                // M√©todo de pagamento
                val paymentText = uiState.selectedPaymentMethod?.let {
                    when (it.type) {
                        com.taskgoapp.taskgo.core.model.PaymentType.CREDIT_CARD -> "Cart√£o de Cr√©dito ‚Ä¢‚Ä¢‚Ä¢‚Ä¢ ${it.lastFourDigits}"
                        com.taskgoapp.taskgo.core.model.PaymentType.DEBIT_CARD -> "Cart√£o de D√©bito ‚Ä¢‚Ä¢‚Ä¢‚Ä¢ ${it.lastFourDigits}"
                        com.taskgoapp.taskgo.core.model.PaymentType.PIX -> "PIX"
                    }
                } ?: "Nenhum m√©todo selecionado"
                Text("Forma de pagamento:", style = FigmaProductName, color = TaskGoTextBlack)
                Text(paymentText, color = TaskGoTextGray, style = FigmaProductDescription)
                
                Spacer(Modifier.height(12.dp))
                
                // Resumo do pedido
                Column(Modifier.fillMaxWidth()) {
                    Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween) {
                        Text("Subtotal:", style = FigmaProductDescription, color = TaskGoTextGray)
                        Text(currencyFormat.format(uiState.subtotal), style = FigmaProductDescription, color = TaskGoTextBlack)
                    }
                    Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween) {
                        Text("Frete:", style = FigmaProductDescription, color = TaskGoTextGray)
                        Text(
                            if (uiState.shipping == 0.0) "Gr√°tis" else currencyFormat.format(uiState.shipping),
                            style = FigmaProductDescription,
                            color = if (uiState.shipping == 0.0) TaskGoGreen else TaskGoTextBlack
                        )
                    }
                    HorizontalDivider(Modifier.padding(vertical = 8.dp))
                    Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween) {
                        Text("Total:", style = FigmaProductName, color = TaskGoTextBlack)
                        Text(currencyFormat.format(uiState.total), style = FigmaPrice, color = TaskGoPriceGreen)
                    }
                }
                
                Spacer(Modifier.height(18.dp))
                
                val canFinalize = uiState.selectedAddress != null && 
                    uiState.selectedPaymentMethod != null && 
                    uiState.cartItems.isNotEmpty() &&
                    uiState.checkoutProcess !is CheckoutProcessState.Processing
                
                Button(
                    onClick = { 
                        uiState.selectedAddress?.id?.let { addressId ->
                            uiState.selectedPaymentMethod?.type?.let { paymentType ->
                                viewModel.finalizeOrder(addressId, paymentType)
                            }
                        }
                    },
                    modifier = Modifier.fillMaxWidth(),
                    enabled = canFinalize
                ) { 
                    if (uiState.checkoutProcess is CheckoutProcessState.Processing) {
                        CircularProgressIndicator(modifier = Modifier.size(20.dp), color = androidx.compose.ui.graphics.Color.White)
                    } else {
                        Text("Finalizar Pedido")
                    }
                }
                OutlinedButton(onClick = onBackClick, modifier = Modifier.fillMaxWidth()) { 
                    Text("Voltar") 
                }
            }
        }
    }
}

```

## [FRONTEND]: feature/checkout/presentation/FormaPagamentoScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.checkout.presentation

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.core.theme.*

@Composable
fun FormaPagamentoScreen(
    onBackClick: () -> Unit,
    onPix: () -> Unit,
    onCartaoCredito: () -> Unit,
    onCartaoDebito: () -> Unit,
    variant: String? = null // null=padr√£o, 'pix_only'
) {
    val options = if(variant == "pix_only") listOf("Pix") else listOf("Pix", "Cart√£o de Cr√©dito", "Cart√£o de D√©bito")
    var selected by remember { mutableStateOf(options.first()) }
    Column(Modifier.fillMaxSize().padding(32.dp)) {
        Text("Forma de pagamento", style = FigmaSectionTitle, color = TaskGoTextBlack)
        Spacer(Modifier.height(18.dp))
        options.forEach {
            Row(
                Modifier
                    .fillMaxWidth()
                    .clickable { selected = it }
                    .padding(12.dp),
                verticalAlignment = Alignment.CenterVertically
            ) {
                RadioButton(selected = selected == it, onClick = { selected = it })
                Text(it, Modifier.weight(1f), color = TaskGoTextBlack)
            }
        }
        Spacer(Modifier.height(32.dp))
        Button(
            onClick = {
                when(selected){
                    "Pix" -> onPix()
                    "Cart√£o de Cr√©dito" -> onCartaoCredito()
                    "Cart√£o de D√©bito" -> onCartaoDebito()
                }
            },
            modifier = Modifier.fillMaxWidth()
        ){ Text("Continuar") }
        OutlinedButton(onClick = onBackClick, modifier = Modifier.fillMaxWidth()) { Text("Voltar") }
    }
}

```

## [FRONTEND]: feature/checkout/presentation/OrderSummaryScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.checkout.presentation

import android.app.Activity
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.CreditCard
import androidx.compose.material.icons.filled.LocationOn
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.design.PrimaryButton
import com.taskgoapp.taskgo.core.model.PaymentType
import com.taskgoapp.taskgo.core.payment.StripePaymentManager
import com.taskgoapp.taskgo.data.firebase.FirebaseFunctionsService
import com.taskgoapp.taskgo.feature.checkout.presentation.CheckoutProcessState.Error
import com.taskgoapp.taskgo.feature.checkout.presentation.CheckoutProcessState.PaymentSheetReady
import com.taskgoapp.taskgo.feature.checkout.presentation.CheckoutProcessState.Processing
import com.taskgoapp.taskgo.feature.checkout.presentation.components.CheckoutCartItemRow
import com.taskgoapp.taskgo.feature.checkout.presentation.components.SelectedFieldCard
import com.taskgoapp.taskgo.feature.checkout.presentation.components.SummaryCard
import kotlinx.coroutines.launch
import javax.inject.Inject

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun OrderSummaryScreen(
    onNavigateBack: () -> Unit,
    onOrderFinished: (orderId: String, total: Double, trackingCode: String) -> Unit,
    onNavigateToPix: (orderId: String, total: Double) -> Unit,
    addressId: String,
    paymentTypeName: String,
    viewModel: CheckoutViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()
    val paymentType = runCatching { PaymentType.valueOf(paymentTypeName) }.getOrDefault(PaymentType.PIX)
    val context = LocalContext.current
    val activity = context as? Activity
    val scope = rememberCoroutineScope()
    
    // Stripe Payment Helper ViewModel
    val stripeHelperViewModel = hiltViewModel<StripePaymentHelperViewModel>()
    val stripeInitialized by stripeHelperViewModel.isInitialized.collectAsStateWithLifecycle()

    LaunchedEffect(addressId, paymentTypeName) {
        if (addressId.isNotBlank()) {
            viewModel.applySelection(addressId, paymentType)
        }
    }
    
    // Initialize Stripe when needed (for card payments)
    LaunchedEffect(paymentType) {
        if ((paymentType == PaymentType.CREDIT_CARD || paymentType == PaymentType.DEBIT_CARD) 
            && !stripeInitialized && activity != null) {
            stripeHelperViewModel.initializeStripe(activity)
        }
    }
    
    // Handle PaymentSheet ready state
    LaunchedEffect(uiState.checkoutProcess, stripeInitialized) {
        val process = uiState.checkoutProcess
        if (process is PaymentSheetReady && stripeInitialized && activity != null) {
            scope.launch {
                val result = stripeHelperViewModel.presentPaymentSheet(
                    activity = activity,
                    clientSecret = process.clientSecret
                )
                result.onSuccess {
                    // Payment successful - webhook will confirm automatically
                    viewModel.onPaymentSheetSuccess(process.orderId, "")
                    onOrderFinished(process.orderId, uiState.total, "")
                }.onFailure { error ->
                    viewModel.onPaymentSheetError(error.message ?: "Erro ao processar pagamento")
                }
            }
        }
    }

    LaunchedEffect(uiState.checkoutProcess) {
        val process = uiState.checkoutProcess
        if (process is CheckoutProcessState.Success) {
            // Se for PIX, navegar para tela de PIX em vez de finalizar imediatamente
            if (paymentType == PaymentType.PIX) {
                onNavigateToPix(process.orderId, uiState.total)
                viewModel.resetCheckoutProcess()
            } else {
                onOrderFinished(process.orderId, uiState.total, process.trackingCode)
                viewModel.resetCheckoutProcess()
            }
        }
    }

    Scaffold(
        topBar = {
            AppTopBar(
                title = "Resumo do pedido",
                onBackClick = onNavigateBack
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .verticalScroll(rememberScrollState())
                .padding(horizontal = 16.dp, vertical = 12.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            SelectedFieldCard(
                title = "Endere√ßo de entrega",
                value = uiState.selectedAddress?.name ?: "Selecione um endere√ßo",
                subtitle = uiState.selectedAddress?.let { "${it.city} - ${it.state}" }
                    ?: "Nenhum endere√ßo selecionado",
                icon = Icons.Default.LocationOn,
                onAction = onNavigateBack
            )

            SelectedFieldCard(
                title = "Pagamento",
                value = uiState.selectedPaymentMethod?.let { "‚Ä¢‚Ä¢‚Ä¢‚Ä¢ ${it.lastFourDigits}" }
                    ?: "Selecione uma forma de pagamento",
                subtitle = uiState.selectedPaymentMethod?.let {
                    when (it.type) {
                        PaymentType.CREDIT_CARD -> "Cart√£o de cr√©dito (${it.cardholderName})"
                        PaymentType.DEBIT_CARD -> "Cart√£o de d√©bito (${it.cardholderName})"
                        PaymentType.PIX -> "PIX"
                    }
                } ?: "Voc√™ poder√° alterar na etapa anterior",
                icon = Icons.Default.CreditCard,
                onAction = onNavigateBack
            )

            SummaryCard(
                subtotal = uiState.subtotal,
                shipping = uiState.shipping,
                total = uiState.total
            )

            HorizontalDivider()

            uiState.cartItems.forEach { item ->
                CheckoutCartItemRow(item = item)
                HorizontalDivider()
            }

            Spacer(modifier = Modifier.height(24.dp))

            PrimaryButton(
                text = if (uiState.checkoutProcess is Processing) "Processando..." else "Confirmar pedido",
                enabled = uiState.checkoutProcess !is Processing,
                onClick = { viewModel.finalizeOrder(addressId, paymentType) },
                modifier = Modifier.fillMaxWidth()
            )
        }
    }

    if (uiState.checkoutProcess is Error) {
        AlertDialog(
            onDismissRequest = { viewModel.resetCheckoutProcess() },
            confirmButton = {
                TextButton(onClick = { viewModel.resetCheckoutProcess() }) {
                    Text("Tentar novamente")
                }
            },
            title = { Text("N√£o foi poss√≠vel concluir o pedido") },
            text = { Text((uiState.checkoutProcess as Error).message) }
        )
    }
}


```

## [FRONTEND]: feature/checkout/presentation/PaymentMethodScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.checkout.presentation

import android.app.Activity
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Payment
import androidx.compose.material3.*
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import com.google.android.gms.wallet.PaymentData
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.rememberCoroutineScope
import kotlinx.coroutines.launch
import kotlinx.coroutines.delay
import com.taskgoapp.taskgo.core.model.PaymentType
import com.taskgoapp.taskgo.core.payment.GooglePayManager
import com.taskgoapp.taskgo.core.theme.*

@Composable
fun PaymentMethodScreen(
    onNavigateBack: () -> Unit,
    onPaymentMethodSelected: (String) -> Unit,
    variant: String? = null, // null=padr√£o, 'two_options'
    price: String = "0.00", // Pre√ßo para Google Pay
    viewModel: CheckoutViewModel
) {
    val context = LocalContext.current
    val activity = context as? Activity
    val googlePayManager = remember { GooglePayManager(context) }
    var googlePayAvailable by remember { mutableStateOf(false) }
    val scope = rememberCoroutineScope()
    
    // Verificar disponibilidade do Google Pay
    LaunchedEffect(Unit) {
        googlePayManager.isReadyToPay().addOnSuccessListener { available ->
            googlePayAvailable = available
        }.addOnFailureListener {
            googlePayAvailable = false
        }
    }
    
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()
    
    val options = if(variant == "two_options") 
        listOf("Cart√£o de Cr√©dito", "Cart√£o de D√©bito") 
    else 
        listOf("Pix", "Cart√£o de Cr√©dito", "Cart√£o de D√©bito")
    
    // Inicializar com o m√©todo j√° selecionado, se houver
    var selected by remember(uiState.selectedPaymentMethod) { 
        mutableStateOf(
            uiState.selectedPaymentMethod?.let {
                when (it.type) {
                    PaymentType.PIX -> "Pix"
                    PaymentType.CREDIT_CARD -> "Cart√£o de Cr√©dito"
                    PaymentType.DEBIT_CARD -> "Cart√£o de D√©bito"
                    else -> options.first()
                }
            } ?: options.first()
        )
    }
    
    // Atualizar sele√ß√£o quando o ViewModel mudar
    LaunchedEffect(uiState.selectedPaymentMethod?.type) {
        uiState.selectedPaymentMethod?.let {
            selected = when (it.type) {
                PaymentType.PIX -> "Pix"
                PaymentType.CREDIT_CARD -> "Cart√£o de Cr√©dito"
                PaymentType.DEBIT_CARD -> "Cart√£o de D√©bito"
                else -> options.first()
            }
        }
    }
    
    Column(Modifier.fillMaxSize().padding(32.dp)) {
        Text("M√©todo de pagamento", style = FigmaSectionTitle, color = TaskGoTextBlack)
        Spacer(Modifier.height(14.dp))
        
        // Google Pay Button (se dispon√≠vel) - Melhorado visualmente
        if (googlePayAvailable && activity != null) {
            Card(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(vertical = 8.dp)
                    .clickable {
                        googlePayManager.loadPaymentData(
                            activity = activity,
                            price = price,
                            currencyCode = "BRL",
                            onSuccess = { paymentData ->
                                try {
                                    val paymentInfo = googlePayManager.extractPaymentInfo(paymentData)
                                    // O token ser√° processado no backend via processGooglePayPayment
                                    onPaymentMethodSelected("Google Pay")
                                } catch (e: Exception) {
                                    // Erro ao processar pagamento
                                }
                            },
                            onError = { exception ->
                                // Tratar erro
                            }
                        )
                    },
                colors = CardDefaults.cardColors(
                    containerColor = Color(0xFF000000) // Preto do Google Pay
                ),
                elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),
                shape = androidx.compose.foundation.shape.RoundedCornerShape(12.dp)
            ) {
                Row(
                    Modifier
                        .fillMaxWidth()
                        .padding(20.dp),
                    horizontalArrangement = Arrangement.Center,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    // Logo do Google Pay (texto estilizado)
                    Text(
                        text = "G",
                        style = MaterialTheme.typography.headlineMedium,
                        color = Color(0xFF4285F4),
                        fontWeight = androidx.compose.ui.text.font.FontWeight.Bold
                    )
                    Text(
                        text = "oogle",
                        style = MaterialTheme.typography.headlineMedium,
                        color = Color(0xFFEA4335),
                        fontWeight = androidx.compose.ui.text.font.FontWeight.Bold
                    )
                    Text(
                        text = " Pay",
                        style = MaterialTheme.typography.headlineMedium,
                        color = Color.White,
                        fontWeight = androidx.compose.ui.text.font.FontWeight.Bold
                    )
                }
            }
            Spacer(Modifier.height(12.dp))
            HorizontalDivider()
            Spacer(Modifier.height(12.dp))
        }
        
        options.forEach { item ->
            Card(modifier = Modifier
                    .fillMaxWidth()
                    .padding(vertical=6.dp)
                    .clickable { selected = item },
                colors= CardDefaults.cardColors(
                    containerColor = if(selected==item) TaskGoGreen.copy(alpha=0.1f) else Color.White)) {
                Row(Modifier.padding(16.dp), verticalAlignment = Alignment.CenterVertically) {
                    RadioButton(
                        selected=selected==item, 
                        onClick={ selected = item }
                    )
                    Text(item, Modifier.weight(1f))
                }
            }
        }
        Spacer(Modifier.height(22.dp))
        Button(
            onClick = {
                // Mapear o m√©todo selecionado para PaymentType e salvar no ViewModel
                val paymentType = when (selected) {
                    "Pix" -> PaymentType.PIX
                    "Cart√£o de Cr√©dito" -> PaymentType.CREDIT_CARD
                    "Cart√£o de D√©bito" -> PaymentType.DEBIT_CARD
                    "Google Pay" -> PaymentType.CREDIT_CARD // Google Pay usa cart√£o de cr√©dito
                    else -> PaymentType.PIX
                }
                
                // Buscar o m√©todo de pagamento correspondente no ViewModel
                val method = uiState.availablePaymentMethods.firstOrNull { 
                    it.type == paymentType && 
                    (paymentType != PaymentType.PIX || it.lastFourDigits == "PIX")
                }
                
                if (method != null) {
                    // M√©todo encontrado, selecionar
                    viewModel.selectPaymentMethod(method)
                } else if (paymentType == PaymentType.PIX) {
                    // Para PIX, sempre criar um m√©todo padr√£o se n√£o existir
                    val pixMethod = com.taskgoapp.taskgo.core.model.PaymentMethod(
                        id = 0L,
                        type = PaymentType.PIX,
                        lastFourDigits = "PIX",
                        cardholderName = "",
                        expiryDate = "",
                        isDefault = false
                    )
                    viewModel.selectPaymentMethod(pixMethod)
                } else {
                    // Para cart√µes, tentar encontrar qualquer cart√£o do tipo
                    val anyCard = uiState.availablePaymentMethods.firstOrNull { it.type == paymentType }
                    anyCard?.let { viewModel.selectPaymentMethod(it) }
                }
                
                // Pequeno delay para garantir que o estado seja atualizado antes de navegar
                scope.launch {
                    delay(100)
                    onPaymentMethodSelected(selected)
                }
            },
            modifier = Modifier.fillMaxWidth()
        ){ Text("Selecionar") }
        OutlinedButton(onClick = onNavigateBack, modifier = Modifier.fillMaxWidth()) { Text("Voltar") }
    }
}

```

## [FRONTEND]: feature/checkout/presentation/PaymentSuccessScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.checkout.presentation

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.CheckCircle
import androidx.compose.material3.Icon
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.core.design.PrimaryButton
import com.taskgoapp.taskgo.core.theme.FigmaSectionTitle
import com.taskgoapp.taskgo.core.theme.FigmaStatusText
import com.taskgoapp.taskgo.core.theme.TaskGoGreen
import com.taskgoapp.taskgo.core.theme.TaskGoPriceDark
import com.taskgoapp.taskgo.core.theme.TaskGoTextGray

@Composable
fun PaymentSuccessScreen(
    totalAmount: Double,
    orderId: String,
    trackingCode: String?,
    onContinue: () -> Unit
) {
    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(horizontal = 24.dp),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Icon(
            imageVector = Icons.Filled.CheckCircle,
            contentDescription = null,
            tint = TaskGoGreen,
            modifier = Modifier.height(96.dp)
        )
        Spacer(modifier = Modifier.height(16.dp))
        Text(
            text = "Pedido confirmado!",
            style = FigmaSectionTitle,
            color = TaskGoPriceDark
        )
        Spacer(modifier = Modifier.height(8.dp))
        Text(
            text = "C√≥digo: $orderId  ‚Ä¢  Total: R$ %.2f".format(totalAmount),
            style = FigmaStatusText,
            color = TaskGoTextGray
        )
        if (!trackingCode.isNullOrBlank()) {
            Spacer(modifier = Modifier.height(8.dp))
            Text(
                text = "Rastreio: $trackingCode",
                style = FigmaStatusText,
                color = TaskGoTextGray
            )
        }
        Spacer(modifier = Modifier.height(32.dp))
        PrimaryButton(
            text = "OK",
            onClick = onContinue,
            modifier = Modifier.fillMaxWidth()
        )
    }
}


```

## [FRONTEND]: feature/checkout/presentation/PixPaymentScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.checkout.presentation

import androidx.compose.foundation.Image
import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.CheckCircle
import androidx.compose.material.icons.filled.ErrorOutline
import androidx.compose.material.icons.filled.HourglassEmpty
import androidx.compose.material.icons.filled.ContentCopy
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.asImageBitmap
import androidx.compose.foundation.background
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.size
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import com.taskgoapp.taskgo.core.theme.*

@Composable
fun PixPaymentScreen(
    orderId: String,
    totalAmount: Double,
    onPaymentSuccess: () -> Unit,
    onBackClick: () -> Unit,
    variant: String? = null, // null=padr√£o, 'waiting', 'error', 'success'
    viewModel: PixPaymentViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()
    
    // Criar pagamento PIX quando a tela carregar
    LaunchedEffect(orderId) {
        if (uiState.pixKey == null && !uiState.isLoading && uiState.error == null) {
            viewModel.createPixPayment(orderId)
        }
    }
    
    Column(
        modifier = Modifier.fillMaxSize().padding(32.dp),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        when(variant) {
            "success" -> {
                Icon(Icons.Default.CheckCircle, null, tint = TaskGoSuccess, modifier = Modifier.size(60.dp))
                Spacer(Modifier.height(14.dp))
                Text("Pagamento aprovado!", style = FigmaTitleLarge, color = TaskGoSuccess)
                Text("Seu pagamento via Pix foi confirmado.", style = FigmaProductDescription, color = TaskGoTextGray, modifier = Modifier.padding(top = 4.dp, bottom = 18.dp))
                Button(onClick = onPaymentSuccess, modifier = Modifier.fillMaxWidth()) { Text("Continuar") }
            }
            "waiting" -> {
                Icon(Icons.Default.HourglassEmpty, null, tint = TaskGoWarning, modifier = Modifier.size(60.dp))
                Spacer(Modifier.height(14.dp))
                Text("Aguardando pagamento...", style = FigmaTitleLarge, color = TaskGoWarning)
                Text("Ap√≥s o pagamento via Pix, a confirma√ß√£o ser√° autom√°tica.", style = FigmaProductDescription, color = TaskGoTextGray, modifier = Modifier.padding(top=4.dp, bottom=18.dp))
            }
            "error" -> {
                Icon(Icons.Default.ErrorOutline, null, tint = TaskGoError, modifier = Modifier.size(60.dp))
                Spacer(Modifier.height(14.dp))
                Text("Pagamento n√£o realizado", style = FigmaTitleLarge, color = TaskGoError)
                Text("N√£o foi poss√≠vel processar o pagamento via Pix. Tente novamente.", style = FigmaProductDescription, color = TaskGoTextGray, modifier = Modifier.padding(top=4.dp, bottom=18.dp))
                Button(onClick = onBackClick, modifier = Modifier.fillMaxWidth()) { Text("Tentar novamente") }
            }
            else -> {
                if (uiState.isLoading) {
                    CircularProgressIndicator()
                    Spacer(Modifier.height(16.dp))
                    Text("Gerando pagamento PIX...", style = FigmaProductDescription, color = TaskGoTextGray)
                } else if (uiState.error != null) {
                    Icon(Icons.Default.ErrorOutline, null, tint = TaskGoError, modifier = Modifier.size(60.dp))
                    Spacer(Modifier.height(14.dp))
                    Text("Erro ao gerar pagamento", style = FigmaTitleLarge, color = TaskGoError)
                    Text(uiState.error ?: "Erro desconhecido", style = FigmaProductDescription, color = TaskGoTextGray, modifier = Modifier.padding(top=4.dp, bottom=18.dp))
                    Button(onClick = { viewModel.createPixPayment(orderId) }, modifier = Modifier.fillMaxWidth()) { Text("Tentar novamente") }
                    OutlinedButton(onClick = onBackClick, modifier = Modifier.fillMaxWidth()) { Text("Cancelar") }
                } else {
                    Text("Pagamento via Pix", style = FigmaSectionTitle, color = TaskGoTextBlack)
                    Spacer(Modifier.height(16.dp))
                    
                    // Mostrar QR Code
                    val qrBitmap = uiState.qrCodeBitmap
                    if (qrBitmap != null) {
                        Image(
                            bitmap = qrBitmap.asImageBitmap(),
                            contentDescription = "QR Code PIX",
                            modifier = Modifier.size(250.dp)
                        )
                    } else {
                        Box(
                            modifier = Modifier.size(250.dp).background(TaskGoSurfaceGrayBg),
                            contentAlignment = Alignment.Center
                        ) {
                            CircularProgressIndicator()
                        }
                    }
                    
                    Spacer(Modifier.height(20.dp))
                    Text("Total: R$ %.2f".format(uiState.amount), style = FigmaPrice, color = TaskGoPriceGreen)
                    Text("Escaneie para pagar ou copie a chave aleat√≥ria Pix:", style = FigmaProductDescription, color = TaskGoTextGray, modifier=Modifier.padding(top=8.dp))
                    
                    // Mostrar chave PIX
                    val pixKey = uiState.pixKey
                    if (pixKey != null) {
                        Card(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(vertical = 8.dp),
                            colors = CardDefaults.cardColors(
                                containerColor = TaskGoSurfaceGrayBg
                            )
                        ) {
                            Row(
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .padding(16.dp),
                                horizontalArrangement = Arrangement.SpaceBetween,
                                verticalAlignment = Alignment.CenterVertically
                            ) {
                                Text(
                                    text = pixKey,
                                    style = FigmaProductDescription,
                                    color = TaskGoTextBlack,
                                    modifier = Modifier.weight(1f)
                                )
                                IconButton(onClick = { viewModel.copyPixKey() }) {
                                    Icon(
                                        imageVector = Icons.Default.ContentCopy,
                                        contentDescription = "Copiar chave",
                                        tint = TaskGoGreen
                                    )
                                }
                            }
                        }
                    }
                    
                    Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
                        Button(
                            onClick = { viewModel.copyPixKey() },
                            modifier = Modifier.weight(1f),
                            enabled = uiState.pixKey != null
                        ) {
                            Icon(Icons.Default.ContentCopy, null, modifier = Modifier.size(18.dp))
                            Spacer(Modifier.width(4.dp))
                            Text("Copiar chave")
                        }
                        OutlinedButton(onClick = onBackClick, modifier = Modifier.weight(1f)) { Text("Cancelar") }
                    }
                }
            }
        }
    }
}

```

## [FRONTEND]: feature/checkout/presentation/PixPaymentViewModel.kt

```kotlin
package com.taskgoapp.taskgo.feature.checkout.presentation

import android.content.ClipData
import android.content.ClipboardManager
import android.content.Context
import android.graphics.Bitmap
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.google.zxing.BarcodeFormat
import com.google.zxing.EncodeHintType
import com.google.zxing.qrcode.QRCodeWriter
import com.taskgoapp.taskgo.data.firebase.FirebaseFunctionsService
import dagger.hilt.android.lifecycle.HiltViewModel
import dagger.hilt.android.qualifiers.ApplicationContext
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.delay
import javax.inject.Inject

data class PixPaymentUiState(
    val isLoading: Boolean = false,
    val error: String? = null,
    val pixKey: String? = null,
    val qrCodeData: String? = null,
    val qrCodeBitmap: Bitmap? = null,
    val amount: Double = 0.0,
    val expiresAt: Long? = null,
    val paymentId: String? = null,
    val isPaymentVerified: Boolean = false,
    val isCheckingPayment: Boolean = false
)

@HiltViewModel
class PixPaymentViewModel @Inject constructor(
    private val functionsService: FirebaseFunctionsService,
    @ApplicationContext private val context: Context
) : ViewModel() {

    private val _uiState = MutableStateFlow(PixPaymentUiState())
    val uiState: StateFlow<PixPaymentUiState> = _uiState.asStateFlow()

    fun createPixPayment(orderId: String) {
        _uiState.value = _uiState.value.copy(isLoading = true, error = null)

        viewModelScope.launch {
            try {
                val result = functionsService.createPixPayment(orderId)
                result.onSuccess { data ->
                    val pixKey = data["pixKey"] as? String
                    val qrCodeData = data["qrCodeData"] as? String
                    val amount = (data["amount"] as? Number)?.toDouble() ?: 0.0
                    val expiresAt = (data["expiresAt"] as? Number)?.toLong()
                    val paymentId = data["paymentId"] as? String

                    // Generate QR code bitmap
                    val qrBitmap = qrCodeData?.let { generateQRCode(it, 512) }

                    _uiState.value = _uiState.value.copy(
                        isLoading = false,
                        pixKey = pixKey,
                        qrCodeData = qrCodeData,
                        qrCodeBitmap = qrBitmap,
                        amount = amount,
                        expiresAt = expiresAt,
                        paymentId = paymentId,
                        error = null
                    )
                    
                    // Start polling for payment verification
                    paymentId?.let { startPaymentPolling(it) }
                }.onFailure { throwable ->
                    _uiState.value = _uiState.value.copy(
                        isLoading = false,
                        error = throwable.message ?: "Erro ao criar pagamento PIX"
                    )
                }
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = e.message ?: "Erro ao criar pagamento PIX"
                )
            }
        }
    }

    fun copyPixKey() {
        val pixKey = _uiState.value.pixKey ?: return
        val clipboard = context.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
        val clip = ClipData.newPlainText("Chave PIX", pixKey)
        clipboard.setPrimaryClip(clip)
    }

    private fun generateQRCode(data: String, size: Int): Bitmap? {
        return try {
            val hints = hashMapOf<EncodeHintType, Any>().apply {
                put(EncodeHintType.CHARACTER_SET, "UTF-8")
                put(EncodeHintType.MARGIN, 1)
            }
            val writer = QRCodeWriter()
            val bitMatrix = writer.encode(data, BarcodeFormat.QR_CODE, size, size, hints)
            val width = bitMatrix.width
            val height = bitMatrix.height
            val bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.RGB_565)
            for (x in 0 until width) {
                for (y in 0 until height) {
                    bitmap.setPixel(x, y, if (bitMatrix[x, y]) android.graphics.Color.BLACK else android.graphics.Color.WHITE)
                }
            }
            bitmap
        } catch (e: Exception) {
            android.util.Log.e("PixPaymentViewModel", "Erro ao gerar QR code: ${e.message}", e)
            null
        }
    }
    
    /**
     * Start polling to verify PIX payment status
     */
    private fun startPaymentPolling(paymentId: String) {
        viewModelScope.launch {
            var attempts = 0
            val maxAttempts = 60 // 5 minutes (60 * 5 seconds)
            
            while (attempts < maxAttempts && !_uiState.value.isPaymentVerified) {
                delay(5000) // Check every 5 seconds
                attempts++
                
                _uiState.value = _uiState.value.copy(isCheckingPayment = true)
                
                val result = functionsService.verifyPixPayment(paymentId)
                result.onSuccess { data ->
                    val status = data["status"] as? String
                    val paid = data["paid"] as? Boolean ?: false
                    
                    if (paid && status == "succeeded") {
                        _uiState.value = _uiState.value.copy(
                            isPaymentVerified = true,
                            isCheckingPayment = false
                        )
                    } else if (status == "expired") {
                        _uiState.value = _uiState.value.copy(
                            error = "Pagamento PIX expirado. Por favor, gere um novo pagamento.",
                            isCheckingPayment = false
                        )
                    } else {
                        _uiState.value = _uiState.value.copy(isCheckingPayment = false)
                    }
                }.onFailure {
                    // Continue polling even if verification fails temporarily
                    _uiState.value = _uiState.value.copy(isCheckingPayment = false)
                }
            }
            
            if (!_uiState.value.isPaymentVerified && attempts >= maxAttempts) {
                _uiState.value = _uiState.value.copy(
                    error = "Tempo de verifica√ß√£o do pagamento expirado. Verifique manualmente.",
                    isCheckingPayment = false
                )
            }
        }
    }
    
    /**
     * Manually verify payment (for testing/admin)
     */
    fun verifyPayment() {
        val paymentId = _uiState.value.paymentId ?: return
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isCheckingPayment = true)
            val result = functionsService.verifyPixPayment(paymentId)
            result.onSuccess { data ->
                val status = data["status"] as? String
                val paid = data["paid"] as? Boolean ?: false
                
                if (paid && status == "succeeded") {
                    _uiState.value = _uiState.value.copy(
                        isPaymentVerified = true,
                        isCheckingPayment = false
                    )
                } else {
                    _uiState.value = _uiState.value.copy(
                        isCheckingPayment = false,
                        error = "Pagamento ainda n√£o confirmado. Status: $status"
                    )
                }
            }.onFailure { throwable ->
                _uiState.value = _uiState.value.copy(
                    isCheckingPayment = false,
                    error = throwable.message ?: "Erro ao verificar pagamento"
                )
            }
        }
    }
}


```

## [FRONTEND]: feature/checkout/presentation/StripePaymentHelperViewModel.kt

```kotlin
package com.taskgoapp.taskgo.feature.checkout.presentation

import android.app.Activity
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.taskgoapp.taskgo.core.payment.StripePaymentManager
import com.taskgoapp.taskgo.data.firebase.FirebaseFunctionsService
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class StripePaymentHelperViewModel @Inject constructor(
    private val functionsService: FirebaseFunctionsService,
    private val stripePaymentManager: StripePaymentManager
) : ViewModel() {
    private val _isInitialized = MutableStateFlow(false)
    val isInitialized: StateFlow<Boolean> = _isInitialized.asStateFlow()
    
    fun initializeStripe(activity: Activity) {
        viewModelScope.launch {
            try {
                val result = functionsService.getStripePublishableKey()
                result.onSuccess { data ->
                    val publishableKey = data["publishableKey"] as? String
                    if (publishableKey != null) {
                        stripePaymentManager.initialize(activity, publishableKey)
                        _isInitialized.value = true
                    }
                }.onFailure {
                    // Handle error
                }
            } catch (e: Exception) {
                // Handle error
            }
        }
    }
    
    suspend fun presentPaymentSheet(
        activity: Activity,
        clientSecret: String
    ): Result<com.stripe.android.paymentsheet.PaymentSheetResult> {
        return stripePaymentManager.presentPaymentSheet(activity, clientSecret)
    }
}


```

# Features - feed


## [FRONTEND]: feature/feed/presentation/components/BlockUserDialog.kt

```kotlin
package com.taskgoapp.taskgo.feature.feed.presentation.components

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.window.Dialog
import com.taskgoapp.taskgo.core.theme.*

/**
 * Dialog de confirma√ß√£o para bloquear um usu√°rio
 */
@Composable
fun BlockUserDialog(
    userName: String,
    onDismiss: () -> Unit,
    onConfirm: () -> Unit
) {
    Dialog(onDismissRequest = onDismiss) {
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            shape = RoundedCornerShape(16.dp),
            colors = CardDefaults.cardColors(
                containerColor = Color.White
            )
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(24.dp),
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                Text(
                    text = "Bloquear Usu√°rio",
                    style = MaterialTheme.typography.titleLarge,
                    fontWeight = FontWeight.Bold,
                    fontSize = 20.sp,
                    color = TaskGoError
                )
                
                Spacer(modifier = Modifier.height(16.dp))
                
                Text(
                    text = "Tem certeza que deseja bloquear $userName?",
                    style = MaterialTheme.typography.bodyLarge,
                    modifier = Modifier.fillMaxWidth()
                )
                
                Spacer(modifier = Modifier.height(8.dp))
                
                Text(
                    text = "Voc√™ n√£o ver√° mais posts deste usu√°rio e ele n√£o poder√° ver seus posts.",
                    style = MaterialTheme.typography.bodyMedium,
                    color = TaskGoTextGray,
                    modifier = Modifier.fillMaxWidth()
                )
                
                Spacer(modifier = Modifier.height(24.dp))
                
                // Bot√µes
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    OutlinedButton(
                        onClick = onDismiss,
                        modifier = Modifier.weight(1f)
                    ) {
                        Text("Cancelar")
                    }
                    
                    Button(
                        onClick = {
                            onConfirm()
                            onDismiss()
                        },
                        modifier = Modifier.weight(1f),
                        colors = ButtonDefaults.buttonColors(
                            containerColor = TaskGoError
                        )
                    ) {
                        Text("Bloquear")
                    }
                }
            }
        }
    }
}

```

## [FRONTEND]: feature/feed/presentation/components/CommentsDialog.kt

```kotlin
package com.taskgoapp.taskgo.feature.feed.presentation.components

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.lazy.rememberLazyListState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Close
import androidx.compose.material.icons.filled.ModeComment
import androidx.compose.material.icons.filled.Send
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalSoftwareKeyboardController
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.foundation.text.KeyboardActions
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.foundation.layout.imePadding
import androidx.compose.foundation.layout.navigationBarsPadding
import androidx.compose.ui.focus.FocusRequester
import androidx.compose.ui.focus.focusRequester
import androidx.hilt.navigation.compose.hiltViewModel
import coil.compose.AsyncImage
import com.taskgoapp.taskgo.core.theme.*
import com.taskgoapp.taskgo.feature.feed.presentation.FeedViewModel
import androidx.compose.runtime.collectAsState
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.launch
import java.text.SimpleDateFormat
import java.util.*

/**
 * Dialog de coment√°rios estilo Instagram com suporte completo a teclado
 * Layout ajusta automaticamente quando o teclado abre
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun CommentsDialog(
    postId: String,
    postUserId: String,
    currentUserId: String?,
    onDismiss: () -> Unit,
    viewModel: FeedViewModel = hiltViewModel(),
    modifier: Modifier = Modifier
) {
    var commentText by remember { mutableStateOf("") }
    var isCreatingComment by remember { mutableStateOf(false) }
    var errorMessage by remember { mutableStateOf<String?>(null) }
    val keyboardController = LocalSoftwareKeyboardController.current
    val scope = rememberCoroutineScope()
    val listState = rememberLazyListState()
    val focusRequester = remember { FocusRequester() }
    
    // Observar coment√°rios em tempo real com tratamento de erro
    val comments by remember(postId) {
        viewModel.observePostComments(postId)
            .catch { e ->
                android.util.Log.e("CommentsDialog", "Erro ao observar coment√°rios: ${e.message}", e)
                emptyList<CommentItem>()
            }
    }.collectAsState(initial = emptyList())
    
    // Handler para criar coment√°rio com feedback completo
    val createCommentHandler = rememberCreateCommentHandler(
        viewModel = viewModel,
        postId = postId,
        comments = comments,
        onStart = {
            isCreatingComment = true
            errorMessage = null
        },
        onSuccess = {
            commentText = ""
            isCreatingComment = false
            keyboardController?.hide()
            // Scroll para o √∫ltimo coment√°rio ap√≥s um delay
            scope.launch {
                kotlinx.coroutines.delay(500) // Aguardar coment√°rio aparecer no Firestore
                if (comments.isNotEmpty()) {
                    try {
                        listState.animateScrollToItem(comments.size - 1)
                    } catch (e: Exception) {
                        // Ignorar erro de scroll se a lista mudou
                    }
                }
            }
        },
        onError = { error ->
            isCreatingComment = false
            errorMessage = error
        }
    )
    
    // Scroll autom√°tico para o √∫ltimo coment√°rio quando novos coment√°rios s√£o adicionados
    LaunchedEffect(comments.size) {
        if (comments.isNotEmpty() && !isCreatingComment) {
            scope.launch {
                try {
                    listState.animateScrollToItem(comments.size - 1)
                } catch (e: Exception) {
                    // Ignorar erro de scroll
                }
            }
        }
    }
    
    // Sheet state para controlar a altura e ajuste ao teclado
    val sheetState = rememberModalBottomSheetState(
        skipPartiallyExpanded = true
    )
    LaunchedEffect(Unit) {
        // Expandir completamente e focar no input ao abrir
        sheetState.expand()
        focusRequester.requestFocus()
    }
    
    ModalBottomSheet(
        onDismissRequest = onDismiss,
        sheetState = sheetState,
        modifier = modifier,
        shape = RoundedCornerShape(topStart = 16.dp, topEnd = 16.dp),
        containerColor = Color.White
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .navigationBarsPadding()
                .imePadding()
        ) {
            // Header (fixo no topo)
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(horizontal = 16.dp, vertical = 12.dp),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = "Coment√°rios",
                    style = MaterialTheme.typography.titleLarge,
                    fontWeight = FontWeight.Bold,
                    color = TaskGoTextBlack
                )
                IconButton(onClick = onDismiss) {
                    Icon(
                        imageVector = Icons.Default.Close,
                        contentDescription = "Fechar",
                        tint = TaskGoTextGray
                    )
                }
            }
            
            HorizontalDivider()
            
            // Lista de coment√°rios (ajusta quando teclado abre)
            if (comments.isEmpty() && !isCreatingComment) {
                // Estado vazio (estilo Instagram)
                Box(
                    modifier = Modifier
                        .fillMaxWidth()
                        .weight(1f, fill = false),
                    contentAlignment = Alignment.Center
                ) {
                    Column(
                        horizontalAlignment = Alignment.CenterHorizontally,
                        verticalArrangement = Arrangement.spacedBy(16.dp),
                        modifier = Modifier.padding(horizontal = 32.dp, vertical = 48.dp)
                    ) {
                        // √çcone de coment√°rios
                        Icon(
                            imageVector = Icons.Default.ModeComment,
                            contentDescription = null,
                            modifier = Modifier.size(64.dp),
                            tint = TaskGoTextGray.copy(alpha = 0.5f)
                        )
                        Text(
                            text = "Bora come√ßar",
                            style = MaterialTheme.typography.titleMedium,
                            fontWeight = FontWeight.Bold,
                            color = TaskGoTextBlack
                        )
                        Text(
                            text = "Deixe um coment√°rio para que outras pessoas tamb√©m participem.",
                            style = MaterialTheme.typography.bodyMedium,
                            color = TaskGoTextGray,
                            textAlign = TextAlign.Center
                        )
                    }
                }
            } else {
                LazyColumn(
                    state = listState,
                    modifier = Modifier
                        .fillMaxWidth()
                        .weight(1f, fill = false),
                    contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp),
                    verticalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    items(comments, key = { it.id }) { comment ->
                        CommentItem(
                            comment = comment,
                            isOwnComment = comment.userId == currentUserId
                        )
                    }
                    
                    // Indicador de loading ao criar coment√°rio
                    if (isCreatingComment) {
                        item {
                            Row(
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .padding(vertical = 8.dp),
                                horizontalArrangement = Arrangement.spacedBy(12.dp),
                                verticalAlignment = Alignment.CenterVertically
                            ) {
                                CircularProgressIndicator(
                                    modifier = Modifier.size(16.dp),
                                    color = TaskGoGreen,
                                    strokeWidth = 2.dp
                                )
                                Text(
                                    text = "Enviando coment√°rio...",
                                    style = MaterialTheme.typography.bodySmall,
                                    color = TaskGoTextGray,
                                    fontSize = 12.sp
                                )
                            }
                        }
                    }
                }
            }
            
            // Mensagem de erro
            errorMessage?.let { error ->
                Text(
                    text = error,
                    color = MaterialTheme.colorScheme.error,
                    style = MaterialTheme.typography.bodySmall,
                    modifier = Modifier.padding(horizontal = 16.dp, vertical = 4.dp)
                )
            }
            
            HorizontalDivider()
            
            // Input de coment√°rio (fixo na parte inferior, ajusta quando teclado abre)
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(horizontal = 16.dp, vertical = 8.dp),
                horizontalArrangement = Arrangement.spacedBy(8.dp),
                verticalAlignment = Alignment.CenterVertically
            ) {
                // Avatar do usu√°rio (se dispon√≠vel)
                currentUserId?.let {
                    AsyncImage(
                        model = null, // TODO: Buscar avatar do usu√°rio atual
                        contentDescription = "Seu avatar",
                        modifier = Modifier
                            .size(36.dp)
                            .clip(CircleShape),
                        contentScale = ContentScale.Crop
                    )
                }
                
                OutlinedTextField(
                    value = commentText,
                    onValueChange = { 
                        if (it.length <= 500) {
                            commentText = it
                            errorMessage = null // Limpar erro ao digitar
                        }
                    },
                    modifier = Modifier
                        .weight(1f)
                        .focusRequester(focusRequester),
                    placeholder = {
                        Text(
                            text = "Comente como Voc√™",
                            color = TaskGoTextGray
                        )
                    },
                    maxLines = 3,
                    singleLine = false,
                    enabled = !isCreatingComment,
                    keyboardOptions = KeyboardOptions(imeAction = ImeAction.Send),
                    keyboardActions = KeyboardActions(
                        onSend = {
                            if (commentText.isNotBlank() && !isCreatingComment) {
                                createCommentHandler(commentText.trim())
                            }
                        }
                    ),
                    colors = OutlinedTextFieldDefaults.colors(
                        focusedBorderColor = TaskGoGreen,
                        unfocusedBorderColor = TaskGoTextGray.copy(alpha = 0.5f),
                        cursorColor = TaskGoGreen,
                        focusedContainerColor = Color.Transparent,
                        unfocusedContainerColor = Color.Transparent
                    ),
                    shape = RoundedCornerShape(24.dp)
                )
                IconButton(
                    onClick = {
                        if (commentText.isNotBlank() && !isCreatingComment) {
                            createCommentHandler(commentText.trim())
                        }
                    },
                    enabled = commentText.isNotBlank() && !isCreatingComment,
                    modifier = Modifier
                        .size(48.dp)
                        .background(
                            if (commentText.isNotBlank() && !isCreatingComment) TaskGoGreen else TaskGoTextGray.copy(alpha = 0.3f),
                            CircleShape
                        )
                ) {
                    if (isCreatingComment) {
                        CircularProgressIndicator(
                            modifier = Modifier.size(20.dp),
                            color = Color.White,
                            strokeWidth = 2.dp
                        )
                    } else {
                        Icon(
                            imageVector = Icons.Default.Send,
                            contentDescription = "Enviar coment√°rio",
                            tint = Color.White,
                            modifier = Modifier.size(24.dp)
                        )
                    }
                }
            }
        }
    }
}

/**
 * Fun√ß√£o auxiliar para criar coment√°rio com tratamento completo de erros
 */
@Composable
private fun rememberCreateCommentHandler(
    viewModel: FeedViewModel,
    postId: String,
    comments: List<CommentItem>,
    onStart: () -> Unit,
    onSuccess: () -> Unit,
    onError: (String) -> Unit
): (String) -> Unit {
    val uiState by viewModel.uiState.collectAsState()
    val scope = rememberCoroutineScope()
    var pendingCommentText by remember { mutableStateOf<String?>(null) }
    val currentUserIdFromViewModel = viewModel.currentUserId
    
    // Observar mudan√ßas no estado de erro
    LaunchedEffect(uiState.error) {
        uiState.error?.let { error ->
            if (error.contains("coment√°rio", ignoreCase = true) && pendingCommentText != null) {
                onError(error)
                pendingCommentText = null
            }
        }
    }
    
    // Observar quando novo coment√°rio aparece na lista
    LaunchedEffect(comments) {
        if (pendingCommentText != null && currentUserIdFromViewModel != null) {
            // Verificar se o coment√°rio apareceu na lista
            // Procurar por coment√°rio com mesmo texto e mesmo userId
            val matchingComment = comments.find { 
                it.text == pendingCommentText && 
                it.userId == currentUserIdFromViewModel
            }
            
            if (matchingComment != null) {
                android.util.Log.d("CommentsDialog", "Coment√°rio detectado na lista: ${matchingComment.id}")
                onSuccess()
                pendingCommentText = null
            }
        }
    }
    
    return { text ->
        onStart()
        pendingCommentText = text
        
        scope.launch {
            try {
                android.util.Log.d("CommentsDialog", "Criando coment√°rio: $text")
                
                // Criar coment√°rio aguardando resultado imediato
                when (val result = viewModel.createCommentAwait(postId, text)) {
                    is com.taskgoapp.taskgo.core.model.Result.Success -> {
                        // Feedback otimista; sucesso final confirmado ao aparecer no listener
                        onSuccess()
                        pendingCommentText = null
                    }
                    is com.taskgoapp.taskgo.core.model.Result.Error -> {
                        val msg = result.exception.message ?: "Erro ao criar coment√°rio"
                        android.util.Log.e("CommentsDialog", "Erro ao criar coment√°rio: $msg", result.exception)
                        onError(msg)
                        pendingCommentText = null
                    }
                    else -> {
                        // Loading n√£o deve ocorrer aqui; tratar como erro gen√©rico
                        onError("Erro ao criar coment√°rio. Tente novamente.")
                        pendingCommentText = null
                    }
                }
            } catch (e: Exception) {
                android.util.Log.e("CommentsDialog", "Erro ao criar coment√°rio: ${e.message}", e)
                onError("Erro ao criar coment√°rio. Tente novamente.")
                pendingCommentText = null
            }
        }
    }
}

/**
 * Item de coment√°rio individual
 */
@Composable
private fun CommentItem(
    comment: CommentItem,
    isOwnComment: Boolean,
    modifier: Modifier = Modifier
) {
    Row(
        modifier = modifier.fillMaxWidth(),
        horizontalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        // Avatar
        AsyncImage(
            model = comment.userAvatarUrl ?: "",
            contentDescription = comment.userName,
            modifier = Modifier
                .size(40.dp)
                .clip(CircleShape),
            contentScale = ContentScale.Crop
        )
        
        Column(modifier = Modifier.weight(1f)) {
            // Nome e texto do coment√°rio
            Row(
                horizontalArrangement = Arrangement.spacedBy(8.dp),
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = comment.userName,
                    style = MaterialTheme.typography.bodyMedium,
                    fontWeight = FontWeight.Bold,
                    color = TaskGoTextBlack,
                    fontSize = 14.sp
                )
                Text(
                    text = comment.text,
                    style = MaterialTheme.typography.bodyMedium,
                    color = TaskGoTextBlack,
                    fontSize = 14.sp
                )
            }
            
            Spacer(modifier = Modifier.height(4.dp))
            
            // Timestamp e a√ß√µes
            Row(
                horizontalArrangement = Arrangement.spacedBy(12.dp),
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = formatCommentDate(comment.createdAt),
                    style = MaterialTheme.typography.bodySmall,
                    color = TaskGoTextGray,
                    fontSize = 12.sp
                )
                // Bot√£o de curtir coment√°rio (opcional)
                TextButton(
                    onClick = { /* TODO: Implementar curtir coment√°rio */ },
                    contentPadding = PaddingValues(horizontal = 8.dp, vertical = 4.dp),
                    modifier = Modifier.height(24.dp)
                ) {
                    Text(
                        text = if (comment.isLiked) "Descurtir" else "Curtir",
                        style = MaterialTheme.typography.bodySmall,
                        color = TaskGoTextGray,
                        fontSize = 12.sp
                    )
                }
            }
        }
    }
}

/**
 * Data model para coment√°rio
 */
data class CommentItem(
    val id: String,
    val postId: String,
    val userId: String,
    val userName: String,
    val userAvatarUrl: String?,
    val text: String,
    val createdAt: Date,
    val isLiked: Boolean = false,
    val likesCount: Int = 0
)

private fun formatCommentDate(date: Date?): String {
    if (date == null) return ""
    
    val now = Date()
    val diff = now.time - date.time
    val seconds = diff / 1000
    val minutes = seconds / 60
    val hours = minutes / 60
    val days = hours / 24
    
    return when {
        seconds < 60 -> "agora"
        minutes < 60 -> "h√° ${minutes}min"
        hours < 24 -> "h√° ${hours}h"
        days < 7 -> "h√° ${days}d"
        else -> {
            val format = SimpleDateFormat("dd/MM/yyyy", Locale("pt", "BR"))
            format.format(date)
        }
    }
}

```

## [FRONTEND]: feature/feed/presentation/components/CreatePostBottomSheet.kt

```kotlin
package com.taskgoapp.taskgo.feature.feed.presentation.components

import android.net.Uri
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.PickVisualMediaRequest
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.lazy.itemsIndexed
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Close
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import coil.compose.AsyncImage
import com.taskgoapp.taskgo.core.design.ImageEditor
import com.taskgoapp.taskgo.core.permissions.PermissionHandler
import com.taskgoapp.taskgo.core.permissions.rememberImageReadPermissionLauncher
import com.taskgoapp.taskgo.core.theme.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun CreatePostBottomSheet(
    onDismiss: () -> Unit,
    onPostCreated: (String, List<Uri>) -> Unit,
    modifier: Modifier = Modifier
) {
    var postText by remember { mutableStateOf("") }
    var selectedMediaUris by remember { mutableStateOf<List<Uri>>(emptyList()) }
    val context = LocalContext.current
    val maxMediaCount = 10
    
    // Verificar permiss√£o reativamente
    val hasImagePermission by remember {
        derivedStateOf {
            PermissionHandler.hasImageReadPermission(context)
        }
    }
    
    // Launcher para sele√ß√£o m√∫ltipla de m√≠dias
    val mediaLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.PickMultipleVisualMedia(maxItems = maxMediaCount)
    ) { uris: List<Uri> ->
        val currentMedia = selectedMediaUris.toMutableList()
        val availableSlots = maxMediaCount - currentMedia.size
        val newMedia = currentMedia + uris.take(availableSlots)
        selectedMediaUris = newMedia.take(maxMediaCount)
    }
    
    val imagePermissionLauncher = rememberImageReadPermissionLauncher(
        onPermissionGranted = {
            mediaLauncher.launch(PickVisualMediaRequest(ActivityResultContracts.PickVisualMedia.ImageAndVideo))
        },
        onPermissionDenied = {
            // Permiss√£o negada
        }
    )
    
    ModalBottomSheet(
        onDismissRequest = onDismiss,
        modifier = modifier,
        shape = RoundedCornerShape(topStart = 16.dp, topEnd = 16.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // Header
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = "Criar Post",
                    style = MaterialTheme.typography.titleLarge,
                    fontWeight = androidx.compose.ui.text.font.FontWeight.Bold,
                    color = TaskGoTextBlack
                )
                IconButton(onClick = onDismiss) {
                    Icon(
                        imageVector = Icons.Default.Close,
                        contentDescription = "Fechar",
                        tint = TaskGoTextGray
                    )
                }
            }
            
            // Campo de texto
            OutlinedTextField(
                value = postText,
                onValueChange = { 
                    if (it.length <= 2000) { // Limite de 2000 caracteres
                        postText = it
                    }
                },
                modifier = Modifier
                    .fillMaxWidth()
                    .heightIn(min = 120.dp, max = 300.dp),
                placeholder = {
                    Text(
                        text = "O que voc√™ est√° pensando?",
                        color = TaskGoTextGray
                    )
                },
                maxLines = 10,
                colors = OutlinedTextFieldDefaults.colors(
                    focusedBorderColor = TaskGoGreen,
                    unfocusedBorderColor = TaskGoTextGray
                ),
                shape = RoundedCornerShape(8.dp)
            )
            
            Text(
                text = "${postText.length}/2000",
                style = MaterialTheme.typography.bodySmall,
                color = TaskGoTextGray,
                modifier = Modifier.align(Alignment.End)
            )
            
            // Preview de m√≠dias selecionadas
            if (selectedMediaUris.isNotEmpty()) {
                LazyRow(
                    horizontalArrangement = Arrangement.spacedBy(8.dp),
                    modifier = Modifier.fillMaxWidth()
                ) {
                    itemsIndexed(selectedMediaUris) { index, uri ->
                        Box(
                            modifier = Modifier
                                .size(100.dp)
                                .clip(RoundedCornerShape(8.dp))
                        ) {
                            AsyncImage(
                                model = uri,
                                contentDescription = "M√≠dia ${index + 1}",
                                modifier = Modifier.fillMaxSize(),
                                contentScale = ContentScale.Crop
                            )
                            
                            // Bot√£o remover
                            IconButton(
                                onClick = {
                                    selectedMediaUris = selectedMediaUris.toMutableList().apply {
                                        removeAt(index)
                                    }
                                },
                                modifier = Modifier
                                    .align(Alignment.TopEnd)
                                    .size(32.dp)
                            ) {
                                Icon(
                                    imageVector = Icons.Default.Close,
                                    contentDescription = "Remover",
                                    tint = MaterialTheme.colorScheme.error,
                                    modifier = Modifier.size(20.dp)
                                )
                            }
                        }
                    }
                }
            }
            
            // Bot√£o adicionar m√≠dia
            if (selectedMediaUris.size < maxMediaCount) {
                OutlinedButton(
                    onClick = {
                        if (hasImagePermission) {
                            mediaLauncher.launch(PickVisualMediaRequest(ActivityResultContracts.PickVisualMedia.ImageAndVideo))
                        } else {
                            imagePermissionLauncher.launch(PermissionHandler.getImageReadPermission())
                        }
                    },
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Icon(
                        imageVector = Icons.Default.Add,
                        contentDescription = null,
                        modifier = Modifier.size(20.dp)
                    )
                    Spacer(modifier = Modifier.width(8.dp))
                    Text("Adicionar Fotos/V√≠deos (${selectedMediaUris.size}/$maxMediaCount)")
                }
            }
            
            // Bot√£o publicar
            Button(
                onClick = {
                    if (postText.isNotBlank() || selectedMediaUris.isNotEmpty()) {
                        onPostCreated(postText, selectedMediaUris)
                    }
                },
                modifier = Modifier.fillMaxWidth(),
                enabled = postText.isNotBlank() || selectedMediaUris.isNotEmpty(),
                colors = ButtonDefaults.buttonColors(
                    containerColor = TaskGoGreen,
                    disabledContainerColor = TaskGoTextGray.copy(alpha = 0.3f)
                ),
                shape = RoundedCornerShape(8.dp)
            ) {
                Text(
                    text = "Publicar",
                    style = MaterialTheme.typography.labelLarge,
                    color = TaskGoBackgroundWhite
                )
            }
        }
    }
}

```

## [FRONTEND]: feature/feed/presentation/components/CreateStoryScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.feed.presentation.components

import android.net.Uri
import android.os.Build
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.gestures.detectDragGestures
import androidx.compose.foundation.gestures.detectTapGestures
import androidx.compose.foundation.gestures.detectTransformGestures
import androidx.compose.material.icons.filled.Delete
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.lazy.grid.items
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Close
import androidx.compose.material.icons.filled.Photo
import androidx.compose.material.icons.filled.TextFields
import androidx.compose.material.icons.filled.MusicNote
import androidx.compose.material.icons.filled.Palette
import androidx.compose.material.icons.filled.ArrowForward
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.window.Dialog
import androidx.compose.ui.window.DialogProperties
import androidx.core.content.FileProvider
import androidx.hilt.navigation.compose.hiltViewModel
import coil.compose.AsyncImage
import kotlinx.coroutines.launch
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.derivedStateOf
import com.taskgoapp.taskgo.core.permissions.PermissionHandler
import com.taskgoapp.taskgo.core.permissions.rememberImageReadPermissionLauncher
import com.taskgoapp.taskgo.core.permissions.rememberCameraPermissionLauncher
import com.taskgoapp.taskgo.feature.feed.presentation.StoriesViewModel
import androidx.activity.result.PickVisualMediaRequest
import androidx.compose.foundation.text.KeyboardActions
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.ui.text.TextRange
import androidx.compose.ui.text.input.TextFieldValue
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.material3.TextField
import androidx.compose.material3.TextFieldDefaults
import androidx.compose.ui.draw.alpha
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.focus.FocusRequester
import androidx.compose.ui.focus.focusRequester

/**
 * Data class para representar um overlay de texto/emoji sobre a imagem
 */
data class TextOverlay(
    val id: String,
    val text: String,
    val x: Float,
    val y: Float,
    val scale: Float = 1f,
    val color: Color = Color.White,
    val fontSize: Float = 24f
)

/**
 * Tela de cria√ß√£o de Story id√™ntica ao Instagram
 * Fluxo simplificado em 2 p√°ginas:
 * 1. C√¢mera/Galeria (captura ou sele√ß√£o de m√≠dia)
 * 2. Edi√ß√£o (texto sobre imagem, stickers, m√∫sica, filtros, compartilhamento)
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun CreateStoryScreen(
    onDismiss: () -> Unit,
    onStoryCreated: () -> Unit,
    viewModel: StoriesViewModel = hiltViewModel()
) {
    // Estados principais
    var selectedMediaUri by remember { mutableStateOf<Uri?>(null) }
    var isEditingMode by remember { mutableStateOf(false) }
    
    // Estados para texto sobre a imagem
    var textOverlays by remember { mutableStateOf<List<TextOverlay>>(emptyList()) }
    var activeTextOverlayId by remember { mutableStateOf<String?>(null) }
    
    // Estados para ferramentas
    var showEmojiPicker by remember { mutableStateOf(false) }
    var showMusicPicker by remember { mutableStateOf(false) }
    var showFiltersPicker by remember { mutableStateOf(false) }
    var showStickerMenu by remember { mutableStateOf(false) }
    
    // Estado para input de texto direto sobre a imagem
    var isTextInputActive by remember { mutableStateOf(false) }
    var currentTextInput by remember { mutableStateOf("") }
    var currentTextInputPosition by remember { mutableStateOf<Pair<Float, Float>?>(null) }
    
    val context = LocalContext.current
    val scope = rememberCoroutineScope()
    val uiState by viewModel.uiState.collectAsState()
    
    // Verificar permiss√µes
    val hasImagePermission by remember {
        derivedStateOf {
        PermissionHandler.hasImageReadPermission(context)
        }
    }
    
    val hasCameraPermission by remember {
        derivedStateOf {
            PermissionHandler.hasCameraPermission(context)
        }
    }
    
    // Declarar mediaLauncher ANTES de imagePermissionLauncher para evitar refer√™ncia n√£o resolvida
    val mediaLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.PickVisualMedia()
    ) { uri: Uri? ->
        uri?.let {
            selectedMediaUri = it
            isEditingMode = true
        }
    }
    
    val imagePermissionLauncher = rememberImageReadPermissionLauncher(
        onPermissionGranted = {
            // Ap√≥s permiss√£o concedida, abrir galeria automaticamente
            mediaLauncher.launch(
                PickVisualMediaRequest(ActivityResultContracts.PickVisualMedia.ImageAndVideo)
            )
        },
        onPermissionDenied = {
            android.util.Log.w("CreateStoryScreen", "Permiss√£o de acesso √† galeria negada")
        }
    )
    
    val cameraPermissionLauncher = com.taskgoapp.taskgo.core.permissions.rememberCameraPermissionLauncher(
        onPermissionGranted = {
            // Ap√≥s permiss√£o concedida, a c√¢mera customizada ser√° mostrada automaticamente
            android.util.Log.d("CreateStoryScreen", "Permiss√£o de c√¢mera concedida")
        },
        onPermissionDenied = {
            android.util.Log.w("CreateStoryScreen", "Permiss√£o de c√¢mera negada")
        }
    )
    
    // Handler para quando foto √© capturada pela c√¢mera customizada
    val onPhotoCaptured: (Uri) -> Unit = { uri ->
        android.util.Log.d("CreateStoryScreen", "Foto capturada pela c√¢mera customizada: $uri")
        selectedMediaUri = uri
        isEditingMode = true
    }
    
    // Solicitar permiss√£o de c√¢mera quando o Dialog aparecer (se necess√°rio)
    LaunchedEffect(Unit) {
        if (!hasCameraPermission) {
            android.util.Log.d("CreateStoryScreen", "Solicitando permiss√£o de c√¢mera")
            cameraPermissionLauncher.launch(android.Manifest.permission.CAMERA)
        }
    }
    
    Dialog(
        onDismissRequest = onDismiss,
        properties = DialogProperties(
            usePlatformDefaultWidth = false,
            dismissOnBackPress = true,
            dismissOnClickOutside = false
        )
    ) {
        Box(
            modifier = Modifier
                .fillMaxSize()
                .background(Color.Black)
        ) {
            when {
                // P√ÅGINA 1: C√¢mera customizada (estilo Instagram) - abre diretamente
                !isEditingMode && selectedMediaUri == null -> {
                    if (hasCameraPermission) {
                        // Mostrar c√¢mera customizada diretamente
                        CustomCameraView(
                            onPhotoCaptured = onPhotoCaptured,
                            onDismiss = onDismiss,
                            onGalleryClick = {
                                // Abrir galeria quando o bot√£o for clicado
                                if (hasImagePermission) {
                                    mediaLauncher.launch(
                                        PickVisualMediaRequest(ActivityResultContracts.PickVisualMedia.ImageAndVideo)
                                    )
                                } else {
                                    imagePermissionLauncher.launch(PermissionHandler.getImageReadPermission())
                                }
                            },
                            modifier = Modifier.fillMaxSize()
                        )
                    } else {
                        // Se n√£o tem permiss√£o, mostrar op√ß√£o de galeria ou solicitar permiss√£o
                        CameraGalleryPage(
                            onCameraClick = {
                                // Solicitar permiss√£o de c√¢mera
                                cameraPermissionLauncher.launch(android.Manifest.permission.CAMERA)
                            },
                            onGalleryClick = {
                                if (hasImagePermission) {
                                    mediaLauncher.launch(
                                        PickVisualMediaRequest(ActivityResultContracts.PickVisualMedia.ImageAndVideo)
                                    )
                                } else {
                                    imagePermissionLauncher.launch(PermissionHandler.getImageReadPermission())
                                }
                            },
                            onClose = onDismiss
                        )
                    }
                }
                
                // P√ÅGINA 2: Edi√ß√£o
                selectedMediaUri != null -> {
                    EditingPage(
                        mediaUri = selectedMediaUri!!,
                        textOverlays = textOverlays,
                        activeTextOverlayId = activeTextOverlayId,
                        onTextOverlayAdded = { text ->
                            val newOverlay = TextOverlay(
                                id = System.currentTimeMillis().toString(),
                                text = text,
                                x = 0.5f,
                                y = 0.5f
                            )
                            textOverlays = textOverlays + newOverlay
                            activeTextOverlayId = newOverlay.id
                        },
                        onTextOverlayUpdated = { id, x, y ->
                            textOverlays = textOverlays.map { overlay ->
                                if (overlay.id == id) overlay.copy(x = x, y = y) else overlay
                            }
                        },
                        onTextOverlayDeleted = { id ->
                            textOverlays = textOverlays.filter { it.id != id }
                            if (activeTextOverlayId == id) {
                                activeTextOverlayId = null
                            }
                        },
                        onTextOverlayTapped = { id ->
                            activeTextOverlayId = if (activeTextOverlayId == id) null else id
                        },
                        onTextOverlayScaleChanged = { id, scale ->
                            textOverlays = textOverlays.map { overlay ->
                                if (overlay.id == id) overlay.copy(scale = scale) else overlay
                            }
                        },
                        onTextOverlayFontSizeChanged = { id, fontSize ->
                            textOverlays = textOverlays.map { overlay ->
                                if (overlay.id == id) overlay.copy(fontSize = fontSize) else overlay
                            }
                        },
                        onShowTextInput = {
                            isTextInputActive = true
                            currentTextInputPosition = Pair(0.5f, 0.5f)
                        },
                        onShowEmojiPicker = { 
                            showEmojiPicker = true
                            showStickerMenu = true
                        },
                        onShowMusicPicker = { showMusicPicker = true },
                        onShowFiltersPicker = { showFiltersPicker = true },
                        onBack = {
                            isEditingMode = false
                            textOverlays = emptyList()
                            activeTextOverlayId = null
                        },
                        onShare = { caption ->
                            scope.launch {
                                try {
                                    android.util.Log.d("CreateStoryScreen", "=== INICIANDO CRIA√á√ÉO DE STORY ===")
                                    val mediaUri = selectedMediaUri
                                    android.util.Log.d("CreateStoryScreen", "URI selecionada: $mediaUri")
                                    
                                    if (mediaUri == null) {
                                        android.util.Log.e("CreateStoryScreen", "ERRO: selectedMediaUri √© null!")
                                        return@launch
                                    }
                                    
                                    val mediaType = try {
                                        val mimeType = context.contentResolver.getType(mediaUri) ?: "image/jpeg"
                                        val detectedType = if (mimeType.startsWith("video/")) "video" else "image"
                                        android.util.Log.d("CreateStoryScreen", "MIME type: $mimeType, Tipo detectado: $detectedType")
                                        detectedType
                                    } catch (e: Exception) {
                                        android.util.Log.w("CreateStoryScreen", "Erro ao detectar tipo de m√≠dia: ${e.message}", e)
                                        "image"
                                    }
                                    
                                    android.util.Log.d("CreateStoryScreen", "Chamando viewModel.createStory com mediaType=$mediaType, caption=null")
                                    
                                    val result = viewModel.createStory(
                                        mediaUri = mediaUri,
                                        mediaType = mediaType,
                                        caption = null // Sempre null - texto √© escrito em cima da foto
                                    )
                                    
                                    android.util.Log.d("CreateStoryScreen", "Resultado recebido: $result")
                                    
                                    when (result) {
                                        is com.taskgoapp.taskgo.core.model.Result.Success -> {
                                            android.util.Log.d("CreateStoryScreen", "‚úÖ Story criada com sucesso! ID: ${result.data}")
                                            // Recarregar stories para garantir que a nova story apare√ßa
                                            viewModel.loadStories()
                                            onStoryCreated()
                                            onDismiss()
                                        }
                                        is com.taskgoapp.taskgo.core.model.Result.Error -> {
                                            android.util.Log.e("CreateStoryScreen", "‚ùå Erro ao criar story: ${result.exception.message}", result.exception)
                                            android.util.Log.e("CreateStoryScreen", "Stack trace:", result.exception)
                                            // Erro ser√° mostrado no UI state do ViewModel
                                        }
                                        else -> {
                                            android.util.Log.w("CreateStoryScreen", "‚ö†Ô∏è Resultado desconhecido ao criar story: $result")
                                        }
                                    }
                                } catch (e: Exception) {
                                    android.util.Log.e("CreateStoryScreen", "‚ùå Exce√ß√£o ao criar story: ${e.message}", e)
                                    android.util.Log.e("CreateStoryScreen", "Stack trace completo:", e)
                                }
                            }
                        },
                        isLoading = uiState.isLoading,
                        isTextInputActive = isTextInputActive,
                        currentTextInput = currentTextInput,
                        onTextInputChanged = { currentTextInput = it },
                        onTextInputConfirmed = {
                            if (currentTextInput.isNotBlank()) {
                                val newOverlay = TextOverlay(
                                    id = System.currentTimeMillis().toString(),
                                    text = currentTextInput,
                                    x = currentTextInputPosition?.first ?: 0.5f,
                                    y = currentTextInputPosition?.second ?: 0.5f
                                )
                                textOverlays = textOverlays + newOverlay
                                activeTextOverlayId = newOverlay.id
                            }
                            isTextInputActive = false
                            currentTextInput = ""
                            currentTextInputPosition = null
                        },
                        onTextInputDismissed = {
                            isTextInputActive = false
                            currentTextInput = ""
                            currentTextInputPosition = null
                        },
                        textInputPosition = currentTextInputPosition
                    )
                }
            }
        }
    }
    
    // Dialogs
    if (showEmojiPicker) {
        EmojiPickerDialog(
            onEmojiSelected = { emoji ->
                val newOverlay = TextOverlay(
                    id = System.currentTimeMillis().toString(),
                    text = emoji,
                    x = 0.5f,
                    y = 0.5f
                )
                textOverlays = textOverlays + newOverlay
                activeTextOverlayId = newOverlay.id
                showEmojiPicker = false
            },
            onDismiss = { showEmojiPicker = false }
        )
    }
    
    if (showMusicPicker) {
        MusicPickerDialog(
            onDismiss = { showMusicPicker = false }
        )
    }
    
    if (showFiltersPicker) {
        FiltersPickerDialog(
            onDismiss = { showFiltersPicker = false }
        )
    }
}

/**
 * P√°gina 1: C√¢mera/Galeria
 */
@Composable
private fun CameraGalleryPage(
    onCameraClick: () -> Unit,
    onGalleryClick: () -> Unit,
    onClose: () -> Unit
) {
    Box(
        modifier = Modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        // Bot√£o X (topo esquerdo)
        IconButton(
            onClick = onClose,
            modifier = Modifier
                .align(Alignment.TopStart)
                .padding(16.dp)
                .size(40.dp)
                .background(Color.Black.copy(alpha = 0.5f), CircleShape)
        ) {
            Icon(
                imageVector = Icons.Default.Close,
                contentDescription = "Fechar",
                tint = Color.White,
                modifier = Modifier.size(24.dp)
            )
        }
        
        // Bot√£o Galeria (topo direito)
        IconButton(
            onClick = onGalleryClick,
            modifier = Modifier
                .align(Alignment.TopEnd)
                .padding(16.dp)
                .size(40.dp)
                .background(Color.Black.copy(alpha = 0.5f), CircleShape)
        ) {
            Icon(
                imageVector = Icons.Default.Photo,
                contentDescription = "Galeria",
                tint = Color.White,
                modifier = Modifier.size(24.dp)
            )
        }
        
        // Bot√£o C√¢mera (centro)
        Button(
            onClick = onCameraClick,
            modifier = Modifier
                .size(80.dp)
                .align(Alignment.BottomCenter)
                .padding(bottom = 32.dp),
            shape = CircleShape,
            colors = ButtonDefaults.buttonColors(
                containerColor = Color.White
            )
        ) {
            Box(
                modifier = Modifier
                    .size(70.dp)
                    .background(Color.White, CircleShape)
                    .padding(4.dp)
                    .background(Color.Black, CircleShape)
            )
        }
    }
}

/**
 * P√°gina 2: Edi√ß√£o
 */
@Composable
private fun EditingPage(
    mediaUri: Uri,
    textOverlays: List<TextOverlay>,
    activeTextOverlayId: String?,
    onTextOverlayAdded: (String) -> Unit,
    onTextOverlayUpdated: (String, Float, Float) -> Unit,
    onTextOverlayDeleted: (String) -> Unit,
    onTextOverlayTapped: (String) -> Unit,
    onTextOverlayScaleChanged: (String, Float) -> Unit,
    onTextOverlayFontSizeChanged: (String, Float) -> Unit,
    onShowTextInput: () -> Unit,
    onShowEmojiPicker: () -> Unit,
    onShowMusicPicker: () -> Unit,
    onShowFiltersPicker: () -> Unit,
    onBack: () -> Unit,
    onShare: (String) -> Unit,
    isLoading: Boolean,
    isTextInputActive: Boolean,
    currentTextInput: String,
    onTextInputChanged: (String) -> Unit,
    onTextInputConfirmed: () -> Unit,
    onTextInputDismissed: () -> Unit,
    textInputPosition: Pair<Float, Float>?
) {
    // Caption removido - texto √© escrito diretamente em cima da foto
    val focusRequester = remember { androidx.compose.ui.focus.FocusRequester() }
    
    LaunchedEffect(isTextInputActive) {
        if (isTextInputActive) {
            focusRequester.requestFocus()
        }
    }
    
    Box(
        modifier = Modifier.fillMaxSize()
    ) {
        // Preview da m√≠dia (full-screen)
        AsyncImage(
            model = mediaUri,
            contentDescription = null,
            modifier = Modifier.fillMaxSize(),
            contentScale = ContentScale.Crop
        )
        
        // Overlay preto semi-transparente
        Box(
            modifier = Modifier
                .fillMaxSize()
                .background(Color.Black.copy(alpha = 0.1f))
        )
        
        // Textos sobre a imagem
        TextOverlaysRenderer(
            overlays = textOverlays,
            activeTextOverlayId = activeTextOverlayId,
            onTextOverlayTapped = onTextOverlayTapped,
            onTextOverlayUpdated = onTextOverlayUpdated,
            onTextOverlayScaleChanged = onTextOverlayScaleChanged,
            onTextOverlayFontSizeChanged = onTextOverlayFontSizeChanged,
            onTextOverlayDeleted = onTextOverlayDeleted
        )
        
        // Controles de tamanho de fonte quando um overlay est√° ativo (estilo Instagram)
        activeTextOverlayId?.let { activeId ->
            val activeOverlay = textOverlays.find { it.id == activeId }
            activeOverlay?.let { overlay ->
                // Controles na parte inferior da tela
                Box(
                    modifier = Modifier
                        .align(Alignment.BottomCenter)
                        .padding(bottom = 100.dp) // Acima do bottom bar
                ) {
                    Row(
                        modifier = Modifier
                            .background(
                                Color.Black.copy(alpha = 0.7f),
                                RoundedCornerShape(24.dp)
                            )
                            .padding(horizontal = 16.dp, vertical = 8.dp),
                        horizontalArrangement = Arrangement.spacedBy(16.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        // Bot√£o diminuir tamanho
                        IconButton(
                            onClick = {
                                val newSize = (overlay.fontSize - 4f).coerceAtLeast(12f)
                                onTextOverlayFontSizeChanged(overlay.id, newSize)
                            },
                            modifier = Modifier.size(36.dp)
                        ) {
                            Text(
                                text = "A-",
                                color = Color.White,
                                fontSize = 18.sp,
                                fontWeight = FontWeight.Bold
                            )
                        }
                        
                        // Tamanho atual
                        Text(
                            text = "${overlay.fontSize.toInt()}",
                            color = Color.White,
                            fontSize = 14.sp,
                            fontWeight = FontWeight.Medium,
                            modifier = Modifier.width(30.dp)
                        )
                        
                        // Bot√£o aumentar tamanho
                        IconButton(
                            onClick = {
                                val newSize = (overlay.fontSize + 4f).coerceAtMost(72f)
                                onTextOverlayFontSizeChanged(overlay.id, newSize)
                            },
                            modifier = Modifier.size(36.dp)
                        ) {
                            Text(
                                text = "A+",
                                color = Color.White,
                                fontSize = 18.sp,
                                fontWeight = FontWeight.Bold
                            )
                        }
                    }
                }
            }
        }
        
        // Input de texto direto sobre a imagem (estilo Instagram)
        if (isTextInputActive && textInputPosition != null) {
            val density = LocalDensity.current
            BoxWithConstraints(
                modifier = Modifier.fillMaxSize()
            ) {
                Box(
                    modifier = Modifier
                        .align(Alignment.Center)
                        .offset(
                            x = with(density) { ((textInputPosition.first - 0.5f) * maxWidth.value).toDp() },
                            y = with(density) { ((textInputPosition.second - 0.5f) * maxHeight.value).toDp() }
                        )
                        .widthIn(max = maxWidth * 0.8f)
                ) {
                    TextField(
                        value = currentTextInput,
                        onValueChange = onTextInputChanged,
                        modifier = Modifier
                            .focusRequester(focusRequester)
                            .background(Color.Transparent),
                        textStyle = androidx.compose.ui.text.TextStyle(
                            color = Color.White,
                            fontSize = 24.sp,
                            fontWeight = FontWeight.Bold,
                            textAlign = TextAlign.Center
                        ),
                        colors = TextFieldDefaults.colors(
                            focusedTextColor = Color.White,
                            unfocusedTextColor = Color.White,
                            focusedContainerColor = Color.Transparent,
                            unfocusedContainerColor = Color.Transparent,
                            focusedIndicatorColor = Color.Transparent,
                            unfocusedIndicatorColor = Color.Transparent,
                            cursorColor = Color.White
                        ),
                        keyboardOptions = KeyboardOptions(
                            keyboardType = androidx.compose.ui.text.input.KeyboardType.Text,
                            imeAction = androidx.compose.ui.text.input.ImeAction.Done
                        ),
                        keyboardActions = KeyboardActions(
                            onDone = {
                                if (currentTextInput.isNotBlank()) {
                                    onTextInputConfirmed()
                                } else {
                                    onTextInputDismissed()
                                }
                            }
                        ),
                        singleLine = false,
                        maxLines = 5
                    )
                }
            }
        }
        
        // TOP BAR
        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(16.dp),
            horizontalArrangement = Arrangement.SpaceBetween
        ) {
            // Bot√£o voltar
            IconButton(
                onClick = onBack,
                modifier = Modifier
                    .size(40.dp)
                    .background(Color.Black.copy(alpha = 0.5f), CircleShape)
            ) {
                Icon(
                    imageVector = Icons.Default.Close,
                    contentDescription = "Voltar",
                    tint = Color.White,
                    modifier = Modifier.size(24.dp)
                )
            }
            
            // Bot√£o Galeria
            IconButton(
                onClick = { /* Abrir galeria novamente */ },
                modifier = Modifier
                    .size(40.dp)
                    .background(Color.Black.copy(alpha = 0.5f), CircleShape)
            ) {
                Icon(
                    imageVector = Icons.Default.Photo,
                    contentDescription = "Galeria",
                    tint = Color.White,
                    modifier = Modifier.size(24.dp)
                )
            }
        }
        
        // SIDE BAR - Ferramentas (direita)
        Column(
            modifier = Modifier
                .align(Alignment.CenterEnd)
                .padding(end = 16.dp),
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            // Texto (Aa)
            IconButton(
                onClick = onShowTextInput,
                modifier = Modifier
                    .size(48.dp)
                    .background(Color.Black.copy(alpha = 0.5f), CircleShape)
            ) {
                Icon(
                    imageVector = Icons.Default.TextFields,
                    contentDescription = "Texto",
                    tint = Color.White,
                    modifier = Modifier.size(24.dp)
                )
            }
            
            // Stickers (emoji)
            IconButton(
                onClick = onShowEmojiPicker,
                modifier = Modifier
                    .size(48.dp)
                    .background(Color.Black.copy(alpha = 0.5f), CircleShape)
            ) {
                Text(
                    text = "üòä",
                    fontSize = 24.sp
                )
            }
            
            // M√∫sica
            IconButton(
                onClick = onShowMusicPicker,
                modifier = Modifier
                    .size(48.dp)
                    .background(Color.Black.copy(alpha = 0.5f), CircleShape)
            ) {
                Icon(
                    imageVector = Icons.Default.MusicNote,
                    contentDescription = "M√∫sica",
                    tint = Color.White,
                    modifier = Modifier.size(24.dp)
                )
            }
            
            // Filtros
            IconButton(
                onClick = onShowFiltersPicker,
                modifier = Modifier
                    .size(48.dp)
                    .background(Color.Black.copy(alpha = 0.5f), CircleShape)
            ) {
                Icon(
                    imageVector = Icons.Default.Palette,
                    contentDescription = "Filtros",
                    tint = Color.White,
                    modifier = Modifier.size(24.dp)
                )
            }
        }
        
        // BOTTOM BAR - Compartilhamento (sem campo de legenda - texto √© escrito em cima da foto)
        Column(
            modifier = Modifier
                .align(Alignment.BottomCenter)
                .fillMaxWidth()
                .background(
                    Color.Black.copy(alpha = 0.7f),
                    RoundedCornerShape(topStart = 16.dp, topEnd = 16.dp)
                )
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            // Bot√£o compartilhar
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Button(
                    onClick = { onShare("") }, // Sem legenda - texto √© escrito em cima da foto
                    modifier = Modifier
                        .weight(1f)
                        .height(48.dp),
                    enabled = !isLoading,
                    colors = ButtonDefaults.buttonColors(
                        containerColor = Color.White.copy(alpha = 0.2f)
                    ),
                    shape = RoundedCornerShape(24.dp)
                ) {
                    if (isLoading) {
                                CircularProgressIndicator(
                                    modifier = Modifier.size(20.dp),
                                    color = Color.White
                                )
                            } else {
                        Text(
                            text = "Seus stories",
                            color = Color.White,
                            fontSize = 14.sp,
                            fontWeight = FontWeight.Medium
                        )
                    }
                }
                
                IconButton(
                    onClick = { onShare("") }, // Sem legenda - texto √© escrito em cima da foto
                    modifier = Modifier
                        .size(48.dp)
                        .background(Color.White.copy(alpha = 0.2f), CircleShape),
                    enabled = !isLoading
                ) {
                    Icon(
                        imageVector = Icons.Default.ArrowForward,
                        contentDescription = "Compartilhar",
                        tint = Color.White,
                        modifier = Modifier.size(24.dp)
                    )
                }
            }
        }
    }
}

/**
 * Renderizador de overlays de texto
 */
@Composable
private fun TextOverlaysRenderer(
    overlays: List<TextOverlay>,
    activeTextOverlayId: String?,
    onTextOverlayTapped: (String) -> Unit,
    onTextOverlayUpdated: (String, Float, Float) -> Unit,
    onTextOverlayScaleChanged: (String, Float) -> Unit,
    onTextOverlayFontSizeChanged: (String, Float) -> Unit,
    onTextOverlayDeleted: (String) -> Unit
) {
    overlays.forEach { overlay ->
        key(overlay.id) {
            TextOverlayItem(
                overlay = overlay,
                isActive = overlay.id == activeTextOverlayId,
                onTap = { onTextOverlayTapped(overlay.id) },
                onDrag = { x, y -> onTextOverlayUpdated(overlay.id, x, y) },
                onScaleChanged = { scale -> onTextOverlayScaleChanged(overlay.id, scale) },
                onFontSizeChanged = { fontSize -> onTextOverlayFontSizeChanged(overlay.id, fontSize) },
                onDelete = { onTextOverlayDeleted(overlay.id) }
            )
        }
    }
}

/**
 * Item de texto/emoji sobre a imagem (estilo Instagram)
 * Suporta: drag, pinch-to-zoom, drag-to-delete com √≠cone de lixeira
 */
@Composable
private fun TextOverlayItem(
    overlay: TextOverlay,
    isActive: Boolean,
    onTap: () -> Unit,
    onDrag: (Float, Float) -> Unit,
    onScaleChanged: (Float) -> Unit,
    onFontSizeChanged: (Float) -> Unit,
    onDelete: () -> Unit
) {
    var offsetX by remember(overlay.x) { mutableStateOf<Float>(overlay.x) }
    var offsetY by remember(overlay.y) { mutableStateOf<Float>(overlay.y) }
    var currentScale by remember(overlay.scale) { mutableStateOf<Float>(overlay.scale) }
    var dragToDeleteProgress by remember { mutableStateOf(0f) } // 0f = normal, 1f = sobre lixeira
    val density = LocalDensity.current
    
    BoxWithConstraints(
        modifier = Modifier.fillMaxSize()
    ) {
        val maxWidth = maxWidth
        val maxHeight = maxHeight
        val trashIconY = maxHeight.value * 0.9f // Posi√ß√£o da lixeira (90% da altura)
        
        Box(
            modifier = Modifier
                .fillMaxSize()
                .pointerInput(overlay.id, isActive, maxHeight.value) {
                    if (isActive) {
                        // Usar detectTransformGestures primeiro (prioridade para pinch-to-zoom)
                        detectTransformGestures(
                            onGesture = { centroid, pan, zoom, rotation ->
                                // Se √© um gesto de zoom (pinch), atualizar escala
                                if (zoom != 1f) {
                                    val newScale = (currentScale * zoom).coerceIn(0.5f, 3f)
                                    currentScale = newScale
                                    onScaleChanged(newScale)
                                    // Resetar drag-to-delete durante pinch
                                    dragToDeleteProgress = 0f
                                }
                                // Se h√° pan durante transform, mover o objeto
                                if (pan.x != 0f || pan.y != 0f) {
                                    val newX = (offsetX + pan.x / size.width.toFloat()).coerceIn(0f, 1f)
                                    val newY = (offsetY + pan.y / size.height.toFloat()).coerceIn(0f, 1f)
                                    offsetX = newX
                                    offsetY = newY
                                    onDrag(offsetX, offsetY)
                                    // Resetar drag-to-delete durante pinch
                                    dragToDeleteProgress = 0f
                                }
                            }
                        )
                        
                        // Drag simples para mover e deletar (apenas com 1 dedo)
                        detectDragGestures(
                            onDragStart = { 
                                dragToDeleteProgress = 0f
                            },
                            onDrag = { change, dragAmount ->
                                change.consume()
                                
                                // Calcular nova posi√ß√£o primeiro
                                val newX = (offsetX + dragAmount.x / size.width.toFloat()).coerceIn(0f, 1f)
                                val newY = (offsetY + dragAmount.y / size.height.toFloat()).coerceIn(0f, 1f)
                                
                                // Calcular posi√ß√£o absoluta na tela AP√ìS aplicar o drag
                                val absoluteYAfterDrag = newY * size.height
                                val deleteZoneHeight = size.height * 0.10f // 10% da altura como zona de delete (√°rea da lixeira)
                                val deleteZoneTop = trashIconY - deleteZoneHeight
                                val deleteZoneBottom = trashIconY + deleteZoneHeight
                                
                                // Verificar se a posi√ß√£o AP√ìS o drag est√° dentro da zona de delete (√°rea inferior onde fica a lixeira)
                                val isInDeleteZone = absoluteYAfterDrag >= deleteZoneTop && absoluteYAfterDrag <= deleteZoneBottom
                                
                                if (isInDeleteZone) {
                                    // Dentro da zona de delete - calcular progresso baseado na dist√¢ncia do centro da lixeira
                                    val distanceFromTrashCenter = kotlin.math.abs(absoluteYAfterDrag - trashIconY)
                                    dragToDeleteProgress = (1f - (distanceFromTrashCenter / deleteZoneHeight).coerceIn(0f, 1f))
                                } else {
                                    // Fora da zona de delete - resetar progresso
                                    dragToDeleteProgress = 0f
                                }
                                
                                // Atualizar posi√ß√£o durante o drag
                                offsetX = newX
                                offsetY = newY
                                onDrag(offsetX, offsetY)
                            },
                            onDragEnd = {
                                // Deletar APENAS se estava claramente sobre a lixeira (na zona de delete) ao soltar
                                if (dragToDeleteProgress >= 0.8f) {
                                    onDelete()
                                }
                                // Resetar estado ap√≥s o drag
                                    dragToDeleteProgress = 0f
                                }
                        )
                    } else {
                        detectTapGestures {
                            onTap()
                        }
                    }
                }
        ) {
            // √çcone de lixeira (aparece quando arrasta para baixo)
            if (isActive && dragToDeleteProgress > 0.1f) {
                Box(
                    modifier = Modifier
                        .align(Alignment.BottomCenter)
                        .offset(y = (-16).dp)
                        .alpha(dragToDeleteProgress)
                ) {
                    Icon(
                        imageVector = Icons.Default.Delete,
                        contentDescription = "Arraste para excluir",
                        tint = Color.White,
                        modifier = Modifier
                            .size(48.dp)
                            .background(
                                if (dragToDeleteProgress > 0.8f) Color.Red else Color.Black.copy(alpha = 0.7f),
                                CircleShape
                            )
                            .padding(12.dp)
                    )
                }
            }
            
            // Texto/emoji posicionado
            Box(
                modifier = Modifier
                    .align(Alignment.Center)
                    .offset(
                        x = with(density) { ((offsetX - 0.5f) * maxWidth.value).toDp() },
                        y = with(density) { ((offsetY - 0.5f) * maxHeight.value).toDp() }
                    )
                    .graphicsLayer {
                        scaleX = currentScale
                        scaleY = currentScale
                        alpha = if (dragToDeleteProgress > 0.1f) 1f - dragToDeleteProgress * 0.5f else 1f
                    }
                    .background(
                        if (isActive) Color.Black.copy(alpha = 0.2f) else Color.Transparent,
                        RoundedCornerShape(4.dp)
                    )
                    .padding(8.dp)
                    .clickable { onTap() }
            ) {
                Text(
                    text = overlay.text,
                    color = overlay.color,
                    fontSize = (overlay.fontSize * currentScale).sp,
                    fontWeight = FontWeight.Bold,
                    textAlign = TextAlign.Center
                )
            }
        }
    }
}

/**
 * Dialog para adicionar texto
 */
@Composable
private fun TextEditorDialog(
    onTextAdded: (String) -> Unit,
    onDismiss: () -> Unit
) {
    var text by remember { mutableStateOf("") }
    
    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Adicionar Texto") },
        text = {
            OutlinedTextField(
                value = text,
                onValueChange = { if (it.length <= 100) text = it },
                modifier = Modifier.fillMaxWidth(),
                label = { Text("Digite o texto") },
                maxLines = 3,
                placeholder = { Text("Digite aqui...") },
                keyboardOptions = KeyboardOptions(
                    keyboardType = androidx.compose.ui.text.input.KeyboardType.Text
                ),
                keyboardActions = KeyboardActions(
                    onDone = {
                        if (text.isNotBlank()) {
                            onTextAdded(text)
                        }
                    }
                )
            )
        },
        confirmButton = {
            TextButton(
                onClick = {
                    if (text.isNotBlank()) {
                        onTextAdded(text)
                    }
                },
                enabled = text.isNotBlank()
            ) {
                Text("Adicionar")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Cancelar")
            }
        }
    )
}

/**
 * Dialog para selecionar emojis (design profissional)
 */
@Composable
private fun EmojiPickerDialog(
    onEmojiSelected: (String) -> Unit,
    onDismiss: () -> Unit
) {
    val emojiCategories = remember {
        mapOf(
            "Faces" to listOf("üòÄ", "üòÉ", "üòÑ", "üòÅ", "üòÜ", "üòÖ", "üòÇ", "ü§£", "üòä", "üòá", "üôÇ", "üôÉ", "üòâ", "üòå", "üòç", "ü•∞", "üòò", "üòó", "üòô", "üòö", "üòã", "üòõ", "üòù", "üòú", "ü§™", "ü§®", "üßê", "ü§ì", "üòé", "ü§©", "ü•≥", "üòè"),
            "Cora√ß√µes" to listOf("‚ù§Ô∏è", "üß°", "üíõ", "üíö", "üíô", "üíú", "üñ§", "ü§ç", "ü§é", "üíî", "‚ù£Ô∏è", "üíï", "üíû", "üíì", "üíó", "üíñ", "üíò", "üíù", "üíü"),
            "M√£os" to listOf("üëç", "üëé", "üëä", "‚úä", "ü§õ", "ü§ú", "ü§û", "‚úåÔ∏è", "ü§ü", "ü§ò", "üëå", "ü§å", "ü§è", "üëà", "üëâ", "üëÜ", "üëá", "‚òùÔ∏è", "üëã", "ü§ö", "üñêÔ∏è", "‚úã", "üññ", "üëè", "üôå", "ü§≤", "ü§ù", "üôè"),
            "Objetos" to listOf("üì±", "üíª", "‚åö", "üì∑", "üìπ", "üé•", "üì∫", "üìª", "üéôÔ∏è", "üéöÔ∏è", "üéõÔ∏è", "‚è±Ô∏è", "‚è≤Ô∏è", "‚è∞", "üï∞Ô∏è", "‚åõ", "‚è≥", "üì°", "üîã", "üîå", "üí°", "üî¶", "üïØÔ∏è", "üßØ", "üõ¢Ô∏è", "üí∏", "üíµ", "üí¥", "üí∂", "üí∑", "üí∞", "üí≥", "üíé", "‚öñÔ∏è", "üõ†Ô∏è", "üîß", "üî®", "‚öíÔ∏è", "üõ†Ô∏è", "‚õèÔ∏è", "üî©", "‚öôÔ∏è", "üß∞", "üß≤", "üî´", "üí£", "üß®", "üî™", "üó°Ô∏è", "‚öîÔ∏è", "üõ°Ô∏è", "üö¨", "‚ö∞Ô∏è", "‚ö±Ô∏è", "üè∫", "üîÆ", "üìø", "üßø", "üíà", "‚öóÔ∏è", "üî≠", "üî¨", "üï≥Ô∏è", "ü©π", "ü©∫", "üíä", "üíâ", "ü©∏", "üß¨", "ü¶†", "üß´", "üß™", "üå°Ô∏è", "üßπ", "ü™†", "üß∫", "üßª", "üöΩ", "üöø", "üõÅ", "üõÄ", "üßº", "ü™•", "ü™í", "üßΩ", "ü™£", "üß¥", "üõéÔ∏è", "üîë", "üóùÔ∏è", "üö™", "ü™ë", "üõãÔ∏è", "üõèÔ∏è", "üõå", "üß∏", "ü™Ü", "üñºÔ∏è", "ü™û", "ü™ü", "üõçÔ∏è", "üõí", "üéÅ", "üéà", "üéâ", "üéä", "üéÄ", "üéóÔ∏è", "üèÜ", "ü•á", "ü•à", "ü•â", "‚öΩ", "‚öæ", "ü•é", "üèÄ", "üèê", "üèà", "ü•è", "üéæ", "üèâ", "ü•ç", "üèì", "üè∏", "üèí", "üèë", "ü•å", "‚õ≥", "üèπ", "üé£", "ü§ø", "ü•ä", "ü•ã", "üéΩ", "üõπ", "üõ∑", "‚õ∏Ô∏è", "ü•å", "üéø", "‚õ∑Ô∏è", "üèÇ", "ü™Ç", "üèãÔ∏è", "ü§º", "ü§∏", "ü§∫", "‚õπÔ∏è", "ü§π", "üßò", "üèÑ", "üèä", "ü§Ω", "üö£", "üßó", "üöµ", "üö¥", "üèá", "ü§æ", "üèåÔ∏è", "üèá", "üßò", "üèÑ", "üèä", "ü§Ω", "üö£", "üßó", "üöµ", "üö¥", "üèá", "ü§æ", "üèåÔ∏è")
        )
    }
    
    var selectedCategory by remember { mutableStateOf("Faces") }
    
    AlertDialog(
        onDismissRequest = onDismiss,
        title = {
            Text(
                text = "Selecionar Emoji",
                fontWeight = FontWeight.Bold,
                fontSize = 18.sp
            )
        },
        text = {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .height(400.dp)
            ) {
                // Categorias
                LazyRow(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(bottom = 16.dp),
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    items(emojiCategories.keys.toList()) { category ->
                        FilterChip(
                            selected = selectedCategory == category,
                            onClick = { selectedCategory = category },
                            label = { Text(category, fontSize = 12.sp) }
                        )
                    }
                }
                
                // Grid de emojis
                LazyVerticalGrid(
                    columns = GridCells.Fixed(8),
                    modifier = Modifier.fillMaxSize(),
                    horizontalArrangement = Arrangement.spacedBy(4.dp),
                    verticalArrangement = Arrangement.spacedBy(4.dp),
                    contentPadding = PaddingValues(8.dp)
                ) {
                    items(emojiCategories[selectedCategory] ?: emptyList()) { emoji ->
                        Box(
                            modifier = Modifier
                                .size(40.dp)
                                .clickable { onEmojiSelected(emoji) }
                                .background(
                                    Color.Transparent,
                                    RoundedCornerShape(8.dp)
                                ),
                            contentAlignment = Alignment.Center
                        ) {
                            Text(
                                text = emoji,
                                fontSize = 28.sp
                            )
                        }
                    }
                }
            }
        },
        confirmButton = {
            TextButton(onClick = onDismiss) {
                Text("Fechar")
            }
        }
    )
}

/**
 * Dialog placeholder para m√∫sica
 */
@Composable
private fun MusicPickerDialog(
    onDismiss: () -> Unit
) {
    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("M√∫sica") },
        text = {
            Text(
                "A sele√ß√£o de m√∫sica ser√° implementada em breve."
            )
        },
        confirmButton = {
            TextButton(onClick = onDismiss) {
                Text("OK")
            }
        }
    )
}

/**
 * Dialog placeholder para filtros
 */
@Composable
private fun FiltersPickerDialog(
    onDismiss: () -> Unit
) {
    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Filtros") },
        text = {
            Text(
                "A sele√ß√£o de filtros ser√° implementada em breve."
            )
        },
        confirmButton = {
            TextButton(onClick = onDismiss) {
                Text("OK")
            }
        }
    )
}

```

## [FRONTEND]: feature/feed/presentation/components/CustomCameraView.kt

```kotlin
package com.taskgoapp.taskgo.feature.feed.presentation.components

import android.net.Uri
import androidx.camera.core.*
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.camera.view.PreviewView
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Close
import androidx.compose.material.icons.filled.FlipCameraAndroid
import androidx.compose.material.icons.filled.Photo
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalLifecycleOwner
import androidx.compose.ui.unit.dp
import androidx.compose.ui.viewinterop.AndroidView
import androidx.core.content.ContextCompat
import java.io.File
import java.text.SimpleDateFormat
import java.util.*
import kotlin.coroutines.resume
import kotlin.coroutines.suspendCoroutine

/**
 * Componente de c√¢mera customizada usando CameraX
 * Similar ao Instagram: c√¢mera pr√≥pria do app, n√£o a c√¢mera nativa
 */
@Composable
fun CustomCameraView(
    onPhotoCaptured: (Uri) -> Unit,
    onDismiss: () -> Unit,
    onGalleryClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    val context = LocalContext.current
    
    var imageCapture: ImageCapture? by remember { mutableStateOf(null) }
    var cameraProvider: ProcessCameraProvider? by remember { mutableStateOf(null) }
    var lensFacing by remember { mutableStateOf(CameraSelector.LENS_FACING_BACK) }
    var isCapturing by remember { mutableStateOf(false) }
    
    // Inicializar CameraX
    LaunchedEffect(Unit) {
        cameraProvider = getCameraProvider(context)
    }
    
    Box(
        modifier = modifier.fillMaxSize()
    ) {
        // Preview da c√¢mera
        cameraProvider?.let { provider ->
            CameraPreview(
                cameraProvider = provider,
                lensFacing = lensFacing,
                onImageCaptureReady = { imageCapture = it },
                modifier = Modifier.fillMaxSize()
            )
        }
        
        // Overlay preto semi-transparente (estilo Instagram)
        Box(
            modifier = Modifier
                .fillMaxSize()
                .background(Color.Black.copy(alpha = 0.1f))
        )
        
        // Top bar
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            // Bot√£o fechar (esquerda) - X de fechar
            IconButton(
                onClick = onDismiss,
                modifier = Modifier
                    .size(48.dp)
                    .background(
                        Color.Black.copy(alpha = 0.5f),
                        CircleShape
                    )
            ) {
                Icon(
                    imageVector = Icons.Default.Close,
                    contentDescription = "Fechar",
                    tint = Color.White,
                    modifier = Modifier.size(24.dp)
                )
            }
            
            // Bot√£o galeria (direita) - similar ao Instagram
            IconButton(
                onClick = onGalleryClick,
                modifier = Modifier
                    .size(48.dp)
                    .background(
                        Color.Black.copy(alpha = 0.5f),
                        CircleShape
                    )
            ) {
                Icon(
                    imageVector = Icons.Default.Photo,
                    contentDescription = "Abrir galeria",
                    tint = Color.White,
                    modifier = Modifier.size(24.dp)
                )
            }
        }
        
        // Bot√£o trocar c√¢mera (frente/tr√°s) - posicionado no topo direito, abaixo do bot√£o de galeria
        IconButton(
            onClick = {
                lensFacing = if (lensFacing == CameraSelector.LENS_FACING_BACK) {
                    CameraSelector.LENS_FACING_FRONT
                } else {
                    CameraSelector.LENS_FACING_BACK
                }
            },
            modifier = Modifier
                .align(Alignment.TopEnd)
                .padding(top = 72.dp, end = 16.dp)
                .size(48.dp)
                .background(
                    Color.Black.copy(alpha = 0.5f),
                    CircleShape
                )
        ) {
            Icon(
                imageVector = Icons.Default.FlipCameraAndroid,
                contentDescription = "Trocar c√¢mera",
                tint = Color.White,
                modifier = Modifier.size(24.dp)
            )
        }
        
        // Bottom bar - Bot√£o de captura
        Column(
            modifier = Modifier
                .align(Alignment.BottomCenter)
                .fillMaxWidth()
                .padding(bottom = 32.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            // Bot√£o de captura (estilo Instagram)
            Button(
                onClick = {
                    if (!isCapturing && imageCapture != null) {
                        isCapturing = true
                        capturePhoto(
                            context = context,
                            imageCapture = imageCapture!!,
                            onPhotoCaptured = { uri ->
                                isCapturing = false
                                onPhotoCaptured(uri)
                            },
                            onError = {
                                isCapturing = false
                            }
                        )
                    }
                },
                modifier = Modifier
                    .size(80.dp),
                shape = CircleShape,
                colors = ButtonDefaults.buttonColors(
                    containerColor = Color.White,
                    disabledContainerColor = Color.Gray
                ),
                enabled = !isCapturing && imageCapture != null
            ) {
                Box(
                    modifier = Modifier
                        .size(70.dp)
                        .background(Color.White, CircleShape)
                        .padding(4.dp)
                        .background(Color.Black, CircleShape)
                )
            }
        }
    }
}

/**
 * Preview da c√¢mera usando CameraX PreviewView
 */
@Composable
private fun CameraPreview(
    cameraProvider: ProcessCameraProvider,
    lensFacing: Int,
    onImageCaptureReady: (ImageCapture) -> Unit,
    modifier: Modifier = Modifier
) {
    val lifecycleOwner = LocalLifecycleOwner.current
    val context = LocalContext.current
    
    AndroidView(
        factory = { ctx ->
            val previewView = PreviewView(ctx)
            val executor = ContextCompat.getMainExecutor(ctx)
            
            val preview = Preview.Builder().build().also {
                it.setSurfaceProvider(previewView.surfaceProvider)
            }
            
            val imageCapture = ImageCapture.Builder()
                .setCaptureMode(ImageCapture.CAPTURE_MODE_MINIMIZE_LATENCY)
                .build()
            
            val cameraSelector = CameraSelector.Builder()
                .requireLensFacing(lensFacing)
                .build()
            
            try {
                cameraProvider.unbindAll()
                cameraProvider.bindToLifecycle(
                    lifecycleOwner,
                    cameraSelector,
                    preview,
                    imageCapture
                )
                onImageCaptureReady(imageCapture)
            } catch (e: Exception) {
                android.util.Log.e("CustomCameraView", "Erro ao inicializar c√¢mera: ${e.message}", e)
            }
            
            previewView
        },
        modifier = modifier
    )
}

/**
 * Captura uma foto usando ImageCapture
 */
private fun capturePhoto(
    context: android.content.Context,
    imageCapture: ImageCapture,
    onPhotoCaptured: (Uri) -> Unit,
    onError: () -> Unit
) {
    // Criar arquivo para salvar a foto
    val photoFile = File(
        context.cacheDir,
        "story_${SimpleDateFormat("yyyyMMdd_HHmmss", Locale.US).format(Date())}.jpg"
    )
    
    val outputFileOptions = ImageCapture.OutputFileOptions.Builder(photoFile).build()
    
    imageCapture.takePicture(
        outputFileOptions,
        ContextCompat.getMainExecutor(context),
        object : ImageCapture.OnImageSavedCallback {
            override fun onImageSaved(output: ImageCapture.OutputFileResults) {
                val savedUri = android.net.Uri.fromFile(photoFile)
                android.util.Log.d("CustomCameraView", "Foto capturada: $savedUri")
                onPhotoCaptured(savedUri)
            }
            
            override fun onError(exception: ImageCaptureException) {
                android.util.Log.e("CustomCameraView", "Erro ao capturar foto: ${exception.message}", exception)
                onError()
            }
        }
    )
}

/**
 * Obt√©m o ProcessCameraProvider
 */
private suspend fun getCameraProvider(context: android.content.Context): ProcessCameraProvider =
    suspendCoroutine { continuation ->
        val cameraProviderFuture = ProcessCameraProvider.getInstance(context)
        cameraProviderFuture.addListener(
            {
                try {
                    continuation.resume(cameraProviderFuture.get())
                } catch (e: Exception) {
                    android.util.Log.e("CustomCameraView", "Erro ao obter camera provider: ${e.message}", e)
                    continuation.resume(cameraProviderFuture.get())
                }
            },
            ContextCompat.getMainExecutor(context)
        )
    }


```

## [FRONTEND]: feature/feed/presentation/components/InlinePostCreator.kt

```kotlin
package com.taskgoapp.taskgo.feature.feed.presentation.components

import android.net.Uri
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.PickVisualMediaRequest
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.lazy.itemsIndexed
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import coil.compose.AsyncImage
import coil.compose.SubcomposeAsyncImage
import coil.compose.SubcomposeAsyncImageContent
import coil.request.ImageRequest
import com.taskgoapp.taskgo.core.permissions.PermissionHandler
import com.taskgoapp.taskgo.core.permissions.rememberImageReadPermissionLauncher
import com.taskgoapp.taskgo.core.theme.*

/**
 * Campo de cria√ß√£o de post inline (similar ao Facebook)
 */
@Composable
fun InlinePostCreator(
    userAvatarUrl: String?,
    userName: String,
    isLoading: Boolean = false,
    onPostCreated: (String, List<Uri>) -> Unit,
    modifier: Modifier = Modifier
) {
    var postText by remember { mutableStateOf("") }
    var selectedMediaUris by remember { mutableStateOf<List<Uri>>(emptyList()) }
    val context = androidx.compose.ui.platform.LocalContext.current
    val maxMediaCount = 10
    
    // Verificar permiss√£o reativamente usando derivedStateOf para reagir a mudan√ßas
    val hasImagePermission by remember {
        derivedStateOf {
            PermissionHandler.hasImageReadPermission(context)
        }
    }
    
    // Launcher para sele√ß√£o m√∫ltipla de m√≠dias
    val mediaLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.PickMultipleVisualMedia(maxItems = maxMediaCount)
    ) { uris: List<Uri> ->
        val currentMedia = selectedMediaUris.toMutableList()
        val availableSlots = maxMediaCount - currentMedia.size
        val newMedia = currentMedia + uris.take(availableSlots)
        selectedMediaUris = newMedia
    }
    
    val imagePermissionLauncher = rememberImageReadPermissionLauncher(
        onPermissionGranted = {
            mediaLauncher.launch(PickVisualMediaRequest(ActivityResultContracts.PickVisualMedia.ImageAndVideo))
        }
    )
    
    Card(
        modifier = modifier.fillMaxWidth(),
        shape = RoundedCornerShape(12.dp),
        colors = CardDefaults.cardColors(containerColor = TaskGoBackgroundWhite)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(12.dp),
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            // Linha superior: Avatar + Campo de texto
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(12.dp),
                verticalAlignment = Alignment.CenterVertically
            ) {
                // Avatar do usu√°rio
                SubcomposeAsyncImage(
                    model = ImageRequest.Builder(context)
                        .data(userAvatarUrl)
                        .crossfade(true)
                        .build(),
                    contentDescription = userName,
                    modifier = Modifier
                        .size(40.dp)
                        .clip(CircleShape)
                        .background(TaskGoBackgroundGray),
                    contentScale = ContentScale.Crop,
                    loading = {
                        // Placeholder durante carregamento
                        Box(
                            modifier = Modifier
                                .fillMaxSize()
                                .background(TaskGoBackgroundGray),
                            contentAlignment = Alignment.Center
                        ) {
                            CircularProgressIndicator(
                                modifier = Modifier.size(20.dp),
                                color = TaskGoGreen,
                                strokeWidth = 2.dp
                            )
                        }
                    },
                    error = {
                        // Placeholder quando erro ao carregar ou URL vazia
                        Box(
                            modifier = Modifier
                                .fillMaxSize()
                                .background(TaskGoBackgroundGray),
                            contentAlignment = Alignment.Center
                        ) {
                            Icon(
                                imageVector = Icons.Default.Person,
                                contentDescription = userName,
                                modifier = Modifier.size(24.dp),
                                tint = TaskGoTextGray
                            )
                        }
                    },
                    success = { state ->
                        SubcomposeAsyncImageContent(
                            painter = state.painter,
                            modifier = Modifier.fillMaxSize(),
                            contentScale = ContentScale.Crop
                        )
                    }
                )
                
                // Campo de texto
                OutlinedTextField(
                    value = postText,
                    onValueChange = { if (it.length <= 2000) postText = it },
                    modifier = Modifier.weight(1f),
                    placeholder = { Text("No que voc√™ est√° pensando?", color = TaskGoTextGray) },
                    colors = OutlinedTextFieldDefaults.colors(
                        focusedContainerColor = TaskGoBackgroundGray,
                        unfocusedContainerColor = TaskGoBackgroundGray,
                        focusedBorderColor = TaskGoGreen,
                        unfocusedBorderColor = TaskGoBackgroundGray
                    ),
                    shape = RoundedCornerShape(20.dp),
                    maxLines = 4
                )
            }
            
            // M√≠dias selecionadas (se houver)
            if (selectedMediaUris.isNotEmpty()) {
                LazyRow(
                    horizontalArrangement = Arrangement.spacedBy(8.dp),
                    modifier = Modifier.fillMaxWidth()
                ) {
                    itemsIndexed(selectedMediaUris) { index, uri ->
                        Box(
                            modifier = Modifier
                                .size(80.dp)
                                .clip(RoundedCornerShape(8.dp))
                        ) {
                            AsyncImage(
                                model = uri,
                                contentDescription = "M√≠dia ${index + 1}",
                                modifier = Modifier.fillMaxSize(),
                                contentScale = ContentScale.Crop
                            )
                            
                            // Bot√£o remover
                            IconButton(
                                onClick = {
                                    selectedMediaUris = selectedMediaUris.toMutableList().apply {
                                        removeAt(index)
                                    }
                                },
                                modifier = Modifier.align(Alignment.TopEnd)
                            ) {
                                Icon(
                                    imageVector = Icons.Default.Close,
                                    contentDescription = "Remover",
                                    tint = TaskGoBackgroundWhite,
                                    modifier = Modifier
                                        .size(20.dp)
                                        .background(
                                            androidx.compose.ui.graphics.Color.Black.copy(alpha = 0.6f),
                                            CircleShape
                                        )
                                        .padding(4.dp)
                                )
                            }
                        }
                    }
                }
            }
            
            // Divisor
            HorizontalDivider(
                modifier = Modifier.fillMaxWidth(),
                color = TaskGoBackgroundGray
            )
            
            // Linha inferior: Bot√µes de a√ß√£o
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceEvenly
            ) {
                // Adicionar Fotos/V√≠deos
                Row(
                    modifier = Modifier
                        .weight(1f)
                        .clickable {
                            if (hasImagePermission) {
                                mediaLauncher.launch(PickVisualMediaRequest(ActivityResultContracts.PickVisualMedia.ImageAndVideo))
                            } else {
                                imagePermissionLauncher.launch(PermissionHandler.getImageReadPermission())
                            }
                        }
                        .padding(vertical = 8.dp),
                    horizontalArrangement = Arrangement.Center,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Icon(
                        imageVector = Icons.Default.Image,
                        contentDescription = null,
                        tint = TaskGoGreen,
                        modifier = Modifier.size(20.dp)
                    )
                    Spacer(modifier = Modifier.width(4.dp))
                    Text(
                        text = "Fotos/V√≠deos",
                        style = MaterialTheme.typography.bodySmall,
                        color = TaskGoTextGray
                    )
                }
                
                // Bot√£o Publicar
                Button(
                    onClick = {
                        if ((postText.isNotBlank() || selectedMediaUris.isNotEmpty()) && !isLoading) {
                            onPostCreated(postText, selectedMediaUris)
                            // Limpar apenas ap√≥s chamar o callback
                            postText = ""
                            selectedMediaUris = emptyList()
                        }
                    },
                    enabled = (postText.isNotBlank() || selectedMediaUris.isNotEmpty()) && !isLoading,
                    colors = ButtonDefaults.buttonColors(
                        containerColor = TaskGoGreen,
                        disabledContainerColor = TaskGoBackgroundGray
                    ),
                    modifier = Modifier
                        .weight(1f)
                        .padding(start = 8.dp)
                ) {
                    if (isLoading) {
                        CircularProgressIndicator(
                            modifier = Modifier.size(20.dp),
                            color = TaskGoBackgroundWhite,
                            strokeWidth = 2.dp
                        )
                    } else {
                        Text(
                            text = "Publicar",
                            color = if (postText.isNotBlank() || selectedMediaUris.isNotEmpty()) {
                                TaskGoBackgroundWhite
                            } else {
                                TaskGoTextGray
                            },
                            fontWeight = FontWeight.Bold
                        )
                    }
                }
            }
        }
    }
}






```

## [FRONTEND]: feature/feed/presentation/components/PostCard.kt

```kotlin
package com.taskgoapp.taskgo.feature.feed.presentation.components

import android.net.Uri
import android.util.Log
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.gestures.detectTapGestures
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.pager.HorizontalPager
import androidx.compose.foundation.pager.rememberPagerState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material.icons.automirrored.filled.Send
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import coil.compose.AsyncImage
import com.taskgoapp.taskgo.core.model.Post
import com.taskgoapp.taskgo.core.design.FullScreenVideoPlayer
import com.taskgoapp.taskgo.core.theme.*
import java.text.SimpleDateFormat
import java.util.*
import kotlin.math.roundToInt

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PostCard(
    post: Post,
    onLikeClick: () -> Unit,
    onUnlikeClick: () -> Unit,
    onDeleteClick: (() -> Unit)? = null, // null se n√£o for post do usu√°rio atual
    onUserClick: ((String) -> Unit)? = null, // Callback para quando clicar no nome/avatar do usu√°rio
    currentUserId: String? = null, // ID do usu√°rio atual para verificar se √© post pr√≥prio
    onCommentClick: (() -> Unit)? = null, // Callback para abrir dialog de coment√°rios
    onShareClick: (() -> Unit)? = null, // Callback para abrir dialog de compartilhar
    onInterestClick: ((Boolean) -> Unit)? = null, // Callback para "Tenho interesse" / "N√£o tenho interesse"
    onRatePostClick: (() -> Unit)? = null, // Callback para avaliar post
    onBlockUserClick: (() -> Unit)? = null, // Callback para bloquear usu√°rio
    modifier: Modifier = Modifier
) {
    var showFullScreenVideo by remember { mutableStateOf<String?>(null) }
    var showDeleteMenu by remember { mutableStateOf(false) }
    var showCommentsDialog by remember { mutableStateOf(false) }
    var showShareDialog by remember { mutableStateOf(false) }
    var showPostMenu by remember { mutableStateOf(false) }
    val isOwnPost = currentUserId != null && post.userId == currentUserId
    
    Column(
        modifier = modifier
            .fillMaxWidth()
            .background(Color.White)
    ) {
        // Header: Avatar, Nome, Data, Menu
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 12.dp, vertical = 8.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.SpaceBetween
        ) {
            Row(
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.spacedBy(12.dp),
                modifier = Modifier
                    .weight(1f)
                    .clickable(enabled = onUserClick != null) {
                        onUserClick?.invoke(post.userId)
                    }
            ) {
                // Avatar circular
                AsyncImage(
                    model = post.userAvatarUrl ?: "",
                    contentDescription = "Avatar de ${post.userName}",
                    modifier = Modifier
                        .size(32.dp)
                        .clip(CircleShape),
                    contentScale = ContentScale.Crop
                )
                
                Column(modifier = Modifier.weight(1f)) {
                    Text(
                        text = post.userName,
                        style = MaterialTheme.typography.bodyMedium,
                        fontWeight = FontWeight.Bold,
                        color = Color.Black,
                        fontSize = 14.sp
                    )
                    Text(
                        text = formatPostDate(post.createdAt),
                        style = MaterialTheme.typography.bodySmall,
                        color = TaskGoTextGray,
                        fontSize = 12.sp
                    )
                }
            }
            
            // Menu de tr√™s pontos (sempre vis√≠vel - op√ß√µes diferentes para posts pr√≥prios vs outros)
            IconButton(
                onClick = { showPostMenu = true },
                modifier = Modifier.size(40.dp)
            ) {
                Icon(
                    imageVector = Icons.Default.MoreVert,
                    contentDescription = "Mais op√ß√µes",
                    tint = Color.Black,
                    modifier = Modifier.size(24.dp)
                )
            }
        }
        
        // Carrossel de M√≠dias (largura total, estilo Instagram)
        if (post.mediaUrls.isNotEmpty()) {
            val hasMultipleMedia = post.mediaUrls.size > 1
            val pagerState = rememberPagerState(pageCount = { post.mediaUrls.size })
            
            Box(modifier = Modifier.fillMaxWidth()) {
                HorizontalPager(
                    state = pagerState,
                    modifier = Modifier
                        .fillMaxWidth()
                        .aspectRatio(1f) // Aspecto quadrado como Instagram
                ) { page ->
                    val mediaUrl = post.mediaUrls[page]
                    val mediaType = post.mediaTypes.getOrNull(page) ?: "image"
                    
                    if (mediaType == "video") {
                        VideoThumbnail(
                            videoUrl = mediaUrl,
                            onVideoClick = { showFullScreenVideo = mediaUrl },
                            modifier = Modifier.fillMaxSize()
                        )
                    } else {
                        AsyncImage(
                            model = mediaUrl,
                            contentDescription = "Imagem ${page + 1}",
                            modifier = Modifier.fillMaxSize(),
                            contentScale = ContentScale.Crop
                        )
                    }
                }
                
                // Indicadores de p√°gina (dots) - apenas se houver m√∫ltiplas imagens
                if (hasMultipleMedia) {
                    Row(
                        modifier = Modifier
                            .align(Alignment.BottomCenter)
                            .padding(bottom = 8.dp),
                        horizontalArrangement = Arrangement.spacedBy(4.dp)
                    ) {
                        repeat(post.mediaUrls.size) { iteration ->
                            val isSelected = pagerState.currentPage == iteration
                            Box(
                                modifier = Modifier
                                    .size(if (isSelected) 8.dp else 6.dp)
                                    .clip(CircleShape)
                                    .background(
                                        if (isSelected) Color.White else Color.White.copy(alpha = 0.5f)
                                    )
                            )
                        }
                    }
                }
            }
        }
        
        // A√ß√µes: Like, Coment√°rio, Compartilhar
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 12.dp, vertical = 8.dp),
            horizontalArrangement = Arrangement.spacedBy(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            // Like
            IconButton(
                onClick = {
                    if (post.isLiked) {
                        onUnlikeClick()
                    } else {
                        onLikeClick()
                    }
                },
                modifier = Modifier.size(40.dp)
            ) {
                Icon(
                    imageVector = if (post.isLiked) Icons.Default.Favorite else Icons.Default.FavoriteBorder,
                    contentDescription = if (post.isLiked) "Descurtir" else "Curtir",
                    tint = if (post.isLiked) Color(0xFFED4956) else Color.Black,
                    modifier = Modifier.size(24.dp)
                )
            }
            
            // Coment√°rio
            IconButton(
                onClick = { 
                    showCommentsDialog = true
                    onCommentClick?.invoke()
                },
                modifier = Modifier.size(40.dp)
            ) {
                Icon(
                    imageVector = Icons.Default.ModeComment,
                    contentDescription = "Comentar",
                    tint = Color.Black,
                    modifier = Modifier.size(24.dp)
                )
            }
            
            // Compartilhar
            IconButton(
                onClick = { 
                    showShareDialog = true
                    onShareClick?.invoke()
                },
                modifier = Modifier.size(40.dp)
            ) {
                Icon(
                    imageVector = Icons.AutoMirrored.Filled.Send,
                    contentDescription = "Compartilhar",
                    tint = Color.Black,
                    modifier = Modifier.size(24.dp)
                )
            }
        }
        
        // Contador de Likes
        if (post.likesCount > 0) {
            Text(
                text = "${post.likesCount} curtidas",
                style = MaterialTheme.typography.bodyMedium,
                fontWeight = FontWeight.Bold,
                color = Color.Black,
                fontSize = 14.sp,
                modifier = Modifier.padding(horizontal = 12.dp, vertical = 4.dp)
            )
        }
        
        // Texto do post com nome do usu√°rio em destaque
        if (post.text.isNotBlank()) {
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(horizontal = 12.dp, vertical = 4.dp)
            ) {
                Text(
                    text = post.userName + " ",
                    style = MaterialTheme.typography.bodyMedium,
                    fontWeight = FontWeight.Bold,
                    color = Color.Black,
                    fontSize = 14.sp,
                    modifier = Modifier.clickable(enabled = onUserClick != null) {
                        onUserClick?.invoke(post.userId)
                    }
                )
                Text(
                    text = post.text,
                    style = MaterialTheme.typography.bodyMedium,
                    color = Color.Black,
                    fontSize = 14.sp,
                    modifier = Modifier.weight(1f)
                )
            }
        }
        
        // Contador de Coment√°rios
        if (post.commentsCount > 0) {
            Text(
                text = "Ver todos os ${post.commentsCount} coment√°rios",
                style = MaterialTheme.typography.bodySmall,
                color = TaskGoTextGray,
                fontSize = 14.sp,
                modifier = Modifier
                    .padding(horizontal = 12.dp, vertical = 4.dp)
                    .clickable { 
                        showCommentsDialog = true
                        onCommentClick?.invoke()
                    }
            )
        }
        
        // Timestamp
        Text(
            text = formatPostDate(post.createdAt),
            style = MaterialTheme.typography.bodySmall,
            color = TaskGoTextGray,
            fontSize = 10.sp,
            modifier = Modifier.padding(horizontal = 12.dp, vertical = 4.dp)
        )
        
        // Divisor
        HorizontalDivider(
            modifier = Modifier.padding(vertical = 8.dp),
            thickness = 0.5.dp,
            color = Color.LightGray.copy(alpha = 0.3f)
        )
    }
    
    // Menu de op√ß√µes do post (3 pontos)
    if (showPostMenu) {
        PostOptionsMenu(
            isOwnPost = isOwnPost,
            onDismiss = { showPostMenu = false },
            onDelete = {
                showPostMenu = false
                showDeleteMenu = true
            },
            onInterest = { hasInterest ->
                onInterestClick?.invoke(hasInterest)
                showPostMenu = false
            },
            onRate = {
                onRatePostClick?.invoke()
                showPostMenu = false
            },
            onBlock = {
                onBlockUserClick?.invoke()
                showPostMenu = false
            }
        )
    }
    
    // Menu de delete (confirma√ß√£o)
    if (showDeleteMenu && onDeleteClick != null) {
        AlertDialog(
            onDismissRequest = { showDeleteMenu = false },
            title = { Text("Deletar post") },
            text = { Text("Tem certeza que deseja deletar este post?") },
            confirmButton = {
                TextButton(
                    onClick = {
                        onDeleteClick()
                        showDeleteMenu = false
                    }
                ) {
                    Text("Deletar", color = MaterialTheme.colorScheme.error)
                }
            },
            dismissButton = {
                TextButton(onClick = { showDeleteMenu = false }) {
                    Text("Cancelar")
                }
            }
        )
    }
    
    // Dialog de coment√°rios
    if (showCommentsDialog) {
        CommentsDialog(
            postId = post.id,
            postUserId = post.userId,
            currentUserId = currentUserId,
            onDismiss = { showCommentsDialog = false }
        )
    }
    
    // Dialog de compartilhar
    if (showShareDialog) {
        SharePostDialog(
            postId = post.id,
            onDismiss = { showShareDialog = false }
        )
    }
    
    // Player de v√≠deo em tela cheia
    showFullScreenVideo?.let { videoUrl ->
        FullScreenVideoPlayer(
            videoUrl = videoUrl,
            onDismiss = { showFullScreenVideo = null }
        )
    }
}

@Composable
private fun VideoThumbnail(
    videoUrl: String,
    onVideoClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    Box(
        modifier = modifier
            .fillMaxSize()
            .background(Color.Black)
            .clickable(onClick = onVideoClick),
        contentAlignment = Alignment.Center
    ) {
        Column(
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            Icon(
                imageVector = Icons.Default.PlayCircleFilled,
                contentDescription = "Tocar v√≠deo",
                modifier = Modifier.size(64.dp),
                tint = Color.White.copy(alpha = 0.9f)
            )
            Text(
                text = "Tocar v√≠deo",
                style = MaterialTheme.typography.bodyMedium,
                color = Color.White.copy(alpha = 0.9f),
                fontSize = 14.sp
            )
        }
    }
}

private fun formatPostDate(date: Date?): String {
    if (date == null) return ""
    
    val now = Date()
    val diff = now.time - date.time
    val seconds = diff / 1000
    val minutes = seconds / 60
    val hours = minutes / 60
    val days = hours / 24
    
    return when {
        seconds < 60 -> "agora"
        minutes < 60 -> "h√° ${minutes}min"
        hours < 24 -> "h√° ${hours}h"
        days < 7 -> "h√° ${days}d"
        else -> {
            val format = SimpleDateFormat("dd/MM/yyyy", Locale("pt", "BR"))
            format.format(date)
        }
    }
}

```

## [FRONTEND]: feature/feed/presentation/components/PostOptionsMenu.kt

```kotlin
package com.taskgoapp.taskgo.feature.feed.presentation.components

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.taskgoapp.taskgo.core.theme.*

/**
 * Menu de op√ß√µes do post (3 pontos) - estilo Instagram
 * Para posts pr√≥prios: apenas excluir
 * Para posts de outros: Tenho interesse, N√£o tenho interesse, Avaliar post, Bloquear usu√°rio
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PostOptionsMenu(
    isOwnPost: Boolean,
    onDismiss: () -> Unit,
    onDelete: () -> Unit,
    onInterest: (Boolean) -> Unit,
    onRate: () -> Unit,
    onBlock: () -> Unit,
    modifier: Modifier = Modifier
) {
    ModalBottomSheet(
        onDismissRequest = onDismiss,
        modifier = modifier,
        shape = RoundedCornerShape(topStart = 16.dp, topEnd = 16.dp),
        containerColor = Color.White
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(vertical = 8.dp)
        ) {
            if (isOwnPost) {
                // Menu para posts pr√≥prios: apenas excluir
                MenuOptionItem(
                    icon = Icons.Default.Delete,
                    title = "Excluir",
                    description = "Excluir este post permanentemente",
                    onClick = {
                        onDelete()
                        onDismiss()
                    },
                    textColor = MaterialTheme.colorScheme.error
                )
            } else {
                // Menu para posts de outros usu√°rios
                MenuOptionItem(
                    icon = Icons.Default.ThumbUp,
                    title = "Tenho interesse",
                    description = "Voc√™ ver√° mais posts como esse",
                    onClick = {
                        onInterest(true)
                        onDismiss()
                    }
                )
                
                HorizontalDivider(modifier = Modifier.padding(horizontal = 16.dp))
                
                MenuOptionItem(
                    icon = Icons.Default.ThumbDown,
                    title = "N√£o tenho interesse",
                    description = "Voc√™ ver√° menos posts como esse",
                    onClick = {
                        onInterest(false)
                        onDismiss()
                    }
                )
                
                HorizontalDivider(modifier = Modifier.padding(horizontal = 16.dp))
                
                MenuOptionItem(
                    icon = Icons.Default.Star,
                    title = "Avaliar post",
                    description = "Avaliar este post",
                    onClick = {
                        onRate()
                        onDismiss()
                    }
                )
                
                HorizontalDivider(modifier = Modifier.padding(horizontal = 16.dp))
                
                MenuOptionItem(
                    icon = Icons.Default.Block,
                    title = "Bloquear",
                    description = "Bloquear ${"usu√°rio"}",
                    onClick = {
                        onBlock()
                        onDismiss()
                    },
                    textColor = MaterialTheme.colorScheme.error
                )
            }
        }
    }
}

@Composable
private fun MenuOptionItem(
    icon: androidx.compose.ui.graphics.vector.ImageVector,
    title: String,
    description: String,
    onClick: () -> Unit,
    textColor: Color = TaskGoTextBlack,
    modifier: Modifier = Modifier
) {
    Row(
        modifier = modifier
            .fillMaxWidth()
            .clickable(onClick = onClick)
            .padding(horizontal = 16.dp, vertical = 16.dp),
        horizontalArrangement = Arrangement.spacedBy(16.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Icon(
            imageVector = icon,
            contentDescription = null,
            tint = textColor,
            modifier = Modifier.size(24.dp)
        )
        Column(modifier = Modifier.weight(1f)) {
            Text(
                text = title,
                style = MaterialTheme.typography.bodyLarge,
                fontWeight = FontWeight.Medium,
                color = textColor,
                fontSize = 16.sp
            )
            Text(
                text = description,
                style = MaterialTheme.typography.bodySmall,
                color = TaskGoTextGray,
                fontSize = 14.sp
            )
        }
    }
}

```

## [FRONTEND]: feature/feed/presentation/components/RadiusFilterDialog.kt

```kotlin
package com.taskgoapp.taskgo.feature.feed.presentation.components

import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.taskgoapp.taskgo.core.theme.*

@Composable
fun RadiusFilterDialog(
    currentRadius: Double,
    onRadiusChanged: (Double) -> Unit,
    onDismiss: () -> Unit,
    modifier: Modifier = Modifier
) {
    var sliderValue by remember(currentRadius) { 
        mutableStateOf(currentRadius.toFloat().coerceIn(10f, 100f))
    }
    
    AlertDialog(
        onDismissRequest = onDismiss,
        title = {
            Text(
                text = "Raio de Busca",
                style = MaterialTheme.typography.titleLarge,
                color = TaskGoTextBlack
            )
        },
        text = {
            Column(
                modifier = Modifier.fillMaxWidth(),
                horizontalAlignment = Alignment.CenterHorizontally,
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                Text(
                    text = "${sliderValue.toInt()} km",
                    style = MaterialTheme.typography.headlineMedium,
                    fontWeight = androidx.compose.ui.text.font.FontWeight.Bold,
                    color = TaskGoGreen
                )
                
                Slider(
                    value = sliderValue,
                    onValueChange = { sliderValue = it },
                    valueRange = 10f..100f,
                    steps = 8, // Incrementos de 10km (10, 20, 30, ..., 100)
                    colors = SliderDefaults.colors(
                        thumbColor = TaskGoGreen,
                        activeTrackColor = TaskGoGreen
                    )
                )
                
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween
                ) {
                    Text(
                        text = "10 km",
                        style = MaterialTheme.typography.bodySmall,
                        color = TaskGoTextGray
                    )
                    Text(
                        text = "100 km",
                        style = MaterialTheme.typography.bodySmall,
                        color = TaskGoTextGray
                    )
                }
            }
        },
        confirmButton = {
            Button(
                onClick = {
                    onRadiusChanged(sliderValue.toDouble())
                    onDismiss()
                },
                colors = ButtonDefaults.buttonColors(
                    containerColor = TaskGoGreen
                )
            ) {
                Text("Aplicar", color = TaskGoBackgroundWhite)
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Cancelar", color = TaskGoTextGray)
            }
        },
        modifier = modifier
    )
}

```

## [FRONTEND]: feature/feed/presentation/components/RatePostDialog.kt

```kotlin
package com.taskgoapp.taskgo.feature.feed.presentation.components

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Star
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.window.Dialog
import com.taskgoapp.taskgo.core.theme.*

/**
 * Dialog para avaliar um post (1-5 estrelas)
 */
@Composable
fun RatePostDialog(
    onDismiss: () -> Unit,
    onConfirm: (rating: Int, comment: String?) -> Unit,
    existingRating: Int? = null,
    existingComment: String? = null
) {
    var selectedRating by remember { mutableStateOf(existingRating ?: 0) }
    var comment by remember { mutableStateOf(existingComment ?: "") }
    
    Dialog(onDismissRequest = onDismiss) {
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            shape = RoundedCornerShape(16.dp),
            colors = CardDefaults.cardColors(
                containerColor = Color.White
            )
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(24.dp),
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                Text(
                    text = "Avaliar Post",
                    style = MaterialTheme.typography.titleLarge,
                    fontWeight = FontWeight.Bold,
                    fontSize = 20.sp
                )
                
                Spacer(modifier = Modifier.height(24.dp))
                
                // Estrelas
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.Center,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    for (i in 1..5) {
                        Icon(
                            imageVector = Icons.Default.Star,
                            contentDescription = "$i estrelas",
                            modifier = Modifier
                                .size(48.dp)
                                .clickable { selectedRating = i },
                            tint = if (i <= selectedRating) Color(0xFFFFD700) else Color(0xFFE0E0E0)
                        )
                        Spacer(modifier = Modifier.width(8.dp))
                    }
                }
                
                Spacer(modifier = Modifier.height(24.dp))
                
                // Campo de coment√°rio (opcional)
                OutlinedTextField(
                    value = comment,
                    onValueChange = { comment = it },
                    label = { Text("Coment√°rio (opcional)") },
                    modifier = Modifier.fillMaxWidth(),
                    maxLines = 4,
                    placeholder = { Text("Deixe um coment√°rio sobre este post...") }
                )
                
                Spacer(modifier = Modifier.height(24.dp))
                
                // Bot√µes
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    OutlinedButton(
                        onClick = onDismiss,
                        modifier = Modifier.weight(1f)
                    ) {
                        Text("Cancelar")
                    }
                    
                    Button(
                        onClick = {
                            if (selectedRating > 0) {
                                onConfirm(selectedRating, comment.takeIf { it.isNotBlank() })
                            }
                        },
                        modifier = Modifier.weight(1f),
                        enabled = selectedRating > 0,
                        colors = ButtonDefaults.buttonColors(
                            containerColor = TaskGoGreen
                        )
                    ) {
                        Text("Avaliar")
                    }
                }
            }
        }
    }
}

```

## [FRONTEND]: feature/feed/presentation/components/SharePostDialog.kt

```kotlin
package com.taskgoapp.taskgo.feature.feed.presentation.components

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Close
import androidx.compose.material.icons.filled.ContentCopy
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalClipboardManager
import androidx.compose.ui.text.AnnotatedString
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.core.theme.*

/**
 * Dialog para copiar link do post
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun SharePostDialog(
    postId: String,
    onDismiss: () -> Unit,
    modifier: Modifier = Modifier
) {
    val clipboardManager = LocalClipboardManager.current
    var linkCopied by remember { mutableStateOf(false) }
    
    // Gerar link do post para dom√≠nio principal (taskgoapps.com) e deep link do app
    val postLink = "https://taskgoapps.com/post/$postId"
    
    ModalBottomSheet(
        onDismissRequest = onDismiss,
        modifier = modifier,
        shape = RoundedCornerShape(topStart = 16.dp, topEnd = 16.dp),
        containerColor = Color.White
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(24.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.spacedBy(24.dp)
        ) {
            // Header
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = "Compartilhar",
                    style = MaterialTheme.typography.titleLarge,
                    fontWeight = FontWeight.Bold,
                    color = TaskGoTextBlack
                )
                IconButton(onClick = onDismiss) {
                    Icon(
                        imageVector = Icons.Default.Close,
                        contentDescription = "Fechar",
                        tint = TaskGoTextGray
                    )
                }
            }
            
            // Link do post
            OutlinedTextField(
                value = postLink,
                onValueChange = { },
                modifier = Modifier.fillMaxWidth(),
                readOnly = true,
                colors = OutlinedTextFieldDefaults.colors(
                    focusedBorderColor = TaskGoGreen,
                    unfocusedBorderColor = TaskGoTextGray,
                    disabledTextColor = TaskGoTextBlack,
                    disabledBorderColor = TaskGoTextGray
                ),
                shape = RoundedCornerShape(8.dp)
            )
            
            // Bot√£o copiar link
            Button(
                onClick = {
                    clipboardManager.setText(AnnotatedString(postLink))
                    linkCopied = true
                },
                modifier = Modifier.fillMaxWidth(),
                colors = ButtonDefaults.buttonColors(
                    containerColor = TaskGoGreen
                ),
                shape = RoundedCornerShape(8.dp)
            ) {
                Icon(
                    imageVector = Icons.Default.ContentCopy,
                    contentDescription = null,
                    modifier = Modifier.size(20.dp)
                )
                Spacer(modifier = Modifier.width(8.dp))
                Text(
                    text = if (linkCopied) "Link copiado!" else "Copiar link",
                    fontWeight = FontWeight.Medium
                )
            }
            
            if (linkCopied) {
                Text(
                    text = "Link copiado para a √°rea de transfer√™ncia",
                    style = MaterialTheme.typography.bodySmall,
                    color = TaskGoGreen
                )
            }
        }
    }
}

```

## [FRONTEND]: feature/feed/presentation/components/StoriesSectionNew.kt

```kotlin
package com.taskgoapp.taskgo.feature.feed.presentation.components

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Person
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import coil.compose.AsyncImage
import coil.compose.SubcomposeAsyncImage
import coil.compose.SubcomposeAsyncImageContent
import coil.request.ImageRequest
import androidx.compose.ui.platform.LocalContext
import com.taskgoapp.taskgo.core.model.Story
import com.taskgoapp.taskgo.core.theme.*

@Composable
fun StoriesSectionNew(
    currentUserAvatarUrl: String?,
    currentUserName: String,
    currentUserId: String?,
    stories: List<Story>,
    onCreateStoryClick: (() -> Unit)?,
    onStoryClick: (String) -> Unit,
    modifier: Modifier = Modifier
) {
    // Verificar se o usu√°rio atual tem stories pr√≥prias
    val currentUserHasStories = remember(stories, currentUserId) {
        currentUserId != null && stories.any { it.userId == currentUserId }
    }
    
    // Separar stories do usu√°rio atual das de outros usu√°rios
    val currentUserStories = remember(stories, currentUserId) {
        if (currentUserId != null) {
            stories.filter { it.userId == currentUserId }
        } else {
            emptyList()
        }
    }
    
    // Agrupar stories de outros usu√°rios: prioriza story n√£o vista para mostrar o anel colorido
    val uniqueUserStories = stories
        .filter { it.userId != currentUserId } // Excluir stories do usu√°rio atual
        .groupBy { it.userId }
        .mapValues { (_, stories) ->
            stories.firstOrNull { !it.isViewed } ?: stories.first()
        }
        .values
        .toList()
    
    LazyRow(
        modifier = modifier.fillMaxWidth(),
        horizontalArrangement = Arrangement.spacedBy(12.dp),
        contentPadding = PaddingValues(horizontal = 16.dp, vertical = 12.dp)
    ) {
        // Meu Story (primeiro) - sempre mostra se pode criar stories
        // Se tiver stories pr√≥prias, permite visualizar; sen√£o, permite criar
        if (onCreateStoryClick != null) {
            item {
                StoryCircle(
                    userName = "Seu story",
                    avatarUrl = currentUserAvatarUrl,
                    isMyStory = true,
                    hasStories = currentUserHasStories,
                    onClick = {
                        if (currentUserHasStories && currentUserId != null) {
                            // Se tem stories, permite visualizar
                            onStoryClick(currentUserId)
                        } else {
                            // Se n√£o tem, permite criar
                            onCreateStoryClick()
                        }
                    }
                )
            }
        }
        
        // Stories de outros usu√°rios
        items(uniqueUserStories, key = { it.id }) { story ->
            StoryCircle(
                userName = story.userName,
                avatarUrl = story.userAvatarUrl,
                isMyStory = false,
                hasStories = !story.isViewed,
                onClick = { onStoryClick(story.userId) }
            )
        }
    }
}

@Composable
private fun StoryCircle(
    userName: String,
    avatarUrl: String?,
    isMyStory: Boolean,
    hasStories: Boolean,
    onClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    val context = LocalContext.current
    
    // Gradiente vibrante estilo Instagram (roxo, rosa, laranja, amarelo)
    val gradientColors = remember {
        if (hasStories) {
            listOf(
                Color(0xFF833AB4), // Roxo
                Color(0xFFFD1D1D), // Vermelho/Rosa
                Color(0xFFFCB045)  // Laranja/Amarelo
            )
        } else {
            listOf(
                Color(0xFFC7C7CC), // Cinza claro
                Color(0xFFA8A8A8)  // Cinza m√©dio
            )
        }
    }
    
    Column(
        modifier = modifier.width(64.dp),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Box(
            modifier = Modifier.clickable(onClick = onClick)
        ) {
            // Borda colorida se tiver stories (usu√°rios ou pr√≥prio)
            Box(
                modifier = Modifier
                    .size(if (hasStories) 64.dp else 56.dp)
                    .background(
                        brush = Brush.linearGradient(
                            colors = gradientColors,
                            start = Offset(0f, 0f),
                            end = Offset(64f, 64f)
                        ),
                        shape = CircleShape
                    )
                    .padding(if (hasStories) 2.5.dp else 0.dp)
            ) {
                SubcomposeAsyncImage(
                    model = ImageRequest.Builder(context)
                        .data(avatarUrl)
                        .crossfade(true)
                        .build(),
                    contentDescription = userName,
                    modifier = Modifier
                        .fillMaxSize()
                        .clip(CircleShape)
                        .background(Color(0xFFE0E0E0)),
                    contentScale = ContentScale.Crop,
                    loading = {
                        Box(
                            modifier = Modifier
                                .fillMaxSize()
                                .background(Color(0xFFE0E0E0)),
                            contentAlignment = Alignment.Center
                        ) {
                            CircularProgressIndicator(
                                modifier = Modifier.size(20.dp),
                                    color = Color(0xFF833AB4),
                                strokeWidth = 2.dp
                            )
                        }
                    },
                    error = {
                        Box(
                            modifier = Modifier
                                .fillMaxSize()
                                .background(Color(0xFFE0E0E0)),
                            contentAlignment = Alignment.Center
                        ) {
                            Icon(
                                imageVector = Icons.Default.Person,
                                contentDescription = userName,
                                modifier = Modifier.size(30.dp),
                                    tint = Color(0xFF999999)
                            )
                        }
                    },
                    success = { state ->
                        SubcomposeAsyncImageContent(
                            painter = state.painter,
                            modifier = Modifier.fillMaxSize(),
                            contentScale = ContentScale.Crop
                        )
                    }
                )
            }
            
            // Bot√£o de adicionar (apenas para meu story)
            if (isMyStory) {
                Box(
                    modifier = Modifier
                        .align(Alignment.BottomEnd)
                        .offset(x = (-2).dp, y = (-2).dp)
                        .size(20.dp)
                        .background(Color.White, CircleShape)
                        .padding(1.dp)
                        .background(Color(0xFF0095F6), CircleShape),
                    contentAlignment = Alignment.Center
                ) {
                    Icon(
                        imageVector = Icons.Default.Add,
                        contentDescription = "Adicionar story",
                        tint = Color.White,
                        modifier = Modifier.size(14.dp)
                    )
                }
            }
        }
        
        Spacer(modifier = Modifier.height(4.dp))
        
        Text(
            text = userName,
            style = MaterialTheme.typography.bodySmall,
            color = TaskGoTextBlack,
            maxLines = 1,
            fontSize = 11.sp,
            fontWeight = if (hasStories) FontWeight.Bold else FontWeight.Normal,
            modifier = Modifier.fillMaxWidth()
        )
    }
}


```

## [FRONTEND]: feature/feed/presentation/components/StoriesViewerScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.feed.presentation.components

import android.view.ViewGroup
import androidx.compose.animation.core.animateFloatAsState
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.gestures.detectDragGestures
import androidx.compose.foundation.gestures.detectTapGestures
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Close
import androidx.compose.material.icons.filled.Pause
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.window.Dialog
import androidx.compose.ui.window.DialogProperties
import coil.compose.AsyncImage
import androidx.compose.ui.viewinterop.AndroidView
import com.taskgoapp.taskgo.core.model.Story
import com.taskgoapp.taskgo.core.theme.*
import androidx.media3.common.MediaItem
import androidx.media3.common.Player
import androidx.media3.exoplayer.ExoPlayer
import androidx.media3.ui.PlayerView
import kotlinx.coroutines.delay

@Composable
fun StoriesViewerScreen(
    stories: List<Story>,
    initialIndex: Int = 0,
    onDismiss: () -> Unit,
    onStoryViewed: (String) -> Unit,
    onUserClick: ((String) -> Unit)? = null,
    currentUserId: String? = null, // ID do usu√°rio atual para verificar se √© dono
    onSwipeUp: ((String) -> Unit)? = null, // Callback para swipe up (apenas stories pr√≥prias)
    onTrackAction: ((String, String) -> Unit)? = null // Callback para tracking de a√ß√µes (storyId, action)
) {
    if (stories.isEmpty()) {
        onDismiss()
        return
    }
    
    var currentIndex by remember { mutableStateOf(initialIndex.coerceIn(0, stories.size - 1)) }
    var progress by remember { mutableStateOf(0f) }
    var isPaused by remember { mutableStateOf(false) }
    var dragOffsetY by remember { mutableStateOf(0f) }
    val context = LocalContext.current
    val currentStory = stories.getOrNull(currentIndex)
    val isVideo = currentStory?.mediaType == "video"

    // Player de v√≠deo dedicado para o story atual (limpa ao trocar de story)
    val exoPlayer = remember(currentIndex) {
        ExoPlayer.Builder(context).build().apply {
            currentStory?.let { story ->
                setMediaItem(MediaItem.fromUri(story.mediaUrl))
                prepare()
                playWhenReady = true
            }
        }
    }
    DisposableEffect(exoPlayer) {
        onDispose { exoPlayer.release() }
    }
    
    val isOwnStory = currentStory != null && currentUserId != null && currentStory.userId == currentUserId
    
    // Marcar como visto ao entrar em cada story
    LaunchedEffect(currentIndex) {
        currentStory?.let { onStoryViewed(it.id) }
        progress = 0f
        isPaused = false
    }

    // Auto-avance: imagem 5s, v√≠deo pela dura√ß√£o (m√°x 30s) ou 30s fallback
    LaunchedEffect(currentIndex, isPaused) {
        val story = stories.getOrNull(currentIndex) ?: return@LaunchedEffect
        progress = 0f

        if (story.mediaType == "video") {
            while (true) {
                if (!isPaused) {
                    val duration = exoPlayer.duration.takeIf { it > 0 }?.coerceAtMost(30_000L) ?: 30_000L
                    val position = exoPlayer.currentPosition
                    progress = (position.toFloat() / duration.toFloat()).coerceIn(0f, 1f)

                    if (exoPlayer.playbackState == Player.STATE_ENDED || position >= duration) {
                        onStoryViewed(story.id)
                        if (currentIndex < stories.size - 1) {
                            onTrackAction?.invoke(story.id, "next_auto")
                            currentIndex++
                            break
                        } else {
                            onDismiss()
                            break
                        }
                    }
                    exoPlayer.playWhenReady = true
                } else {
                    exoPlayer.playWhenReady = false
                }
                delay(50)
            }
        } else {
            val duration = 5_000L
            while (progress < 1f && !isPaused) {
                delay(50)
                progress += 50f / duration.toFloat()
            }
            if (progress >= 1f) {
                onStoryViewed(story.id)
                if (currentIndex < stories.size - 1) {
                    onTrackAction?.invoke(story.id, "next_auto")
                    isPaused = false
                    currentIndex++
                } else {
                    onDismiss()
                }
            }
        }
    }
    
    if (currentStory == null) {
        onDismiss()
        return
    }
    
    Dialog(
        onDismissRequest = onDismiss,
        properties = DialogProperties(
            usePlatformDefaultWidth = false,
            decorFitsSystemWindows = false
        )
    ) {
        Box(
            modifier = Modifier
                .fillMaxSize()
                .background(Color.Black)
                .pointerInput(Unit) {
                    detectDragGestures(
                        onDrag = { change, dragAmount ->
                            // Detectar swipe up (dragAmount.y negativo significativo)
                            if (dragAmount.y < -50 && isOwnStory && onSwipeUp != null) {
                                // Swipe up detectado - abrir analytics
                                currentStory?.let { story ->
                                    onSwipeUp(story.id)
                                    onTrackAction?.invoke(story.id, "swipe_up") // Track action
                                }
                                return@detectDragGestures
                            }
                            
                            // Para swipe down (dragAmount.y positivo)
                            if (dragAmount.y > 100) {
                                // Swipe down significativo - fechar viewer
                                currentStory?.let { story ->
                                    onTrackAction?.invoke(story.id, "back") // Track back action
                                }
                                onDismiss()
                                return@detectDragGestures
                            }
                            
                            dragOffsetY += dragAmount.y
                        },
                        onDragEnd = {
                            dragOffsetY = 0f
                        }
                    )
                }
                .pointerInput(Unit) {
                    detectTapGestures(
                        onPress = {
                            isPaused = true
                            if (isVideo) exoPlayer.playWhenReady = false
                            tryAwaitRelease()
                            isPaused = false
                            if (isVideo) exoPlayer.playWhenReady = true
                        },
                        onTap = { offset ->
                            val story = stories.getOrNull(currentIndex) ?: return@detectTapGestures
                            val screenWidth = size.width
                            if (offset.x < screenWidth / 2) {
                                // Tap na esquerda - voltar
                                if (currentIndex > 0) {
                                    onTrackAction?.invoke(story.id, "back")
                                    currentIndex--
                                    progress = 0f
                                } else {
                                    onTrackAction?.invoke(story.id, "back")
                                    onDismiss()
                                }
                            } else {
                                // Tap na direita - avan√ßar
                                if (currentIndex < stories.size - 1) {
                                    onTrackAction?.invoke(story.id, "next_tap")
                                    currentIndex++
                                    progress = 0f
                                } else {
                                    onDismiss()
                                }
                            }
                        }
                    )
                }
        ) {
            // Barra de progresso no topo
            StoryProgressBar(
                stories = stories,
                currentIndex = currentIndex,
                progress = progress,
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(8.dp)
                    .height(4.dp)
            )
            
            // Header com avatar e nome do usu√°rio
            StoryHeader(
                story = currentStory,
                onClose = onDismiss,
                onUserClick = {
                    // Track profile visit action when user clicks on header
                    onUserClick?.invoke(currentStory.userId)
                    if (currentUserId != null && currentStory.userId != currentUserId) {
                        // Usu√°rio visualizou o perfil de outro usu√°rio a partir da story
                        onTrackAction?.invoke(currentStory.id, "navigation")
                    }
                },
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp)
            )
            
            // Conte√∫do da story (imagem ou v√≠deo)
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(top = 60.dp, bottom = 100.dp),
                contentAlignment = Alignment.Center
            ) {
                if (currentStory.mediaType == "video") {
                    // Player de v√≠deo com ExoPlayer (comportamento IG-like)
                    AndroidView(
                        factory = { ctx ->
                            PlayerView(ctx).apply {
                                player = exoPlayer
                                useController = false
                                layoutParams = ViewGroup.LayoutParams(
                                    ViewGroup.LayoutParams.MATCH_PARENT,
                                    ViewGroup.LayoutParams.MATCH_PARENT
                                )
                            }
                        },
                        modifier = Modifier.fillMaxSize()
                    )
                } else {
                    AsyncImage(
                        model = currentStory.mediaUrl,
                        contentDescription = null,
                        modifier = Modifier.fillMaxSize(),
                        contentScale = ContentScale.Crop
                    )
                }
                
                // Caption (se houver)
                currentStory.caption?.let { caption ->
                    Text(
                        text = caption,
                        color = Color.White,
                        fontSize = 16.sp,
                        modifier = Modifier
                            .align(Alignment.BottomCenter)
                            .padding(16.dp)
                    )
                }
            }
            
            // Indicador de pausa
            if (isPaused) {
                Icon(
                    imageVector = Icons.Default.Pause,
                    contentDescription = "Pausado",
                    tint = Color.White.copy(alpha = 0.8f),
                    modifier = Modifier
                        .align(Alignment.Center)
                        .size(64.dp)
                )
            }
        }
    }
}

@Composable
private fun StoryProgressBar(
    stories: List<Story>,
    currentIndex: Int,
    progress: Float,
    modifier: Modifier = Modifier
) {
    Row(
        modifier = modifier,
        horizontalArrangement = Arrangement.spacedBy(4.dp)
    ) {
        stories.forEachIndexed { index, _ ->
            val segmentProgress = when {
                index < currentIndex -> 1f
                index == currentIndex -> progress
                else -> 0f
            }
            
            LinearProgressIndicator(
                progress = segmentProgress,
                modifier = Modifier
                    .weight(1f)
                    .height(4.dp)
                    .clip(CircleShape),
                color = Color.White,
                trackColor = Color.White.copy(alpha = 0.3f)
            )
        }
    }
}

@Composable
private fun StoryHeader(
    story: Story,
    onClose: () -> Unit,
    onUserClick: ((String) -> Unit)?,
    modifier: Modifier = Modifier
) {
    Row(
        modifier = modifier,
        horizontalArrangement = Arrangement.SpaceBetween,
        verticalAlignment = Alignment.CenterVertically
    ) {
        Row(
            modifier = Modifier
                .weight(1f)
                .clickable { onUserClick?.invoke(story.userId) },
            horizontalArrangement = Arrangement.spacedBy(12.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            AsyncImage(
                model = story.userAvatarUrl ?: "",
                contentDescription = story.userName,
                modifier = Modifier
                    .size(40.dp)
                    .clip(CircleShape),
                contentScale = ContentScale.Crop
            )
            
            Column {
                Text(
                    text = story.userName,
                    color = Color.White,
                    fontSize = 16.sp,
                    fontWeight = FontWeight.Bold
                )
                Text(
                    text = formatStoryTime(story.createdAt),
                    color = Color.White.copy(alpha = 0.7f),
                    fontSize = 12.sp
                )
            }
        }
        
        IconButton(onClick = onClose) {
            Icon(
                imageVector = Icons.Default.Close,
                contentDescription = "Fechar",
                tint = Color.White
            )
        }
    }
}

private fun formatStoryTime(date: java.util.Date): String {
    val now = System.currentTimeMillis()
    val diff = now - date.time
    val hours = (diff / (1000 * 60 * 60)).toInt()
    
    return when {
        hours < 1 -> "Agora"
        hours == 1 -> "1 hora atr√°s"
        hours < 24 -> "$hours horas atr√°s"
        else -> "${hours / 24} dias atr√°s"
    }
}


```

## [FRONTEND]: feature/feed/presentation/components/StoryAnalyticsScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.feed.presentation.components

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Close
import androidx.compose.material.icons.filled.Info
import androidx.compose.material.icons.filled.MoreVert
import androidx.compose.material.icons.automirrored.filled.Send
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.window.Dialog
import androidx.compose.ui.window.DialogProperties
import androidx.hilt.navigation.compose.hiltViewModel
import coil.compose.AsyncImage
import com.taskgoapp.taskgo.core.model.Story
import com.taskgoapp.taskgo.core.model.StoryView
import com.taskgoapp.taskgo.feature.feed.presentation.StoryAnalyticsViewModel
import com.taskgoapp.taskgo.core.theme.*

/**
 * Tela de Analytics de Story (estilo Instagram)
 * Exibida quando o usu√°rio faz swipe up em uma story pr√≥pria
 */
@Composable
fun StoryAnalyticsScreen(
    storyId: String,
    ownerUserId: String,
    userStories: List<Story> = emptyList(), // Stories do usu√°rio para preview
    onDismiss: () -> Unit,
    viewModel: StoryAnalyticsViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    var selectedTab by remember { mutableStateOf(0) } // 0 = Intera√ß√µes, 1 = Descoberta
    
    LaunchedEffect(storyId, ownerUserId) {
        viewModel.loadAnalytics(storyId, ownerUserId)
    }
    
    Dialog(
        onDismissRequest = onDismiss,
        properties = DialogProperties(
            usePlatformDefaultWidth = false,
            decorFitsSystemWindows = false
        )
    ) {
        Box(
            modifier = Modifier
                .fillMaxSize()
                .background(Color(0xFF1A1A1A)) // Fundo escuro estilo Instagram
        ) {
            Column(
                modifier = Modifier.fillMaxSize()
            ) {
                // Header com X e t√≠tulo
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    IconButton(
                        onClick = onDismiss,
                        modifier = Modifier.size(40.dp)
                    ) {
                        Icon(
                            imageVector = Icons.Default.Close,
                            contentDescription = "Fechar",
                            tint = Color.White
                        )
                    }
                    
                    Text(
                        text = "Insights",
                        style = MaterialTheme.typography.titleMedium,
                        color = Color.White,
                        fontWeight = FontWeight.Bold
                    )
                    
                    Spacer(modifier = Modifier.size(40.dp)) // Espa√ßamento para alinhar t√≠tulo
                }
                
                // Preview de stories (horizontal scroll√°vel)
                if (userStories.isNotEmpty()) {
                    StoryPreviewsSection(
                        stories = userStories,
                        selectedStoryId = storyId,
                        currentViews = uiState.analytics?.views?.size ?: 0
                    )
                }
                
                // Abas: Intera√ß√µes e Descoberta
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(horizontal = 16.dp, vertical = 8.dp),
                    horizontalArrangement = Arrangement.spacedBy(0.dp)
                ) {
                    TabButton(
                        text = "Intera√ß√µes",
                        isSelected = selectedTab == 0,
                        onClick = { selectedTab = 0 },
                        modifier = Modifier.weight(1f)
                    )
                    TabButton(
                        text = "Descoberta",
                        isSelected = selectedTab == 1,
                        onClick = { selectedTab = 1 },
                        modifier = Modifier.weight(1f)
                    )
                }
                
                // Conte√∫do das abas
                when (selectedTab) {
                    0 -> InteractionsTab(uiState.analytics)
                    1 -> DiscoveryTab(uiState.analytics)
                }
            }
            
            // Loading indicator
            if (uiState.isLoading) {
                Box(
                    modifier = Modifier
                        .fillMaxSize()
                        .background(Color.Black.copy(alpha = 0.5f)),
                    contentAlignment = Alignment.Center
                ) {
                    CircularProgressIndicator(color = Color.White)
                }
            }
        }
    }
}

@Composable
private fun StoryPreviewsSection(
    stories: List<Story>,
    selectedStoryId: String,
    currentViews: Int
) {
    LazyRow(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 8.dp),
        horizontalArrangement = Arrangement.spacedBy(8.dp),
        contentPadding = PaddingValues(horizontal = 16.dp)
    ) {
        items(stories, key = { it.id }) { story ->
            val isSelected = story.id == selectedStoryId
            Box(
                modifier = Modifier
                    .size(60.dp)
                    .clip(RoundedCornerShape(8.dp))
                    .background(
                        if (isSelected) Color(0xFFFF1744) else Color(0xFF424242)
                    )
                    .padding(if (isSelected) 2.dp else 0.dp)
            ) {
                AsyncImage(
                    model = story.mediaUrl,
                    contentDescription = null,
                    modifier = Modifier
                        .fillMaxSize()
                        .clip(RoundedCornerShape(8.dp)),
                    contentScale = ContentScale.Crop
                )
                
                // Contador de visualiza√ß√µes
                if (isSelected) {
                    Box(
                        modifier = Modifier
                            .align(Alignment.BottomCenter)
                            .padding(4.dp)
                            .background(Color(0xFFFF1744).copy(alpha = 0.9f), RoundedCornerShape(4.dp))
                            .padding(horizontal = 4.dp, vertical = 2.dp)
                    ) {
                        Row(
                            verticalAlignment = Alignment.CenterVertically,
                            horizontalArrangement = Arrangement.spacedBy(4.dp)
                        ) {
                            Text(
                                text = "$currentViews",
                                color = Color.White,
                                fontSize = 10.sp,
                                fontWeight = FontWeight.Bold
                            )
                            Icon(
                                imageVector = Icons.Default.Info,
                                contentDescription = null,
                                tint = Color.White,
                                modifier = Modifier.size(10.dp)
                            )
                        }
                    }
                }
            }
        }
    }
}

@Composable
private fun TabButton(
    text: String,
    isSelected: Boolean,
    onClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    Column(
        modifier = modifier
            .clickable(onClick = onClick)
            .padding(vertical = 12.dp)
    ) {
        Text(
            text = text,
            color = if (isSelected) Color.White else Color(0xFF999999),
            fontSize = 14.sp,
            fontWeight = if (isSelected) FontWeight.Bold else FontWeight.Normal,
            modifier = Modifier.align(Alignment.CenterHorizontally)
        )
        
        // Linha de sele√ß√£o
        if (isSelected) {
            HorizontalDivider(
                modifier = Modifier
                    .padding(top = 8.dp)
                    .fillMaxWidth(0.5f)
                    .align(Alignment.CenterHorizontally),
                thickness = 2.dp,
                color = Color(0xFF0095F6) // Azul Instagram
            )
        }
    }
}

@Composable
private fun InteractionsTab(analytics: com.taskgoapp.taskgo.core.model.StoryAnalytics?) {
    LazyColumn(
        modifier = Modifier.fillMaxSize(),
        contentPadding = PaddingValues(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        item {
            Text(
                text = "Intera√ß√µes",
                style = MaterialTheme.typography.titleMedium,
                color = Color.White.copy(alpha = 0.7f),
                fontSize = 12.sp,
                modifier = Modifier.padding(bottom = 8.dp)
            )
        }
        
        item {
            MetricRow(
                label = "A√ß√µes executadas a partir desse story",
                value = "0", // TODO: Implementar tracking de a√ß√µes
                showInfo = false
            )
        }
        
        item {
            MetricRow(
                label = "Visitas ao perfil",
                value = "${analytics?.interactions?.profileVisits ?: 0}",
                showInfo = false
            )
        }
        
        // Lista de visualiza√ß√µes
        item {
            Text(
                text = "Visualiza√ß√µes (${analytics?.views?.size ?: 0})",
                style = MaterialTheme.typography.titleMedium,
                color = Color.White,
                fontSize = 14.sp,
                fontWeight = FontWeight.Bold,
                modifier = Modifier.padding(top = 16.dp, bottom = 8.dp)
            )
        }
        
        if (analytics?.views.isNullOrEmpty()) {
            item {
                Text(
                    text = "Nenhuma visualiza√ß√£o ainda",
                    color = Color.White.copy(alpha = 0.5f),
                    fontSize = 14.sp,
                    modifier = Modifier.padding(vertical = 32.dp)
                )
            }
        } else {
            items(analytics?.views ?: emptyList(), key = { it.userId }) { view ->
                StoryViewRow(
                    view = view,
                    onSendMessage = { /* TODO: Implementar mensagem direta */ },
                    onMoreOptions = { /* TODO: Implementar op√ß√µes */ }
                )
            }
        }
    }
}

@Composable
private fun DiscoveryTab(analytics: com.taskgoapp.taskgo.core.model.StoryAnalytics?) {
    LazyColumn(
        modifier = Modifier.fillMaxSize(),
        contentPadding = PaddingValues(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        item {
            Text(
                text = "Descoberta",
                style = MaterialTheme.typography.titleMedium,
                color = Color.White.copy(alpha = 0.7f),
                fontSize = 12.sp,
                modifier = Modifier.padding(bottom = 8.dp)
            )
        }
        
        item {
            // Contas alcan√ßadas (destaque)
            Box(
                modifier = Modifier
                    .fillMaxWidth()
                    .background(Color(0xFF2A2A2A), RoundedCornerShape(8.dp))
                    .padding(16.dp)
            ) {
                Column {
                    Text(
                        text = "${analytics?.accountsReached ?: 0}",
                        style = MaterialTheme.typography.headlineMedium,
                        color = Color.White,
                        fontSize = 32.sp,
                        fontWeight = FontWeight.Bold
                    )
                    Text(
                        text = "Contas alcan√ßadas",
                        color = Color.White.copy(alpha = 0.7f),
                        fontSize = 14.sp,
                        modifier = Modifier.padding(top = 4.dp)
                    )
                }
            }
        }
        
        item {
            MetricRow(
                label = "Impress√µes",
                value = "${analytics?.impressions ?: 0}",
                showInfo = true
            )
        }
        
        item {
            MetricRow(
                label = "Seguidores",
                value = "${analytics?.followers ?: 0}",
                showInfo = true
            )
        }
        
        item {
            MetricRow(
                label = "Navega√ß√£o",
                value = "${analytics?.navigation ?: 0}",
                showInfo = true
            )
        }
        
        item {
            MetricRow(
                label = "Voltar",
                value = "${analytics?.back ?: 0}",
                showInfo = true
            )
        }
        
        item {
            MetricRow(
                label = "Alinhamentos",
                value = "${analytics?.alignments ?: 0}",
                showInfo = true
            )
        }
        
        item {
            MetricRow(
                label = "No story",
                value = "${analytics?.views?.size ?: 0}",
                showInfo = true
            )
        }
    }
}

@Composable
private fun MetricRow(
    label: String,
    value: String,
    showInfo: Boolean
) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 8.dp),
        horizontalArrangement = Arrangement.SpaceBetween,
        verticalAlignment = Alignment.CenterVertically
    ) {
        Row(
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.spacedBy(4.dp)
        ) {
            Text(
                text = label,
                color = Color.White,
                fontSize = 14.sp
            )
            if (showInfo) {
                Icon(
                    imageVector = Icons.Default.Info,
                    contentDescription = "Informa√ß√£o",
                    tint = Color.White.copy(alpha = 0.5f),
                    modifier = Modifier.size(14.dp)
                )
            }
        }
        Text(
            text = value,
            color = Color.White,
            fontSize = 14.sp,
            fontWeight = FontWeight.Bold
        )
    }
}

@Composable
private fun StoryViewRow(
    view: StoryView,
    onSendMessage: () -> Unit,
    onMoreOptions: () -> Unit
) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 8.dp),
        horizontalArrangement = Arrangement.SpaceBetween,
        verticalAlignment = Alignment.CenterVertically
    ) {
        Row(
            modifier = Modifier.weight(1f),
            horizontalArrangement = Arrangement.spacedBy(12.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            AsyncImage(
                model = view.userAvatarUrl ?: "",
                contentDescription = view.userName,
                modifier = Modifier
                    .size(40.dp)
                    .clip(CircleShape),
                contentScale = ContentScale.Crop
            )
            
            Column {
                Text(
                    text = view.userName,
                    color = Color.White,
                    fontSize = 14.sp,
                    fontWeight = FontWeight.Bold
                )
                Text(
                    text = formatViewTime(view.viewedAt),
                    color = Color.White.copy(alpha = 0.5f),
                    fontSize = 12.sp
                )
            }
        }
        
        Row(
            horizontalArrangement = Arrangement.spacedBy(8.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            IconButton(
                onClick = onMoreOptions,
                modifier = Modifier.size(32.dp)
            ) {
                Icon(
                    imageVector = Icons.Default.MoreVert,
                    contentDescription = "Mais op√ß√µes",
                    tint = Color.White.copy(alpha = 0.7f),
                    modifier = Modifier.size(20.dp)
                )
            }
            
            IconButton(
                onClick = onSendMessage,
                modifier = Modifier.size(32.dp)
            ) {
                Icon(
                    imageVector = Icons.AutoMirrored.Filled.Send,
                    contentDescription = "Enviar mensagem",
                    tint = Color.White.copy(alpha = 0.7f),
                    modifier = Modifier.size(20.dp)
                )
            }
        }
    }
}

private fun formatViewTime(date: java.util.Date): String {
    val now = java.util.Date()
    val diff = now.time - date.time
    val hours = (diff / (1000 * 60 * 60)).toInt()
    
    return when {
        hours < 1 -> "Agora"
        hours == 1 -> "1 hora atr√°s"
        hours < 24 -> "$hours horas atr√°s"
        else -> "${hours / 24} dias atr√°s"
    }
}

```

## [FRONTEND]: feature/feed/presentation/FeedScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.feed.presentation

import android.net.Uri
import android.util.Log
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.FilterList
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.design.TGIcon
import com.taskgoapp.taskgo.core.design.TGIcons
import com.taskgoapp.taskgo.feature.feed.presentation.components.PostCard
import com.taskgoapp.taskgo.feature.feed.presentation.components.RadiusFilterDialog
import com.taskgoapp.taskgo.feature.feed.presentation.components.StoriesSectionNew
import com.taskgoapp.taskgo.feature.feed.presentation.components.RatePostDialog
import com.taskgoapp.taskgo.feature.feed.presentation.components.BlockUserDialog
import com.taskgoapp.taskgo.feature.feed.presentation.components.StoriesViewerScreen
import com.taskgoapp.taskgo.feature.feed.presentation.components.CreateStoryScreen
import com.taskgoapp.taskgo.feature.feed.presentation.components.StoryAnalyticsScreen
import com.taskgoapp.taskgo.feature.feed.presentation.StoriesViewModel
import com.taskgoapp.taskgo.feature.feed.presentation.components.InlinePostCreator
import com.taskgoapp.taskgo.core.theme.*
import androidx.compose.ui.res.stringResource
import com.taskgoapp.taskgo.R
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import androidx.compose.runtime.collectAsState

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun FeedScreen(
    viewModel: FeedViewModel = hiltViewModel(),
    storiesViewModel: StoriesViewModel = hiltViewModel(),
    onNavigateToMessages: () -> Unit = {},
    onNavigateToUserProfile: ((String) -> Unit)? = null,
    onNavigateToSearch: () -> Unit = {},
    onNavigateToNotifications: () -> Unit = {},
    onNavigateToCart: () -> Unit = {},
    modifier: Modifier = Modifier,
    showTopBar: Boolean = true
) {
    val uiState by viewModel.uiState.collectAsState()
    val storiesUiState by storiesViewModel.uiState.collectAsState()
    var showRadiusFilterDialog by remember { mutableStateOf(false) }
    var showCreateStory by remember { mutableStateOf(false) }
    var selectedUserIdForStory by remember { mutableStateOf<String?>(null) }
    var showStoryAnalytics by remember { mutableStateOf<String?>(null) } // storyId quando analytics deve ser exibido

    // Observa stories com a localiza√ß√£o atual do feed (estilo IG)
    LaunchedEffect(uiState.userLocation, uiState.currentRadius) {
        storiesViewModel.loadStories(
            radiusKm = uiState.currentRadius,
            userLocation = uiState.userLocation
        )
    }

    // Estados para dialogs de a√ß√µes do post
    var postToRate by remember { mutableStateOf<com.taskgoapp.taskgo.core.model.Post?>(null) }
    var userToBlock by remember { mutableStateOf<Pair<String, String>?>(null) } // userId, userName

    
    Scaffold(
        topBar = {
            if (showTopBar) {
                AppTopBar(
                    title = "Feed",
                    backgroundColor = TaskGoGreen,
                    titleColor = Color.White,
                    actions = {
                        Row(
                            horizontalArrangement = Arrangement.spacedBy(4.dp),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            IconButton(
                                onClick = { showRadiusFilterDialog = true },
                                modifier = Modifier.size(36.dp)
                            ) {
                                Icon(
                                    imageVector = Icons.Default.FilterList,
                                    contentDescription = "Filtro de raio",
                                    tint = Color.White,
                                    modifier = Modifier.size(TGIcons.Sizes.Medium)
                                )
                            }
                            IconButton(
                                onClick = onNavigateToSearch,
                                modifier = Modifier.size(36.dp)
                            ) {
                                TGIcon(
                                    iconRes = TGIcons.Search,
                                    contentDescription = "Buscar",
                                    size = TGIcons.Sizes.Medium,
                                    tint = Color.White
                                )
                            }
                            IconButton(
                                onClick = onNavigateToNotifications,
                                modifier = Modifier.size(36.dp)
                            ) {
                                TGIcon(
                                    iconRes = TGIcons.Bell,
                                    contentDescription = "Notifica√ß√µes",
                                    size = TGIcons.Sizes.Medium,
                                    tint = Color.White
                                )
                            }
                            IconButton(
                                onClick = onNavigateToCart,
                                modifier = Modifier.size(36.dp)
                            ) {
                                TGIcon(
                                    iconRes = TGIcons.Cart,
                                    contentDescription = "Carrinho",
                                    size = TGIcons.Sizes.Medium,
                                    tint = Color.White
                                )
                            }
                            IconButton(
                                onClick = onNavigateToMessages,
                                modifier = Modifier.size(36.dp)
                            ) {
                                TGIcon(
                                    iconRes = TGIcons.Messages,
                                    contentDescription = "Mensagens",
                                    size = TGIcons.Sizes.Medium,
                                    tint = Color.White
                                )
                            }
                        }
                    }
                )
            }
        }
    ) { paddingValues ->
        when {
            uiState.isLoading && uiState.posts.isEmpty() -> {
                // Loading inicial
                Box(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(paddingValues),
                    contentAlignment = Alignment.Center
                ) {
                    CircularProgressIndicator(color = TaskGoGreen)
                }
            }
            
            uiState.error != null && uiState.posts.isEmpty() -> {
                // Erro
                Column(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(paddingValues)
                        .padding(16.dp),
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.Center
                ) {
                    Text(
                        text = uiState.error ?: "Erro desconhecido",
                        style = MaterialTheme.typography.bodyLarge,
                        color = MaterialTheme.colorScheme.error
                    )
                    Spacer(modifier = Modifier.height(16.dp))
                    Button(
                        onClick = {
                            viewModel.clearError()
                            viewModel.refreshFeed()
                        },
                        colors = ButtonDefaults.buttonColors(containerColor = TaskGoGreen)
                    ) {
                        Text("Tentar novamente")
                    }
                }
            }
            
            else -> {
                // Feed principal com Stories e Posts
                LazyColumn(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(paddingValues),
                    verticalArrangement = Arrangement.spacedBy(16.dp),
                    contentPadding = PaddingValues(vertical = 16.dp)
                ) {
                    // Campo de cria√ß√£o de post inline (apenas para prestadores e vendedores)
                    if (uiState.canPost) {
                        item {
                            InlinePostCreator(
                                userAvatarUrl = uiState.currentUserAvatarUrl,
                                userName = uiState.currentUserName,
                                isLoading = uiState.isLoading,
                                onPostCreated = { text, mediaUris ->
                                    viewModel.createPost(text, mediaUris)
                                },
                                modifier = Modifier.padding(horizontal = 16.dp)
                            )
                        }
                    }
                    
                    // Se√ß√£o de Stories (apenas prestadores e vendedores podem criar stories)
                    item {
                        StoriesSectionNew(
                            currentUserAvatarUrl = uiState.currentUserAvatarUrl,
                            currentUserName = uiState.currentUserName,
                            currentUserId = viewModel.currentUserId,
                            stories = storiesUiState.stories,
                            onCreateStoryClick = if (uiState.canPost) {
                                { showCreateStory = true }
                            } else {
                                null
                            },
                            onStoryClick = { userId ->
                                selectedUserIdForStory = userId
                            }
                        )
                    }
                    
                    // Divisor
                    item {
                        HorizontalDivider(
                            modifier = Modifier.padding(horizontal = 16.dp),
                            color = TaskGoBackgroundGray
                        )
                    }
                    
                    // Lista de posts
                    if (uiState.posts.isEmpty()) {
                        item {
                            // Empty state
                            Column(
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .padding(32.dp),
                                horizontalAlignment = Alignment.CenterHorizontally,
                                verticalArrangement = Arrangement.spacedBy(8.dp)
                            ) {
                                Text(
                                    text = "Nenhum post encontrado",
                                    style = MaterialTheme.typography.titleMedium,
                                    color = TaskGoTextGray
                                )
                                Text(
                                    text = "Seja o primeiro a postar na sua regi√£o!",
                                    style = MaterialTheme.typography.bodyMedium,
                                    color = TaskGoTextGray
                                )
                            }
                        }
                    } else {
                        items(
                            items = uiState.posts,
                            key = { it.id }
                        ) { post ->
                            PostCard(
                                post = post,
                                onLikeClick = { viewModel.likePost(post.id) },
                                onUnlikeClick = { viewModel.unlikePost(post.id) },
                                onDeleteClick = if (post.userId == viewModel.currentUserId) {
                                    { viewModel.deletePost(post.id) }
                                } else {
                                    null
                                },
                                onUserClick = onNavigateToUserProfile,
                                currentUserId = viewModel.currentUserId,
                                onCommentClick = { /* Dialog ser√° aberto automaticamente pelo PostCard */ },
                                onShareClick = { /* Dialog ser√° aberto automaticamente pelo PostCard */ },
                                onInterestClick = { hasInterest ->
                                    viewModel.setPostInterest(post.id, hasInterest)
                                },
                                onRatePostClick = {
                                    postToRate = post
                                },
                                onBlockUserClick = {
                                    userToBlock = post.userId to post.userName
                                },
                                modifier = Modifier.padding(horizontal = 16.dp)
                            )
                        }
                    }
                    
                    // Loading mais posts
                    if (uiState.isLoading && uiState.posts.isNotEmpty()) {
                        item {
                            CircularProgressIndicator(
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .padding(16.dp)
                                    .wrapContentWidth(Alignment.CenterHorizontally),
                                color = TaskGoGreen
                            )
                        }
                    }
                }
            }
        }
    }
    
    // Dialog para filtrar raio
    if (showRadiusFilterDialog) {
        RadiusFilterDialog(
            currentRadius = uiState.currentRadius,
            onRadiusChanged = { newRadius ->
                viewModel.updateRadius(newRadius)
            },
            onDismiss = { showRadiusFilterDialog = false }
        )
    }
    
    // Dialog de cria√ß√£o de Story
    if (showCreateStory) {
        CreateStoryScreen(
            onDismiss = { showCreateStory = false },
            onStoryCreated = {
                storiesViewModel.loadStories()
                showCreateStory = false
            }
        )
    }
    
    // Viewer de Stories
    selectedUserIdForStory?.let { userId ->
        val isOwnStory = userId == viewModel.currentUserId
        
        // Para stories pr√≥prias, buscar diretamente do reposit√≥rio
        // Para stories de outros, usar as j√° carregadas
        val userStoriesFlow = remember(userId) {
            if (isOwnStory) {
                storiesViewModel.observeUserStories(userId)
            } else {
                kotlinx.coroutines.flow.flowOf(storiesUiState.stories.filter { it.userId == userId })
            }
        }
        
        val userStories by userStoriesFlow.collectAsState(initial = emptyList())
        
        if (userStories.isNotEmpty()) {
            StoriesViewerScreen(
                stories = userStories,
                initialIndex = 0,
                onDismiss = { 
                    selectedUserIdForStory = null
                    showStoryAnalytics = null
                },
                onStoryViewed = { storyId ->
                    storiesViewModel.markStoryAsViewed(storyId)
                },
                onUserClick = onNavigateToUserProfile,
                currentUserId = viewModel.currentUserId,
                onSwipeUp = if (isOwnStory) { storyId: String ->
                    // Abrir analytics quando swipe up em story pr√≥pria
                    showStoryAnalytics = storyId
                } else null,
                onTrackAction = { storyId: String, action: String ->
                    // Track story actions
                    storiesViewModel.trackStoryAction(storyId, action)
                }
            )
        }
    }
    
    // Tela de Analytics de Story (swipe up)
    showStoryAnalytics?.let { storyId ->
        val story = storiesUiState.stories.find { it.id == storyId }
        val userStories = storiesUiState.stories.filter { it.userId == story?.userId }
        val ownerUserId = story?.userId ?: viewModel.currentUserId ?: ""
        
        if (ownerUserId.isNotBlank()) {
            StoryAnalyticsScreen(
                storyId = storyId,
                ownerUserId = ownerUserId,
                userStories = userStories,
                onDismiss = { showStoryAnalytics = null }
            )
        }
    }
    
    // Dialog de avalia√ß√£o de post
    postToRate?.let { post ->
        var existingRating by remember { mutableStateOf<com.taskgoapp.taskgo.core.model.PostRating?>(null) }
        
        LaunchedEffect(post.id) {
            withContext(Dispatchers.IO) {
                existingRating = viewModel.getUserPostRating(post.id)
            }
        }
        
        RatePostDialog(
            onDismiss = { postToRate = null },
            onConfirm = { rating, comment ->
                viewModel.ratePost(post.id, rating, comment)
                postToRate = null
            },
            existingRating = existingRating?.rating,
            existingComment = existingRating?.comment
        )
    }
    
    // Dialog de bloqueio de usu√°rio
    userToBlock?.let { (userId, userName) ->
        BlockUserDialog(
            userName = userName,
            onDismiss = { userToBlock = null },
            onConfirm = {
                viewModel.blockUser(userId)
                userToBlock = null
            }
        )
    }
}

```

## [FRONTEND]: feature/feed/presentation/FeedViewModel.kt

```kotlin
package com.taskgoapp.taskgo.feature.feed.presentation

import android.net.Uri
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.taskgoapp.taskgo.core.model.Post
import com.taskgoapp.taskgo.core.model.PostLocation
import com.taskgoapp.taskgo.core.model.Result
import com.taskgoapp.taskgo.core.model.AccountType
import com.taskgoapp.taskgo.core.location.LocationManager
import com.taskgoapp.taskgo.data.repository.FeedMediaRepository
import com.taskgoapp.taskgo.data.repository.FirebaseAuthRepository
import com.taskgoapp.taskgo.domain.usecase.*
import com.taskgoapp.taskgo.domain.repository.UserRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import javax.inject.Inject

data class FeedUiState(
    val posts: List<Post> = emptyList(),
    val isLoading: Boolean = false,
    val error: String? = null,
    val currentRadius: Double = 50.0, // Padr√£o 50km
    val userLocation: Pair<Double, Double>? = null, // latitude, longitude
    val userCity: String? = null,
    val userState: String? = null,
    val currentUserAvatarUrl: String? = null,
    val currentUserName: String = "",
    val canPost: Boolean = false, // Apenas prestadores e vendedores podem postar
    val selectedPost: Post? = null // Post selecionado para detalhes
)

@HiltViewModel
class FeedViewModel @Inject constructor(
    private val getFeedPostsUseCase: GetFeedPostsUseCase,
    private val createPostUseCase: CreatePostUseCase,
    private val likePostUseCase: LikePostUseCase,
    private val unlikePostUseCase: UnlikePostUseCase,
    private val deletePostUseCase: DeletePostUseCase,
    private val feedMediaRepository: FeedMediaRepository,
    private val locationManager: LocationManager,
    private val authRepository: FirebaseAuthRepository,
    private val userRepository: UserRepository,
    private val feedRepository: com.taskgoapp.taskgo.domain.repository.FeedRepository
) : ViewModel() {
    
    private val _uiState = MutableStateFlow(FeedUiState())
    val uiState: StateFlow<FeedUiState> = _uiState.asStateFlow()
    
    val currentUserId: String?
        get() = authRepository.getCurrentUser()?.uid
    
    init {
        loadUserLocation()
        loadCurrentUserProfile()
    }
    
    /**
     * Carrega dados do perfil do usu√°rio atual para exibir no feed
     */
    private fun loadCurrentUserProfile() {
        viewModelScope.launch {
            try {
                userRepository.observeCurrentUser().collect { user ->
                    user?.let {
                        // Apenas parceiros podem postar (unifica√ß√£o de prestadores e vendedores)
                        val canPost = it.accountType == AccountType.PARCEIRO || 
                                     it.accountType == AccountType.PRESTADOR || 
                                     it.accountType == AccountType.VENDEDOR
                        _uiState.value = _uiState.value.copy(
                            currentUserAvatarUrl = it.avatarUri,
                            currentUserName = it.name,
                            canPost = canPost
                        )
                    }
                }
            } catch (e: Exception) {
                android.util.Log.e("FeedViewModel", "Erro ao carregar perfil do usu√°rio: ${e.message}", e)
            }
        }
    }
    
    /**
     * Carrega a localiza√ß√£o do usu√°rio (GPS ou do perfil)
     */
    fun loadUserLocation() {
        viewModelScope.launch {
            try {
                // Tentar obter localiza√ß√£o GPS primeiro
                val location = locationManager.getCurrentLocation()
                if (location != null) {
                    val address = locationManager.getAddressFromLocation(
                        location.latitude,
                        location.longitude
                    )
                    _uiState.value = _uiState.value.copy(
                        userLocation = location.latitude to location.longitude,
                        userCity = address?.locality,
                        userState = address?.adminArea
                    )
                    loadFeed()
                } else {
                    // Fallback: usar cidade do perfil
                    loadLocationFromProfile()
                }
            } catch (e: Exception) {
                android.util.Log.e("FeedViewModel", "Erro ao obter localiza√ß√£o: ${e.message}", e)
                loadLocationFromProfile()
            }
        }
    }
    
    /**
     * Carrega localiza√ß√£o do perfil do usu√°rio
     */
    private fun loadLocationFromProfile() {
        viewModelScope.launch {
            try {
                userRepository.observeCurrentUser().collect { user ->
                    user?.let {
                        // Tentar obter coordenadas da cidade do perfil usando geocoding
                        val city = it.city
                        
                        if (city != null) {
                            // Se n√£o temos coordenadas GPS, vamos tentar usar geocoding
                            // Por enquanto, vamos apenas definir a cidade
                            // O feed pode ainda funcionar mas sem filtro por dist√¢ncia exata
                            _uiState.value = _uiState.value.copy(
                                userCity = city
                            )
                            // N√£o carregar feed aqui se n√£o tivermos coordenadas
                            // O usu√°rio precisar√° permitir acesso √† localiza√ß√£o
                        }
                    }
                }
            } catch (e: Exception) {
                android.util.Log.e("FeedViewModel", "Erro ao carregar localiza√ß√£o do perfil: ${e.message}", e)
                _uiState.value = _uiState.value.copy(error = "Erro ao carregar localiza√ß√£o")
            }
        }
    }
    
    /**
     * Carrega o feed de posts
     */
    fun loadFeed() {
        val location = _uiState.value.userLocation
        if (location == null) {
            _uiState.value = _uiState.value.copy(
                error = "Localiza√ß√£o n√£o dispon√≠vel. Por favor, permita o acesso √† localiza√ß√£o ou atualize sua cidade no perfil."
            )
            return
        }
        
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoading = true, error = null)
            
            try {
                getFeedPostsUseCase(
                    location.first,
                    location.second,
                    _uiState.value.currentRadius
                ).collect { posts ->
                    _uiState.value = _uiState.value.copy(
                        posts = posts,
                        isLoading = false
                    )
                }
            } catch (e: Exception) {
                android.util.Log.e("FeedViewModel", "Erro ao carregar feed: ${e.message}", e)
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = "Erro ao carregar feed: ${e.message}"
                )
            }
        }
    }
    
    /**
     * Atualiza o feed (pull to refresh)
     */
    fun refreshFeed() {
        loadUserLocation()
    }
    
    /**
     * Cria um novo post
     */
    fun createPost(text: String, mediaUris: List<Uri>) {
        val location = _uiState.value.userLocation
        val userId = currentUserId
        
        if (userId == null) {
            _uiState.value = _uiState.value.copy(error = "Usu√°rio n√£o autenticado")
            return
        }
        
        // Verificar se o usu√°rio pode postar (apenas prestadores e vendedores)
        if (!_uiState.value.canPost) {
            _uiState.value = _uiState.value.copy(error = "Apenas prestadores e vendedores podem criar posts")
            return
        }
        
        if (location == null) {
            _uiState.value = _uiState.value.copy(error = "Localiza√ß√£o n√£o dispon√≠vel para criar post")
            return
        }
        
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoading = true, error = null)
            
            try {
                // Determinar tipos de m√≠dia (assumir que s√£o imagens por padr√£o)
                // Em uma implementa√ß√£o completa, detectar tipo de arquivo
                val mediaTypes = mediaUris.map { uri ->
                    val path = uri.toString().lowercase()
                    when {
                        path.contains("video") || path.contains(".mp4") || path.contains(".mov") -> "video"
                        else -> "image"
                    }
                }
                
                // Fazer upload das m√≠dias primeiro
                val mediaUrls = if (mediaUris.isNotEmpty()) {
                    val uploadResults = feedMediaRepository.uploadPostMediaBatch(
                        mediaUris,
                        userId,
                        mediaTypes
                    )
                    
                    when (uploadResults) {
                        is Result.Success -> uploadResults.data
                        is Result.Error -> {
                            _uiState.value = _uiState.value.copy(
                                isLoading = false,
                                error = "Erro ao fazer upload das m√≠dias: ${uploadResults.exception.message}"
                            )
                            return@launch
                        }
                        else -> {
                            _uiState.value = _uiState.value.copy(
                                isLoading = false,
                                error = "Erro desconhecido ao fazer upload das m√≠dias"
                            )
                            return@launch
                        }
                    }
                } else {
                    emptyList()
                }
                
                // Criar localiza√ß√£o do post
                val postLocation = PostLocation(
                    city = _uiState.value.userCity ?: "",
                    state = "", // Estado n√£o dispon√≠vel no UserProfile, pode ser preenchido via geocoding se necess√°rio
                    latitude = location.first,
                    longitude = location.second
                )
                
                // Criar post no Firestore
                val result = try {
                    createPostUseCase(text, mediaUrls, mediaTypes, postLocation)
                } catch (e: Exception) {
                    android.util.Log.e("FeedViewModel", "Erro ao chamar createPostUseCase: ${e.message}", e)
                    com.taskgoapp.taskgo.core.model.Result.Error(e)
                }
                
                when (result) {
                    is Result.Success -> {
                        _uiState.value = _uiState.value.copy(
                            isLoading = false,
                            error = null
                        )
                        // Feed ser√° atualizado automaticamente pelo listener
                        android.util.Log.d("FeedViewModel", "Post criado com sucesso")
                    }
                    is Result.Error -> {
                        android.util.Log.e("FeedViewModel", "Erro ao criar post: ${result.exception.message}", result.exception)
                        _uiState.value = _uiState.value.copy(
                            isLoading = false,
                            error = "Erro ao criar post: ${result.exception.message ?: "Erro desconhecido"}"
                        )
                    }
                    else -> {
                        android.util.Log.w("FeedViewModel", "Resultado desconhecido ao criar post: $result")
                        _uiState.value = _uiState.value.copy(
                            isLoading = false,
                            error = "Erro desconhecido ao criar post"
                        )
                    }
                }
            } catch (e: Exception) {
                android.util.Log.e("FeedViewModel", "Erro ao criar post: ${e.message}", e)
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = "Erro ao criar post: ${e.message}"
                )
            }
        }
    }
    
    /**
     * Adiciona like em um post
     */
    fun likePost(postId: String) {
        val userId = currentUserId ?: return
        
        viewModelScope.launch {
            val result = likePostUseCase(postId, userId)
            if (result is Result.Error) {
                android.util.Log.e("FeedViewModel", "Erro ao curtir post: ${result.exception.message}", result.exception)
            }
        }
    }
    
    /**
     * Remove like de um post
     */
    fun unlikePost(postId: String) {
        val userId = currentUserId ?: return
        
        viewModelScope.launch {
            val result = unlikePostUseCase(postId, userId)
            if (result is Result.Error) {
                android.util.Log.e("FeedViewModel", "Erro ao descurtir post: ${result.exception.message}", result.exception)
            }
        }
    }
    
    /**
     * Deleta um post
     */
    fun deletePost(postId: String) {
        viewModelScope.launch {
            val result = deletePostUseCase(postId)
            if (result is Result.Error) {
                android.util.Log.e("FeedViewModel", "Erro ao deletar post: ${result.exception.message}", result.exception)
                _uiState.value = _uiState.value.copy(error = "Erro ao deletar post: ${result.exception.message}")
            }
        }
    }
    
    /**
     * Atualiza o raio de busca
     */
    fun updateRadius(newRadius: Double) {
        _uiState.value = _uiState.value.copy(currentRadius = newRadius)
        loadFeed()
    }
    
    /**
     * Observa coment√°rios de um post
     */
    fun observePostComments(postId: String): Flow<List<com.taskgoapp.taskgo.feature.feed.presentation.components.CommentItem>> {
        return feedRepository.observePostComments(postId)
    }
    
    /**
     * Cria um coment√°rio em um post
     */
    fun createComment(postId: String, text: String) {
        viewModelScope.launch {
            val result = feedRepository.createComment(postId, text)
            when (result) {
                is Result.Success -> {
                    android.util.Log.d("FeedViewModel", "Coment√°rio criado com sucesso: ${result.data}")
                }
                is Result.Error -> {
                    android.util.Log.e("FeedViewModel", "Erro ao criar coment√°rio: ${result.exception.message}", result.exception)
                    _uiState.value = _uiState.value.copy(error = "Erro ao criar coment√°rio: ${result.exception.message}")
                }
                is Result.Loading -> {
                    // Loading state - n√£o precisa fazer nada
                }
            }
        }
    }
    
    /**
     * Variante suspensa para cria√ß√£o de coment√°rio com retorno imediato de Result
     * √ötil em cen√°rios de UI que precisam sinalizar erro sem depender do listener
     */
    suspend fun createCommentAwait(postId: String, text: String): Result<String> {
        return try {
            feedRepository.createComment(postId, text)
        } catch (e: Exception) {
            Result.Error(e)
        }
    }
    
    /**
     * Deleta um coment√°rio
     */
    fun deleteComment(postId: String, commentId: String) {
        viewModelScope.launch {
            val result = feedRepository.deleteComment(postId, commentId)
            when (result) {
                is Result.Success -> {
                    android.util.Log.d("FeedViewModel", "Coment√°rio deletado com sucesso")
                }
                is Result.Error -> {
                    android.util.Log.e("FeedViewModel", "Erro ao deletar coment√°rio: ${result.exception.message}", result.exception)
                    _uiState.value = _uiState.value.copy(error = "Erro ao deletar coment√°rio: ${result.exception.message}")
                }
                is Result.Loading -> {
                    // Loading state - n√£o precisa fazer nada
                }
            }
        }
    }
    
    /**
     * Limpa o erro
     */
    fun clearError() {
        _uiState.value = _uiState.value.copy(error = null)
    }
    
    /**
     * Carrega um post espec√≠fico por ID
     */
    fun loadPostById(postId: String) {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoading = true, error = null, selectedPost = null)
            try {
                val post = feedRepository.getPostById(postId)
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    selectedPost = post,
                    error = if (post == null) "Post n√£o encontrado" else null
                )
            } catch (e: Exception) {
                android.util.Log.e("FeedViewModel", "Erro ao carregar post: ${e.message}", e)
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = "Erro ao carregar post: ${e.message}",
                    selectedPost = null
                )
            }
        }
    }
    
    /**
     * Define interesse em um post (Tenho interesse / N√£o tenho interesse)
     */
    fun setPostInterest(postId: String, isInterested: Boolean) {
        viewModelScope.launch {
            try {
                when (val result = feedRepository.setPostInterest(postId, isInterested)) {
                    is Result.Success -> {
                        android.util.Log.d("FeedViewModel", "Interesse definido: $isInterested para post $postId")
                        // Recarregar posts para atualizar o feed
                        refreshFeed()
                    }
                    is Result.Error -> {
                        android.util.Log.e("FeedViewModel", "Erro ao definir interesse: ${result.exception.message}")
                        _uiState.value = _uiState.value.copy(error = "Erro ao definir interesse: ${result.exception.message}")
                    }
                    is Result.Loading -> {}
                }
            } catch (e: Exception) {
                android.util.Log.e("FeedViewModel", "Erro ao definir interesse: ${e.message}", e)
                _uiState.value = _uiState.value.copy(error = "Erro ao definir interesse: ${e.message}")
            }
        }
    }
    
    /**
     * Remove interesse de um post
     */
    fun removePostInterest(postId: String) {
        viewModelScope.launch {
            try {
                when (val result = feedRepository.removePostInterest(postId)) {
                    is Result.Success -> {
                        android.util.Log.d("FeedViewModel", "Interesse removido do post $postId")
                        refreshFeed()
                    }
                    is Result.Error -> {
                        android.util.Log.e("FeedViewModel", "Erro ao remover interesse: ${result.exception.message}")
                    }
                    is Result.Loading -> {}
                }
            } catch (e: Exception) {
                android.util.Log.e("FeedViewModel", "Erro ao remover interesse: ${e.message}", e)
            }
        }
    }
    
    /**
     * Avalia um post (1-5 estrelas)
     */
    fun ratePost(postId: String, rating: Int, comment: String? = null) {
        viewModelScope.launch {
            try {
                when (val result = feedRepository.ratePost(postId, rating, comment)) {
                    is Result.Success -> {
                        android.util.Log.d("FeedViewModel", "Post $postId avaliado com $rating estrelas")
                        // Recarregar post para atualizar avalia√ß√£o
                        loadPostById(postId)
                    }
                    is Result.Error -> {
                        android.util.Log.e("FeedViewModel", "Erro ao avaliar post: ${result.exception.message}")
                        _uiState.value = _uiState.value.copy(error = "Erro ao avaliar post: ${result.exception.message}")
                    }
                    is Result.Loading -> {}
                }
            } catch (e: Exception) {
                android.util.Log.e("FeedViewModel", "Erro ao avaliar post: ${e.message}", e)
                _uiState.value = _uiState.value.copy(error = "Erro ao avaliar post: ${e.message}")
            }
        }
    }
    
    /**
     * Obt√©m avalia√ß√£o do usu√°rio atual para um post
     */
    suspend fun getUserPostRating(postId: String): com.taskgoapp.taskgo.core.model.PostRating? {
        return feedRepository.getUserPostRating(postId)
    }
    
    /**
     * Bloqueia um usu√°rio
     */
    fun blockUser(userId: String) {
        viewModelScope.launch {
            try {
                when (val result = feedRepository.blockUser(userId)) {
                    is Result.Success -> {
                        android.util.Log.d("FeedViewModel", "Usu√°rio $userId bloqueado")
                        // Recarregar feed para remover posts do usu√°rio bloqueado
                        refreshFeed()
                    }
                    is Result.Error -> {
                        android.util.Log.e("FeedViewModel", "Erro ao bloquear usu√°rio: ${result.exception.message}")
                        _uiState.value = _uiState.value.copy(error = "Erro ao bloquear usu√°rio: ${result.exception.message}")
                    }
                    is Result.Loading -> {}
                }
            } catch (e: Exception) {
                android.util.Log.e("FeedViewModel", "Erro ao bloquear usu√°rio: ${e.message}", e)
                _uiState.value = _uiState.value.copy(error = "Erro ao bloquear usu√°rio: ${e.message}")
            }
        }
    }
    
    /**
     * Desbloqueia um usu√°rio
     */
    fun unblockUser(userId: String) {
        viewModelScope.launch {
            try {
                when (val result = feedRepository.unblockUser(userId)) {
                    is Result.Success -> {
                        android.util.Log.d("FeedViewModel", "Usu√°rio $userId desbloqueado")
                        refreshFeed()
                    }
                    is Result.Error -> {
                        android.util.Log.e("FeedViewModel", "Erro ao desbloquear usu√°rio: ${result.exception.message}")
                    }
                    is Result.Loading -> {}
                }
            } catch (e: Exception) {
                android.util.Log.e("FeedViewModel", "Erro ao desbloquear usu√°rio: ${e.message}", e)
            }
        }
    }
    
    /**
     * Verifica se um usu√°rio est√° bloqueado
     */
    suspend fun isUserBlocked(userId: String): Boolean {
        return feedRepository.isUserBlocked(userId)
    }
}

```

## [FRONTEND]: feature/feed/presentation/PostDetailScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.feed.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.feature.feed.presentation.components.PostCard
import com.taskgoapp.taskgo.core.theme.*

/**
 * Tela de detalhes de um post espec√≠fico
 * Acess√≠vel via deep link: https://taskgo.app/post/{postId}
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PostDetailScreen(
    postId: String,
    onBackClick: () -> Unit,
    onNavigateToUserProfile: ((String) -> Unit)? = null,
    viewModel: FeedViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    
    // Carregar post espec√≠fico quando a tela for aberta
    LaunchedEffect(postId) {
        viewModel.loadPostById(postId)
    }
    
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Post",
                onBackClick = onBackClick,
                backgroundColor = TaskGoGreen,
                titleColor = androidx.compose.ui.graphics.Color.White
            )
        }
    ) { paddingValues ->
        when {
            uiState.isLoading -> {
                Box(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(paddingValues),
                    contentAlignment = androidx.compose.ui.Alignment.Center
                ) {
                    CircularProgressIndicator(color = TaskGoGreen)
                }
            }
            uiState.error != null -> {
                Column(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(paddingValues)
                        .padding(16.dp),
                    verticalArrangement = Arrangement.Center,
                    horizontalAlignment = androidx.compose.ui.Alignment.CenterHorizontally
                ) {
                    Text(
                        text = uiState.error ?: "Erro ao carregar post",
                        color = MaterialTheme.colorScheme.error,
                        style = MaterialTheme.typography.bodyLarge
                    )
                    Spacer(modifier = Modifier.height(16.dp))
                    Button(onClick = { viewModel.loadPostById(postId) }) {
                        Text("Tentar novamente")
                    }
                }
            }
            else -> {
                val post = uiState.selectedPost
                if (post != null) {
                    Column(
                        modifier = Modifier
                            .fillMaxSize()
                            .padding(paddingValues)
                            .verticalScroll(rememberScrollState())
                    ) {
                        PostCard(
                            post = post,
                            onLikeClick = { viewModel.likePost(post.id) },
                            onUnlikeClick = { viewModel.unlikePost(post.id) },
                            onDeleteClick = if (post.userId == viewModel.currentUserId) {
                                { 
                                    viewModel.deletePost(post.id)
                                    onBackClick()
                                }
                            } else null,
                            onUserClick = onNavigateToUserProfile,
                            currentUserId = viewModel.currentUserId,
                            onCommentClick = { /* Dialog ser√° aberto automaticamente pelo PostCard */ },
                            onShareClick = { /* Dialog ser√° aberto automaticamente pelo PostCard */ },
                            onInterestClick = { hasInterest ->
                                // TODO: Implementar l√≥gica de interesse
                                android.util.Log.d("PostDetailScreen", "Interesse: $hasInterest para post ${post.id}")
                            },
                            onRatePostClick = {
                                // TODO: Implementar l√≥gica de avalia√ß√£o
                                android.util.Log.d("PostDetailScreen", "Avaliar post ${post.id}")
                            },
                            onBlockUserClick = {
                                // TODO: Implementar l√≥gica de bloqueio
                                android.util.Log.d("PostDetailScreen", "Bloquear usu√°rio ${post.userId}")
                            },
                            modifier = Modifier.fillMaxWidth()
                        )
                    }
                } else {
                    Box(
                        modifier = Modifier
                            .fillMaxSize()
                            .padding(paddingValues),
                        contentAlignment = androidx.compose.ui.Alignment.Center
                    ) {
                        Text(
                            text = "Post n√£o encontrado",
                            style = MaterialTheme.typography.bodyLarge
                        )
                    }
                }
            }
        }
    }
}

```

## [FRONTEND]: feature/feed/presentation/StoriesViewModel.kt

```kotlin
package com.taskgoapp.taskgo.feature.feed.presentation

import android.net.Uri
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.taskgoapp.taskgo.core.model.Result
import com.taskgoapp.taskgo.core.model.Story
import com.taskgoapp.taskgo.core.model.StoryLocation
import com.taskgoapp.taskgo.data.repository.FeedMediaRepository
import com.taskgoapp.taskgo.data.repository.FirebaseAuthRepository
import com.taskgoapp.taskgo.domain.repository.StoriesRepository
import com.taskgoapp.taskgo.domain.repository.UserRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import java.util.Date
import java.util.UUID
import javax.inject.Inject

data class StoriesUiState(
    val stories: List<Story> = emptyList(),
    val userStories: Map<String, List<Story>> = emptyMap(), // userId -> List<Story>
    val isLoading: Boolean = false,
    val error: String? = null,
    val currentUserId: String? = null,
    val currentUserName: String = "",
    val currentUserAvatarUrl: String? = null
)

@HiltViewModel
class StoriesViewModel @Inject constructor(
    private val storiesRepository: StoriesRepository,
    private val feedMediaRepository: FeedMediaRepository,
    private val authRepository: FirebaseAuthRepository,
    private val userRepository: UserRepository
) : ViewModel() {
    
    private val _uiState = MutableStateFlow(StoriesUiState())
    val uiState: StateFlow<StoriesUiState> = _uiState.asStateFlow()
    
    val currentUserId: String?
        get() = authRepository.getCurrentUser()?.uid
    
    init {
        loadCurrentUserProfile()
        loadStories(50.0, null)
    }
    
    private fun loadCurrentUserProfile() {
        viewModelScope.launch {
            userRepository.observeCurrentUser().collect { user ->
                user?.let {
                    _uiState.value = _uiState.value.copy(
                        currentUserId = it.id,
                        currentUserName = it.name,
                        currentUserAvatarUrl = it.avatarUri
                    )
                }
            }
        }
    }
    
    fun loadStories(radiusKm: Double = 50.0, userLocation: Pair<Double, Double>? = null) {
        val userId = currentUserId ?: return
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoading = true, error = null)
            try {
                storiesRepository.observeStories(userId, radiusKm, userLocation)
                    .catch { e ->
                        android.util.Log.e("StoriesViewModel", "Erro ao carregar stories: ${e.message}", e)
                        _uiState.value = _uiState.value.copy(
                            isLoading = false,
                            error = "Erro ao carregar stories: ${e.message}"
                        )
                    }
                    .collect { stories ->
                        // Agrupar stories por usu√°rio
                        val grouped = stories.groupBy { it.userId }
                        _uiState.value = _uiState.value.copy(
                            stories = stories,
                            userStories = grouped,
                            isLoading = false,
                            error = null
                        )
                    }
            } catch (e: Exception) {
                android.util.Log.e("StoriesViewModel", "Erro ao observar stories: ${e.message}", e)
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = "Erro ao carregar stories: ${e.message}"
                )
            }
        }
    }
    
    fun observeUserStories(userId: String): Flow<List<Story>> {
        val currentUserId = currentUserId ?: return flowOf(emptyList())
        return storiesRepository.observeUserStories(userId, currentUserId)
            .catch { e ->
                android.util.Log.e("StoriesViewModel", "Erro ao carregar stories do usu√°rio: ${e.message}", e)
                emit(emptyList())
            }
    }
    
    suspend fun createStory(
        mediaUri: Uri,
        mediaType: String,
        caption: String? = null,
        location: StoryLocation? = null
    ): Result<String> {
        val userId = currentUserId ?: return Result.Error(Exception("Usu√°rio n√£o autenticado"))
        val userName = _uiState.value.currentUserName.ifEmpty { "Usu√°rio" }
        val userAvatarUrl = _uiState.value.currentUserAvatarUrl
        
        return try {
            _uiState.value = _uiState.value.copy(isLoading = true, error = null)
            
            // Fazer upload da m√≠dia
            val uploadResult = feedMediaRepository.uploadStoryMedia(mediaUri, userId, mediaType)
            
            when (uploadResult) {
                is Result.Success -> {
                    val mediaUrl = uploadResult.data
                    val createdAt = Date()
                    val expiresAt = Date(createdAt.time + 24 * 60 * 60 * 1000) // 24 horas
                    
                    val story = Story(
                        id = UUID.randomUUID().toString(),
                        userId = userId,
                        userName = userName,
                        userAvatarUrl = userAvatarUrl,
                        mediaUrl = mediaUrl,
                        mediaType = mediaType,
                        caption = caption,
                        createdAt = createdAt,
                        expiresAt = expiresAt,
                        location = location
                    )
                    
                    val result = storiesRepository.createStory(story)
                    
                    // Adicionar story localmente √† lista para aparecer imediatamente
                    // O observeStories vai sincronizar com o Firestore depois
                    if (result is Result.Success) {
                        val currentStories = _uiState.value.stories
                        val updatedStories = currentStories + story
                        val grouped = updatedStories.groupBy { it.userId }
                        _uiState.value = _uiState.value.copy(
                            stories = updatedStories,
                            userStories = grouped,
                            isLoading = false
                        )
                        android.util.Log.d("StoriesViewModel", "Story adicionado localmente: ${story.id}, Total stories: ${updatedStories.size}")
                    } else {
                        _uiState.value = _uiState.value.copy(isLoading = false)
                    }
                    
                    result
                }
                is Result.Error -> {
                    _uiState.value = _uiState.value.copy(
                        isLoading = false,
                        error = "Erro ao fazer upload: ${uploadResult.exception.message}"
                    )
                    Result.Error(uploadResult.exception)
                }
                else -> {
                    _uiState.value = _uiState.value.copy(isLoading = false)
                    Result.Error(Exception("Resultado desconhecido do upload"))
                }
            }
        } catch (e: Exception) {
            android.util.Log.e("StoriesViewModel", "Erro ao criar story: ${e.message}", e)
            _uiState.value = _uiState.value.copy(
                isLoading = false,
                error = "Erro ao criar story: ${e.message}"
            )
            Result.Error(e)
        }
    }
    
    fun markStoryAsViewed(storyId: String) {
        val userId = currentUserId ?: return
        viewModelScope.launch {
            storiesRepository.markStoryAsViewed(storyId, userId)
        }
    }
    
    fun trackStoryAction(storyId: String, action: String) {
        val userId = currentUserId ?: return
        viewModelScope.launch {
            storiesRepository.trackStoryAction(storyId, userId, action)
        }
    }
    
    fun deleteStory(storyId: String) {
        val userId = currentUserId ?: return
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoading = true)
            val result = storiesRepository.deleteStory(storyId, userId)
            _uiState.value = _uiState.value.copy(isLoading = false)
            
            when (result) {
                is Result.Error -> {
                    _uiState.value = _uiState.value.copy(error = result.exception.message)
                }
                else -> {
                    // Story deletada com sucesso
                }
            }
        }
    }
    
    fun clearError() {
        _uiState.value = _uiState.value.copy(error = null)
    }
}


```

## [FRONTEND]: feature/feed/presentation/StoryAnalyticsViewModel.kt

```kotlin
package com.taskgoapp.taskgo.feature.feed.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.taskgoapp.taskgo.core.model.StoryAnalytics
import com.taskgoapp.taskgo.domain.repository.StoriesRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import javax.inject.Inject

data class StoryAnalyticsUiState(
    val analytics: StoryAnalytics? = null,
    val isLoading: Boolean = false,
    val error: String? = null
)

@HiltViewModel
class StoryAnalyticsViewModel @Inject constructor(
    private val storiesRepository: StoriesRepository
) : ViewModel() {
    
    private val _uiState = MutableStateFlow(StoryAnalyticsUiState())
    val uiState: StateFlow<StoryAnalyticsUiState> = _uiState.asStateFlow()
    
    fun loadAnalytics(storyId: String, ownerUserId: String) {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoading = true, error = null)
            
            storiesRepository.observeStoryAnalytics(storyId, ownerUserId)
                .catch { e ->
                    android.util.Log.e("StoryAnalyticsViewModel", "Erro ao carregar analytics: ${e.message}", e)
                    _uiState.value = _uiState.value.copy(
                        isLoading = false,
                        error = "Erro ao carregar analytics: ${e.message}"
                    )
                }
                .collect { analytics ->
                    _uiState.value = _uiState.value.copy(
                        analytics = analytics,
                        isLoading = false,
                        error = null
                    )
                }
        }
    }
    
    fun trackAction(storyId: String, userId: String, action: String) {
        viewModelScope.launch {
            storiesRepository.trackStoryAction(storyId, userId, action)
        }
    }
    
    fun clearError() {
        _uiState.value = _uiState.value.copy(error = null)
    }
}

```

## [FRONTEND]: feature/feed/presentation/UserFeedScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.feed.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.taskgoapp.taskgo.feature.feed.presentation.components.PostCard
import com.taskgoapp.taskgo.core.theme.*

@Composable
fun UserFeedScreen(
    userId: String,
    viewModel: UserFeedViewModel = hiltViewModel(),
    modifier: Modifier = Modifier
) {
    val uiState by viewModel.uiState.collectAsState()
    val currentUserId = remember(userId) { userId }
    
    LaunchedEffect(currentUserId) {
        viewModel.loadUserPosts(currentUserId)
    }
    
    Box(
        modifier = modifier.fillMaxSize()
    ) {
        when {
            uiState.isLoading && uiState.posts.isEmpty() -> {
                // Loading inicial
                CircularProgressIndicator(
                    modifier = Modifier.align(Alignment.Center),
                    color = TaskGoGreen
                )
            }
            
            uiState.error != null && uiState.posts.isEmpty() -> {
                // Erro
                Column(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(16.dp),
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.Center
                ) {
                    Text(
                        text = uiState.error ?: "Erro desconhecido",
                        style = MaterialTheme.typography.bodyLarge,
                        color = MaterialTheme.colorScheme.error
                    )
                    Spacer(modifier = Modifier.height(16.dp))
                    Button(
                        onClick = {
                            viewModel.clearError()
                            viewModel.loadUserPosts(currentUserId)
                        },
                        colors = ButtonDefaults.buttonColors(
                            containerColor = TaskGoGreen
                        )
                    ) {
                        Text("Tentar novamente")
                    }
                }
            }
            
            uiState.posts.isEmpty() -> {
                // Empty state
                Column(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(16.dp),
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.Center
                ) {
                    Text(
                        text = "Nenhum post ainda",
                        style = MaterialTheme.typography.titleMedium,
                        color = TaskGoTextGray
                    )
                    Spacer(modifier = Modifier.height(8.dp))
                    Text(
                        text = "Este usu√°rio ainda n√£o publicou nada",
                        style = MaterialTheme.typography.bodyMedium,
                        color = TaskGoTextGray
                    )
                }
            }
            
            else -> {
                // Lista de posts
                LazyColumn(
                    modifier = Modifier.fillMaxSize(),
                    contentPadding = PaddingValues(16.dp),
                    verticalArrangement = Arrangement.spacedBy(16.dp)
                ) {
                    items(
                        items = uiState.posts,
                        key = { it.id }
                    ) { post ->
                        PostCard(
                            post = post,
                            onLikeClick = { /* Like ser√° implementado quando necess√°rio */ },
                            onUnlikeClick = { /* Unlike ser√° implementado quando necess√°rio */ },
                            onDeleteClick = null, // Feed do perfil n√£o permite deletar
                            currentUserId = null, // TODO: Obter currentUserId se necess√°rio
                            onCommentClick = { /* Dialog ser√° aberto automaticamente pelo PostCard */ },
                            onShareClick = { /* Dialog ser√° aberto automaticamente pelo PostCard */ },
                            onInterestClick = { /* TODO: Implementar */ },
                            onRatePostClick = { /* TODO: Implementar */ },
                            onBlockUserClick = { /* TODO: Implementar */ }
                        )
                    }
                    
                    // Loading mais posts (se implementar pagina√ß√£o)
                    if (uiState.isLoading && uiState.posts.isNotEmpty()) {
                        item {
                            CircularProgressIndicator(
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .padding(16.dp)
                                    .wrapContentWidth(Alignment.CenterHorizontally),
                                color = TaskGoGreen
                            )
                        }
                    }
                }
            }
        }
    }
}

```

## [FRONTEND]: feature/feed/presentation/UserFeedViewModel.kt

```kotlin
package com.taskgoapp.taskgo.feature.feed.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.taskgoapp.taskgo.core.model.Post
import com.taskgoapp.taskgo.core.model.Result
import com.taskgoapp.taskgo.domain.usecase.GetUserPostsUseCase
import com.taskgoapp.taskgo.domain.usecase.DeletePostUseCase
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import javax.inject.Inject

data class UserFeedUiState(
    val posts: List<Post> = emptyList(),
    val isLoading: Boolean = false,
    val error: String? = null
)

@HiltViewModel
class UserFeedViewModel @Inject constructor(
    private val getUserPostsUseCase: GetUserPostsUseCase,
    private val deletePostUseCase: DeletePostUseCase
) : ViewModel() {
    
    private val _uiState = MutableStateFlow(UserFeedUiState())
    val uiState: StateFlow<UserFeedUiState> = _uiState.asStateFlow()
    
    /**
     * Carrega posts de um usu√°rio espec√≠fico
     */
    fun loadUserPosts(userId: String) {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoading = true, error = null)
            
            try {
                getUserPostsUseCase(userId).collect { posts ->
                    _uiState.value = _uiState.value.copy(
                        posts = posts,
                        isLoading = false
                    )
                }
            } catch (e: Exception) {
                android.util.Log.e("UserFeedViewModel", "Erro ao carregar posts do usu√°rio: ${e.message}", e)
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = "Erro ao carregar posts: ${e.message}"
                )
            }
        }
    }
    
    /**
     * Deleta um post
     */
    fun deletePost(postId: String) {
        viewModelScope.launch {
            val result = deletePostUseCase(postId)
            if (result is Result.Error) {
                android.util.Log.e("UserFeedViewModel", "Erro ao deletar post: ${result.exception.message}", result.exception)
                _uiState.value = _uiState.value.copy(error = "Erro ao deletar post: ${result.exception.message}")
            }
        }
    }
    
    /**
     * Limpa o erro
     */
    fun clearError() {
        _uiState.value = _uiState.value.copy(error = null)
    }
}

```

# Features - home


## [FRONTEND]: feature/home/presentation/HomeScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.home.presentation

import androidx.annotation.DrawableRes
import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.ExperimentalFoundationApi
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.horizontalScroll
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.pager.HorizontalPager
import androidx.compose.foundation.pager.rememberPagerState
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Star
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.compose.ui.layout.ContentScale
import androidx.hilt.navigation.compose.hiltViewModel
import android.util.Log
import coil.compose.AsyncImage
import coil.request.ImageRequest
import androidx.compose.ui.platform.LocalContext
import com.taskgoapp.taskgo.R
import com.taskgoapp.taskgo.core.design.*
import com.taskgoapp.taskgo.core.data.models.*
import com.taskgoapp.taskgo.core.data.models.ServiceCategory as DataServiceCategory
import com.taskgoapp.taskgo.core.model.Product
import com.taskgoapp.taskgo.core.model.HomeBanner
import com.taskgoapp.taskgo.core.theme.*
import com.taskgoapp.taskgo.core.location.LocationManager
import com.taskgoapp.taskgo.core.location.calculateDistance
import com.taskgoapp.taskgo.core.maps.ProvidersMapView
import com.taskgoapp.taskgo.data.firestore.models.ServiceFirestore
import androidx.core.content.ContextCompat
import android.location.Location as AndroidLocation
import kotlinx.coroutines.delay
import java.text.NumberFormat
import java.util.Locale

enum class FilterType {
    SERVICES, PRODUCTS
}

data class HomeBannerContent(
    val id: String,
    @DrawableRes val imageRes: Int? = null,
    val imageUrl: String? = null,
    val title: String,
    val subtitle: String,
    val actionLabel: String,
    val onClick: () -> Unit
)

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun HomeScreen(
    onNavigateToService: (String) -> Unit,
    onNavigateToProduct: (String) -> Unit,
    onNavigateToCreateWorkOrder: () -> Unit,
    onNavigateToProposals: () -> Unit,
    onNavigateToBuyBanner: () -> Unit,
    onNavigateToNotifications: () -> Unit = {},
    onNavigateToSettings: () -> Unit = {},
    onNavigateToMessages: () -> Unit = {},
    onNavigateToCart: () -> Unit = {},
    onNavigateToSearch: () -> Unit = {},
    onNavigateToLocalProviders: () -> Unit = {},
    onNavigateToDiscountedProducts: () -> Unit = {},
    onNavigateToProviderProfile: (String, Boolean) -> Unit = { _, _ -> },
    onNavigateToLocalServiceOrders: () -> Unit = {},
    variant: String? = null
) {
    val viewModel: HomeViewModel = hiltViewModel()
    val uiState by viewModel.uiState.collectAsState()
    val products by viewModel.products.collectAsState()
    val services by viewModel.services.collectAsState()
    val categories by viewModel.categories.collectAsState()
    val productCategories by viewModel.productCategories.collectAsState()
    val stores by viewModel.stores.collectAsState()
    val accountType by viewModel.accountType.collectAsState()
    val remoteBanners by viewModel.homeBanners.collectAsState()
    
    var searchQuery by remember { mutableStateOf("") }
    var selectedCategory by remember { mutableStateOf<DataServiceCategory?>(null) }
    var selectedProductFilter by remember { mutableStateOf<String?>(null) } // Filtro de produtos: promo√ß√µes, valores, etc
    val isLoading = variant == "loading" || uiState.isLoading
    val showDynamicBanner = variant == "banner"
    
    // Solicitar permiss√£o de notifica√ß√µes quando entrar na home pela primeira vez
    val context = androidx.compose.ui.platform.LocalContext.current
    val hasNotificationPermission = remember {
        com.taskgoapp.taskgo.core.permissions.PermissionHandler.hasNotificationPermission(context)
    }
    val notificationPermissionLauncher = com.taskgoapp.taskgo.core.permissions.rememberNotificationPermissionLauncher(
        onPermissionGranted = {},
        onPermissionDenied = {}
    )
    
    LaunchedEffect(Unit) {
        if (!hasNotificationPermission && notificationPermissionLauncher != null && android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.TIRAMISU) {
            // Solicitar permiss√£o ap√≥s um pequeno delay para n√£o interferir na navega√ß√£o
            kotlinx.coroutines.delay(1000)
            notificationPermissionLauncher.launch(android.Manifest.permission.POST_NOTIFICATIONS)
        }
    }
    
    var selectedFilterType by remember { mutableStateOf<FilterType?>(FilterType.SERVICES) }
    
    // Obter localiza√ß√£o do usu√°rio para filtrar produtos em destaque
    val locationManager = remember { LocationManager(context) }
    var userLocation by remember { mutableStateOf<android.location.Location?>(null) }
    
    // Carregar localiza√ß√£o do usu√°rio
    LaunchedEffect(Unit) {
        try {
            if (ContextCompat.checkSelfPermission(
                    context,
                    android.Manifest.permission.ACCESS_FINE_LOCATION
                ) == android.content.pm.PackageManager.PERMISSION_GRANTED ||
                ContextCompat.checkSelfPermission(
                    context,
                    android.Manifest.permission.ACCESS_COARSE_LOCATION
                ) == android.content.pm.PackageManager.PERMISSION_GRANTED
            ) {
                userLocation = locationManager.getCurrentLocation()
            }
        } catch (e: Exception) {
            Log.e("HomeScreen", "Erro ao obter localiza√ß√£o: ${e.message}", e)
        }
    }
    
    // Filtrar produtos baseado nos filtros selecionados
    val filteredProducts = remember(products, searchQuery, selectedProductFilter, userLocation) {
        products
            .filter { product ->
                if (!product.active) return@filter false
                // Aplicar filtro de busca
                if (searchQuery.isNotBlank()) {
                    val matchesSearch = product.title.contains(searchQuery, ignoreCase = true) ||
                        product.description?.contains(searchQuery, ignoreCase = true) == true
                    if (!matchesSearch) return@filter false
                }
                
                // Aplicar filtros espec√≠ficos de produtos
                when (selectedProductFilter) {
                    "Em Promo√ß√£o" -> {
                        // Produtos em destaque E com desconto informado
                        product.featured == true && (product.discountPercentage ?: 0.0) > 0.0
                    }
                    "At√© R$ 50" -> {
                        product.price <= 50.0
                    }
                    "R$ 50 - R$ 100" -> {
                        product.price >= 50.0 && product.price <= 100.0
                    }
                    "R$ 100 - R$ 250" -> {
                        product.price >= 100.0 && product.price <= 250.0
                    }
                    "Acima de R$ 250" -> {
                        product.price > 250.0
                    }
                    "Mais Vendidos" -> {
                        // Placeholder: usar vendas quando dispon√≠vel; por enquanto, usar destaque com desconto
                        product.featured == true && (product.discountPercentage ?: 0.0) > 0.0
                    }
                    "Novos" -> true // sem campo de data, n√£o filtra
                    "Melhor Avaliados" -> (product.rating ?: 0.0) >= 4.0
                    "Todos", null -> true // mostrar todos por padr√£o
                    else -> true
                }
            }
            .sortedByDescending { product ->
                // Ordenar por relev√¢ncia baseado no filtro
                when (selectedProductFilter) {
                    "Melhor Avaliados" -> product.rating ?: 0.0
                    "Mais Vendidos" -> if (product.featured == true && (product.discountPercentage ?: 0.0) > 0.0) 1.0 else 0.0
                    else -> product.rating ?: 0.0
                }
            }
            .let { filtered ->
                // Se o usu√°rio tem localiza√ß√£o, filtra raio 100km; sen√£o, mant√©m lista filtrada
                val productLat = userLocation?.latitude
                val productLng = userLocation?.longitude
                
                if (productLat != null && productLng != null) {
                    filtered.filter { product ->
                        val prodLat = product.latitude
                        val prodLng = product.longitude
                        if (prodLat != null && prodLng != null) {
                            val distance = calculateDistance(
                                productLat,
                                productLng,
                                prodLat,
                                prodLng
                            )
                            distance <= 100.0
                        } else {
                            false // Sem localiza√ß√£o do produto, n√£o exibe
                        }
                    }
                } else {
                    filtered // Sem localiza√ß√£o do usu√°rio, n√£o esvazia a vitrine
                }
            }
    }

    val resolveBannerAction: (String?) -> () -> Unit = { route ->
        when (route?.uppercase()) {
            "LOCAL_PROVIDERS" -> onNavigateToLocalProviders
            "LOCAL_ORDERS", "SERVICE_ORDERS" -> onNavigateToLocalServiceOrders
            "DISCOUNTS", "PROMOTIONS" -> onNavigateToDiscountedProducts
            "CREATE_ORDER" -> onNavigateToCreateWorkOrder
            "PROPOSALS" -> onNavigateToProposals
            "BUY_BANNER" -> onNavigateToBuyBanner
            "MESSAGES" -> onNavigateToMessages
            "CART" -> onNavigateToCart
            else -> onNavigateToDiscountedProducts
        }
    }
    
    val fallbackBanners = remember(accountType) {
        when (accountType) {
            com.taskgoapp.taskgo.core.model.AccountType.PARCEIRO,
            com.taskgoapp.taskgo.core.model.AccountType.PRESTADOR -> listOf(
                HomeBannerContent(
                    id = "ordens_servico_destaque",
                    imageRes = R.drawable.banner_ordens_servico,
                    title = "",
                    subtitle = "",
                    actionLabel = "",
                    onClick = onNavigateToLocalServiceOrders
                ),
                HomeBannerContent(
                    id = "produtos_descontos",
                    imageRes = R.drawable.banner_produtos_descontos,
                    title = "",
                    subtitle = "",
                    actionLabel = "",
                    onClick = onNavigateToDiscountedProducts
                )
            )
            com.taskgoapp.taskgo.core.model.AccountType.VENDEDOR,
            com.taskgoapp.taskgo.core.model.AccountType.CLIENTE -> listOf(
                HomeBannerContent(
                    id = "prestadores_locais",
                    imageRes = R.drawable.banner_prestadores_locais,
                    title = "",
                    subtitle = "",
                    actionLabel = "",
                    onClick = onNavigateToLocalProviders
                ),
                HomeBannerContent(
                    id = "produtos_descontos",
                    imageRes = R.drawable.banner_produtos_descontos,
                    title = "",
                    subtitle = "",
                    actionLabel = "",
                    onClick = onNavigateToDiscountedProducts
                )
            )
        }
    }
    
    val remoteHeroBanners = remember(remoteBanners, accountType) {
        val matchesAccount: (com.taskgoapp.taskgo.core.model.HomeBanner) -> Boolean = { banner ->
            when (banner.audience) {
                com.taskgoapp.taskgo.core.model.HomeBanner.Audience.TODOS -> true
                com.taskgoapp.taskgo.core.model.HomeBanner.Audience.PRESTADOR ->
                    accountType == com.taskgoapp.taskgo.core.model.AccountType.PRESTADOR
                com.taskgoapp.taskgo.core.model.HomeBanner.Audience.CLIENTE ->
                    accountType != com.taskgoapp.taskgo.core.model.AccountType.PRESTADOR
            }
        }
        remoteBanners
            .filter { matchesAccount(it) && !it.imageUrl.isNullOrBlank() }
            .sortedByDescending { it.priority }
            .map { banner ->
                HomeBannerContent(
                    id = banner.id,
                    imageUrl = banner.imageUrl,
                    title = "",
                    subtitle = "",
                    actionLabel = "",
                    onClick = resolveBannerAction(banner.actionRoute)
                )
            }
    }
    
    val heroBanners = remember(remoteHeroBanners, fallbackBanners) {
        if (remoteHeroBanners.isNotEmpty()) remoteHeroBanners else fallbackBanners
    }
    
    // Loading State
    if (isLoading) {
        Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
            CircularProgressIndicator()
        }
        return
    }

    Scaffold(
        topBar = {
            AppTopBar(
                title = stringResource(R.string.home_title),
                actions = {
                    Row(
                        horizontalArrangement = Arrangement.spacedBy(4.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        IconButton(
                            onClick = onNavigateToSearch,
                            modifier = Modifier.size(36.dp)
                        ) {
                            TGIcon(
                                iconRes = TGIcons.Search,
                                contentDescription = "Buscar",
                                size = TGIcons.Sizes.Medium,
                                tint = Color.White
                            )
                        }
                        IconButton(
                            onClick = onNavigateToNotifications,
                            modifier = Modifier.size(36.dp)
                        ) {
                            TGIcon(
                                iconRes = TGIcons.Bell,
                                contentDescription = "Notifica√ß√µes",
                                size = TGIcons.Sizes.Medium,
                                tint = Color.White
                            )
                        }
                        IconButton(
                            onClick = onNavigateToCart,
                            modifier = Modifier.size(36.dp)
                        ) {
                            TGIcon(
                                iconRes = TGIcons.Cart,
                                contentDescription = "Carrinho",
                                size = TGIcons.Sizes.Medium,
                                tint = Color.White
                            )
                        }
                        IconButton(
                            onClick = onNavigateToMessages,
                            modifier = Modifier.size(36.dp)
                        ) {
                            TGIcon(
                                iconRes = TGIcons.Messages,
                                contentDescription = "Mensagens",
                                size = TGIcons.Sizes.Medium,
                                tint = Color.White
                            )
                        }
                    }
                }
            )
        }
    ) { paddingValues ->
        LazyColumn(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // Filter Type Selector (Servi√ßos / Produtos)
            item {
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    FilterTypeChip(
                        text = "Servi√ßos",
                        selected = selectedFilterType == FilterType.SERVICES,
                        onClick = { 
                            selectedFilterType = if (selectedFilterType == FilterType.SERVICES) null else FilterType.SERVICES
                        },
                        modifier = Modifier.weight(1f)
                    )
                    FilterTypeChip(
                        text = "Produtos",
                        selected = selectedFilterType == FilterType.PRODUCTS,
                        onClick = { 
                            selectedFilterType = if (selectedFilterType == FilterType.PRODUCTS) null else FilterType.PRODUCTS
                        },
                        modifier = Modifier.weight(1f)
                    )
                }
            }
            
            // Filtros - Diferentes para Produtos e Servi√ßos
            item {
                Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
                    Text(
                        text = if (selectedFilterType == FilterType.PRODUCTS) "Filtros de Produtos" else "Filtros de Servi√ßos",
                        style = FigmaProductName,
                        color = TaskGoTextBlack,
                        fontWeight = FontWeight.Bold
                    )
                    Row(
                        horizontalArrangement = Arrangement.spacedBy(8.dp),
                        modifier = Modifier.horizontalScroll(rememberScrollState())
                    ) {
                        if (selectedFilterType == FilterType.PRODUCTS) {
                            // Filtros espec√≠ficos para produtos: valores, promo√ß√µes, etc
                            val productFilters = listOf(
                                "Todos",
                                "Em Promo√ß√£o",
                                "At√© R$ 50",
                                "R$ 50 - R$ 100",
                                "R$ 100 - R$ 250",
                                "Acima de R$ 250",
                                "Mais Vendidos",
                                "Novos",
                                "Melhor Avaliados"
                            )
                            productFilters.forEach { filterName ->
                                TGChip(
                                    text = filterName,
                                    selected = selectedProductFilter == filterName,
                                    onClick = { 
                                        selectedProductFilter = if (selectedProductFilter == filterName) null else filterName
                                    }
                                )
                            }
                        } else {
                            // Filtros de categorias de servi√ßos
                            if (categories.isNotEmpty()) {
                                categories.take(8).forEach { category ->
                                    TGChip(
                                        text = category.name,
                                        selected = selectedCategory?.id == category.id,
                                        onClick = { 
                                            selectedCategory = if (selectedCategory?.id == category.id) null else category
                                        }
                                    )
                                }
                            } else {
                                // Placeholder chips quando n√£o h√° categorias
                                listOf("Todos", "Mais Procurados", "Novos", "Em Destaque").forEach { categoryName ->
                                    TGChip(
                                        text = categoryName,
                                        selected = selectedCategory?.name == categoryName,
                                        onClick = { 
                                            selectedCategory = if (selectedCategory?.name == categoryName) null else 
                                                DataServiceCategory(id = 0, name = categoryName, icon = "", description = "")
                                        }
                                    )
                                }
                            }
                        }
                    }
                }
            }
            
            item {
                HomeBannerCarousel(
                    banners = heroBanners,
                    modifier = Modifier.fillMaxWidth()
                )
            }
            
            // Banner/Ads Section - DESATIVADO (ser√° lan√ßado futuramente)
            // item {
            //     BannerCard(
            //         title = "Divulgue seu neg√≥cio!",
            //         description = "Compre um banner e alcance mais clientes",
            //         onBuyBanner = onNavigateToBuyBanner
            //     )
            // }
            
            // Featured Section - Produtos ou Servi√ßos baseado no filtro selecionado
            item {
                Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
                    Text(
                        text = if (selectedFilterType == FilterType.SERVICES) "Servi√ßos em Destaque" else stringResource(R.string.home_featured_title),
                        style = FigmaProductName,
                        color = TaskGoTextBlack,
                        fontWeight = FontWeight.Bold
                    )
                    
                    // Products List - Scroll Horizontal (APENAS quando produtos selecionado)
                    if (selectedFilterType == FilterType.PRODUCTS) {
                        if (filteredProducts.isNotEmpty()) {
                            LazyRow(
                                horizontalArrangement = Arrangement.spacedBy(12.dp),
                                modifier = Modifier.fillMaxWidth()
                            ) {
                                items(filteredProducts.take(6).size) { index ->
                                    val product = filteredProducts[index]
                                    ProductCard(
                                        product = product,
                                        onClick = { onNavigateToProduct(product.id) },
                                        modifier = Modifier.width(180.dp)
                                    )
                                }
                            }
                        } else {
                            // Empty state para produtos em destaque
                            EmptyProductsState(onSearchClick = onNavigateToSearch)
                        }
                    } else if (selectedFilterType == FilterType.SERVICES) {
                        // Services List - Scroll Horizontal
                        if (services.isNotEmpty()) {
                            LazyRow(
                                horizontalArrangement = Arrangement.spacedBy(12.dp),
                                modifier = Modifier.fillMaxWidth()
                            ) {
                                items(services.take(6).size) { index ->
                                    val service = services[index]
                                    ServiceCard(
                                        service = service,
                                        onClick = { onNavigateToService(service.id) },
                                        onProviderClick = { providerId ->
                                            onNavigateToProviderProfile(providerId, false)
                                        },
                                        modifier = Modifier.width(180.dp)
                                    )
                                }
                            }
                        } else {
                            // Empty state para servi√ßos em destaque
                            EmptyServicesState(onSearchClick = onNavigateToSearch)
                        }
                    }
                }
            }
            
            // Mapa com Prestadores e Lojas em Tempo Real (movido para depois dos cards)
            item {
                Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
                    Text(
                        text = "Lojas Pr√≥ximas",
                        style = FigmaProductName,
                        color = TaskGoTextBlack,
                        fontWeight = FontWeight.Bold
                    )
                    ProvidersMapView(
                        userLocation = userLocation,
                        stores = stores,
                        onStoreClick = { storeId ->
                            // Navegar para perfil da loja
                            onNavigateToProviderProfile(storeId, true)
                        },
                        modifier = Modifier
                            .fillMaxWidth()
                            .height(300.dp)
                    )
                }
            }
            
            // Dynamic Banner (se solicitado)
            if (showDynamicBanner) {
                item {
                    BannerCard(
                        title = "Super Banner!",
                        description = "Oferta exclusiva para voc√™.",
                        onBuyBanner = onNavigateToBuyBanner
                    )
                }
            }
        }
    }
}

@OptIn(ExperimentalFoundationApi::class)
@Composable
private fun HomeBannerCarousel(
    banners: List<HomeBannerContent>,
    modifier: Modifier = Modifier
) {
    if (banners.isEmpty()) return
    val pagerState = rememberPagerState(pageCount = { banners.size })
    
    if (banners.size > 1) {
        LaunchedEffect(banners.size) {
            while (true) {
                delay(5500)
                val next = (pagerState.currentPage + 1) % banners.size
                pagerState.animateScrollToPage(next)
            }
        }
    }
    
    Column(modifier = modifier) {
        HorizontalPager(
            state = pagerState,
            pageSpacing = 16.dp,
            modifier = Modifier
                .fillMaxWidth()
                .height(200.dp)
        ) { page ->
            HomeBannerCard(
                banner = banners[page],
                modifier = Modifier.fillMaxWidth()
            )
        }
        if (banners.size > 1) {
            Spacer(modifier = Modifier.height(12.dp))
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.Center
            ) {
                banners.indices.forEach { index ->
                    val isSelected = pagerState.currentPage == index
                    Box(
                        modifier = Modifier
                            .padding(horizontal = 4.dp)
                            .height(6.dp)
                            .width(if (isSelected) 26.dp else 10.dp)
                            .clip(RoundedCornerShape(3.dp))
                            .background(
                                if (isSelected) TaskGoGreen else TaskGoSurfaceGray
                            )
                    )
                }
            }
        }
    }
}

@Composable
private fun HomeBannerCard(
    banner: HomeBannerContent,
    modifier: Modifier = Modifier
) {
    val context = LocalContext.current
    Card(
        modifier = modifier
            .fillMaxWidth()
            .clickable { banner.onClick() },
        shape = RoundedCornerShape(16.dp),
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
    ) {
        Box(
            modifier = Modifier
                .fillMaxWidth()
                .height(200.dp)
        ) {
            when {
                banner.imageUrl != null -> {
                    AsyncImage(
                        model = ImageRequest.Builder(context)
                            .data(banner.imageUrl)
                            .crossfade(true)
                            .build(),
                        contentDescription = null,
                        modifier = Modifier.fillMaxSize(),
                        contentScale = ContentScale.Crop
                    )
                }
                banner.imageRes != null -> {
                    AsyncImage(
                        model = ImageRequest.Builder(context)
                            .data(banner.imageRes)
                            .crossfade(true)
                            .allowHardware(false)
                            .build(),
                        contentDescription = null,
                        modifier = Modifier.fillMaxSize(),
                        contentScale = ContentScale.Crop
                    )
                }
                else -> {
                    Box(
                        modifier = Modifier
                            .fillMaxSize()
                            .background(TaskGoGreen.copy(alpha = 0.2f))
                    )
                }
            }
        }
    }
}

@Composable
fun BannerCard(
    title: String,
    description: String,
    onBuyBanner: () -> Unit
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .clickable { onBuyBanner() },
        colors = CardDefaults.cardColors(
            containerColor = TaskGoGreen
        ),
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Column(modifier = Modifier.weight(1f)) {
                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    TGIcon(
                        iconRes = TGIcons.Bell,
                        contentDescription = null,
                        size = TGIcons.Sizes.Medium,
                        tint = Color.White
                    )
                    Text(
                        text = title,
                        style = FigmaProductName,
                        fontWeight = FontWeight.Bold,
                        color = Color.White
                    )
                }
                Spacer(modifier = Modifier.height(4.dp))
                Text(
                    text = description,
                    style = FigmaProductDescription,
                    color = Color.White.copy(alpha = 0.9f)
                )
            }
            
            Button(
                onClick = onBuyBanner,
                colors = ButtonDefaults.buttonColors(
                    containerColor = Color.White,
                    contentColor = TaskGoGreen
                ),
                shape = RoundedCornerShape(8.dp)
            ) {
                Text(
                    text = "Comprar",
                    style = FigmaButtonText,
                    fontWeight = FontWeight.Bold
                )
            }
        }
    }
}

@Composable
fun FilterTypeChip(
    text: String,
    selected: Boolean,
    onClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    FilterChip(
        selected = selected,
        onClick = onClick,
        modifier = modifier,
        label = {
            Text(
                text = text,
                style = FigmaButtonText,
                color = if (selected) TaskGoBackgroundWhite else TaskGoTextBlack
            )
        },
        colors = FilterChipDefaults.filterChipColors(
            selectedContainerColor = TaskGoGreen,
            selectedLabelColor = TaskGoBackgroundWhite,
            containerColor = TaskGoSurfaceGray,
            labelColor = TaskGoTextBlack
        )
    )
}

@Composable
fun EmptyProductsState(
    onSearchClick: () -> Unit
) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(
            containerColor = TaskGoSurfaceGray
        )
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(24.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            TGIcon(
                iconRes = TGIcons.Products,
                contentDescription = null,
                size = 64.dp,
                tint = TaskGoTextGray
            )
            Text(
                text = "Nenhum produto em destaque",
                style = FigmaProductName,
                color = TaskGoTextGray,
                fontWeight = FontWeight.Bold
            )
            Text(
                text = "Use a busca para encontrar produtos ou servi√ßos",
                style = FigmaProductDescription,
                color = TaskGoTextGray
            )
            TextButton(onClick = onSearchClick) {
                Text("Ir para busca", color = TaskGoGreen, fontWeight = FontWeight.Bold)
            }
        }
    }
}

@Composable
fun EmptyServicesState(
    onSearchClick: () -> Unit
) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(
            containerColor = TaskGoSurfaceGray
        )
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(24.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            TGIcon(
                iconRes = TGIcons.Services,
                contentDescription = null,
                size = 64.dp,
                tint = TaskGoTextGray
            )
            Text(
                text = "Nenhum servi√ßo cadastrado",
                style = FigmaProductName,
                color = TaskGoTextGray,
                fontWeight = FontWeight.Bold
            )
            Text(
                text = "Use a busca para encontrar produtos ou servi√ßos",
                style = FigmaProductDescription,
                color = TaskGoTextGray
            )
            TextButton(onClick = onSearchClick) {
                Text("Explorar servi√ßos", color = TaskGoGreen, fontWeight = FontWeight.Bold)
            }
        }
    }
}

@Composable
fun ProductCard(
    product: Product,
    onClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    val currencyFormat = remember {
        NumberFormat.getCurrencyInstance(Locale("pt", "BR"))
    }
    Card(
        modifier = modifier.fillMaxWidth(),
        onClick = onClick,
        colors = CardDefaults.cardColors(
            containerColor = TaskGoBackgroundWhite
        ),
        elevation = CardDefaults.cardElevation(defaultElevation = 6.dp),
        shape = RoundedCornerShape(16.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            val imageUri = remember(product.imageUris) {
                product.imageUris.firstOrNull { it.isNotBlank() }
            }
            Box(
                modifier = Modifier
                    .fillMaxWidth()
                    .height(190.dp)
                    .clip(RoundedCornerShape(14.dp))
                    .background(TaskGoSurfaceGray),
                contentAlignment = Alignment.Center
            ) {
                if (imageUri != null) {
                    AsyncImage(
                        model = ImageRequest.Builder(LocalContext.current)
                            .data(imageUri)
                            .crossfade(true)
                            .build(),
                        contentDescription = "Imagem do produto ${product.title}",
                        modifier = Modifier.fillMaxSize(),
                        contentScale = ContentScale.Crop
                    )
                } else {
                    TGIcon(
                        iconRes = TGIcons.Products,
                        contentDescription = null,
                        size = TGIcons.Sizes.ExtraLarge,
                        tint = TaskGoTextGray
                    )
                }

                if (product.featured == true && (product.discountPercentage ?: 0.0) > 0.0) {
                    Surface(
                        modifier = Modifier
                            .align(Alignment.TopStart)
                            .padding(10.dp),
                        color = TaskGoOrange,
                        shape = RoundedCornerShape(20.dp)
                    ) {
                        Text(
                            text = "Destaque",
                            color = Color.White,
                            style = MaterialTheme.typography.labelSmall,
                            modifier = Modifier.padding(horizontal = 10.dp, vertical = 4.dp)
                        )
                    }
                }
            }

            Column(verticalArrangement = Arrangement.spacedBy(6.dp)) {
                Text(
                    text = product.title,
                    style = FigmaProductName,
                    color = TaskGoTextBlack,
                    fontWeight = FontWeight.Bold,
                    maxLines = 1,
                    overflow = TextOverflow.Ellipsis
                )

                product.sellerName?.takeIf { it.isNotBlank() }?.let { seller ->
                    Text(
                        text = seller,
                        style = FigmaProductDescription,
                        color = TaskGoTextGray,
                        maxLines = 1,
                        overflow = TextOverflow.Ellipsis
                    )
                }

                product.description?.takeIf { it.isNotBlank() }?.let { description ->
                    Text(
                        text = description,
                        style = MaterialTheme.typography.bodyMedium,
                        color = TaskGoTextGray,
                        maxLines = 2,
                        overflow = TextOverflow.Ellipsis
                    )
                }
            }

            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Column {
                    Text(
                        text = "Pre√ßo",
                        style = MaterialTheme.typography.bodySmall,
                        color = TaskGoTextGray
                    )
                    Text(
                        text = currencyFormat.format(product.price),
                        style = FigmaPrice,
                        color = TaskGoPriceGreen,
                        fontWeight = FontWeight.Bold
                    )
                }
                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.spacedBy(4.dp)
                ) {
                    Icon(
                        imageVector = Icons.Default.Star,
                        contentDescription = "Avalia√ß√£o",
                        tint = TaskGoStarYellow,
                        modifier = Modifier.size(18.dp)
                    )
                    Text(
                        text = "%.1f".format(product.rating ?: 0.0),
                        style = FigmaRatingText,
                        color = TaskGoTextDark
                    )
                }
            }
        }
    }
}

@Composable
private fun ServiceCard(
    service: ServiceFirestore,
    onClick: () -> Unit,
    onProviderClick: ((String) -> Unit)? = null,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier
            .clickable { onClick() },
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),
        shape = RoundedCornerShape(12.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(12.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            // Imagem do servi√ßo
            if (service.images.isNotEmpty()) {
                AsyncImage(
                    model = ImageRequest.Builder(LocalContext.current)
                        .data(service.images.first())
                        .size(200)
                        .build(),
                    contentDescription = service.title,
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(120.dp)
                        .clip(RoundedCornerShape(8.dp)),
                    contentScale = androidx.compose.ui.layout.ContentScale.Crop
                )
            } else {
                Box(
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(120.dp)
                        .background(TaskGoBorder, RoundedCornerShape(8.dp)),
                    contentAlignment = Alignment.Center
                ) {
                    Text(
                        text = "üîß",
                        style = MaterialTheme.typography.headlineMedium
                    )
                }
            }
            
            // T√≠tulo
            Text(
                text = service.title,
                style = MaterialTheme.typography.titleSmall,
                fontWeight = FontWeight.Bold,
                color = TaskGoTextBlack,
                maxLines = 2,
                overflow = androidx.compose.ui.text.style.TextOverflow.Ellipsis
            )
            
            // Descri√ß√£o
            Text(
                text = service.description,
                style = MaterialTheme.typography.bodySmall,
                color = TaskGoTextGray,
                maxLines = 2,
                overflow = androidx.compose.ui.text.style.TextOverflow.Ellipsis
            )
            
            // Informa√ß√µes do prestador (clic√°vel)
            if (service.providerId.isNotBlank() && onProviderClick != null) {
                com.taskgoapp.taskgo.core.design.UserAvatarNameLoader(
                    userId = service.providerId,
                    onUserClick = { onProviderClick(service.providerId) },
                    avatarSize = 32.dp,
                    showName = true
                )
            }
            
            // Pre√ßo e Rating
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = NumberFormat.getCurrencyInstance(Locale("pt", "BR")).format(service.price),
                    style = MaterialTheme.typography.titleSmall,
                    color = TaskGoGreen,
                    fontWeight = FontWeight.Bold
                )
                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.spacedBy(4.dp)
                ) {
                    Icon(
                        imageVector = Icons.Default.Star,
                        contentDescription = "Avalia√ß√£o",
                        tint = TaskGoStarYellow,
                        modifier = Modifier.size(16.dp)
                    )
                    Text(
                        text = "%.1f".format(service.rating ?: 0.0),
                        style = FigmaRatingText,
                        color = TaskGoTextDark
                    )
                }
            }
        }
    }
}

```

## [FRONTEND]: feature/home/presentation/HomeViewModel.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.home.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.taskgoapp.taskgo.core.model.Product
import com.taskgoapp.taskgo.core.data.models.ServiceCategory
import com.taskgoapp.taskgo.core.maps.ProviderLocation
import com.taskgoapp.taskgo.core.maps.StoreLocation
import com.taskgoapp.taskgo.domain.repository.ProductsRepository
import com.taskgoapp.taskgo.data.repository.FirestoreMapLocationsRepository
import com.taskgoapp.taskgo.data.repository.FirestoreServicesRepository
import com.taskgoapp.taskgo.data.firestore.models.ServiceFirestore
import com.taskgoapp.taskgo.domain.repository.UserRepository
import com.taskgoapp.taskgo.domain.repository.HomeBannersRepository
import com.taskgoapp.taskgo.core.model.HomeBanner
import com.taskgoapp.taskgo.core.model.AccountType
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch
import javax.inject.Inject

data class HomeUiState(
    val isLoading: Boolean = false,
    val error: String? = null,
    val products: List<Product> = emptyList(),
    val categories: List<ServiceCategory> = emptyList()
)

@HiltViewModel
class HomeViewModel @Inject constructor(
    private val productsRepository: ProductsRepository,
    private val mapLocationsRepository: FirestoreMapLocationsRepository,
    private val servicesRepository: FirestoreServicesRepository,
    private val userRepository: UserRepository,
    private val categoriesRepository: com.taskgoapp.taskgo.domain.repository.CategoriesRepository,
    private val homeBannersRepository: HomeBannersRepository
) : ViewModel() {

    private val _uiState = MutableStateFlow(HomeUiState())
    val uiState: StateFlow<HomeUiState> = _uiState.asStateFlow()

    val products: StateFlow<List<Product>> = productsRepository
        .observeProducts()
        .stateIn(
            viewModelScope,
            SharingStarted.WhileSubscribed(5_000),
            emptyList()
        )

    // Carregar categorias de servi√ßos dinamicamente do Firestore
    val categories: StateFlow<List<ServiceCategory>> = categoriesRepository
        .observeServiceCategories()
        .stateIn(
            viewModelScope,
            SharingStarted.WhileSubscribed(5_000),
            emptyList()
        )
    
    // Carregar categorias de produtos dinamicamente do Firestore
    val productCategories: StateFlow<List<String>> = categoriesRepository
        .observeProductCategories()
        .stateIn(
            viewModelScope,
            SharingStarted.WhileSubscribed(5_000),
            emptyList()
        )
    
    // Localiza√ß√µes de prestadores e lojas para o mapa
    val providers: StateFlow<List<ProviderLocation>> = mapLocationsRepository
        .observeProvidersWithLocation()
        .stateIn(
            viewModelScope,
            SharingStarted.WhileSubscribed(5_000),
            emptyList()
        )
    
    val stores: StateFlow<List<StoreLocation>> = mapLocationsRepository
        .observeStoresWithLocation()
        .stateIn(
            viewModelScope,
            SharingStarted.WhileSubscribed(5_000),
            emptyList()
        )
    
    // Servi√ßos oferecidos (ativos)
    val services: StateFlow<List<ServiceFirestore>> = servicesRepository
        .observeAllActiveServices()
        .stateIn(
            viewModelScope,
            SharingStarted.WhileSubscribed(5_000),
            emptyList()
        )
    
    // Account type do usu√°rio atual
    val accountType: StateFlow<AccountType> = userRepository
        .observeCurrentUser()
        .map { user -> user?.accountType ?: AccountType.CLIENTE }
        .stateIn(
            viewModelScope,
            SharingStarted.WhileSubscribed(5_000),
            AccountType.CLIENTE
        )

    val homeBanners: StateFlow<List<HomeBanner>> = homeBannersRepository
        .observeHomeBanners()
        .stateIn(
            viewModelScope,
            SharingStarted.WhileSubscribed(5_000),
            emptyList()
        )

    private fun loadData() {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoading = true, error = null)
            try {
                // Os produtos v√™m automaticamente via Flow do reposit√≥rio
                // TODO: Carregar categorias quando houver reposit√≥rio
                _uiState.value = _uiState.value.copy(isLoading = false)
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = e.message ?: "Erro ao carregar dados"
                )
            }
        }
    }

    fun refresh() {
        loadData()
    }

    fun clearError() {
        _uiState.value = _uiState.value.copy(error = null)
    }

    private fun observeProductErrors() {
        viewModelScope.launch {
            productsRepository.observeProductErrors()
                .catch { throwable ->
                    val message = throwable.message ?: "Erro desconhecido ao observar produtos"
                    _uiState.value = _uiState.value.copy(error = message)
                }
                .collect { message ->
                    _uiState.value = _uiState.value.copy(error = message)
                }
        }
    }
}


```

# Features - messages


## [FRONTEND]: feature/messages/presentation/ChatScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.messages.presentation
import com.taskgoapp.taskgo.core.theme.*

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.rememberLazyListState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.Send
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.R
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.model.ChatMessage
import com.taskgoapp.taskgo.core.model.MessageThread
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.compose.foundation.clickable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import java.text.SimpleDateFormat
import java.util.*
import java.time.ZoneId
import java.time.ZonedDateTime

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ChatScreen(
    threadId: String,
    onNavigateBack: () -> Unit,
    viewModel: ChatViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    
    LaunchedEffect(threadId) {
        viewModel.loadThread(threadId)
    }
    
    var messageText by remember { mutableStateOf("") }
    
    val listState = rememberLazyListState()
    
    LaunchedEffect(uiState.messages.size) {
        if (uiState.messages.isNotEmpty()) {
            listState.animateScrollToItem(uiState.messages.size - 1)
        }
    }
    
    // Mostrar erro se houver
    uiState.error?.let { error ->
        LaunchedEffect(error) {
            // Pode mostrar um snackbar ou toast aqui se necess√°rio
        }
    }
    
    Scaffold(
        topBar = {
            AppTopBar(
                title = uiState.thread?.title ?: "Conversa",
                onBackClick = onNavigateBack
            )
        },
        bottomBar = {
            Column {
                // Bot√£o de aceita√ß√£o (se necess√°rio)
                if (uiState.showAcceptButton && !uiState.isAccepting) {
                    Button(
                        onClick = { viewModel.acceptService() },
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(horizontal = 16.dp, vertical = 8.dp),
                        colors = ButtonDefaults.buttonColors(
                            containerColor = TaskGoGreen
                        ),
                        enabled = !uiState.isAccepting
                    ) {
                        Text(
                            text = uiState.acceptButtonText,
                            style = MaterialTheme.typography.labelLarge,
                            fontWeight = FontWeight.Bold
                        )
                    }
                }
                
                if (uiState.isAccepting) {
                    LinearProgressIndicator(
                        modifier = Modifier.fillMaxWidth(),
                        color = TaskGoGreen
                    )
                }
                
                ChatInput(
                    value = messageText,
                    onValueChange = { messageText = it },
                    onSend = {
                        if (messageText.isNotBlank()) {
                            viewModel.sendMessage(messageText)
                            messageText = ""
                        }
                    }
                )
            }
        }
    ) { paddingValues ->
        if (uiState.isLoading) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues),
                contentAlignment = Alignment.Center
            ) {
                CircularProgressIndicator(color = TaskGoGreen)
            }
        } else {
            LazyColumn(
                state = listState,
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues),
                contentPadding = PaddingValues(16.dp),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                items(uiState.messages.size) { index ->
                    val message = uiState.messages[index]
                    ChatBubble(
                        message = message,
                        isMine = message.senderMe
                    )
                }
            }
        }
    }
}

@Composable
private fun ChatBubble(
    message: ChatMessage,
    isMine: Boolean
) {
    val alignment = if (isMine) Alignment.End else Alignment.Start
    // Bal√µes: usu√°rio = A4FFB6, recebido = D9D9D9
    val backgroundColor = if (isMine)
        TaskGoBackgroundLight.copy(alpha = 0.6f)
    else
        TaskGoDividerLight
    
    val textColor = TaskGoTextBlack

    Column(
        modifier = Modifier.fillMaxWidth(),
        horizontalAlignment = alignment
    ) {
        Row(
            verticalAlignment = Alignment.Bottom,
            horizontalArrangement = if (isMine) Arrangement.End else Arrangement.Start
        ) {
            if (!isMine) {
                // Avatar for other person's messages
                Box(
                    modifier = Modifier
                        .size(32.dp)
                        .clip(CircleShape)
                        .background(TaskGoBackgroundGray),
                    contentAlignment = Alignment.Center
                ) {
                    Icon(
                        imageVector = Icons.Default.Person,
                        contentDescription = null,
                        modifier = Modifier.size(20.dp),
                        tint = TaskGoTextBlack
                    )
                }
                
                Spacer(modifier = Modifier.width(8.dp))
            }
            
            // Message bubble
            Box(
                modifier = Modifier
                    .clip(
                        RoundedCornerShape(
                            topStart = 16.dp,
                            topEnd = 16.dp,
                            bottomStart = if (isMine) 16.dp else 4.dp,
                            bottomEnd = if (isMine) 4.dp else 16.dp
                        )
                    )
                    .background(backgroundColor)
                    .padding(12.dp)
            ) {
                Text(
                    text = message.text,
                    style = FigmaProductDescription,
                    color = textColor,
                    maxLines = 10
                )
            }
        }
        
        Spacer(modifier = Modifier.height(4.dp))
        
        // Time
        Text(
            text = formatMessageTime(message.time),
            style = FigmaStatusText,
            color = TaskGoTextGray,
            modifier = Modifier.padding(horizontal = 4.dp)
        )
    }
}

@Composable
private fun TypingIndicator() {
    Row(
        modifier = Modifier.padding(vertical = 8.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Box(
            modifier = Modifier
                .size(32.dp)
                .clip(CircleShape)
                .background(TaskGoBackgroundGray),
            contentAlignment = Alignment.Center
        ) {
            Icon(
                imageVector = Icons.Default.Person,
                contentDescription = null,
                modifier = Modifier.size(20.dp),
                tint = TaskGoTextBlack
            )
        }
        
        Spacer(modifier = Modifier.width(8.dp))
        
        Box(
            modifier = Modifier
                .clip(
                    RoundedCornerShape(
                        topStart = 16.dp,
                        topEnd = 16.dp,
                        bottomStart = 4.dp,
                        bottomEnd = 16.dp
                    )
                )
                .background(TaskGoSurfaceGray)
                .padding(12.dp)
        ) {
            Row(
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.spacedBy(4.dp)
            ) {
                repeat(3) { _ ->
                    Box(
                        modifier = Modifier
                            .size(8.dp)
                            .clip(CircleShape)
                            .background(TaskGoTextGray)
                    )
                }
            }
        }
    }
}

@Composable
private fun ChatInput(
    value: String,
    onValueChange: (String) -> Unit,
    onSend: () -> Unit
) {
    Surface(
        tonalElevation = 8.dp,
        shadowElevation = 8.dp
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalAlignment = Alignment.Bottom
        ) {
            OutlinedTextField(
                value = value,
                onValueChange = onValueChange,
                modifier = Modifier.weight(1f),
                placeholder = { Text(stringResource(R.string.messages_input_placeholder), style = FigmaProductDescription, color = TaskGoTextGray) },
                maxLines = 4,
                colors = OutlinedTextFieldDefaults.colors(
                    focusedBorderColor = TaskGoGreen,
                    unfocusedBorderColor = TaskGoDivider
                )
            )
            
            Spacer(modifier = Modifier.width(12.dp))
            
            FloatingActionButton(
                onClick = onSend,
                modifier = Modifier.size(48.dp),
                containerColor = TaskGoGreen
            ) {
                Icon(
                    imageVector = Icons.AutoMirrored.Filled.Send,
                    contentDescription = stringResource(R.string.messages_send),
                    tint = Color.White
                )
            }
        }
    }
}

private fun formatMessageTime(timestamp: Long): String {
    val now = System.currentTimeMillis()
    val today = Calendar.getInstance().apply {
        timeInMillis = now
        set(Calendar.HOUR_OF_DAY, 0)
        set(Calendar.MINUTE, 0)
        set(Calendar.SECOND, 0)
        set(Calendar.MILLISECOND, 0)
    }.timeInMillis
    
    val messageDate = Calendar.getInstance().apply {
        timeInMillis = timestamp
        set(Calendar.HOUR_OF_DAY, 0)
        set(Calendar.MINUTE, 0)
        set(Calendar.SECOND, 0)
        set(Calendar.MILLISECOND, 0)
    }.timeInMillis
    
    val yesterday = today - 86400000 // 24 horas em milissegundos
    
    return when {
        messageDate >= today -> {
            val formatter = SimpleDateFormat("HH:mm", Locale("pt", "BR"))
            formatter.format(Date(timestamp))
        }
        messageDate >= yesterday -> "Ontem"
        else -> {
            val formatter = SimpleDateFormat("dd/MM", Locale("pt", "BR"))
            formatter.format(Date(timestamp))
        }
    }
}

```

## [FRONTEND]: feature/messages/presentation/ChatViewModel.kt

```kotlin
package com.taskgoapp.taskgo.feature.messages.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.database.DataSnapshot
import com.google.firebase.database.DatabaseError
import com.google.firebase.database.FirebaseDatabase
import com.google.firebase.database.ValueEventListener
import com.taskgoapp.taskgo.core.model.ChatMessage
import com.taskgoapp.taskgo.core.model.MessageThread
import com.taskgoapp.taskgo.data.firestore.models.OrderFirestore
import com.taskgoapp.taskgo.data.repository.FirestoreOrderRepository
import com.taskgoapp.taskgo.data.repository.FirestoreUserRepository
import com.taskgoapp.taskgo.domain.repository.MessageRepository
import com.taskgoapp.taskgo.core.model.Result
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.tasks.await
import kotlinx.coroutines.launch
import javax.inject.Inject

data class ChatViewModelUiState(
    val isLoading: Boolean = false,
    val thread: MessageThread? = null,
    val messages: List<ChatMessage> = emptyList(),
    val order: OrderFirestore? = null,
    val currentUserRole: String? = null,
    val showAcceptButton: Boolean = false,
    val acceptButtonText: String = "",
    val isAccepting: Boolean = false,
    val error: String? = null
)

@HiltViewModel
class ChatViewModel @Inject constructor(
    private val messageRepository: com.taskgoapp.taskgo.domain.repository.MessageRepository,
    private val orderRepository: com.taskgoapp.taskgo.data.repository.FirestoreOrderRepository,
    private val userRepository: com.taskgoapp.taskgo.data.repository.FirestoreUserRepository,
    private val firebaseAuth: com.google.firebase.auth.FirebaseAuth
) : ViewModel() {
    
    private val _uiState = MutableStateFlow(ChatViewModelUiState())
    val uiState: StateFlow<ChatViewModelUiState> = _uiState.asStateFlow()
    
    private val database = FirebaseDatabase.getInstance()
    private var threadListener: ValueEventListener? = null
    
    fun loadThread(threadId: String) {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoading = true, error = null)
            
            try {
                // Carregar thread
                val thread = messageRepository.getThread(threadId)
                if (thread == null) {
                    _uiState.value = _uiState.value.copy(
                        isLoading = false,
                        error = "Thread n√£o encontrada"
                    )
                    return@launch
                }
                
                _uiState.value = _uiState.value.copy(thread = thread)
                
                // Obter orderId da thread no Firebase Realtime Database
                // Note: threadsRef aponta para "conversations" no MessageRepositoryImpl
                val conversationsRef = database.reference.child("conversations")
                val threadSnapshot = conversationsRef.child(threadId).get().await()
                val threadData = threadSnapshot.getValue(Map::class.java) as? Map<*, *>
                val orderId = threadData?.get("orderId") as? String
                
                // Carregar ordem se orderId existir
                if (orderId != null) {
                    loadOrderAndUpdateState(orderId)
                }
                
                _uiState.value = _uiState.value.copy(isLoading = false)
                
                // Observar mensagens em uma coroutine separada (ap√≥s inicializa√ß√£o)
                launch {
                    messageRepository.observeMessages(threadId).collect { messages ->
                        _uiState.value = _uiState.value.copy(messages = messages)
                    }
                }
            } catch (e: Exception) {
                android.util.Log.e("ChatViewModel", "Erro ao carregar thread: ${e.message}", e)
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = "Erro ao carregar conversa: ${e.message}"
                )
            }
        }
    }
    
    private suspend fun loadOrderAndUpdateState(orderId: String) {
        val order = orderRepository.getOrder(orderId)
        _uiState.value = _uiState.value.copy(order = order)
        
        // Verificar role do usu√°rio atual
        val currentUserId = firebaseAuth.currentUser?.uid
        if (currentUserId != null) {
            val user = userRepository.getUser(currentUserId)
            val userRole = user?.role ?: "client"
            _uiState.value = _uiState.value.copy(currentUserRole = userRole)
            
            // Determinar se deve mostrar bot√£o de aceita√ß√£o
            updateAcceptButtonVisibility(order, userRole, currentUserId)
        }
    }
    
    private fun updateAcceptButtonVisibility(
        order: OrderFirestore?,
        userRole: String,
        currentUserId: String
    ) {
        if (order == null) {
            _uiState.value = _uiState.value.copy(showAcceptButton = false)
            return
        }
        
        // Verificar se a ordem est√° em um status que permite aceita√ß√£o
        // Aceita√ß√£o pode ocorrer quando h√° proposta (status "proposed") ou quando foi aceita parcialmente (status "accepted")
        // N√£o pode aceitar se j√° est√° em andamento, conclu√≠da ou cancelada
        val canAccept = order.status == "proposed" || 
                       (order.status == "accepted" && (!order.acceptedByProvider || !order.acceptedByClient))
        
        if (!canAccept) {
            _uiState.value = _uiState.value.copy(showAcceptButton = false)
            return
        }
        
        // Verificar se j√° existe proposta (providerId deve estar definido)
        if (order.providerId.isNullOrBlank()) {
            _uiState.value = _uiState.value.copy(showAcceptButton = false)
            return
        }
        
        // Provider v√™ bot√£o "Aceitar Servi√ßo"
        if (userRole == "provider" && order.providerId == currentUserId) {
            val alreadyAccepted = order.acceptedByProvider
            _uiState.value = _uiState.value.copy(
                showAcceptButton = !alreadyAccepted,
                acceptButtonText = if (alreadyAccepted) "Servi√ßo Aceito" else "Aceitar Servi√ßo"
            )
            return
        }
        
        // Client v√™ bot√£o "Aceitar Or√ßamento"
        if (userRole == "client" && order.clientId == currentUserId) {
            val alreadyAccepted = order.acceptedByClient
            _uiState.value = _uiState.value.copy(
                showAcceptButton = !alreadyAccepted,
                acceptButtonText = if (alreadyAccepted) "Or√ßamento Aceito" else "Aceitar Or√ßamento"
            )
            return
        }
        
        _uiState.value = _uiState.value.copy(showAcceptButton = false)
    }
    
    fun acceptService() {
        val order = _uiState.value.order ?: return
        val currentUserRole = _uiState.value.currentUserRole ?: return
        
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isAccepting = true, error = null)
            
            try {
                val result = if (currentUserRole == "provider") {
                    orderRepository.acceptServiceByProvider(order.id)
                } else {
                    orderRepository.acceptQuoteByClient(order.id)
                }
                
                // Type-safe check: Kotlin smart cast preserva Result.Success<Unit> dentro do bloco
                when (result) {
                    is com.taskgoapp.taskgo.core.model.Result.Success -> {
                        // result √© automaticamente Result.Success<Unit> aqui devido ao smart cast
                        // Recarregar ordem para atualizar estado
                        val updatedOrder = orderRepository.getOrder(order.id)
                        _uiState.value = _uiState.value.copy(
                            order = updatedOrder,
                            isAccepting = false
                        )
                        updateAcceptButtonVisibility(
                            updatedOrder,
                            currentUserRole,
                            firebaseAuth.currentUser?.uid ?: ""
                        )
                    }
                    is com.taskgoapp.taskgo.core.model.Result.Error -> {
                        _uiState.value = _uiState.value.copy(
                            isAccepting = false,
                            error = result.exception.message ?: "Erro ao aceitar"
                        )
                    }
                    is com.taskgoapp.taskgo.core.model.Result.Loading -> {
                        // Nada a fazer, j√° est√° em loading
                    }
                }
            } catch (e: Exception) {
                android.util.Log.e("ChatViewModel", "Erro ao aceitar: ${e.message}", e)
                _uiState.value = _uiState.value.copy(
                    isAccepting = false,
                    error = "Erro ao aceitar: ${e.message}"
                )
            }
        }
    }
    
    fun sendMessage(text: String) {
        val threadId = _uiState.value.thread?.id ?: return
        
        viewModelScope.launch {
            try {
                messageRepository.sendMessage(threadId, text)
            } catch (e: Exception) {
                android.util.Log.e("ChatViewModel", "Erro ao enviar mensagem: ${e.message}", e)
                _uiState.value = _uiState.value.copy(
                    error = "Erro ao enviar mensagem: ${e.message}"
                )
            }
        }
    }
    
    fun clearError() {
        _uiState.value = _uiState.value.copy(error = null)
    }
    
    override fun onCleared() {
        super.onCleared()
        threadListener?.let {
            val conversationsRef = database.reference.child("conversations")
            conversationsRef.removeEventListener(it)
        }
    }
}


```

## [FRONTEND]: feature/messages/presentation/MessagesScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.messages.presentation

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.ui.res.painterResource
import com.taskgoapp.taskgo.core.design.TGIcons
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.collectAsState
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.taskgoapp.taskgo.R
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.design.PrimaryButton
import com.taskgoapp.taskgo.core.model.AccountType
import com.taskgoapp.taskgo.core.model.MessageThread
import com.taskgoapp.taskgo.core.theme.FigmaButtonText
import com.taskgoapp.taskgo.core.theme.FigmaProductDescription
import com.taskgoapp.taskgo.core.theme.FigmaProductName
import com.taskgoapp.taskgo.core.theme.FigmaSectionTitle
import com.taskgoapp.taskgo.core.theme.FigmaStatusText
import com.taskgoapp.taskgo.core.theme.TaskGoBackgroundGray
import com.taskgoapp.taskgo.core.theme.TaskGoGreen
import com.taskgoapp.taskgo.core.theme.TaskGoTextBlack
import com.taskgoapp.taskgo.core.theme.TaskGoTextGray
import java.text.SimpleDateFormat
import java.util.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MessagesScreen(
    onBackClick: () -> Unit,
    onNavigateToChat: (Long) -> Unit,
    onNavigateToCreateWorkOrder: () -> Unit,
    onNavigateToProposals: () -> Unit,
    onNavigateToNotifications: () -> Unit,
    onNavigateToSettings: () -> Unit,
    onNavigateToCart: () -> Unit,
    onNavigateToProviders: () -> Unit,
    onNavigateToServiceOrders: () -> Unit,
    variant: String? = null
) {
    // Dados v√™m do backend via ViewModel
    val viewModel: MessagesViewModel = hiltViewModel()
    val uiState by viewModel.uiState.collectAsState()
    val threads by viewModel.threads.collectAsState()
    val accountType by viewModel.accountType.collectAsState()
    
    Scaffold(
        topBar = {
            AppTopBar(
                title = stringResource(R.string.messages_title),
                onBackClick = null // Sem bot√£o de voltar
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            
            if (uiState.isLoading || variant == "loading") {
                Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                    CircularProgressIndicator()
                }
            } else if (uiState.error != null) {
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    Text(
                        text = uiState.error ?: "Erro ao carregar mensagens",
                        color = MaterialTheme.colorScheme.error
                    )
                }
            } else if (threads.isNotEmpty()) {
                LazyColumn(
                    contentPadding = PaddingValues(16.dp),
                    verticalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    items(threads) { thread ->
                        MessageThreadCard(
                            thread = thread,
                            onClick = { onNavigateToChat(thread.id.toLongOrNull() ?: 0L) }
                        )
                    }
                }
            } else {
                // Empty State
                Box(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(32.dp),
                    contentAlignment = Alignment.Center
                ) {
                    Column(
                        horizontalAlignment = Alignment.CenterHorizontally
                    ) {
                        Icon(
                            painter = painterResource(TGIcons.Messages),
                            contentDescription = null,
                            modifier = Modifier.size(80.dp),
                            tint = TaskGoTextGray
                        )
                        
                        Spacer(modifier = Modifier.height(16.dp))
                        
                        Text(
                            text = stringResource(R.string.messages_empty_title),
                            style = FigmaSectionTitle,
                            color = TaskGoTextBlack
                        )
                        
                        Spacer(modifier = Modifier.height(8.dp))
                        
                        Text(
                            text = stringResource(R.string.messages_empty_message),
                            style = FigmaProductDescription,
                            color = TaskGoTextGray,
                            modifier = Modifier.padding(horizontal = 32.dp),
                            textAlign = androidx.compose.ui.text.style.TextAlign.Center
                        )
                        
                        Spacer(modifier = Modifier.height(24.dp))
                        
                        // Bot√£o condicional baseado no tipo de conta
                        when (accountType) {
                            AccountType.PARCEIRO,
                            AccountType.PRESTADOR -> {
                                PrimaryButton(
                                    text = stringResource(R.string.messages_find_service_orders),
                                    onClick = onNavigateToServiceOrders
                                )
                            }
                            AccountType.CLIENTE, AccountType.VENDEDOR -> {
                        PrimaryButton(
                                    text = stringResource(R.string.messages_find_providers),
                                    onClick = onNavigateToProviders
                        )
                            }
                        }
                    }
                }
            }
        }
    }
}

@Composable
private fun MessageThreadCard(
    thread: MessageThread,
    onClick: () -> Unit
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .clickable(onClick = onClick),
        elevation = CardDefaults.cardElevation(defaultElevation = 1.dp)
    ) {
        Row(
            modifier = Modifier.padding(16.dp),
            verticalAlignment = Alignment.Top
        ) {
            // Avatar
            Box(
                modifier = Modifier
                    .size(48.dp)
                    .clip(CircleShape)
                    .background(TaskGoBackgroundGray),
                        contentAlignment = Alignment.Center
                    ) {
                        Icon(
                    painter = painterResource(when (thread.title) {
                        "Ordem de servi√ßo" -> TGIcons.Edit
                        "Compra de Furadeira" -> TGIcons.Cart
                        "Servi√ßo de Montagem" -> TGIcons.Services
                        else -> TGIcons.Profile
                    }),
                            contentDescription = null,
                            tint = TaskGoTextBlack
                        )
            }
            
            Spacer(modifier = Modifier.width(12.dp))
            
            // Thread Info
            Column(
                modifier = Modifier.weight(1f)
            ) {
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.Top
                ) {
                    Text(
                        text = thread.title,
                        style = FigmaProductName,
                        color = TaskGoTextBlack,
                        maxLines = 1,
                        overflow = TextOverflow.Ellipsis,
                        modifier = Modifier.weight(1f)
                    )
                    
                    Spacer(modifier = Modifier.width(8.dp))
                    
                    Text(
                        text = formatTime(thread.lastTime),
                        style = FigmaStatusText,
                        color = TaskGoTextGray
                    )
                }
                
                Spacer(modifier = Modifier.height(4.dp))
                
                Text(
                    text = thread.lastMessage,
                    style = FigmaProductDescription,
                    color = TaskGoTextGray,
                    maxLines = 2,
                    overflow = TextOverflow.Ellipsis
                )
            }
        }
    }
}

private fun formatTime(timestamp: Long): String {
    val now = System.currentTimeMillis()
    val diff = now - timestamp
    
    return when {
        diff < 60 * 1000 -> "Agora"
        diff < 60 * 60 * 1000 -> "${diff / (60 * 1000)}m"
        diff < 24 * 60 * 60 * 1000 -> "${diff / (60 * 60 * 1000)}h"
        else -> {
            val date = Date(timestamp)
            val formatter = SimpleDateFormat("dd/MM", Locale("pt", "BR"))
            formatter.format(date)
        }
    }
}

```

## [FRONTEND]: feature/messages/presentation/MessagesViewModel.kt

```kotlin
package com.taskgoapp.taskgo.feature.messages.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.taskgoapp.taskgo.core.model.AccountType
import com.taskgoapp.taskgo.core.model.ChatMessage
import com.taskgoapp.taskgo.core.model.MessageThread
import com.taskgoapp.taskgo.domain.repository.MessageRepository
import com.taskgoapp.taskgo.domain.repository.UserRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch
import javax.inject.Inject

data class MessagesUiState(
    val isLoading: Boolean = false,
    val error: String? = null,
    val threads: List<MessageThread> = emptyList()
)

data class ChatUiState(
    val isLoading: Boolean = false,
    val error: String? = null,
    val thread: MessageThread? = null,
    val messages: List<ChatMessage> = emptyList()
)

@HiltViewModel
class MessagesViewModel @Inject constructor(
    private val messageRepository: MessageRepository,
    private val userRepository: UserRepository
) : ViewModel() {
    
    val accountType: StateFlow<AccountType> = userRepository
        .observeCurrentUser()
        .map { user -> user?.accountType ?: AccountType.CLIENTE }
        .stateIn(
            viewModelScope,
            SharingStarted.WhileSubscribed(5_000),
            AccountType.CLIENTE
        )

    private val _uiState = MutableStateFlow(MessagesUiState())
    val uiState: StateFlow<MessagesUiState> = _uiState.asStateFlow()

    val threads: StateFlow<List<MessageThread>> = messageRepository
        .observeThreads()
        .stateIn(
            viewModelScope,
            SharingStarted.WhileSubscribed(5_000),
            emptyList()
        )

    fun getChatState(threadId: String): StateFlow<ChatUiState> {
        val stateFlow = MutableStateFlow(ChatUiState())

        viewModelScope.launch {
            // Observar thread
            messageRepository.getThread(threadId)?.let { thread ->
                stateFlow.value = stateFlow.value.copy(thread = thread)
            }

            // Observar mensagens
            messageRepository.observeMessages(threadId).collect { messages ->
                stateFlow.value = stateFlow.value.copy(messages = messages)
            }
        }

        return stateFlow.asStateFlow()
    }

    init {
        loadThreads()
    }

    private fun loadThreads() {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoading = true, error = null)
            try {
                // Os dados v√™m automaticamente via Flow do reposit√≥rio
                _uiState.value = _uiState.value.copy(isLoading = false)
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = e.message ?: "Erro ao carregar mensagens"
                )
            }
        }
    }

    fun sendMessage(threadId: String, text: String) {
        viewModelScope.launch {
            try {
                messageRepository.sendMessage(threadId, text)
            } catch (e: Exception) {
                // Tratar erro se necess√°rio
            }
        }
    }

    fun createThread(title: String): String? {
        var threadId: String? = null
        viewModelScope.launch {
            try {
                threadId = messageRepository.createThread(title)
            } catch (e: Exception) {
                // Tratar erro se necess√°rio
            }
        }
        return threadId
    }

    fun refresh() {
        loadThreads()
    }

    fun clearError() {
        _uiState.value = _uiState.value.copy(error = null)
    }
    
    /**
     * Busca ou cria uma thread baseada em orderId
     */
    suspend fun getOrCreateThreadForOrder(
        orderId: String,
        orderRepository: com.taskgoapp.taskgo.data.repository.FirestoreOrderRepository,
        userRepository: com.taskgoapp.taskgo.data.repository.FirestoreUserRepository
    ): String {
        val msgRepo = messageRepository as? com.taskgoapp.taskgo.data.repository.MessageRepositoryImpl
            ?: throw IllegalStateException("MessageRepository n√£o √© MessageRepositoryImpl")
        
        return msgRepo.getOrCreateThreadForOrder(orderId, orderRepository, userRepository)
    }
    
    /**
     * Busca ou cria uma thread baseada em providerId
     */
    suspend fun getOrCreateThreadForProvider(
        providerId: String,
        userRepository: com.taskgoapp.taskgo.data.repository.FirestoreUserRepository
    ): String {
        val msgRepo = messageRepository as? com.taskgoapp.taskgo.data.repository.MessageRepositoryImpl
            ?: throw IllegalStateException("MessageRepository n√£o √© MessageRepositoryImpl")
        
        return msgRepo.getOrCreateThreadForProvider(providerId, userRepository)
    }
}


```

# Features - notifications


## [FRONTEND]: feature/notifications/presentation/NotificationDetailScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.notifications.presentation

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.taskgoapp.taskgo.core.theme.TaskGoBackgroundWhite
import com.taskgoapp.taskgo.core.theme.TaskGoGreen
import com.taskgoapp.taskgo.core.theme.TaskGoTextBlack
import com.taskgoapp.taskgo.core.theme.TaskGoTextGray

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun NotificationDetailScreen(
	notificationId: String,
	title: String,
	message: String,
	timestamp: String,
	onBackClick: () -> Unit
) {
	Column(
		modifier = Modifier
			.fillMaxSize()
			.background(TaskGoBackgroundWhite)
	) {
		TopAppBar(
			title = {
				Text(
					text = "Notifica√ß√£o",
					color = TaskGoTextBlack,
					fontSize = 18.sp,
					fontWeight = FontWeight.Bold
				)
			},
			navigationIcon = {
				IconButton(onClick = onBackClick) {
					Icon(
						imageVector = Icons.Filled.ArrowBack,
						contentDescription = "Voltar",
						tint = TaskGoTextBlack
					)
				}
			},
			colors = TopAppBarDefaults.topAppBarColors(
				containerColor = TaskGoBackgroundWhite
			)
		)

		Column(
			modifier = Modifier
				.fillMaxSize()
				.padding(16.dp),
			verticalArrangement = Arrangement.spacedBy(12.dp)
		) {
			Text(
				text = title,
				color = TaskGoTextBlack,
				fontSize = 20.sp,
				fontWeight = FontWeight.Bold
			)
			Text(
				text = timestamp,
				color = TaskGoTextGray,
				fontSize = 12.sp
			)
			HorizontalDivider(color = Color(0xFFE0E0E0))
			Text(
				text = message,
				color = TaskGoTextBlack,
				fontSize = 14.sp,
				lineHeight = 20.sp
			)

			Spacer(modifier = Modifier.height(24.dp))

			Button(
				onClick = onBackClick,
				modifier = Modifier
					.fillMaxWidth()
					.height(52.dp),
				colors = ButtonDefaults.buttonColors(
					containerColor = TaskGoGreen
				),
				shape = MaterialTheme.shapes.medium
			) {
				Text(
					text = "Voltar",
					color = Color.White,
					fontWeight = FontWeight.Bold,
					fontSize = 16.sp,
					textAlign = TextAlign.Center
				)
			}
		}
	}
}

```

## [FRONTEND]: feature/notifications/presentation/NotificationsScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.notifications.presentation

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Notifications
import androidx.compose.material.icons.filled.Settings
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.collectAsState
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.hilt.navigation.compose.hiltViewModel
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.R
import com.taskgoapp.taskgo.data.firestore.models.NotificationFirestore

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun NotificationsScreen(
    onBackClick: () -> Unit,
    onNavigateToNotificationsSettings: () -> Unit,
    onNotificationClick: (String) -> Unit,
    variant: String? = null,
    viewModel: NotificationsViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    val notifications by viewModel.notifications.collectAsState()
    var showSuccessDialog by remember { mutableStateOf(false) }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .background(MaterialTheme.colorScheme.surface)
    ) {
        // Header
        AppTopBar(
            title = stringResource(R.string.notifications_title),
            onBackClick = onBackClick,
            backgroundColor = MaterialTheme.colorScheme.primary,
            titleColor = MaterialTheme.colorScheme.onPrimary,
            backIconColor = MaterialTheme.colorScheme.onPrimary,
            actions = {
                IconButton(
                    onClick = { onNavigateToNotificationsSettings() }
                ) {
                    Icon(
                        imageVector = Icons.Default.Settings,
                        contentDescription = stringResource(R.string.cd_notifications_settings),
                        tint = MaterialTheme.colorScheme.onPrimary
                    )
                }
            }
        )

        if (variant == "settings") {
            // Settings screen ser√° tratado em NotificationsSettingsScreen
            onNavigateToNotificationsSettings()
        } else {
            // Notifications List
            if (uiState.isLoading) {
                Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                    CircularProgressIndicator()
                }
            } else if (uiState.error != null) {
                Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                    Column(
                        horizontalAlignment = Alignment.CenterHorizontally,
                        verticalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        Text(
                            text = uiState.error ?: "Erro ao carregar notifica√ß√µes",
                            style = MaterialTheme.typography.bodyLarge,
                            color = MaterialTheme.colorScheme.error
                        )
                    }
                }
            } else if (notifications.isEmpty()) {
                Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                    Column(
                        horizontalAlignment = Alignment.CenterHorizontally,
                        verticalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        Icon(
                            imageVector = Icons.Default.Notifications,
                            contentDescription = null,
                            modifier = Modifier.size(64.dp),
                            tint = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                        Text(
                            text = "Sem notifica√ß√µes",
                            style = MaterialTheme.typography.bodyLarge,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                }
            } else {
                LazyColumn(
                    modifier = Modifier.fillMaxSize(),
                    contentPadding = PaddingValues(16.dp),
                    verticalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    items(notifications) { notification ->
                        NotificationItemCard(
                            notification = notification,
                            viewModel = viewModel,
                            onClick = { 
                                if (!notification.read) {
                                    viewModel.markAsRead(notification.id)
                                }
                                onNotificationClick(notification.id)
                            }
                        )
                    }
                }
            }
        }
    }

    // Success Dialog
    if (showSuccessDialog) {
        AlertDialog(
            onDismissRequest = { showSuccessDialog = false },
            title = {
                Row(
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Icon(
                        imageVector = Icons.Default.Notifications,
                        contentDescription = null,
                        tint = MaterialTheme.colorScheme.primary,
                        modifier = Modifier.size(24.dp)
                    )
                    Spacer(modifier = Modifier.width(8.dp))
                    Text(
                        text = "TaskGo",
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold
                    )
                }
            },
            text = {
                Text(
                    text = stringResource(R.string.notifications_settings_saved),
                    style = MaterialTheme.typography.bodyMedium
                )
            },
            confirmButton = {
                TextButton(
                    onClick = { showSuccessDialog = false }
                ) {
                    Text("OK")
                }
            }
        )
    }
}

@Composable
private fun NotificationItemCard(
    notification: NotificationFirestore,
    viewModel: NotificationsViewModel,
    onClick: () -> Unit
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .clickable { onClick() },
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp),
        colors = CardDefaults.cardColors(
            containerColor = if (notification.read) 
                MaterialTheme.colorScheme.surface 
            else 
                MaterialTheme.colorScheme.surfaceVariant
        )
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalAlignment = Alignment.Top
        ) {
            // Icon
            Box(
                modifier = Modifier
                    .size(40.dp)
                    .background(
                        color = MaterialTheme.colorScheme.primaryContainer,
                        shape = RoundedCornerShape(8.dp)
                    ),
                contentAlignment = Alignment.Center
            ) {
                Text(
                    text = viewModel.getNotificationIcon(notification.type),
                    fontSize = 20.sp
                )
            }

            Spacer(modifier = Modifier.width(12.dp))

            // Content
            Column(
                modifier = Modifier.weight(1f)
            ) {
                Text(
                    text = notification.title,
                    color = MaterialTheme.colorScheme.onSurface,
                    fontSize = 16.sp,
                    fontWeight = FontWeight.Bold
                )

                Spacer(modifier = Modifier.height(4.dp))

                Text(
                    text = notification.message,
                    color = MaterialTheme.colorScheme.onSurfaceVariant,
                    fontSize = 14.sp,
                    fontWeight = FontWeight.Normal
                )

                Spacer(modifier = Modifier.height(8.dp))

                Text(
                    text = viewModel.formatTimestamp(notification.createdAt),
                    color = MaterialTheme.colorScheme.outline,
                    fontSize = 12.sp,
                    fontWeight = FontWeight.Normal
                )
            }

            // Unread indicator
            if (!notification.read) {
                Spacer(modifier = Modifier.width(8.dp))
                Box(
                    modifier = Modifier
                        .size(8.dp)
                        .background(
                            color = MaterialTheme.colorScheme.primary,
                            shape = CircleShape
                        )
                )
            }
        }
    }
}

```

## [FRONTEND]: feature/notifications/presentation/NotificationsViewModel.kt

```kotlin
package com.taskgoapp.taskgo.feature.notifications.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.taskgoapp.taskgo.data.firestore.models.NotificationFirestore
import com.taskgoapp.taskgo.data.repository.FirestoreNotificationRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch
import java.text.SimpleDateFormat
import java.util.*
import javax.inject.Inject

data class NotificationsUiState(
    val isLoading: Boolean = false,
    val error: String? = null
)

@HiltViewModel
class NotificationsViewModel @Inject constructor(
    private val notificationRepository: FirestoreNotificationRepository
) : ViewModel() {

    private val _uiState = MutableStateFlow(NotificationsUiState())
    val uiState: StateFlow<NotificationsUiState> = _uiState.asStateFlow()

    val notifications: StateFlow<List<NotificationFirestore>> = notificationRepository
        .observeNotifications()
        .stateIn(
            viewModelScope,
            SharingStarted.WhileSubscribed(5_000),
            emptyList()
        )

    fun markAsRead(notificationId: String) {
        viewModelScope.launch {
            notificationRepository.markAsRead(notificationId)
        }
    }

    fun formatTimestamp(timestamp: Date?): String {
        if (timestamp == null) return ""
        
        val now = Date()
        val diff = now.time - timestamp.time
        
        return when {
            diff < 60 * 1000 -> "Agora"
            diff < 60 * 60 * 1000 -> "${diff / (60 * 1000)}m atr√°s"
            diff < 24 * 60 * 60 * 1000 -> "${diff / (60 * 60 * 1000)}h atr√°s"
            diff < 7 * 24 * 60 * 60 * 1000 -> {
                val days = diff / (24 * 60 * 60 * 1000)
                if (days == 1L) "Ontem" else "$days dias atr√°s"
            }
            else -> {
                val formatter = SimpleDateFormat("dd/MM/yyyy", Locale.getDefault())
                formatter.format(timestamp)
            }
        }
    }

    fun getNotificationIcon(type: String): String {
        return when (type) {
            "order_created" -> "üì¶"
            "order_accepted" -> "‚úÖ"
            "order_completed" -> "üéâ"
            "payment_received" -> "üí∞"
            "review_received" -> "‚≠ê"
            "system_alert" -> "üîî"
            "document_verification" -> "üìÑ"
            else -> "üîî"
        }
    }
}


```

# Features - orders


## [FRONTEND]: feature/orders/presentation/DetalhesPedidoScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.orders.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ShoppingCart
import androidx.compose.material.icons.filled.ErrorOutline
import androidx.compose.material.icons.filled.Cancel
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.core.theme.*

@Composable
fun DetalhesPedidoScreen(
    orderId: String,
    onBackClick: () -> Unit,
    onRastrearPedido: (String) -> Unit,
    onVerResumo: (String) -> Unit,
    onEnviarPedido: ((String) -> Unit)? = null, // Para vendedores
    variant: String? = null
) {
    val status = when(variant) {
        "pending" -> "Aguardando pagamento"
        "canceled" -> "Pedido cancelado"
        else -> "A caminho"
    }
    val cor = when(variant) {
        "pending" -> TaskGoWarning
        "canceled" -> TaskGoError
        else -> TaskGoSuccess
    }
    val icone = when(variant) {
        "pending" -> Icons.Default.ErrorOutline
        "canceled" -> Icons.Default.Cancel
        else -> Icons.Default.ShoppingCart
    }
    val produtos = listOf(
        "Guarda-roupa 2 portas" to 750.0,
        "Colch√£o ortop√©dico" to 350.0
    )

    Column(modifier = Modifier.fillMaxSize().padding(24.dp)) {
        Row(verticalAlignment = Alignment.CenterVertically) {
            Icon(icone, null, tint = cor, modifier = Modifier.size(40.dp))
            Spacer(modifier = Modifier.width(12.dp))
            Text("Pedido #$orderId", style = FigmaSectionTitle, color = TaskGoTextBlack)
            Spacer(Modifier.weight(1f))
            Text(status, color = cor, style = FigmaSectionTitle)
        }
        Spacer(modifier = Modifier.height(14.dp))
        Card(modifier = Modifier.fillMaxWidth(), shape = RoundedCornerShape(12.dp)) {
            Column(modifier = Modifier.padding(14.dp)) {
                Text("Produtos", style = FigmaProductDescription, color = TaskGoTextGrayLight)
                produtos.forEach { (nome, valor) ->
                    Row {
                        Text(nome, Modifier.weight(1f), color = TaskGoTextBlack)
                        Text("R$ %.2f".format(valor), color = TaskGoPriceGreen)
                    }
                }
                HorizontalDivider(Modifier.padding(vertical = 8.dp))
                Text("Subtotal: R$ %.2f".format(produtos.sumOf { it.second }), style = FigmaPrice, color = TaskGoTextBlack)
                Text("Taxa de entrega: R$ 15.00", color = TaskGoTextGray)
                Text("Total: R$ %.2f".format(produtos.sumOf { it.second } + 15), style = FigmaSectionTitle, color = TaskGoPriceGreen, fontWeight = FontWeight.Bold)
            }
        }
        Spacer(modifier = Modifier.height(18.dp))
        Card(modifier = Modifier.fillMaxWidth(), shape = RoundedCornerShape(12.dp)) {
            Column(Modifier.padding(14.dp)) {
                Text("Endere√ßo de entrega:", color = TaskGoTextGrayLight, style = FigmaProductDescription)
                Text("[Endere√ßo de entrega]", color = TaskGoTextBlack, style = FigmaProductName)
            }
        }
        Spacer(modifier = Modifier.height(18.dp))
        Row(horizontalArrangement = Arrangement.spacedBy(8.dp), modifier = Modifier.align(Alignment.End)) {
            // Bot√£o de envio para vendedores (quando pedido est√° pago)
            if (onEnviarPedido != null && variant != "pending" && variant != "canceled") {
                Button(
                    onClick = { onEnviarPedido(orderId) },
                    colors = ButtonDefaults.buttonColors(containerColor = TaskGoGreen)
                ) {
                    Text("Confirmar Envio")
                }
            }
            Button(onClick = { onRastrearPedido(orderId) }, enabled = variant != "pending") {
                Text("Rastrear pedido")
            }
            OutlinedButton(onClick = { onVerResumo(orderId) }) {
                Text("Ver resumo")
            }
        }
        if(variant == "canceled") {
            Spacer(modifier = Modifier.height(18.dp))
            Text("Este pedido foi cancelado.", color = TaskGoError, style = FigmaProductDescription)
        }
    }
}

```

## [FRONTEND]: feature/orders/presentation/MeusPedidosScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.orders.presentation
import com.taskgoapp.taskgo.core.theme.*

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowForward
import androidx.compose.material.icons.filled.*
import androidx.compose.material.icons.filled.Inventory
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.collectAsState
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import coil.compose.AsyncImage
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.model.OrderStatus
import com.taskgoapp.taskgo.core.model.PurchaseOrder
import com.taskgoapp.taskgo.core.model.OrderItem
import java.text.SimpleDateFormat
import java.util.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MeusPedidosScreen(
    onBackClick: () -> Unit,
    onOrderClick: (String) -> Unit,
    onNavigateToCreateReview: ((String, String, String?) -> Unit)? = null, // targetId, type, orderId
    viewModel: MyOrdersViewModel = hiltViewModel()
) {
    var selectedTabIndex by remember { mutableStateOf(0) }
    val tabs = listOf("Em andamento", "Conclu√≠do", "Cancelado")
    
    // Carregar pedidos reais do Firestore
    val allOrders by viewModel.orders.collectAsState()
    
    // Converter Order para PurchaseOrder para exibi√ß√£o
    val purchaseOrders = allOrders.map { order ->
        PurchaseOrder(
            id = order.id.toString(),
            orderNumber = order.id.toString(),
            createdAt = order.createdAt.toEpochMilli(),
            total = order.total,
            subtotal = order.total,
            deliveryFee = 0.0,
            status = when (order.status) {
                "EM_ANDAMENTO" -> OrderStatus.EM_ANDAMENTO
                "CONCLUIDO" -> OrderStatus.CONCLUIDO
                "CANCELADO" -> OrderStatus.CANCELADO
                else -> OrderStatus.EM_ANDAMENTO
            },
            items = order.items.map { item ->
                OrderItem(
                    productId = item.productId,
                    price = item.price,
                    quantity = item.quantity
                )
            },
            paymentMethod = "",
            trackingCode = null,
            deliveryAddress = null
        )
    }
    
    val filteredOrders = when (selectedTabIndex) {
        0 -> purchaseOrders.filter { it.status == OrderStatus.EM_ANDAMENTO }
        1 -> purchaseOrders.filter { it.status == OrderStatus.CONCLUIDO }
        2 -> purchaseOrders.filter { it.status == OrderStatus.CANCELADO }
        else -> emptyList()
    }
    
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Meus Pedidos",
                onBackClick = onBackClick
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            // Tabs
            TabRow(
                selectedTabIndex = selectedTabIndex,
                modifier = Modifier.padding(horizontal = 16.dp)
            ) {
                tabs.forEachIndexed { index, title ->
                    Tab(
                        selected = selectedTabIndex == index,
                        onClick = { selectedTabIndex = index },
                        text = { Text(title) }
                    )
                }
            }
            
            // Orders List
            LazyColumn(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(16.dp),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                if (filteredOrders.isEmpty()) {
                    item {
                        Box(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(32.dp),
                            contentAlignment = Alignment.Center
                        ) {
                            Text(
                                text = "Nenhum pedido encontrado",
                                style = MaterialTheme.typography.bodyLarge,
                                color = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                        }
                    }
                } else {
                    items(filteredOrders) { order ->
                        OrderCard(
                            order = order,
                            onClick = { onOrderClick(order.id) },
                            onNavigateToCreateReview = onNavigateToCreateReview
                        )
                    }
                }
            }
        }
    }
}

@Composable
private fun OrderCard(
    order: PurchaseOrder,
    onClick: () -> Unit,
    onNavigateToCreateReview: ((String, String, String?) -> Unit)? = null
) {
    val dateFormat = SimpleDateFormat("dd/MM/yyyy", Locale.getDefault())
    val orderDate = dateFormat.format(Date(order.createdAt))
    
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .clickable { onClick() },
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.surface
        ),
        shape = RoundedCornerShape(12.dp),
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
    ) {
        Row(
            modifier = Modifier.padding(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            // Product Image
            Box(
                modifier = Modifier
                    .size(80.dp)
                    .clip(RoundedCornerShape(8.dp))
                    .background(MaterialTheme.colorScheme.surfaceVariant),
                contentAlignment = Alignment.Center
            ) {
                if (order.items.isNotEmpty()) {
                    // Placeholder para imagem do produto
                    Icon(
                        imageVector = Icons.Default.Inventory,
                        contentDescription = "Produto",
                        tint = MaterialTheme.colorScheme.onSurfaceVariant,
                        modifier = Modifier.size(40.dp)
                    )
                } else {
                    Icon(
                        imageVector = Icons.Default.Inventory,
                        contentDescription = "Produto",
                        tint = MaterialTheme.colorScheme.onSurfaceVariant,
                        modifier = Modifier.size(32.dp)
                    )
                }
            }
            
            Spacer(modifier = Modifier.width(16.dp))
            
            // Order Details
            Column(
                modifier = Modifier.weight(1f)
            ) {
                Text(
                    text = "Pedido #${order.orderNumber}",
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold
                )
                
                if (order.items.isNotEmpty()) {
                    Text(
                        text = "Produto ID: ${order.items.first().productId}",
                        style = MaterialTheme.typography.bodyMedium,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
                
                Text(
                    text = "R$ ${String.format("%.2f", order.total)}",
                    style = MaterialTheme.typography.titleMedium,
                    color = TaskGoSuccessGreen,
                    fontWeight = FontWeight.Bold
                )
                
                Text(
                    text = "Data da compra $orderDate",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
                
                // Status
                val statusText = when (order.status) {
                    OrderStatus.EM_ANDAMENTO -> "Em andamento"
                    OrderStatus.CONCLUIDO -> "Entregue"
                    OrderStatus.CANCELADO -> "Cancelado"
                }
                
                val statusColor = when (order.status) {
                    OrderStatus.EM_ANDAMENTO -> TaskGoSuccessGreen
                    OrderStatus.CONCLUIDO -> TaskGoSuccessGreen
                    OrderStatus.CANCELADO -> Color.Red
                }
                
                Text(
                    text = statusText,
                    style = MaterialTheme.typography.bodyMedium,
                    color = statusColor,
                    fontWeight = FontWeight.Bold
                )
                
                // Bot√£o de avalia√ß√£o para pedidos conclu√≠dos
                if (order.status == OrderStatus.CONCLUIDO && onNavigateToCreateReview != null && order.items.isNotEmpty()) {
                    Spacer(modifier = Modifier.height(8.dp))
                    Button(
                        onClick = {
                            val productId = order.items.first().productId
                            onNavigateToCreateReview(productId, "PRODUCT", order.id)
                        },
                        modifier = Modifier.fillMaxWidth(),
                        colors = ButtonDefaults.buttonColors(
                            containerColor = TaskGoGreen
                        )
                    ) {
                        Icon(
                            imageVector = Icons.Default.Star,
                            contentDescription = null,
                            modifier = Modifier.size(18.dp)
                        )
                        Spacer(modifier = Modifier.width(8.dp))
                        Text("Avaliar Produto", style = FigmaButtonText)
                    }
                }
            }
            
            // Arrow
            Icon(
                imageVector = Icons.AutoMirrored.Filled.ArrowForward,
                contentDescription = "Ver detalhes",
                tint = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }
    }
}
```

## [FRONTEND]: feature/orders/presentation/MyOrdersScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.orders.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.clickable
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.core.design.*
import com.taskgoapp.taskgo.core.model.Order
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import java.util.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MyOrdersScreen(
    onBackClick: () -> Unit,
    onOrderClick: (Long) -> Unit
) {
    val viewModel: MyOrdersViewModel = hiltViewModel()
    var selectedTabIndex by remember { mutableStateOf(0) }
    val tabs = listOf("Em andamento", "Conclu√≠do", "Cancelado")
    
    val orders by viewModel.orders.collectAsStateWithLifecycle(initialValue = emptyList())
    
    val filteredOrders = when (selectedTabIndex) {
        0 -> orders.filter { it.status in listOf("CONFIRMED", "IN_TRANSIT", "OUT_FOR_DELIVERY", "PENDING") }
        1 -> orders.filter { it.status in listOf("DELIVERED", "CONCLUIDO") }
        2 -> orders.filter { it.status in listOf("CANCELLED", "CANCELADO") }
        else -> emptyList()
    }
    
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Meus Pedidos",
                onBackClick = onBackClick
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            // Tabs
            TabRow(
                selectedTabIndex = selectedTabIndex,
                modifier = Modifier.padding(horizontal = 16.dp)
            ) {
                tabs.forEachIndexed { index, title ->
                    Tab(
                        selected = selectedTabIndex == index,
                        onClick = { selectedTabIndex = index },
                        text = { Text(title) }
                    )
                }
            }
            
            // Orders List
            LazyColumn(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(16.dp),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                if (filteredOrders.isEmpty()) {
                    item {
                        EmptyState(
                            icon = Icons.Default.ShoppingBag,
                            title = "Nenhum pedido encontrado",
                            message = "Voc√™ n√£o tem pedidos com este status."
                        )
                    }
                } else {
                    items(filteredOrders) { order ->
                        OrderCard(
                            order = order,
                            onClick = { onOrderClick(order.id) }
                        )
                    }
                }
            }
        }
    }
}

@Composable
fun OrderCard(
    order: Order,
    onClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    val statusText = when (order.status) {
        "PENDING" -> "Pendente"
        "CONFIRMED" -> "Confirmado"
        "IN_TRANSIT" -> "Em tr√¢nsito"
        "OUT_FOR_DELIVERY" -> "Saiu para entrega"
        "DELIVERED" -> "Entregue"
        "CANCELLED" -> "Cancelado"
        else -> order.status
    }
    
    val statusColor = when (order.status) {
        "PENDING" -> MaterialTheme.colorScheme.tertiary
        "CONFIRMED" -> MaterialTheme.colorScheme.primary
        "IN_TRANSIT" -> MaterialTheme.colorScheme.secondary
        "OUT_FOR_DELIVERY" -> MaterialTheme.colorScheme.secondary
        "DELIVERED" -> MaterialTheme.colorScheme.secondary
        "CANCELLED" -> MaterialTheme.colorScheme.error
        else -> MaterialTheme.colorScheme.primary
    }
    
    Card(
        modifier = modifier
            .fillMaxWidth()
            .clickable { onClick() },
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = "Pedido #${order.id}",
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold
                )
                AssistChip(
                    onClick = { },
                    label = { Text(statusText) },
                    colors = AssistChipDefaults.assistChipColors(
                        containerColor = statusColor.copy(alpha = 0.1f)
                    )
                )
            }
            
            Spacer(modifier = Modifier.height(8.dp))
            
            // Order Items
            order.items.forEach { item ->
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Text(
                        text = "${item.quantity}x Produto #${item.productId}",
                        style = MaterialTheme.typography.bodyMedium
                    )
                    Text(
                        text = "R$ %.2f".format(item.price * item.quantity),
                        style = MaterialTheme.typography.bodyMedium,
                        fontWeight = FontWeight.Medium
                    )
                }
            }
            
            Spacer(modifier = Modifier.height(8.dp))
            
            HorizontalDivider()
            
            Spacer(modifier = Modifier.height(8.dp))
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = "Total",
                    style = MaterialTheme.typography.titleSmall,
                    fontWeight = FontWeight.Bold
                )
                Text(
                    text = "R$ %.2f".format(order.total),
                    style = MaterialTheme.typography.titleSmall,
                    fontWeight = FontWeight.Bold
                )
            }
            
            if (order.status == "IN_TRANSIT" || order.status == "OUT_FOR_DELIVERY") {
                Spacer(modifier = Modifier.height(8.dp))
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween
                ) {
                    OutlinedButton(
                        onClick = { /* TODO: Implementar cancelamento */ },
                        colors = ButtonDefaults.outlinedButtonColors(
                            contentColor = MaterialTheme.colorScheme.error
                        )
                    ) {
                        Text("Cancelar Item")
                    }
                    PrimaryButton(
                        text = "Ver Rastreio",
                        onClick = { /* TODO: Implementar rastreamento */ }
                    )
                }
            }
        }
    }
}

```

## [FRONTEND]: feature/orders/presentation/MyOrdersScreens.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.orders.presentation

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.taskgoapp.taskgo.core.theme.TaskGoBackgroundWhite
import com.taskgoapp.taskgo.core.theme.TaskGoGreen
import com.taskgoapp.taskgo.core.theme.TaskGoTextBlack
import com.taskgoapp.taskgo.core.theme.TaskGoTextGray

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MyOrdersInProgressScreen(
	onBackClick: () -> Unit,
	onOrderClick: (String) -> Unit
) {
	val orders = remember {
		listOf(
			OrderItem("#1001", "Guarda roupa", "Previs√£o entrega 30/07/2025"),
			OrderItem("#1002", "Fog√£o de embutir", "Previs√£o entrega 02/08/2025")
		)
	}
	OrdersListBase(
		title = "Meus pedidos em andamento",
		badgeColor = Color(0xFFFFF3CD),
		badgeTextColor = Color(0xFF856404),
		orders = orders,
		onBackClick = onBackClick,
		onOrderClick = onOrderClick
	)
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MyOrdersCompletedScreen(
	onBackClick: () -> Unit,
	onOrderClick: (String) -> Unit
) {
	val orders = remember {
		listOf(
			OrderItem("#0991", "Furadeira sem fio", "Entregue em 12/07/2025")
		)
	}
	OrdersListBase(
		title = "Meus pedidos conclu√≠dos",
		badgeColor = Color(0xFFD4EDDA),
		badgeTextColor = Color(0xFF155724),
		orders = orders,
		onBackClick = onBackClick,
		onOrderClick = onOrderClick
	)
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MyOrdersCanceledScreen(
	onBackClick: () -> Unit,
	onOrderClick: (String) -> Unit
) {
	val orders = remember {
		listOf(
			OrderItem("#0981", "Martelo", "Pedido cancelado")
		)
	}
	OrdersListBase(
		title = "Meus pedidos cancelados",
		badgeColor = Color(0xFFF8D7DA),
		badgeTextColor = Color(0xFF721C24),
		orders = orders,
		onBackClick = onBackClick,
		onOrderClick = onOrderClick
	)
}

data class OrderItem(
	val id: String,
	val title: String,
	val subtitle: String
)

@OptIn(ExperimentalMaterial3Api::class)
@Composable
private fun OrdersListBase(
	title: String,
	badgeColor: Color,
	badgeTextColor: Color,
	orders: List<OrderItem>,
	onBackClick: () -> Unit,
	onOrderClick: (String) -> Unit
) {
	Column(
		modifier = Modifier
			.fillMaxSize()
			.background(TaskGoBackgroundWhite)
	) {
		TopAppBar(
			title = {
				Text(text = title, color = TaskGoTextBlack, fontSize = 18.sp, fontWeight = FontWeight.Bold)
			},
			navigationIcon = {
				IconButton(onClick = onBackClick) {
					Icon(imageVector = Icons.Filled.ArrowBack, contentDescription = "Voltar", tint = TaskGoTextBlack)
				}
			},
			colors = TopAppBarDefaults.topAppBarColors(containerColor = TaskGoBackgroundWhite)
		)

		LazyColumn(
			modifier = Modifier
				.fillMaxSize()
				.padding(16.dp),
			verticalArrangement = Arrangement.spacedBy(12.dp)
		) {
			items(orders) { order ->
				OrderCard(order, badgeColor, badgeTextColor) { onOrderClick(order.id) }
			}
		}
	}
}

@Composable
private fun OrderCard(
	order: OrderItem,
	badgeColor: Color,
	badgeTextColor: Color,
	onClick: () -> Unit
) {
	Card(
		modifier = Modifier.fillMaxWidth(),
		colors = CardDefaults.cardColors(containerColor = Color.White),
		elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
	) {
		Column(Modifier.padding(16.dp)) {
			Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween, verticalAlignment = Alignment.CenterVertically) {
				Text(text = order.title, color = TaskGoTextBlack, fontSize = 16.sp, fontWeight = FontWeight.Bold)
				Surface(color = badgeColor, shape = MaterialTheme.shapes.small) {
					Text(
						text = order.subtitle,
						color = badgeTextColor,
						fontSize = 10.sp,
						modifier = Modifier.padding(horizontal = 8.dp, vertical = 4.dp)
					)
				}
			}
		}
	}
}


```

## [FRONTEND]: feature/orders/presentation/MyOrdersViewModel.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.orders.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.taskgoapp.taskgo.domain.repository.OrdersRepository
import com.taskgoapp.taskgo.core.model.PurchaseOrder
import com.taskgoapp.taskgo.core.model.Order as SimpleOrder
import com.taskgoapp.taskgo.core.model.OrderItem
import com.taskgoapp.taskgo.core.model.OrderStatus
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import javax.inject.Inject
import java.time.Instant

@HiltViewModel
class MyOrdersViewModel @Inject constructor(
    private val ordersRepository: OrdersRepository
) : ViewModel() {
    
    val orders: StateFlow<List<SimpleOrder>> = ordersRepository
        .observeOrders()
        .map { purchaseOrders ->
            purchaseOrders.map { it.toSimpleOrder() }
        }
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyList())
    
    fun observeOrdersByStatus(status: String): StateFlow<List<SimpleOrder>> {
        val orderStatus = when (status) {
            "EM_ANDAMENTO" -> OrderStatus.EM_ANDAMENTO
            "CONCLUIDO" -> OrderStatus.CONCLUIDO
            "CANCELADO" -> OrderStatus.CANCELADO
            else -> null
        }
        
        return if (orderStatus != null) {
            ordersRepository
                .observeOrdersByStatus(orderStatus)
                .map { purchaseOrders ->
                    purchaseOrders.map { it.toSimpleOrder() }
                }
                .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyList())
        } else {
            orders
        }
    }
    
    private fun PurchaseOrder.toSimpleOrder(): SimpleOrder {
        return SimpleOrder(
            id = this.id.toLongOrNull() ?: 0L,
            items = this.items.map { OrderItem(it.productId, it.productTitle, it.quantity, it.price) },
            total = this.total,
            status = this.status.name,
            createdAt = Instant.ofEpochMilli(this.createdAt)
        )
    }
}





```

## [FRONTEND]: feature/orders/presentation/OrderSuccessScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.orders.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.foundation.background
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.CheckCircle
import androidx.compose.material.icons.filled.HourglassEmpty
import androidx.compose.material.icons.filled.ErrorOutline
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.core.theme.*

@Composable
fun OrderSuccessScreen(
    orderId: String,
    totalAmount: Double,
    address: String?,
    onHome: () -> Unit,
    onViewOrder: () -> Unit,
    variant: String? = null // null=success, 'pending', 'error'
) {
    Box(
        modifier = Modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Column(
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center,
            modifier = Modifier.padding(32.dp)
        ) {
            when (variant) {
                "pending" -> {
                    Icon(
                        imageVector = Icons.Filled.HourglassEmpty,
                        contentDescription = "Aguardando processamento",
                        tint = TaskGoWarning,
                        modifier = Modifier.size(80.dp)
                    )
                    Spacer(modifier = Modifier.height(20.dp))
                    Text(
                        "Aguardando confirma√ß√£o",
                        style = FigmaTitleLarge,
                        color = TaskGoWarning
                    )
                    Text(
                        "Seu pedido est√° sendo processado. Assim que confirmado, enviaremos uma notifica√ß√£o.",
                        style = FigmaProductDescription,
                        color = TaskGoTextGray,
                        modifier = Modifier.padding(top = 8.dp, bottom = 20.dp),
                        fontWeight = FontWeight.Normal
                    )
                }
                "error" -> {
                    Icon(
                        imageVector = Icons.Filled.ErrorOutline,
                        contentDescription = "Erro ao processar",
                        tint = TaskGoError,
                        modifier = Modifier.size(80.dp)
                    )
                    Spacer(modifier = Modifier.height(20.dp))
                    Text(
                        "Algo deu errado",
                        style = FigmaTitleLarge,
                        color = TaskGoError
                    )
                    Text(
                        "N√£o foi poss√≠vel processar seu pedido no momento. Tente novamente ou fale com o suporte.",
                        style = FigmaProductDescription,
                        color = TaskGoTextGray,
                        modifier = Modifier.padding(top = 8.dp, bottom = 20.dp),
                        fontWeight = FontWeight.Normal
                    )
                }
                else -> {
                    Icon(
                        imageVector = Icons.Filled.CheckCircle,
                        contentDescription = "Pedido realizado com sucesso",
                        tint = TaskGoSuccess,
                        modifier = Modifier.size(80.dp)
                    )
                    Spacer(modifier = Modifier.height(20.dp))
                    Text(
                        "Pedido finalizado com sucesso!",
                        style = FigmaTitleLarge,
                        color = TaskGoSuccess
                    )
                    Text(
                        "Seu pedido foi confirmado e entraremos em contato para envio e acompanhamento.",
                        style = FigmaProductDescription,
                        color = TaskGoTextGray,
                        modifier = Modifier.padding(top = 8.dp, bottom = 20.dp),
                        fontWeight = FontWeight.Normal
                    )
                }
            }
            HorizontalDivider(modifier = Modifier.padding(vertical = 12.dp))
            Text(
                "Pedido #$orderId",
                style = FigmaSectionTitle,
                color = TaskGoTextBlack
            )
            Row(
                horizontalArrangement = Arrangement.SpaceAround,
                modifier = Modifier.padding(vertical = 8.dp, horizontal = 16.dp)
            ) {
                Column(horizontalAlignment = Alignment.Start, modifier = Modifier.weight(1f)) {
                    Text("Total", style = FigmaProductDescription, color = TaskGoTextGrayLight)
                    Text("R$ %.2f".format(totalAmount), style = FigmaPrice, color = TaskGoPriceGreen, fontWeight = FontWeight.Bold)
                }
                if (address != null) {
                    Column(horizontalAlignment = Alignment.Start, modifier = Modifier.weight(2f)) {
                        Text("Endere√ßo", style = FigmaProductDescription, color = TaskGoTextGrayLight)
                        Text(address, style = FigmaProductName, color = TaskGoTextBlack)
                    }
                }
            }
            Spacer(modifier = Modifier.height(32.dp))
            Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
                Button(onClick = onHome) {
                    Text("Voltar para In√≠cio")
                }
                if (variant != "error") {
                    OutlinedButton(onClick = onViewOrder) {
                        Text("Ver Pedido")
                    }
                }
            }
        }
    }
}


```

## [FRONTEND]: feature/orders/presentation/RastreamentoPedidoScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.orders.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.foundation.rememberScrollState
import androidx.compose.material3.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.LocalShipping
import androidx.compose.material.icons.filled.CheckCircle
import androidx.compose.material.icons.filled.ErrorOutline
import androidx.compose.material.icons.filled.Cancel
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.core.theme.*

@Composable
fun RastreamentoPedidoScreen(
    orderId: String,
    onBackClick: () -> Unit,
    onVerDetalhes: (String) -> Unit,
    variant: String? = null // null=transito, 'delivered', 'delayed', 'canceled'
) {
    val eventosTransito = listOf(
        "Pedido recebido",
        "Pagamento aprovado",
        "Pedido despachado",
        "A caminho do endere√ßo"
    )
    val eventosEntregue = eventosTransito + "Pedido entregue"
    val eventosAtrasado = eventosTransito + "Entrega em atraso"
    val eventosCancelado = eventosTransito.take(2) + "Pedido cancelado"
    val eventos = when(variant) {
        "delivered" -> eventosEntregue
        "delayed" -> eventosAtrasado
        "canceled" -> eventosCancelado
        else -> eventosTransito
    }
    val icone = when(variant) {
        "delivered" -> Icons.Default.CheckCircle
        "delayed" -> Icons.Default.ErrorOutline
        "canceled" -> Icons.Default.Cancel
        else -> Icons.Default.LocalShipping
    }
    val cor = when(variant) {
        "delivered" -> TaskGoSuccess
        "delayed" -> TaskGoWarning
        "canceled" -> TaskGoError
        else -> TaskGoPrimary
    }
    val status = when(variant) {
        "delivered" -> "Entregue"
        "delayed" -> "Entrega em atraso"
        "canceled" -> "Pedido cancelado"
        else -> "Em tr√¢nsito"
    }
    Column(
            modifier = Modifier
                .fillMaxSize()
            .padding(24.dp)
            .verticalScroll(rememberScrollState()),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Icon(icone, contentDescription = status, tint = cor, modifier = Modifier.size(56.dp))
        Spacer(modifier = Modifier.height(12.dp))
        Text("Rastreamento do Pedido", style = FigmaSectionTitle, color = TaskGoTextBlack)
        Text("Pedido #$orderId", style = FigmaProductDescription, color = TaskGoTextGray)
        Spacer(modifier = Modifier.height(20.dp))
        Text("Status: $status", style = FigmaSectionTitle, color = cor)
        Spacer(modifier = Modifier.height(16.dp))
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    shape = RoundedCornerShape(12.dp)
                ) {
                    Column(
                Modifier.padding(16.dp)
            ) {
                eventos.forEachIndexed { i, evento ->
                    Row(verticalAlignment = Alignment.CenterVertically) {
                        Icon(
                            imageVector = if (i == eventos.lastIndex) icone else Icons.Default.LocalShipping,
                            contentDescription = null,
                            tint = if (i == eventos.lastIndex) cor else TaskGoTextGrayLight,
                            modifier = Modifier.size(28.dp)
                        )
                        Spacer(modifier = Modifier.width(8.dp))
                        Text(
                            evento,
                            style = FigmaProductDescription,
                            color = if (i == eventos.lastIndex) cor else TaskGoTextGray
                        )
                    }
                    if (i != eventos.lastIndex) HorizontalDivider()
                }
            }
        }
        Spacer(modifier = Modifier.height(32.dp))
        Button(onClick = { onVerDetalhes(orderId) }) {
            Text("Ver detalhes do pedido")
        }
        Spacer(modifier = Modifier.height(12.dp))
        OutlinedButton(onClick = onBackClick) {
            Text("Voltar")
        }
    }
}

```

## [FRONTEND]: feature/orders/presentation/ResumoPedidoScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.orders.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.Alignment
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.core.theme.*

@Composable
fun ResumoPedidoScreen(
    orderId: String,
    onBackClick: () -> Unit,
    onIrParaPedidos: () -> Unit,
    variant: String? = null // null padr√£o, 'discount', 'voucher'
) {
    val produtos = listOf(
        "Guarda-roupa 2 portas" to 750.0,
        "Colch√£o ortop√©dico" to 350.0
    )
    val desconto = if (variant == "discount") 100.0 else 0.0
    val voucher = if (variant == "voucher") 50.0 else 0.0
    val subtotal = produtos.sumOf { it.second }
    val total = subtotal + 15 - desconto - voucher
    Column(Modifier.fillMaxSize().padding(24.dp)) {
        Text("Resumo do Pedido", style = FigmaSectionTitle, color = TaskGoTextBlack)
        Spacer(Modifier.height(14.dp))
        Card(Modifier.fillMaxWidth(), shape = RoundedCornerShape(12.dp)) {
            Column(Modifier.padding(14.dp)) {
                Text("Produtos", style = FigmaProductDescription, color = TaskGoTextGrayLight)
                produtos.forEach { (nome, valor) ->
                    Row {
                        Text(nome, Modifier.weight(1f), color = TaskGoTextBlack)
                        Text("R$ %.2f".format(valor), color = TaskGoPriceGreen)
                    }
                }
                HorizontalDivider(Modifier.padding(vertical = 8.dp))
                Text("Subtotal: R$ %.2f".format(subtotal), style = FigmaPrice)
                Text("Taxa de entrega: R$ 15.00", color = TaskGoTextGray)
                if(desconto > 0) Text("Desconto: -R$ %.2f".format(desconto), color = TaskGoSuccess)
                if(voucher > 0) Text("Voucher aplicado: -R$ %.2f".format(voucher), color = TaskGoAccent)
                Text("Total: R$ %.2f".format(total), style = FigmaSectionTitle, color = TaskGoPriceGreen, fontWeight = FontWeight.Bold)
            }
        }
        Spacer(Modifier.height(18.dp))
        Card(Modifier.fillMaxWidth(), shape = RoundedCornerShape(12.dp)) {
            Column(Modifier.padding(14.dp)) {
                Text("Endere√ßo de entrega:", color = TaskGoTextGrayLight, style = FigmaProductDescription)
                Text("[Endere√ßo de entrega]", color = TaskGoTextBlack, style = FigmaProductName)
            }
        }
        Spacer(Modifier.height(32.dp))
        Row(horizontalArrangement = Arrangement.spacedBy(8.dp), modifier = Modifier.align(Alignment.End)) {
            Button(onClick = onIrParaPedidos) {
                Text("Finalizar pedido")
            }
            OutlinedButton(onClick = onBackClick) {
                Text("Voltar")
            }
        }
    }
}

```

## [FRONTEND]: feature/orders/presentation/ShipmentScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.orders.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.theme.*
import com.taskgoapp.taskgo.data.firestore.models.PurchaseOrderFirestore
import kotlinx.coroutines.launch
import kotlinx.coroutines.tasks.await
import kotlinx.coroutines.flow.asStateFlow
import javax.inject.Inject

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ShipmentScreen(
    orderId: String,
    onBackClick: () -> Unit,
    onShipmentConfirmed: () -> Unit,
    viewModel: ShipmentViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    val scope = rememberCoroutineScope()
    
    LaunchedEffect(orderId) {
        viewModel.loadOrder(orderId)
    }
    
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Confirmar Envio",
                onBackClick = onBackClick
            )
        }
    ) { paddingValues ->
        if (uiState.isLoading) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues),
                contentAlignment = Alignment.Center
            ) {
                CircularProgressIndicator()
            }
        } else if (uiState.order == null) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues),
                contentAlignment = Alignment.Center
            ) {
                Text("Pedido n√£o encontrado", color = TaskGoTextGray)
            }
        } else {
            val order = uiState.order!!
            val isSameCity = uiState.isSameCity
            
            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues)
                    .verticalScroll(rememberScrollState())
                    .padding(16.dp),
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                // Informa√ß√µes do Pedido
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    colors = CardDefaults.cardColors(
                        containerColor = TaskGoSurface
                    )
                ) {
                    Column(
                        modifier = Modifier.padding(16.dp),
                        verticalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        Text(
                            text = "Pedido #${order.orderNumber}",
                            style = MaterialTheme.typography.titleMedium,
                            fontWeight = FontWeight.Bold,
                            color = TaskGoTextBlack
                        )
                        Text(
                            text = "Total: R$ ${String.format("%.2f", order.total)}",
                            style = MaterialTheme.typography.bodyLarge,
                            color = TaskGoTextBlack
                        )
                        if (order.deliveryAddressDetails != null) {
                            Text(
                                text = "Endere√ßo: ${order.deliveryAddressDetails.city}, ${order.deliveryAddressDetails.state}",
                                style = MaterialTheme.typography.bodyMedium,
                                color = TaskGoTextGray
                            )
                        }
                    }
                }
                
                if (isSameCity) {
                    // Pedido na mesma cidade - confirma√ß√£o simples
                    SameCityShipmentSection(
                        onConfirmDelivery = { deliveryTime ->
                            scope.launch {
                                viewModel.confirmSameCityDelivery(orderId, deliveryTime)
                                onShipmentConfirmed()
                            }
                        }
                    )
                } else {
                    // Pedido entre cidades - rastreamento
                    CrossCityShipmentSection(
                        trackingCode = uiState.trackingCode,
                        trackingUrl = uiState.trackingUrl,
                        carrierName = uiState.carrierName,
                        shippingMethod = uiState.shippingMethod,
                        onTrackingCodeChange = { viewModel.updateTrackingCode(it) },
                        onTrackingUrlChange = { viewModel.updateTrackingUrl(it) },
                        onCarrierChange = { viewModel.updateCarrier(it) },
                        onShippingMethodChange = { viewModel.updateShippingMethod(it) },
                        onConfirmShipment = {
                            scope.launch {
                                viewModel.confirmShipment(orderId)
                                onShipmentConfirmed()
                            }
                        }
                    )
                }
            }
        }
    }
}

@Composable
private fun SameCityShipmentSection(
    onConfirmDelivery: (String) -> Unit
) {
    var deliveryTime by remember { mutableStateOf("") }
    var showTimePicker by remember { mutableStateOf(false) }
    
    Card(
        modifier = Modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(
            containerColor = TaskGoSurface
        )
    ) {
        Column(
            modifier = Modifier.padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            Row(
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Icon(
                    imageVector = Icons.Default.LocationOn,
                    contentDescription = null,
                    tint = TaskGoGreen
                )
                Text(
                    text = "Pedido na Mesma Cidade",
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold,
                    color = TaskGoTextBlack
                )
            }
            
            Text(
                text = "Este pedido ser√° entregue na mesma cidade. Confirme quando o pedido chegou ao cliente.",
                style = MaterialTheme.typography.bodyMedium,
                color = TaskGoTextGray
            )
            
            OutlinedTextField(
                value = deliveryTime,
                onValueChange = { deliveryTime = it },
                label = { Text("Hor√°rio de Chegada (ex: 14:30)") },
                modifier = Modifier.fillMaxWidth(),
                leadingIcon = {
                    Icon(Icons.Default.Schedule, contentDescription = null)
                },
                placeholder = { Text("HH:MM") }
            )
            
            Button(
                onClick = { 
                    if (deliveryTime.isNotBlank()) {
                        onConfirmDelivery(deliveryTime)
                    }
                },
                modifier = Modifier.fillMaxWidth(),
                enabled = deliveryTime.isNotBlank(),
                colors = ButtonDefaults.buttonColors(
                    containerColor = TaskGoGreen
                )
            ) {
                Text("Confirmar Entrega")
            }
        }
    }
}

@Composable
private fun CrossCityShipmentSection(
    trackingCode: String,
    trackingUrl: String?,
    carrierName: String?,
    shippingMethod: String?,
    onTrackingCodeChange: (String) -> Unit,
    onTrackingUrlChange: (String) -> Unit,
    onCarrierChange: (String) -> Unit,
    onShippingMethodChange: (String) -> Unit,
    onConfirmShipment: () -> Unit
) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(
            containerColor = TaskGoSurface
        )
    ) {
        Column(
            modifier = Modifier.padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            Row(
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Icon(
                    imageVector = Icons.Default.LocalShipping,
                    contentDescription = null,
                    tint = TaskGoGreen
                )
                Text(
                    text = "Pedido Entre Cidades",
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold,
                    color = TaskGoTextBlack
                )
            }
            
            Text(
                text = "Este pedido ser√° enviado para outra cidade. Informe os dados de rastreamento.",
                style = MaterialTheme.typography.bodyMedium,
                color = TaskGoTextGray
            )
            
            // Sele√ß√£o de transportadora
            Text(
                text = "Transportadora",
                style = MaterialTheme.typography.labelLarge,
                fontWeight = FontWeight.Medium,
                color = TaskGoTextBlack
            )
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                FilterChip(
                    selected = shippingMethod == "CORREIOS",
                    onClick = { onShippingMethodChange("CORREIOS") },
                    label = { Text("Correios") },
                    modifier = Modifier.weight(1f)
                )
                FilterChip(
                    selected = shippingMethod == "OTHER",
                    onClick = { onShippingMethodChange("OTHER") },
                    label = { Text("Outra") },
                    modifier = Modifier.weight(1f)
                )
            }
            
            if (shippingMethod == "CORREIOS") {
                // C√≥digo de rastreamento dos Correios
                OutlinedTextField(
                    value = trackingCode,
                    onValueChange = onTrackingCodeChange,
                    label = { Text("C√≥digo de Rastreamento") },
                    modifier = Modifier.fillMaxWidth(),
                    leadingIcon = {
                        Icon(Icons.Default.QrCode, contentDescription = null)
                    },
                    placeholder = { Text("Ex: AA123456789BR") },
                    singleLine = true
                )
            } else if (shippingMethod == "OTHER") {
                // Outra transportadora
                OutlinedTextField(
                    value = carrierName ?: "",
                    onValueChange = onCarrierChange,
                    label = { Text("Nome da Transportadora") },
                    modifier = Modifier.fillMaxWidth(),
                    leadingIcon = {
                        Icon(Icons.Default.LocalShipping, contentDescription = null)
                    },
                    singleLine = true
                )
                
                OutlinedTextField(
                    value = trackingCode,
                    onValueChange = onTrackingCodeChange,
                    label = { Text("C√≥digo de Rastreamento") },
                    modifier = Modifier.fillMaxWidth(),
                    leadingIcon = {
                        Icon(Icons.Default.QrCode, contentDescription = null)
                    },
                    placeholder = { Text("C√≥digo de rastreamento") },
                    singleLine = true
                )
                
                OutlinedTextField(
                    value = trackingUrl ?: "",
                    onValueChange = onTrackingUrlChange,
                    label = { Text("URL de Rastreamento") },
                    modifier = Modifier.fillMaxWidth(),
                    leadingIcon = {
                        Icon(Icons.Default.Link, contentDescription = null)
                    },
                    placeholder = { Text("https://...") },
                    singleLine = true
                )
            }
            
            Button(
                onClick = onConfirmShipment,
                modifier = Modifier.fillMaxWidth(),
                enabled = trackingCode.isNotBlank() && shippingMethod != null,
                colors = ButtonDefaults.buttonColors(
                    containerColor = TaskGoGreen
                )
            ) {
                Text("Confirmar Envio")
            }
        }
    }
}

@dagger.hilt.android.lifecycle.HiltViewModel
class ShipmentViewModel @Inject constructor(
    private val firestoreOrdersRepository: com.taskgoapp.taskgo.data.repository.FirestoreOrdersRepositoryImpl,
    private val functionsService: com.taskgoapp.taskgo.data.firebase.FirebaseFunctionsService
) : androidx.lifecycle.ViewModel() {
    
    private val _uiState = kotlinx.coroutines.flow.MutableStateFlow(ShipmentUiState())
    val uiState: kotlinx.coroutines.flow.StateFlow<ShipmentUiState> = _uiState.asStateFlow()
    
    suspend fun loadOrder(orderId: String) {
        _uiState.value = _uiState.value.copy(isLoading = true)
        try {
            val order = firestoreOrdersRepository.getPurchaseOrder(orderId)
            if (order != null) {
                // Verificar se √© mesma cidade comparando cidade do vendedor com cidade do cliente
                val isSameCity = checkIfSameCity(order)
                _uiState.value = _uiState.value.copy(
                    order = order,
                    isSameCity = isSameCity,
                    isLoading = false
                )
            } else {
                _uiState.value = _uiState.value.copy(isLoading = false)
            }
        } catch (e: Exception) {
            android.util.Log.e("ShipmentVM", "Erro ao carregar pedido: ${e.message}", e)
            _uiState.value = _uiState.value.copy(isLoading = false)
        }
    }
    
    private suspend fun checkIfSameCity(order: PurchaseOrderFirestore): Boolean {
        // TODO: Implementar l√≥gica para verificar se vendedor e cliente est√£o na mesma cidade
        // Por enquanto, retorna false (assume que √© entre cidades)
        return false
    }
    
    fun updateTrackingCode(code: String) {
        _uiState.value = _uiState.value.copy(trackingCode = code)
    }
    
    fun updateTrackingUrl(url: String) {
        _uiState.value = _uiState.value.copy(trackingUrl = url)
    }
    
    fun updateCarrier(name: String) {
        _uiState.value = _uiState.value.copy(carrierName = name)
    }
    
    fun updateShippingMethod(method: String) {
        _uiState.value = _uiState.value.copy(shippingMethod = method)
    }
    
    suspend fun confirmShipment(orderId: String) {
        val state = _uiState.value
        try {
            // Criar documento de envio no Firestore
            val shipmentData = hashMapOf<String, Any>(
                "purchaseOrderId" to orderId,
                "orderId" to orderId, // Mantido para compatibilidade
                "sellerId" to (state.order?.storeId ?: ""),
                "clientId" to (state.order?.clientId ?: ""),
                "isLocalDelivery" to false,
                "isSameCity" to false, // Mantido para compatibilidade
                "shippingMethod" to (state.shippingMethod ?: "CORREIOS"),
                "carrier" to (state.shippingMethod ?: "Correios"),
                "carrierName" to (state.carrierName ?: (state.shippingMethod ?: "Correios")),
                "trackingCode" to state.trackingCode,
                "status" to "SHIPPED"
            )
            if (state.trackingUrl != null) shipmentData["trackingUrl"] = state.trackingUrl
            if (state.carrierName != null) shipmentData["carrierName"] = state.carrierName
            shipmentData["shippedAt"] = com.google.firebase.firestore.FieldValue.serverTimestamp()
            shipmentData["createdAt"] = com.google.firebase.firestore.FieldValue.serverTimestamp()
            shipmentData["updatedAt"] = com.google.firebase.firestore.FieldValue.serverTimestamp()
            
            // CR√çTICO: Usar FirestoreHelper para garantir que est√° usando database 'taskgo'
            val shipmentRef = com.taskgoapp.taskgo.core.firebase.FirestoreHelper.getInstance()
                .collection("shipments")
                .add(shipmentData)
                .await()
            
            // Atualizar status do pedido
            firestoreOrdersRepository.updatePurchaseOrderStatus(orderId, "SHIPPED")
            
            // Transferir pagamento para o vendedor ap√≥s confirma√ß√£o de envio
            val transferResult = functionsService.transferPaymentToSeller(orderId)
            transferResult.onSuccess {
                android.util.Log.d("ShipmentVM", "Pagamento transferido com sucesso para o vendedor")
            }.onFailure { error ->
                android.util.Log.e("ShipmentVM", "Erro ao transferir pagamento: ${error.message}", error)
                // N√£o lan√ßar exce√ß√£o aqui - o envio foi confirmado, apenas logar o erro
            }
        } catch (e: Exception) {
            android.util.Log.e("ShipmentVM", "Erro ao confirmar envio: ${e.message}", e)
            throw e
        }
    }
    
    suspend fun confirmSameCityDelivery(orderId: String, deliveryTime: String) {
        try {
            val shipmentData = hashMapOf<String, Any>(
                "purchaseOrderId" to orderId,
                "orderId" to orderId, // Mantido para compatibilidade
                "sellerId" to (_uiState.value.order?.storeId ?: ""),
                "clientId" to (_uiState.value.order?.clientId ?: ""),
                "isLocalDelivery" to true,
                "isSameCity" to true, // Mantido para compatibilidade
                "shippingMethod" to "SAME_CITY",
                "carrier" to "Local",
                "carrierName" to "Entrega Local",
                "status" to "DELIVERED",
                "deliveryTime" to deliveryTime
            )
            shipmentData["deliveredAt"] = com.google.firebase.firestore.FieldValue.serverTimestamp()
            shipmentData["createdAt"] = com.google.firebase.firestore.FieldValue.serverTimestamp()
            shipmentData["updatedAt"] = com.google.firebase.firestore.FieldValue.serverTimestamp()
            
            com.taskgoapp.taskgo.core.firebase.FirestoreHelper.getInstance()
                .collection("shipments")
                .add(shipmentData)
                .await()
            
            // Atualizar status do pedido
            firestoreOrdersRepository.updatePurchaseOrderStatus(orderId, "DELIVERED")
            
            // Transferir pagamento para o vendedor ap√≥s confirma√ß√£o de entrega local
            val transferResult = functionsService.transferPaymentToSeller(orderId)
            transferResult.onSuccess {
                android.util.Log.d("ShipmentVM", "Pagamento transferido com sucesso para o vendedor")
            }.onFailure { error ->
                android.util.Log.e("ShipmentVM", "Erro ao transferir pagamento: ${error.message}", error)
                // N√£o lan√ßar exce√ß√£o aqui - a entrega foi confirmada, apenas logar o erro
            }
        } catch (e: Exception) {
            android.util.Log.e("ShipmentVM", "Erro ao confirmar entrega: ${e.message}", e)
            throw e
        }
    }
}

data class ShipmentUiState(
    val order: PurchaseOrderFirestore? = null,
    val isSameCity: Boolean = false,
    val trackingCode: String = "",
    val trackingUrl: String? = null,
    val carrierName: String? = null,
    val shippingMethod: String? = null,
    val isLoading: Boolean = false
)


```

# Features - products


## [FRONTEND]: feature/products/presentation/CarrinhoScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.products.presentation

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.R
import com.taskgoapp.taskgo.core.data.PreferencesManager
import com.taskgoapp.taskgo.core.design.AppTopBar

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun CarrinhoScreen(
    onBackClick: () -> Unit,
    onContinuar: () -> Unit
) {
    val context = LocalContext.current
    val preferencesManager = remember { PreferencesManager(context) }
    
    var quantity by remember { mutableStateOf(preferencesManager.getCartQuantity()) }
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Carrinho",
                onBackClick = onBackClick
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // Cart items
            Card(
                modifier = Modifier.fillMaxWidth(),
                colors = CardDefaults.cardColors(
                    containerColor = MaterialTheme.colorScheme.surface
                )
            ) {
                Row(
                    modifier = Modifier.padding(16.dp),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    // Product image placeholder
                    Box(
                        modifier = Modifier
                            .size(80.dp)
                            .background(
                                color = MaterialTheme.colorScheme.surfaceVariant,
                                shape = MaterialTheme.shapes.medium
                            ),
                        contentAlignment = Alignment.Center
                    ) {
                        Text(
                            text = "üì¶",
                            style = MaterialTheme.typography.headlineMedium
                        )
                    }

                    Spacer(modifier = Modifier.width(16.dp))

                    // Product details
                    Column(
                        modifier = Modifier.weight(1f)
                    ) {
                        Text(
                            text = "Guarda Roupa",
                            style = MaterialTheme.typography.titleMedium,
                            fontWeight = FontWeight.Medium
                        )
                        Text(
                            text = "R$ 750,00",
                            style = MaterialTheme.typography.titleMedium,
                            color = MaterialTheme.colorScheme.primary,
                            fontWeight = FontWeight.Bold
                        )
                        Row(
                            verticalAlignment = Alignment.CenterVertically,
                            horizontalArrangement = Arrangement.spacedBy(8.dp)
                        ) {
                            Text(
                                text = "Quantidade:",
                                style = MaterialTheme.typography.bodyMedium,
                                color = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                            
                            IconButton(
                                onClick = { 
                                    if (quantity > 1) {
                                        quantity--
                                        preferencesManager.saveCartQuantity(quantity)
                                    }
                                },
                                modifier = Modifier.size(32.dp)
                            ) {
                                Icon(
                                    painter = painterResource(R.drawable.ic_delete),
                                    contentDescription = "Diminuir",
                                    modifier = Modifier.size(16.dp),
                                    tint = MaterialTheme.colorScheme.onSurfaceVariant
                                )
                            }
                            
                            Text(
                                text = quantity.toString(),
                                style = MaterialTheme.typography.bodyMedium,
                                fontWeight = FontWeight.Medium
                            )
                            
                            IconButton(
                                onClick = { 
                                    quantity++
                                    preferencesManager.saveCartQuantity(quantity)
                                },
                                modifier = Modifier.size(32.dp)
                            ) {
                                Icon(
                                    painter = painterResource(R.drawable.ic_add),
                                    contentDescription = "Aumentar",
                                    modifier = Modifier.size(16.dp),
                                    tint = MaterialTheme.colorScheme.onSurfaceVariant
                                )
                            }
                        }
                    }

                    // Delete button
                    IconButton(
                        onClick = { /* TODO: Remover item */ }
                    ) {
                        Icon(
                            imageVector = Icons.Default.Delete,
                            contentDescription = "Remover",
                            tint = MaterialTheme.colorScheme.error
                        )
                    }
                }
            }

            Spacer(modifier = Modifier.weight(1f))

            // Total
            Card(
                modifier = Modifier.fillMaxWidth(),
                colors = CardDefaults.cardColors(
                    containerColor = MaterialTheme.colorScheme.surface
                )
            ) {
                Column(
                    modifier = Modifier.padding(16.dp),
                    verticalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween
                    ) {
                        Text(
                            text = "Subtotal:",
                            style = MaterialTheme.typography.bodyLarge
                        )
                        Text(
                            text = "R$ 750,00",
                            style = MaterialTheme.typography.bodyLarge
                        )
                    }
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween
                    ) {
                        Text(
                            text = "Frete:",
                            style = MaterialTheme.typography.bodyLarge
                        )
                        Text(
                            text = "R$ 25,00",
                            style = MaterialTheme.typography.bodyLarge
                        )
                    }
                    HorizontalDivider()
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween
                    ) {
                        Text(
                            text = "Total:",
                            style = MaterialTheme.typography.titleLarge,
                            fontWeight = FontWeight.Bold
                        )
                        Text(
                            text = "R$ 775,00",
                            style = MaterialTheme.typography.titleLarge,
                            color = MaterialTheme.colorScheme.primary,
                            fontWeight = FontWeight.Bold
                        )
                    }
                }
            }

            // Continue button
            Button(
                onClick = onContinuar,
                modifier = Modifier.fillMaxWidth(),
                colors = ButtonDefaults.buttonColors(
                    containerColor = MaterialTheme.colorScheme.primary
                )
            ) {
                Text(
                    text = "Continuar",
                    fontWeight = FontWeight.Bold
                )
            }
        }
    }
}

```

## [FRONTEND]: feature/products/presentation/CartScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.products.presentation

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.layout.ContentScale
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import coil.compose.AsyncImage
import coil.request.ImageRequest
import com.taskgoapp.taskgo.R
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.theme.*
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.delay
import com.taskgoapp.taskgo.core.data.models.CartItem

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun CartScreen(
    onNavigateToCheckout: () -> Unit,
    onNavigateToProductDetail: (String) -> Unit,
    onNavigateBack: () -> Unit,
    onNavigateToProducts: () -> Unit = {},
    variant: String? = null,
    viewModel: CartViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    val isLoading = variant == "loading" || uiState.isLoading
    val isError = variant == "error" || uiState.error != null
    val isSelectingAddress = variant == "selection_address"
    val cartItems = uiState.cartItems
    val total = uiState.total
    val deliveryFee = uiState.deliveryFee
    val finalTotal = uiState.finalTotal
    
    var showRemoveDialog by remember { mutableStateOf<com.taskgoapp.taskgo.core.data.models.CartItem?>(null) }

    // Loading state
    if (isLoading) {
        Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
            CircularProgressIndicator()
        }
        return
    }

    // Error state
    if (isError) {
        Box(
            modifier = Modifier.fillMaxSize(),
            contentAlignment = Alignment.Center
        ) {
            Column(horizontalAlignment = Alignment.CenterHorizontally) {
                Icon(
                    imageVector = Icons.Default.ErrorOutline,
                    contentDescription = null,
                    modifier = Modifier.size(72.dp),
                    tint = TaskGoError
                )
                Spacer(modifier = Modifier.height(18.dp))
                Text(
                    text = "Erro ao carregar o carrinho",
                    style = FigmaProductName,
                    color = TaskGoError
                )
                Text(
                    text = "Tente novamente em instantes.",
                    style = FigmaProductDescription,
                    color = TaskGoTextGray
                )
                Spacer(modifier = Modifier.height(20.dp))
                Button(
                    onClick = onNavigateBack,
                    colors = ButtonDefaults.buttonColors(
                        containerColor = TaskGoGreen
                    )
                ) {
                    Text(
                        "Tentar Novamente",
                        style = FigmaButtonText,
                        color = Color.White
                    )
                }
            }
        }
        return
    }

    Scaffold(
        topBar = {
            AppTopBar(
                title = stringResource(R.string.cart_title),
                onBackClick = onNavigateBack
            )
        },
        bottomBar = {
            if (cartItems.isNotEmpty()) {
                CartBottomBar(
                    total = finalTotal,
                    itemCount = cartItems.size,
                    onCheckout = onNavigateToCheckout
                )
            }
        }
    ) { paddingValues ->
        if (cartItems.isNotEmpty()) {
            LazyColumn(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues),
                contentPadding = PaddingValues(16.dp),
                verticalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                if (isSelectingAddress) {
                    item {
                        Card(modifier = Modifier.fillMaxWidth()) {
                            Column(Modifier.padding(18.dp)) {
                                Text("Entregar em:", style = FigmaProductName, color = TaskGoTextBlack)
                                Text("[Endere√ßo de entrega]", style = FigmaProductDescription, color = TaskGoTextGray)
                            }
                        }
                        Spacer(modifier = Modifier.height(8.dp))
                    }
                }
                item {
                    Text(
                        text = stringResource(R.string.cart_items_title, cartItems.size),
                        style = FigmaProductName,
                        color = TaskGoTextBlack
                    )
                    Spacer(modifier = Modifier.height(16.dp))
                }
                items(cartItems.size) { index ->
                    val cartItemWithId = cartItems[index]
                    val cartItem = cartItemWithId.uiCartItem
                    CartItemCard(
                        cartItem = cartItem,
                        onQuantityIncrease = { viewModel.increaseQuantity(cartItemWithId.productId) },
                        onQuantityDecrease = { viewModel.decreaseQuantity(cartItemWithId.productId) },
                        onRemove = { showRemoveDialog = cartItem },
                        onClick = { onNavigateToProductDetail(cartItemWithId.productId) }
                    )
                }
                item {
                    Spacer(modifier = Modifier.height(16.dp))
                    Card(
                        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
                    ) {
                        Column(
                            modifier = Modifier.padding(16.dp)
                        ) {
                            Text(
                                text = stringResource(R.string.cart_summary_title),
                                style = FigmaProductName,
                                color = TaskGoTextBlack
                            )
                            Spacer(modifier = Modifier.height(12.dp))
                            SummaryRow(
                                label = stringResource(R.string.cart_subtotal),
                                value = "R$ ${String.format("%.2f", total)}"
                            )
                            SummaryRow(
                                label = stringResource(R.string.cart_delivery),
                                value = "R$ ${String.format("%.2f", deliveryFee)}"
                            )
                            HorizontalDivider(color = TaskGoDivider, modifier = Modifier.padding(vertical = 8.dp))
                            SummaryRow(
                                label = stringResource(R.string.cart_total),
                                value = "R$ ${String.format("%.2f", finalTotal)}",
                                isProminent = true
                            )
                        }
                    }
                }
            }
        } else {
            // Empty Cart
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues),
                contentAlignment = Alignment.Center
            ) {
                Column(
                    horizontalAlignment = Alignment.CenterHorizontally,
                    modifier = Modifier.padding(32.dp)
                ) {
                    Icon(
                        imageVector = Icons.Default.ShoppingCart,
                        contentDescription = null,
                        modifier = Modifier.size(80.dp),
                        tint = TaskGoTextGray
                    )
                    Spacer(modifier = Modifier.height(16.dp))
                    Text(
                        text = stringResource(R.string.cart_empty_title),
                        style = FigmaSectionTitle,
                        color = TaskGoTextGray
                    )
                    Spacer(modifier = Modifier.height(8.dp))
                    Text(
                        text = stringResource(R.string.cart_empty_message),
                        style = FigmaProductDescription,
                        color = TaskGoTextGray,
                        modifier = Modifier.padding(horizontal = 32.dp)
                    )
                    Spacer(modifier = Modifier.height(24.dp))
                    Button(
                        onClick = onNavigateToProducts,
                        colors = ButtonDefaults.buttonColors(
                            containerColor = TaskGoGreen
                        )
                    ) {
                        Icon(
                            imageVector = Icons.Default.ShoppingBag,
                            contentDescription = null,
                            tint = Color.White
                        )
                        Spacer(modifier = Modifier.width(8.dp))
                        Text(
                            stringResource(R.string.cart_start_shopping),
                            style = FigmaButtonText,
                            color = Color.White
                        )
                    }
                }
            }
        }
    }
    // Remove Item Dialog
    showRemoveDialog?.let { item ->
        AlertDialog(
            onDismissRequest = { showRemoveDialog = null },
            title = { Text(stringResource(R.string.cart_remove_title)) },
            text = { Text(stringResource(R.string.cart_remove_message, item.product.name)) },
            confirmButton = {
                TextButton(
                    onClick = {
                        // Encontrar o productId do item removido
                        uiState.cartItems.find { it.uiCartItem == item }?.let { cartItemWithId ->
                            viewModel.removeItem(cartItemWithId.productId)
                        }
                        showRemoveDialog = null
                    }
                ) {
                    Text(stringResource(R.string.cart_remove_confirm))
                }
            },
            dismissButton = {
                TextButton(
                    onClick = { showRemoveDialog = null }
                ) {
                    Text(stringResource(R.string.cart_remove_cancel))
                }
            }
        )
    }
}

@Composable
private fun CartItemCard(
    cartItem: CartItem,
    onQuantityIncrease: () -> Unit,
    onQuantityDecrease: () -> Unit,
    onRemove: () -> Unit,
    onClick: () -> Unit
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .clickable(onClick = onClick),
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
    ) {
        Row(
            modifier = Modifier.padding(12.dp),
            verticalAlignment = Alignment.Top
        ) {
            // Product Image
            val imageUri = cartItem.product.imageUrl
            Box(
                modifier = Modifier
                    .size(80.dp)
                    .background(TaskGoSurfaceGray),
                contentAlignment = Alignment.Center
            ) {
                if (imageUri != null && imageUri.isNotBlank()) {
                    coil.compose.AsyncImage(
                        model = coil.request.ImageRequest.Builder(LocalContext.current)
                            .data(imageUri)
                            .crossfade(true)
                            .build(),
                        contentDescription = cartItem.product.name,
                        modifier = Modifier.fillMaxSize(),
                        contentScale = androidx.compose.ui.layout.ContentScale.Crop
                    )
                } else {
                Icon(
                    imageVector = Icons.Default.Image,
                    contentDescription = null,
                    modifier = Modifier.size(32.dp),
                    tint = TaskGoTextGray
                )
                }
            }
            
            Spacer(modifier = Modifier.width(12.dp))
            
            // Product Info
            Column(
                modifier = Modifier.weight(1f)
            ) {
                Text(
                    text = cartItem.product.name,
                    style = FigmaProductName,
                    color = TaskGoTextBlack,
                    maxLines = 2
                )
                
                Spacer(modifier = Modifier.height(4.dp))
                
                Text(
                    text = "R$ ${String.format("%.2f", cartItem.product.price)}",
                    style = FigmaPrice,
                    color = TaskGoPriceGreen
                )
                
                Spacer(modifier = Modifier.height(8.dp))
                
                // Quantity Controls
                Row(
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    IconButton(
                        onClick = onQuantityDecrease,
                        modifier = Modifier.size(32.dp)
                    ) {
                        Icon(
                            imageVector = Icons.Default.Remove,
                            contentDescription = stringResource(R.string.cart_decrease_quantity),
                            tint = TaskGoGreen
                        )
                    }
                    
                    Text(
                        text = cartItem.quantity.toString(),
                        modifier = Modifier.padding(horizontal = 12.dp),
                        style = FigmaProductName,
                        color = TaskGoTextBlack
                    )
                    
                    IconButton(
                        onClick = onQuantityIncrease,
                        modifier = Modifier.size(32.dp)
                    ) {
                        Icon(
                            imageVector = Icons.Default.Add,
                            contentDescription = stringResource(R.string.cart_increase_quantity)
                        )
                    }
                }
            }
            
            // Remove Button
            IconButton(
                onClick = onRemove,
                modifier = Modifier.size(32.dp)
            ) {
                Icon(
                    imageVector = Icons.Default.Delete,
                    contentDescription = stringResource(R.string.cart_remove_item),
                    tint = TaskGoError
                )
            }
        }
    }
}

@Composable
private fun CartBottomBar(
    total: Double,
    itemCount: Int,
    onCheckout: () -> Unit
) {
    Surface(
        tonalElevation = 8.dp,
        shadowElevation = 8.dp
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Column(modifier = Modifier.weight(1f)) {
                Text(
                    text = stringResource(R.string.cart_total),
                    style = FigmaProductDescription,
                    color = TaskGoTextGray
                )
                Text(
                    text = "R$ ${String.format("%.2f", total)}",
                    style = FigmaPrice,
                    color = TaskGoPriceGreen
                )
            }
            
            Button(
                onClick = onCheckout,
                modifier = Modifier.height(48.dp),
                colors = ButtonDefaults.buttonColors(
                    containerColor = TaskGoGreen
                )
            ) {
                Text(
                    stringResource(R.string.cart_checkout),
                    style = FigmaButtonText,
                    color = Color.White
                )
            }
        }
    }
}

@Composable
private fun SummaryRow(
    label: String,
    value: String,
    isProminent: Boolean = false
) {
    Row(
        modifier = Modifier.fillMaxWidth(),
        horizontalArrangement = Arrangement.SpaceBetween,
        verticalAlignment = Alignment.CenterVertically
    ) {
        Text(
            text = label,
            style = if (isProminent) FigmaProductName else FigmaProductDescription,
            color = if (isProminent) TaskGoTextBlack else TaskGoTextGray
        )
        Text(
            text = value,
            style = if (isProminent) FigmaPrice else FigmaProductDescription,
            color = if (isProminent) TaskGoPriceGreen else TaskGoTextBlack
        )
    }
}

```

## [FRONTEND]: feature/products/presentation/CartViewModel.kt

```kotlin
package com.taskgoapp.taskgo.feature.products.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.taskgoapp.taskgo.core.data.models.CartItem as UICartItem
import com.taskgoapp.taskgo.core.data.models.Product as UIProduct
import com.taskgoapp.taskgo.core.model.CartItem
import com.taskgoapp.taskgo.core.model.Product
import com.taskgoapp.taskgo.domain.repository.ProductsRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import javax.inject.Inject

data class CartItemWithId(
    val productId: String,
    val uiCartItem: UICartItem
)

data class CartUiState(
    val isLoading: Boolean = false,
    val cartItems: List<CartItemWithId> = emptyList(),
    val total: Double = 0.0,
    val deliveryFee: Double = 0.0,
    val finalTotal: Double = 0.0,
    val error: String? = null
)

@HiltViewModel
class CartViewModel @Inject constructor(
    private val productsRepository: ProductsRepository
) : ViewModel() {
    
    private val _uiState = MutableStateFlow(CartUiState())
    val uiState: StateFlow<CartUiState> = _uiState.asStateFlow()
    
    init {
        loadCart()
    }
    
    private fun loadCart() {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoading = true)
            
            productsRepository.observeCart()
                .flatMapLatest { cartItems ->
                    if (cartItems.isEmpty()) {
                        flowOf(emptyList<UICartItem>())
                    } else {
                        // Buscar produtos para cada item do carrinho
                        val productsFlow = cartItems.map { cartItem ->
                            flow {
                                val product = productsRepository.getProduct(cartItem.productId)
                                emit(product to cartItem)
                            }
                        }
                        combine(productsFlow) { results ->
                            results.mapIndexedNotNull { index, result ->
                                val (product, cartItem) = result as Pair<Product?, CartItem>
                                product?.let { p ->
                                    CartItemWithId(
                                        productId = cartItem.productId,
                                        uiCartItem = UICartItem(
                                            id = index.toLong(),
                                            product = UIProduct(
                                                id = p.id.hashCode().toLong(),
                                                name = p.title,
                                                description = p.description ?: "",
                                                price = p.price,
                                                category = p.category ?: "",
                                                imageUrl = p.imageUris.firstOrNull(),
                                                inStock = true,
                                                seller = null
                                            ),
                                            quantity = cartItem.qty
                                        )
                                    )
                                }
                            }
                        }
                    }
                }
                .catch { e ->
                    _uiState.value = _uiState.value.copy(
                        error = e.message ?: "Erro ao carregar carrinho",
                        isLoading = false
                    )
                }
                .collect { cartItemsWithId ->
                    val cartItemsList = cartItemsWithId.filterIsInstance<CartItemWithId>()
                    val total = cartItemsList.sumOf { it.uiCartItem.quantity * it.uiCartItem.product.price }
                    val deliveryFee = if (total > 0) 15.0 else 0.0
                    val finalTotal = total + deliveryFee
                    
                    _uiState.value = _uiState.value.copy(
                        cartItems = cartItemsList,
                        total = total,
                        deliveryFee = deliveryFee,
                        finalTotal = finalTotal,
                        isLoading = false
                    )
                }
        }
    }
    
    fun increaseQuantity(productId: String) {
        viewModelScope.launch {
            productsRepository.addToCart(productId, 1)
        }
    }
    
    fun decreaseQuantity(productId: String) {
        viewModelScope.launch {
            productsRepository.addToCart(productId, -1)
        }
    }
    
    fun removeItem(productId: String) {
        viewModelScope.launch {
            productsRepository.removeFromCart(productId)
        }
    }
    
    fun clearCart() {
        viewModelScope.launch {
            productsRepository.clearCart()
        }
    }
}


```

## [FRONTEND]: feature/products/presentation/CheckoutScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.products.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.core.design.*
import com.taskgoapp.taskgo.core.data.*
import com.taskgoapp.taskgo.core.data.models.Address as ModelAddress
import com.taskgoapp.taskgo.core.data.models.PaymentMethod as ModelPaymentMethod
import com.taskgoapp.taskgo.core.data.models.PaymentType

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun CheckoutScreen(
    onBackClick: () -> Unit,
    onAddressSelection: () -> Unit,
    onPaymentMethodSelection: () -> Unit,
    onOrderSummary: () -> Unit
) {
    val selectedAddress = ModelAddress(
        id = 1L,
        name = "Carlos Silva",
        phone = "(11) 99999-9999",
        cep = "01234-567",
        street = "Rua das Flores",
        neighborhood = "Centro",
        city = "S√£o Paulo",
        state = "SP",
        isDefault = true
    )
    
    val selectedPaymentMethod = ModelPaymentMethod(
        id = 1L,
        type = PaymentType.PIX,
        lastFourDigits = "PIX",
        cardholderName = "Carlos Silva",
        expiryDate = "",
        isDefault = true
    )
    
    val subtotal = 1349.97
    val shipping = 29.99
    val total = subtotal + shipping
    
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Checkout",
                onBackClick = onBackClick
            )
        },
        bottomBar = {
            Surface(
                modifier = Modifier.fillMaxWidth(),
                color = MaterialTheme.colorScheme.surface,
                shadowElevation = 8.dp
            ) {
                Column(
                    modifier = Modifier.padding(16.dp)
                ) {
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Column {
                            Text(
                                text = "Total",
                                style = MaterialTheme.typography.titleMedium,
                                fontWeight = FontWeight.Bold
                            )
                            Text(
                                text = "R$ %.2f".format(total),
                                style = MaterialTheme.typography.headlineSmall,
                                fontWeight = FontWeight.Bold,
                                color = MaterialTheme.colorScheme.primary
                            )
                        }
                        PrimaryButton(
                            text = "Finalizar Pedido",
                            onClick = onOrderSummary,
                            modifier = Modifier.width(200.dp)
                        )
                    }
                }
            }
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp)
                .verticalScroll(rememberScrollState()),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // Delivery Address
            Card(
                modifier = Modifier.fillMaxWidth(),
                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
            ) {
                Column(
                    modifier = Modifier.padding(16.dp)
                ) {
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(
                            text = "Endere√ßo de Entrega",
                            style = MaterialTheme.typography.titleMedium,
                            fontWeight = FontWeight.Bold
                        )
                        TextButton(onClick = onAddressSelection) {
                            Text("Alterar")
                        }
                    }
                    
                    Spacer(modifier = Modifier.height(8.dp))
                    
                    Text(
                        text = "${selectedAddress.name} - ${selectedAddress.phone}",
                        style = MaterialTheme.typography.bodyMedium,
                        fontWeight = FontWeight.Medium
                    )
                    Text(
                        text = "${selectedAddress.street}",
                        style = MaterialTheme.typography.bodyMedium
                    )
                    Text(
                        text = "${selectedAddress.neighborhood}, ${selectedAddress.city} - ${selectedAddress.state}",
                        style = MaterialTheme.typography.bodyMedium
                    )
                    Text(
                        text = "CEP: ${selectedAddress.cep}",
                        style = MaterialTheme.typography.bodyMedium
                    )
                }
            }
            
            // Payment Method
            Card(
                modifier = Modifier.fillMaxWidth(),
                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
            ) {
                Column(
                    modifier = Modifier.padding(16.dp)
                ) {
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(
                            text = "Forma de Pagamento",
                            style = MaterialTheme.typography.titleMedium,
                            fontWeight = FontWeight.Bold
                        )
                        TextButton(onClick = onPaymentMethodSelection) {
                            Text("Alterar")
                        }
                    }
                    
                    Spacer(modifier = Modifier.height(8.dp))
                    
                    Row(
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Icon(
                            imageVector = when (selectedPaymentMethod.type) {
                                PaymentType.PIX -> Icons.Default.QrCode
                                PaymentType.CREDIT_CARD -> Icons.Default.CreditCard
                                PaymentType.DEBIT_CARD -> Icons.Default.CreditCard
                                else -> Icons.Default.Payment
                            },
                            contentDescription = null,
                            tint = MaterialTheme.colorScheme.primary
                        )
                        Spacer(modifier = Modifier.width(12.dp))
                        Column {
                            Text(
                                text = when (selectedPaymentMethod.type) {
                                    PaymentType.PIX -> "PIX"
                                    PaymentType.CREDIT_CARD -> "Cart√£o de Cr√©dito"
                                    PaymentType.DEBIT_CARD -> "Cart√£o de D√©bito"
                                    else -> "Pagamento"
                                },
                                style = MaterialTheme.typography.bodyMedium,
                                fontWeight = FontWeight.Medium
                            )
                            Text(
                                text = selectedPaymentMethod.cardholderName,
                                style = MaterialTheme.typography.bodySmall,
                                color = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                        }
                    }
                }
            }
            
            // Order Summary
            Card(
                modifier = Modifier.fillMaxWidth(),
                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
            ) {
                Column(
                    modifier = Modifier.padding(16.dp)
                ) {
                    Text(
                        text = "Resumo do Pedido",
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold
                    )
                    
                    Spacer(modifier = Modifier.height(16.dp))
                    
                    // Order Items
                    val orderItems = listOf(
                        "1x Furadeira sem fio - R$ 299,99",
                        "1x Guarda Roupa 6 Portas - R$ 899,99",
                        "2x Kit de Ferramentas B√°sicas - R$ 299,98"
                    )
                    
                    orderItems.forEach { item ->
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.SpaceBetween
                        ) {
                            Text(
                                text = item,
                                style = MaterialTheme.typography.bodyMedium
                            )
                        }
                        Spacer(modifier = Modifier.height(4.dp))
                    }
                    
                    HorizontalDivider(modifier = Modifier.padding(vertical = 8.dp))
                    
                    // Totals
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween
                    ) {
                        Text(
                            text = "Subtotal",
                            style = MaterialTheme.typography.bodyMedium
                        )
                        Text(
                            text = "R$ %.2f".format(subtotal),
                            style = MaterialTheme.typography.bodyMedium
                        )
                    }
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween
                    ) {
                        Text(
                            text = "Frete",
                            style = MaterialTheme.typography.bodyMedium
                        )
                        Text(
                            text = "R$ %.2f".format(shipping),
                            style = MaterialTheme.typography.bodyMedium
                        )
                    }
                    HorizontalDivider(modifier = Modifier.padding(vertical = 8.dp))
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween
                    ) {
                        Text(
                            text = "Total",
                            style = MaterialTheme.typography.titleMedium,
                            fontWeight = FontWeight.Bold
                        )
                        Text(
                            text = "R$ %.2f".format(total),
                            style = MaterialTheme.typography.titleMedium,
                            fontWeight = FontWeight.Bold
                        )
                    }
                }
            }
        }
    }
}



```

## [FRONTEND]: feature/products/presentation/CreateProductScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.products.presentation

import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.CameraAlt
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.collectAsState
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.hilt.navigation.compose.hiltViewModel
import com.taskgoapp.taskgo.core.design.TGIcons
import com.taskgoapp.taskgo.core.security.DocumentVerificationBlock
import com.taskgoapp.taskgo.core.security.DocumentVerificationManager
import com.taskgoapp.taskgo.core.theme.*
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject

@HiltViewModel
class CreateProductViewModel @Inject constructor(
    private val documentVerificationManager: DocumentVerificationManager
) : ViewModel() {
    private val _isVerified = MutableStateFlow(false)
    val isVerified: StateFlow<Boolean> = _isVerified.asStateFlow()
    
    init {
        viewModelScope.launch {
            _isVerified.value = documentVerificationManager.hasDocumentsVerified()
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun CreateProductScreen(
    onBackClick: () -> Unit,
    onProductCreated: () -> Unit,
    onNavigateToIdentityVerification: () -> Unit = {},
    viewModel: CreateProductViewModel = hiltViewModel()
) {
    val isVerified by viewModel.isVerified.collectAsState()
    
    DocumentVerificationBlock(
        isVerified = isVerified,
        onVerifyClick = onNavigateToIdentityVerification
    ) {
        var productName by remember { mutableStateOf("") }
        var productPrice by remember { mutableStateOf("") }
        var productDescription by remember { mutableStateOf("") }
        var selectedImages by remember { mutableStateOf<List<String>>(emptyList()) }
        var isCreating by remember { mutableStateOf(false) }

        Column(
            modifier = Modifier
                .fillMaxSize()
                .background(TaskGoBackgroundWhite)
        ) {
            // Top Bar
            TopAppBar(
                title = {
                    Text(
                        text = "Criar Produto",
                        color = TaskGoTextBlack,
                        fontSize = 18.sp,
                        fontWeight = FontWeight.Bold
                    )
                },
                navigationIcon = {
                    IconButton(onClick = onBackClick) {
                        Icon(
                            imageVector = Icons.Filled.ArrowBack,
                            contentDescription = "Voltar",
                            tint = TaskGoTextBlack
                        )
                    }
                },
                colors = TopAppBarDefaults.topAppBarColors(
                    containerColor = TaskGoBackgroundWhite
                )
            )

            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .verticalScroll(rememberScrollState())
                    .padding(16.dp),
                verticalArrangement = Arrangement.spacedBy(20.dp)
            ) {
                // Se√ß√£o de fotos
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    shape = RoundedCornerShape(12.dp),
                    colors = CardDefaults.cardColors(
                        containerColor = Color.White
                    ),
                    elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
                ) {
                    Column(
                        modifier = Modifier.padding(20.dp)
                    ) {
                        Text(
                            text = "Fotos do Produto",
                            color = TaskGoTextBlack,
                            fontSize = 16.sp,
                            fontWeight = FontWeight.Bold
                        )
                        
                        Spacer(modifier = Modifier.height(12.dp))
                        
                        if (selectedImages.isEmpty()) {
                            // Placeholder para adicionar fotos
                            Box(
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .height(120.dp)
                                    .border(
                                        width = 2.dp,
                                        color = Color(0xFFD9D9D9),
                                        shape = RoundedCornerShape(8.dp)
                                    )
                                    .clickable { 
                                        // TODO: Implementar sele√ß√£o de imagens
                                        selectedImages = listOf("image1", "image2", "image3")
                                    },
                                contentAlignment = Alignment.Center
                            ) {
                                Column(
                                    horizontalAlignment = Alignment.CenterHorizontally
                                ) {
                                    Icon(
                                        imageVector = Icons.Filled.CameraAlt,
                                        contentDescription = "Adicionar foto",
                                        tint = TaskGoTextGray,
                                        modifier = Modifier.size(32.dp)
                                    )
                                    Spacer(modifier = Modifier.height(8.dp))
                                    Text(
                                        text = "Adicione fotos",
                                        color = TaskGoTextGray,
                                        fontSize = 14.sp
                                    )
                                }
                            }
                        } else {
                            // Grid de imagens selecionadas
                            LazyRow(
                                horizontalArrangement = Arrangement.spacedBy(8.dp)
                            ) {
                                items(selectedImages.size + 1) { index ->
                                    if (index < selectedImages.size) {
                                        // Imagem selecionada
                                        Box(
                                            modifier = Modifier
                                                .size(80.dp)
                                                .background(
                                                    color = Color(0xFFF0F0F0),
                                                    shape = RoundedCornerShape(8.dp)
                                                ),
                                            contentAlignment = Alignment.Center
                                        ) {
                                            Text(
                                                text = "Foto ${index + 1}",
                                                color = TaskGoTextGray,
                                                fontSize = 10.sp
                                            )
                                        }
                                    } else {
                                        // Bot√£o para adicionar mais fotos
                                        Box(
                                            modifier = Modifier
                                                .size(80.dp)
                                                .border(
                                                    width = 2.dp,
                                                    color = Color(0xFFD9D9D9),
                                                    shape = RoundedCornerShape(8.dp)
                                                )
                                                .clickable { 
                                                    // TODO: Implementar sele√ß√£o de mais imagens
                                                },
                                            contentAlignment = Alignment.Center
                                        ) {
                                            Icon(
                                                imageVector = Icons.Filled.Add,
                                                contentDescription = "Adicionar mais fotos",
                                                tint = TaskGoTextGray,
                                                modifier = Modifier.size(20.dp)
                                            )
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                // Campo Nome do Produto
                OutlinedTextField(
                    value = productName,
                    onValueChange = { productName = it },
                    label = { 
                        Text(
                            "Nome do Produto",
                            color = TaskGoTextGray,
                            fontSize = 14.sp
                        ) 
                    },
                    placeholder = { Text("Ex: Furadeira") },
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(56.dp),
                    shape = RoundedCornerShape(8.dp),
                    colors = OutlinedTextFieldDefaults.colors(
                        focusedBorderColor = TaskGoGreen,
                        unfocusedBorderColor = Color(0xFFD9D9D9),
                        focusedLabelColor = TaskGoTextGray,
                        unfocusedLabelColor = TaskGoTextGray,
                        cursorColor = TaskGoGreen
                    ),
                    keyboardOptions = androidx.compose.foundation.text.KeyboardOptions(keyboardType = KeyboardType.Text)
                )
                
                // Campo Pre√ßo
                OutlinedTextField(
                    value = productPrice,
                    onValueChange = { newValue ->
                        productPrice = com.taskgoapp.taskgo.core.utils.TextFormatters.formatPrice(newValue)
                    },
                    label = { 
                        Text(
                            "Pre√ßo",
                            color = TaskGoTextGray,
                            fontSize = 14.sp
                        ) 
                    },
                    placeholder = { Text("Ex: 250,00") },
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(56.dp),
                    shape = RoundedCornerShape(8.dp),
                    colors = OutlinedTextFieldDefaults.colors(
                        focusedBorderColor = TaskGoGreen,
                        unfocusedBorderColor = Color(0xFFD9D9D9),
                        focusedLabelColor = TaskGoTextGray,
                        unfocusedLabelColor = TaskGoTextGray,
                        cursorColor = TaskGoGreen
                    ),
                    keyboardOptions = androidx.compose.foundation.text.KeyboardOptions(keyboardType = KeyboardType.Decimal)
                )
                
                // Campo Descri√ß√£o
                OutlinedTextField(
                    value = productDescription,
                    onValueChange = { productDescription = it },
                    label = { 
                        Text(
                            "Descri√ß√£o",
                            color = TaskGoTextGray,
                            fontSize = 14.sp
                        ) 
                    },
                    placeholder = { Text("Descreva o produto...") },
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(120.dp),
                    shape = RoundedCornerShape(8.dp),
                    colors = OutlinedTextFieldDefaults.colors(
                        focusedBorderColor = TaskGoGreen,
                        unfocusedBorderColor = Color(0xFFD9D9D9),
                        focusedLabelColor = TaskGoTextGray,
                        unfocusedLabelColor = TaskGoTextGray,
                        cursorColor = TaskGoGreen
                    ),
                    maxLines = 4
                )
                
                Spacer(modifier = Modifier.height(20.dp))
                
                // Bot√£o Criar Produto
                Button(
                    onClick = { 
                        isCreating = true
                        // Simular cria√ß√£o do produto
                        onProductCreated()
                    },
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(56.dp),
                    shape = RoundedCornerShape(8.dp),
                    colors = ButtonDefaults.buttonColors(
                        containerColor = TaskGoGreen
                    ),
                    enabled = !isCreating && productName.isNotEmpty() && productPrice.isNotEmpty()
                ) {
                    if (isCreating) {
                        CircularProgressIndicator(
                            color = Color.White,
                            modifier = Modifier.size(20.dp)
                        )
                    } else {
                        Text(
                            text = "Criar Produto",
                            color = Color.White,
                            fontSize = 16.sp,
                            fontWeight = FontWeight.Bold
                        )
                    }
                }
            }
        }
    }
}

```

## [FRONTEND]: feature/products/presentation/CriarProdutoScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.products.presentation

import android.net.Uri
import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.design.ImageEditor
import com.taskgoapp.taskgo.core.security.DocumentVerificationBlock

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun CriarProdutoScreen(
    onBackClick: () -> Unit,
    onProductCreated: () -> Unit,
    onNavigateToIdentityVerification: () -> Unit = {},
    viewModel: ProductFormViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    val isVerified by viewModel.isVerified.collectAsState()
    
    var nome by remember { mutableStateOf("") }
    var preco by remember { mutableStateOf("") }
    var endereco by remember { mutableStateOf("") }
    var selectedImageUris by remember { mutableStateOf<List<Uri>>(emptyList()) }
    var showSuccessMessage by remember { mutableStateOf(false) }

    Scaffold(
        topBar = {
            AppTopBar(
                title = "Criar Produto",
                onBackClick = onBackClick
            )
        }
    ) { paddingValues ->
        Box(modifier = Modifier.fillMaxSize()) {
            DocumentVerificationBlock(
                isVerified = isVerified,
                onVerifyClick = onNavigateToIdentityVerification
            ) {
                Column(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(paddingValues)
                        .padding(16.dp),
                    verticalArrangement = Arrangement.spacedBy(16.dp)
                ) {
                    // Seletor de fotos
                    ImageEditor(
                        selectedImageUris = selectedImageUris,
                        onImagesChanged = { uris -> selectedImageUris = uris },
                        maxImages = 5,
                        placeholderText = "Adicione fotos do produto"
                    )

                    // Nome do produto
                    Column {
                        Text(
                            text = "Nome do produto",
                            style = MaterialTheme.typography.bodyMedium,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                        Spacer(modifier = Modifier.height(8.dp))
                        OutlinedTextField(
                            value = nome,
                            onValueChange = { nome = it },
                            modifier = Modifier.fillMaxWidth(),
                            singleLine = true,
                            placeholder = { Text("Ex: Furadeira") }
                        )
                    }

                    // Pre√ßo
                    Column {
                        Text(
                            text = "Pre√ßo",
                            style = MaterialTheme.typography.bodyMedium,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                        Spacer(modifier = Modifier.height(8.dp))
                        OutlinedTextField(
                            value = preco,
                            onValueChange = { preco = it },
                            modifier = Modifier.fillMaxWidth(),
                            singleLine = true,
                            prefix = { Text("R$ ") },
                            placeholder = { Text("250,00") }
                        )
                    }

                    // Endere√ßo
                    Column {
                        Text(
                            text = "Endere√ßo",
                            style = MaterialTheme.typography.bodyMedium,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                        Spacer(modifier = Modifier.height(8.dp))
                        OutlinedTextField(
                            value = endereco,
                            onValueChange = { endereco = it },
                            modifier = Modifier.fillMaxWidth(),
                            singleLine = true,
                            placeholder = { Text("Rua das Palmeiras, 123 S√£o Paulo, SP") }
                        )
                    }

                    Spacer(modifier = Modifier.weight(1f))

                    // Bot√£o criar produto
                    Button(
                        onClick = { 
                            viewModel.onTitleChange(nome)
                            viewModel.onPriceChange(preco)
                            viewModel.onDescriptionChange("")
                            viewModel.onSellerNameChange("Usu√°rio")
                            selectedImageUris.forEach { uri ->
                                viewModel.addImage(uri.toString())
                            }
                            viewModel.save()
                            showSuccessMessage = true
                        },
                        modifier = Modifier.fillMaxWidth(),
                        colors = ButtonDefaults.buttonColors(
                            containerColor = MaterialTheme.colorScheme.primary
                        ),
                        enabled = nome.isNotBlank() && preco.isNotBlank() && endereco.isNotBlank()
                    ) {
                        Text(
                            text = "Criar Produto",
                            fontWeight = FontWeight.Bold
                        )
                    }
                }
            }
            
            // Success message
            if (showSuccessMessage) {
                AlertDialog(
                    onDismissRequest = { showSuccessMessage = false },
                    title = { Text("Sucesso") },
                    text = { Text("Produto criado com sucesso!") },
                    confirmButton = {
                        TextButton(onClick = { 
                            showSuccessMessage = false
                            onProductCreated()
                        }) {
                            Text("OK")
                        }
                    }
                )
            }
        }
    }
}

```

## [FRONTEND]: feature/products/presentation/DetalhesProdutoScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.products.presentation

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ShoppingCart
import androidx.compose.ui.res.painterResource
import com.taskgoapp.taskgo.R
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.core.design.AppTopBar

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun DetalhesProdutoScreen(
    onBackClick: () -> Unit,
    onAdicionarCarrinho: () -> Unit
) {
    var quantity by remember { mutableStateOf(1) }

    Scaffold(
        topBar = {
            AppTopBar(
                title = "Detalhes do Produto",
                onBackClick = onBackClick
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // Product image
            Box(
                modifier = Modifier
                    .fillMaxWidth()
                    .height(200.dp)
                    .background(
                        color = MaterialTheme.colorScheme.surfaceVariant,
                        shape = MaterialTheme.shapes.medium
                    ),
                contentAlignment = Alignment.Center
            ) {
                Text(
                    text = "üì¶",
                    style = MaterialTheme.typography.displayMedium
                )
            }

            // Product info
            Column(
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Text(
                    text = "Guarda Roupa",
                    style = MaterialTheme.typography.headlineMedium,
                    fontWeight = FontWeight.Bold
                )

                Text(
                    text = "R$ 750,00",
                    style = MaterialTheme.typography.headlineSmall,
                    color = MaterialTheme.colorScheme.primary,
                    fontWeight = FontWeight.Bold
                )

                Text(
                    text = "Guarda-roupa de 3 portas com espelho",
                    style = MaterialTheme.typography.bodyLarge,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }

            // Quantity selector
            Row(
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                Text(
                    text = "Quantidade:",
                    style = MaterialTheme.typography.bodyLarge
                )

                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    IconButton(
                        onClick = { if (quantity > 1) quantity-- }
                    ) {
                        Icon(
                            painter = painterResource(R.drawable.ic_delete),
                            contentDescription = "Diminuir",
                            modifier = Modifier.size(24.dp)
                        )
                    }

                    Text(
                        text = quantity.toString(),
                        style = MaterialTheme.typography.titleLarge,
                        modifier = Modifier.padding(horizontal = 16.dp)
                    )

                    IconButton(
                        onClick = { quantity++ }
                    ) {
                        Icon(
                            painter = painterResource(R.drawable.ic_add),
                            contentDescription = "Aumentar",
                            modifier = Modifier.size(24.dp)
                        )
                    }
                }
            }

            Spacer(modifier = Modifier.weight(1f))

            // Add to cart button
            Button(
                onClick = onAdicionarCarrinho,
                modifier = Modifier.fillMaxWidth(),
                colors = ButtonDefaults.buttonColors(
                    containerColor = MaterialTheme.colorScheme.primary
                )
            ) {
                Icon(
                    imageVector = Icons.Default.ShoppingCart,
                    contentDescription = null,
                    modifier = Modifier.size(20.dp)
                )
                Spacer(modifier = Modifier.width(8.dp))
                Text(
                    text = "Adicionar ao Carrinho",
                    fontWeight = FontWeight.Bold
                )
            }
        }
    }
}

```

## [FRONTEND]: feature/products/presentation/DiscountedProductsScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.products.presentation

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.lazy.grid.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.collectAsState
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.window.Dialog
import androidx.compose.ui.platform.LocalContext
import coil.request.ImageRequest
import androidx.hilt.navigation.compose.hiltViewModel
import coil.compose.AsyncImage
import com.taskgoapp.taskgo.R
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.design.TGIcons
import com.taskgoapp.taskgo.core.design.TGIcon
import com.taskgoapp.taskgo.core.model.Product
import com.taskgoapp.taskgo.core.theme.*
import com.taskgoapp.taskgo.core.design.FilterBar
import com.taskgoapp.taskgo.core.design.FilterBottomSheet
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.ui.draw.clip
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.material.icons.filled.Star

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun DiscountedProductsScreen(
    onNavigateToProductDetail: (String) -> Unit,
    onNavigateToCart: () -> Unit,
    onBackClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    val viewModel: ProductsViewModel = hiltViewModel()
    val allProducts by viewModel.products.collectAsState()
    val filterState by viewModel.filterState.collectAsState()
    val categories by viewModel.productCategories.collectAsState()
    
    // Filtrar apenas produtos com desconto
    val discountedProducts = remember(allProducts) {
        allProducts.filter { product ->
            // Assumindo que produtos com desconto t√™m um campo discount ou price menor que originalPrice
            // Por enquanto, vamos mostrar todos os produtos, mas voc√™ pode adicionar l√≥gica de desconto
            true // TODO: Filtrar por produtos que realmente t√™m desconto
        }
    }
    
    var showFilterSheet by remember { mutableStateOf(false) }
    var searchQuery by remember { mutableStateOf("") }
    var showImagePreview by remember { mutableStateOf<String?>(null) }
    
    // Adicionar "Todos" no in√≠cio das categorias se n√£o estiver presente
    val categoriesWithAll = remember(categories) {
        if (categories.isEmpty() || categories.first() != "Todos") {
            listOf("Todos") + categories.filter { it != "Todos" }
        } else {
            categories
        }
    }
    
    // Atualizar busca quando o usu√°rio digitar
    LaunchedEffect(searchQuery) {
        viewModel.updateSearchQuery(searchQuery)
    }
    
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Produtos com Descontos",
                subtitle = "Aproveite os melhores descontos do dia!",
                onBackClick = onBackClick,
                backgroundColor = TaskGoGreen,
                titleColor = Color.White,
                subtitleColor = Color.White,
                backIconColor = Color.White
            )
        }
    ) { paddingValues ->
        Column(
            modifier = modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(horizontal = 16.dp),
            verticalArrangement = Arrangement.spacedBy(4.dp)
        ) {
            // Barra de Busca
            com.taskgoapp.taskgo.core.design.SearchBar(
                query = searchQuery,
                onQueryChange = { searchQuery = it },
                placeholder = "Buscar produtos com desconto...",
                modifier = Modifier.padding(top = 4.dp)
            )
            
            // Barra de Filtros
            FilterBar(
                categories = categoriesWithAll,
                selectedCategories = filterState.selectedCategories,
                onCategorySelected = { category ->
                    if (category == "Todos") {
                        viewModel.updateFilterState(filterState.copy(selectedCategories = emptySet()))
                    } else {
                        viewModel.toggleCategory(category)
                    }
                },
                onFilterClick = { showFilterSheet = true },
                modifier = Modifier.padding(vertical = 8.dp)
            )
            
            // Grid de produtos
            if (discountedProducts.isEmpty()) {
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    Text(
                        text = "Nenhum produto com desconto encontrado",
                        color = TaskGoTextGray
                    )
                }
            } else {
                LazyVerticalGrid(
                    columns = GridCells.Fixed(2),
                    verticalArrangement = Arrangement.spacedBy(12.dp),
                    horizontalArrangement = Arrangement.spacedBy(12.dp),
                    modifier = Modifier.fillMaxSize()
                ) {
                    items(discountedProducts) { product ->
                        DiscountedProductCard(
                            product = product,
                            onProductClick = { onNavigateToProductDetail(product.id) },
                            onImageClick = { imageUrl ->
                                showImagePreview = imageUrl
                            }
                        )
                    }
                }
            }
        }
        
        // Bottom Sheet de Filtros
        FilterBottomSheet(
            isOpen = showFilterSheet,
            onDismiss = { showFilterSheet = false },
            filterState = filterState,
            onFilterStateChange = { newState ->
                viewModel.updateFilterState(newState)
            }
        )
    }
    
    // Image Preview Modal
    showImagePreview?.let { imageUrl ->
        ImagePreviewModal(
            imageUrl = imageUrl,
            onDismiss = { showImagePreview = null }
        )
    }
}

@Composable
private fun DiscountedProductCard(
    product: Product,
    onProductClick: () -> Unit,
    onImageClick: (String) -> Unit,
    modifier: Modifier = Modifier
) {
    val currencyFormat = remember {
        java.text.NumberFormat.getCurrencyInstance(java.util.Locale("pt", "BR"))
    }
    val imageUri = remember(product.imageUris) {
        product.imageUris.firstOrNull { it.isNotBlank() }
    }
    val context = LocalContext.current
    
    Card(
        modifier = modifier
            .fillMaxWidth()
            .clip(RoundedCornerShape(16.dp)),
        shape = RoundedCornerShape(16.dp),
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
    ) {
        Column {
            Box(
                modifier = Modifier
                    .fillMaxWidth()
                    .height(150.dp)
                    .background(TaskGoSurfaceGray)
                    .clickable { 
                        if (imageUri != null) {
                            onImageClick(imageUri)
                        } else {
                            onProductClick()
                        }
                    },
                contentAlignment = Alignment.Center
            ) {
                if (imageUri != null) {
                    AsyncImage(
                        model = ImageRequest.Builder(context)
                            .data(imageUri)
                            .crossfade(true)
                            .build(),
                        contentDescription = "Imagem do produto ${product.title}",
                        modifier = Modifier.fillMaxSize(),
                        contentScale = ContentScale.Crop
                    )
                } else {
                    TGIcon(
                        iconRes = TGIcons.Products,
                        contentDescription = null,
                        size = TGIcons.Sizes.Large,
                        tint = TaskGoTextGray
                    )
                }
                
                // Badge de desconto
                if (product.featured == true) {
                    Surface(
                        modifier = Modifier
                            .align(Alignment.TopStart)
                            .padding(8.dp),
                        color = TaskGoError,
                        shape = RoundedCornerShape(18.dp)
                    ) {
                        Text(
                            text = "Promo√ß√£o",
                            color = Color.White,
                            style = MaterialTheme.typography.labelSmall,
                            modifier = Modifier.padding(horizontal = 8.dp, vertical = 4.dp)
                        )
                    }
                }
            }
            
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(12.dp)
                    .clickable { onProductClick() },
                verticalArrangement = Arrangement.spacedBy(6.dp)
            ) {
                Text(
                    text = product.title,
                    style = FigmaProductName,
                    color = TaskGoTextBlack,
                    maxLines = 1,
                    overflow = TextOverflow.Ellipsis
                )
                
                product.description?.takeIf { it.isNotBlank() }?.let { description ->
                    Text(
                        text = description,
                        style = MaterialTheme.typography.bodyMedium,
                        color = TaskGoTextGray,
                        maxLines = 2,
                        overflow = TextOverflow.Ellipsis
                    )
                }
                
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Column {
                        Text(
                            text = "Pre√ßo",
                            style = MaterialTheme.typography.bodySmall,
                            color = TaskGoTextGray
                        )
                        Text(
                            text = currencyFormat.format(product.price),
                            style = FigmaPrice,
                            color = TaskGoPriceGreen,
                            fontWeight = FontWeight.Bold
                        )
                    }
                    Row(
                        verticalAlignment = Alignment.CenterVertically,
                        horizontalArrangement = Arrangement.spacedBy(4.dp)
                    ) {
                        Icon(
                            imageVector = Icons.Default.Star,
                            contentDescription = "Avalia√ß√£o",
                            tint = TaskGoStarYellow,
                            modifier = Modifier.size(16.dp)
                        )
                        Text(
                            text = "%.1f".format(product.rating ?: 0.0),
                            style = FigmaRatingText,
                            color = TaskGoTextDark
                        )
                    }
                }
            }
        }
    }
}

@Composable
private fun ImagePreviewModal(
    imageUrl: String,
    onDismiss: () -> Unit
) {
    val context = LocalContext.current
    
    Dialog(onDismissRequest = onDismiss) {
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            shape = RoundedCornerShape(16.dp)
        ) {
            Column {
                Box(
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(400.dp)
                ) {
                    AsyncImage(
                        model = ImageRequest.Builder(context)
                            .data(imageUrl)
                            .crossfade(true)
                            .build(),
                        contentDescription = "Preview da imagem",
                        modifier = Modifier.fillMaxSize(),
                        contentScale = ContentScale.Fit
                    )
                }
                
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp),
                    horizontalArrangement = Arrangement.End
                ) {
                    TextButton(onClick = onDismiss) {
                        Text("Fechar")
                    }
                }
            }
        }
    }
}


```

## [FRONTEND]: feature/products/presentation/EditarProdutoScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.products.presentation

import android.net.Uri
import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.design.ImageEditor

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun EditarProdutoScreen(
    onBackClick: () -> Unit,
    viewModel: ProductFormViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    
    var nome by remember { mutableStateOf("Guarda Roupa") }
    var descricao by remember { mutableStateOf("Guarda-roupa de 3 portas com espelho") }
    var preco by remember { mutableStateOf("750,00") }
    var categoria by remember { mutableStateOf("M√≥veis") }
    var selectedImageUris by remember { mutableStateOf(listOf<Uri>()) }
    var showSuccessMessage by remember { mutableStateOf(false) }

    Scaffold(
        topBar = {
            AppTopBar(
                title = "Editar Produto",
                onBackClick = onBackClick
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // Seletor de fotos
            ImageEditor(
                selectedImageUris = selectedImageUris,
                onImagesChanged = { uris -> selectedImageUris = uris },
                maxImages = 5,
                placeholderText = "Adicione fotos do produto"
            )

            // Nome
            Column {
                Text(
                    text = "Nome",
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
                Spacer(modifier = Modifier.height(8.dp))
                OutlinedTextField(
                    value = nome,
                    onValueChange = { nome = it },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = true
                )
            }

            // Descri√ß√£o
            Column {
                Text(
                    text = "Descri√ß√£o",
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
                Spacer(modifier = Modifier.height(8.dp))
                OutlinedTextField(
                    value = descricao,
                    onValueChange = { descricao = it },
                    modifier = Modifier.fillMaxWidth(),
                    minLines = 3,
                    maxLines = 5
                )
            }

            // Pre√ßo
            Column {
                Text(
                    text = "Pre√ßo",
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
                Spacer(modifier = Modifier.height(8.dp))
                OutlinedTextField(
                    value = preco,
                    onValueChange = { preco = it },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = true,
                    prefix = { Text("R$ ") }
                )
            }

            // Categoria
            Column {
                Text(
                    text = "Categoria",
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
                Spacer(modifier = Modifier.height(8.dp))
                OutlinedTextField(
                    value = categoria,
                    onValueChange = { categoria = it },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = true
                )
            }

            Spacer(modifier = Modifier.weight(1f))

            // Save button
            Button(
                onClick = { 
                    viewModel.onTitleChange(nome)
                    viewModel.onPriceChange(preco)
                    viewModel.onDescriptionChange(descricao)
                    viewModel.onSellerNameChange("Usu√°rio")
                    selectedImageUris.forEach { uri ->
                        viewModel.addImage(uri.toString())
                    }
                    viewModel.save()
                    showSuccessMessage = true
                },
                modifier = Modifier.fillMaxWidth(),
                colors = ButtonDefaults.buttonColors(
                    containerColor = MaterialTheme.colorScheme.primary
                )
            ) {
                Text(
                    text = "Salvar Altera√ß√µes",
                    fontWeight = FontWeight.Bold
                )
            }
        }
    }

    // Success message
    if (showSuccessMessage) {
        AlertDialog(
            onDismissRequest = { showSuccessMessage = false },
            title = { Text("Sucesso") },
            text = { Text("Produto salvo com sucesso!") },
            confirmButton = {
                TextButton(onClick = { showSuccessMessage = false }) {
                    Text("OK")
                }
            }
        )
    }
}

```

## [FRONTEND]: feature/products/presentation/EditProductScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.products.presentation

import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.CameraAlt
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.taskgoapp.taskgo.core.design.TGIcons
import com.taskgoapp.taskgo.core.theme.TaskGoGreen
import com.taskgoapp.taskgo.core.theme.TaskGoTextBlack
import com.taskgoapp.taskgo.core.theme.TaskGoTextGray
import com.taskgoapp.taskgo.core.theme.TaskGoBackgroundWhite

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun EditProductScreen(
    productId: String,
    onBackClick: () -> Unit,
    onProductUpdated: () -> Unit,
    onProductDeleted: () -> Unit
) {
    // Dados v√™m do Firestore - iniciar vazios
    var productName by remember { mutableStateOf("") }
    var productPrice by remember { mutableStateOf("") }
    var productDescription by remember { mutableStateOf("") }
    var selectedImages by remember { mutableStateOf<List<String>>(emptyList()) }
    var isUpdating by remember { mutableStateOf(false) }
    var showDeleteDialog by remember { mutableStateOf(false) }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .background(TaskGoBackgroundWhite)
    ) {
        // Top Bar
        TopAppBar(
            title = {
                Text(
                    text = "Editar Produto",
                    color = TaskGoTextBlack,
                    fontSize = 18.sp,
                    fontWeight = FontWeight.Bold
                )
            },
            navigationIcon = {
                IconButton(onClick = onBackClick) {
                    Icon(
                        imageVector = Icons.Filled.ArrowBack,
                        contentDescription = "Voltar",
                        tint = TaskGoTextBlack
                    )
                }
            },
            actions = {
                IconButton(
                    onClick = { showDeleteDialog = true }
                ) {
                    Icon(
                        imageVector = Icons.Filled.Delete,
                        contentDescription = "Excluir produto",
                        tint = Color(0xFFDC3545)
                    )
                }
            },
            colors = TopAppBarDefaults.topAppBarColors(
                containerColor = TaskGoBackgroundWhite
            )
        )

        Column(
            modifier = Modifier
                .fillMaxSize()
                .verticalScroll(rememberScrollState())
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(20.dp)
        ) {
            // Se√ß√£o de fotos
            Card(
                modifier = Modifier.fillMaxWidth(),
                shape = RoundedCornerShape(12.dp),
                colors = CardDefaults.cardColors(
                    containerColor = Color.White
                ),
                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
            ) {
                Column(
                    modifier = Modifier.padding(20.dp)
                ) {
                    Text(
                        text = "Fotos do Produto",
                        color = TaskGoTextBlack,
                        fontSize = 16.sp,
                        fontWeight = FontWeight.Bold
                    )
                    
                    Spacer(modifier = Modifier.height(12.dp))
                    
                    Text(
                        text = "Adicione ou substitua as fotos",
                        color = TaskGoTextGray,
                        fontSize = 12.sp
                    )
                    
                    Spacer(modifier = Modifier.height(12.dp))
                    
                    // Grid de imagens
                    LazyRow(
                        horizontalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        items(selectedImages.size + 1) { index ->
                            if (index < selectedImages.size) {
                                // Imagem existente
                                Box(
                                    modifier = Modifier
                                        .size(80.dp)
                                        .background(
                                            color = Color(0xFFF0F0F0),
                                            shape = RoundedCornerShape(8.dp)
                                        ),
                                    contentAlignment = Alignment.Center
                                ) {
                                    Text(
                                        text = "Foto ${index + 1}",
                                        color = TaskGoTextGray,
                                        fontSize = 10.sp
                                    )
                                }
                            } else {
                                // Bot√£o para adicionar mais fotos
                                Box(
                                    modifier = Modifier
                                        .size(80.dp)
                                        .border(
                                            width = 2.dp,
                                            color = Color(0xFFD9D9D9),
                                            shape = RoundedCornerShape(8.dp)
                                        )
                                        .clickable { 
                                            // TODO: Implementar sele√ß√£o de mais imagens
                                        },
                                    contentAlignment = Alignment.Center
                                ) {
                                    Icon(
                                        imageVector = Icons.Filled.Add,
                                        contentDescription = "Adicionar mais fotos",
                                        tint = TaskGoTextGray,
                                        modifier = Modifier.size(20.dp)
                                    )
                                }
                            }
                        }
                    }
                }
            }
            
            // Campo Nome do Produto
            OutlinedTextField(
                value = productName,
                onValueChange = { productName = it },
                label = { 
                    Text(
                        "Nome do Produto",
                        color = TaskGoTextGray,
                        fontSize = 14.sp
                    ) 
                },
                modifier = Modifier
                    .fillMaxWidth()
                    .height(56.dp),
                shape = RoundedCornerShape(8.dp),
                colors = OutlinedTextFieldDefaults.colors(
                    focusedBorderColor = TaskGoGreen,
                    unfocusedBorderColor = Color(0xFFD9D9D9),
                    focusedLabelColor = TaskGoTextGray,
                    unfocusedLabelColor = TaskGoTextGray,
                    cursorColor = TaskGoGreen
                ),
                keyboardOptions = androidx.compose.foundation.text.KeyboardOptions(keyboardType = KeyboardType.Text)
            )
            
            // Campo Pre√ßo
            OutlinedTextField(
                value = productPrice,
                onValueChange = { newValue ->
                    productPrice = com.taskgoapp.taskgo.core.utils.TextFormatters.formatPrice(newValue)
                },
                label = { 
                    Text(
                        "Pre√ßo",
                        color = TaskGoTextGray,
                        fontSize = 14.sp
                    ) 
                },
                modifier = Modifier
                    .fillMaxWidth()
                    .height(56.dp),
                shape = RoundedCornerShape(8.dp),
                colors = OutlinedTextFieldDefaults.colors(
                    focusedBorderColor = TaskGoGreen,
                    unfocusedBorderColor = Color(0xFFD9D9D9),
                    focusedLabelColor = TaskGoTextGray,
                    unfocusedLabelColor = TaskGoTextGray,
                    cursorColor = TaskGoGreen
                ),
                keyboardOptions = androidx.compose.foundation.text.KeyboardOptions(keyboardType = KeyboardType.Decimal)
            )
            
            // Campo Descri√ß√£o
            OutlinedTextField(
                value = productDescription,
                onValueChange = { productDescription = it },
                label = { 
                    Text(
                        "Descri√ß√£o",
                        color = TaskGoTextGray,
                        fontSize = 14.sp
                    ) 
                },
                modifier = Modifier
                    .fillMaxWidth()
                    .height(120.dp),
                shape = RoundedCornerShape(8.dp),
                colors = OutlinedTextFieldDefaults.colors(
                    focusedBorderColor = TaskGoGreen,
                    unfocusedBorderColor = Color(0xFFD9D9D9),
                    focusedLabelColor = TaskGoTextGray,
                    unfocusedLabelColor = TaskGoTextGray,
                    cursorColor = TaskGoGreen
                ),
                maxLines = 4
            )
            
            Spacer(modifier = Modifier.height(20.dp))
            
            // Bot√µes de a√ß√£o
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                OutlinedButton(
                    onClick = { onBackClick() },
                    modifier = Modifier.weight(1f),
                    shape = RoundedCornerShape(8.dp),
                    colors = ButtonDefaults.outlinedButtonColors(
                        contentColor = TaskGoTextBlack
                    )
                ) {
                    Text(
                        text = "Cancelar",
                        fontSize = 14.sp,
                        fontWeight = FontWeight.Medium
                    )
                }
                
                Button(
                    onClick = { 
                        isUpdating = true
                        // Simular atualiza√ß√£o do produto
                        onProductUpdated()
                    },
                    modifier = Modifier.weight(1f),
                    shape = RoundedCornerShape(8.dp),
                    colors = ButtonDefaults.buttonColors(
                        containerColor = TaskGoGreen
                    ),
                    enabled = !isUpdating && productName.isNotEmpty() && productPrice.isNotEmpty()
                ) {
                    if (isUpdating) {
                        CircularProgressIndicator(
                            color = Color.White,
                            modifier = Modifier.size(16.dp)
                        )
                    } else {
                        Text(
                            text = "Alterar",
                            color = Color.White,
                            fontSize = 14.sp,
                            fontWeight = FontWeight.Medium
                        )
                    }
                }
            }
        }
    }
    
    // Dialog de confirma√ß√£o de exclus√£o
    if (showDeleteDialog) {
        AlertDialog(
            onDismissRequest = { showDeleteDialog = false },
            title = {
                Text(
                    text = "Excluir Produto",
                    color = TaskGoTextBlack,
                    fontWeight = FontWeight.Bold
                )
            },
            text = {
                Text(
                    text = "Tem certeza que deseja excluir este produto? Esta a√ß√£o n√£o pode ser desfeita.",
                    color = TaskGoTextGray
                )
            },
            confirmButton = {
                TextButton(
                    onClick = { 
                        showDeleteDialog = false
                        onProductDeleted()
                    },
                    colors = ButtonDefaults.textButtonColors(
                        contentColor = Color(0xFFDC3545)
                    )
                ) {
                    Text("Excluir")
                }
            },
            dismissButton = {
                TextButton(
                    onClick = { showDeleteDialog = false }
                ) {
                    Text("Cancelar")
                }
            }
        )
    }
}

```

## [FRONTEND]: feature/products/presentation/GerenciarProdutosScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.products.presentation

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material.icons.filled.Edit
import androidx.compose.ui.graphics.Color
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.collectAsState
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import coil.compose.AsyncImage
import coil.request.ImageRequest
import androidx.compose.ui.platform.LocalContext
import androidx.compose.foundation.Image
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.window.Dialog
import androidx.compose.foundation.background
import androidx.compose.ui.draw.clip
import androidx.compose.ui.res.painterResource
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.design.TGIcons
import com.taskgoapp.taskgo.core.theme.TaskGoGreen
import com.taskgoapp.taskgo.core.theme.TaskGoTextDark
import com.taskgoapp.taskgo.core.theme.TaskGoTextGray
import com.taskgoapp.taskgo.core.theme.TaskGoSurfaceGray
import com.taskgoapp.taskgo.core.model.Product

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun GerenciarProdutosScreen(
    onBackClick: () -> Unit,
    onCriarProduto: () -> Unit,
    onEditarProduto: (String) -> Unit,
    viewModel: GerenciarProdutosViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    var showImagePreview by remember { mutableStateOf<String?>(null) }
    
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Gerenciar Produtos",
                onBackClick = onBackClick
            )
        },
        floatingActionButton = {
            FloatingActionButton(
                onClick = onCriarProduto,
                containerColor = TaskGoGreen
            ) {
                Icon(
                    imageVector = Icons.Default.Add,
                    contentDescription = "Criar Produto",
                    tint = Color.White
                )
            }
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            if (uiState.isLoading) {
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    CircularProgressIndicator()
                }
            } else if (uiState.error != null) {
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    colors = CardDefaults.cardColors(
                        containerColor = MaterialTheme.colorScheme.errorContainer
                    )
                ) {
                    Text(
                        text = uiState.error ?: "Erro ao carregar produtos",
                        modifier = Modifier.padding(16.dp),
                        color = MaterialTheme.colorScheme.onErrorContainer
                    )
                }
            } else if (uiState.products.isEmpty()) {
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    Column(
                        horizontalAlignment = Alignment.CenterHorizontally,
                        verticalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        Text(
                            text = "Nenhum produto encontrado",
                            style = MaterialTheme.typography.titleMedium,
                            color = TaskGoTextGray
                        )
                        Text(
                            text = "Crie seu primeiro produto",
                            style = MaterialTheme.typography.bodyMedium,
                            color = TaskGoTextGray
                        )
                    }
                }
            } else {
                LazyColumn(
                    verticalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    items(uiState.products) { product ->
                        ProductCard(
                            product = product,
                            onEditClick = { onEditarProduto(product.id) },
                            onDeleteClick = { viewModel.deleteProduct(product.id) },
                            onImageClick = { imageUrl ->
                                showImagePreview = imageUrl
                            }
                        )
                    }
                }
            }
        }
    }
    
    // Image Preview Modal
    showImagePreview?.let { imageUrl ->
        ImagePreviewModal(
            imageUrl = imageUrl,
            onDismiss = { showImagePreview = null }
        )
    }
}

@Composable
private fun ProductCard(
    product: Product,
    onEditClick: () -> Unit,
    onDeleteClick: () -> Unit,
    onImageClick: (String) -> Unit
) {
    val context = LocalContext.current
    
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .clickable { onEditClick() },
        shape = RoundedCornerShape(12.dp),
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Column(modifier = Modifier.weight(1f)) {
                    Text(
                        text = product.title,
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold,
                        color = TaskGoTextDark
                    )
                    Spacer(modifier = Modifier.height(4.dp))
                    Text(
                        text = "R$ ${String.format("%.2f", product.price)}",
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold,
                        color = TaskGoGreen
                    )
                }
            }
            
            // Product image preview - exibir sempre, mesmo se vazio
            val firstImageUri = product.imageUris.firstOrNull { it.isNotBlank() }
            Box(
                modifier = Modifier
                    .fillMaxWidth()
                    .height(200.dp)
                    .clip(RoundedCornerShape(8.dp))
                    .background(TaskGoSurfaceGray)
                    .then(
                        if (firstImageUri != null) {
                            Modifier.clickable { onImageClick(firstImageUri) }
                        } else {
                            Modifier
                        }
                    )
            ) {
                if (firstImageUri != null) {
                    AsyncImage(
                        model = ImageRequest.Builder(context)
                            .data(firstImageUri)
                            .crossfade(true)
                            .build(),
                        contentDescription = "Imagem do produto ${product.title}",
                        modifier = Modifier.fillMaxSize(),
                        contentScale = ContentScale.Crop
                    )
                } else {
                    // Placeholder quando n√£o h√° imagem
                    Box(
                        modifier = Modifier.fillMaxSize(),
                        contentAlignment = Alignment.Center
                    ) {
                        Column(
                            horizontalAlignment = Alignment.CenterHorizontally,
                            verticalArrangement = Arrangement.spacedBy(8.dp)
                        ) {
                            Icon(
                                painter = painterResource(com.taskgoapp.taskgo.core.design.TGIcons.Products),
                                contentDescription = "Sem imagem",
                                modifier = Modifier.size(48.dp),
                                tint = TaskGoTextGray
                            )
                            Text(
                                text = "Sem imagem",
                                style = MaterialTheme.typography.bodySmall,
                                color = TaskGoTextGray
                            )
                        }
                    }
                }
            }
            
            product.description?.let { description ->
                if (description.isNotEmpty()) {
                    Text(
                        text = description,
                        style = MaterialTheme.typography.bodyMedium,
                        color = TaskGoTextDark,
                        maxLines = 3
                    )
                }
            }
            
            if (product.imageUris.size > 1) {
                Text(
                    text = "üì∑ ${product.imageUris.size} imagens",
                    style = MaterialTheme.typography.bodySmall,
                    color = TaskGoTextGray
                )
            }
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                OutlinedButton(
                    onClick = onDeleteClick,
                    modifier = Modifier.weight(1f),
                    colors = ButtonDefaults.outlinedButtonColors(
                        contentColor = MaterialTheme.colorScheme.error
                    )
                ) {
                    Icon(
                        imageVector = Icons.Default.Delete,
                        contentDescription = "Excluir",
                        modifier = Modifier.size(18.dp)
                    )
                    Spacer(modifier = Modifier.width(4.dp))
                    Text("Excluir")
                }
                
                Button(
                    onClick = onEditClick,
                    modifier = Modifier.weight(1f),
                    colors = ButtonDefaults.buttonColors(
                        containerColor = TaskGoGreen
                    )
                ) {
                    Icon(
                        imageVector = Icons.Default.Edit,
                        contentDescription = "Editar",
                        modifier = Modifier.size(18.dp)
                    )
                    Spacer(modifier = Modifier.width(4.dp))
                    Text("Editar")
                }
            }
        }
    }
}

@Composable
private fun ImagePreviewModal(
    imageUrl: String,
    onDismiss: () -> Unit
) {
    val context = LocalContext.current
    
    androidx.compose.ui.window.Dialog(onDismissRequest = onDismiss) {
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            shape = RoundedCornerShape(16.dp)
        ) {
            Column {
                Box(
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(400.dp)
                ) {
                    AsyncImage(
                        model = ImageRequest.Builder(context)
                            .data(imageUrl)
                            .crossfade(true)
                            .build(),
                        contentDescription = "Preview da imagem",
                        modifier = Modifier.fillMaxSize(),
                        contentScale = ContentScale.Fit
                    )
                }
                
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp),
                    horizontalArrangement = Arrangement.End
                ) {
                    TextButton(onClick = onDismiss) {
                        Text("Fechar")
                    }
                }
            }
        }
    }
}

```

## [FRONTEND]: feature/products/presentation/GerenciarProdutosViewModel.kt

```kotlin
package com.taskgoapp.taskgo.feature.products.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.taskgoapp.taskgo.core.model.Product
import com.taskgoapp.taskgo.domain.repository.ProductsRepository
import com.google.firebase.auth.FirebaseAuth
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.launch
import kotlinx.coroutines.flow.onEach

data class GerenciarProdutosState(
    val products: List<Product> = emptyList(),
    val isLoading: Boolean = false,
    val error: String? = null
)

@HiltViewModel
class GerenciarProdutosViewModel @Inject constructor(
    private val productsRepository: ProductsRepository,
    private val firebaseAuth: FirebaseAuth
) : ViewModel() {

    private val _uiState = MutableStateFlow(GerenciarProdutosState())
    val uiState: StateFlow<GerenciarProdutosState> = _uiState.asStateFlow()

    init {
        observeProducts()
    }

    private fun observeProducts() {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoading = true)
            
            val currentUserId = firebaseAuth.currentUser?.uid
            if (currentUserId == null) {
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = "Usu√°rio n√£o autenticado"
                )
                return@launch
            }
            
            try {
                // Observar mudan√ßas em tempo real - filtrar apenas produtos do usu√°rio atual
                productsRepository.observeProducts()
                    .onEach { allProducts ->
                        // Filtrar apenas produtos do usu√°rio atual baseado no sellerId
                        val myProducts = allProducts.filter { product ->
                            product.sellerId == currentUserId
                        }
                        _uiState.value = _uiState.value.copy(
                            products = myProducts,
                            isLoading = false,
                            error = null
                        )
                    }
                    .catch { e ->
                        android.util.Log.e("GerenciarProdutosVM", "Erro ao observar produtos: ${e.message}", e)
                        // N√£o atualizar erro aqui para n√£o sobrescrever produtos j√° carregados
                    }
                    .collect { }
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = "Erro ao carregar produtos: ${e.message}"
                )
            }
        }
    }

    fun loadProducts() {
        viewModelScope.launch {
            try {
                _uiState.value = _uiState.value.copy(isLoading = true)
                val products = productsRepository.getMyProducts()
                _uiState.value = _uiState.value.copy(
                    products = products,
                    isLoading = false,
                    error = null
                )
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = "Erro ao carregar produtos: ${e.message}"
                )
            }
        }
    }

    fun deleteProduct(productId: String) {
        viewModelScope.launch {
            try {
                productsRepository.deleteProduct(productId)
                loadProducts() // Reload the list
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    error = "Erro ao deletar produto: ${e.message}"
                )
            }
        }
    }
}

```

## [FRONTEND]: feature/products/presentation/ManageProductsScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.products.presentation

import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Edit
import androidx.compose.material.icons.filled.Search
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.taskgoapp.taskgo.core.design.TGIcons
import com.taskgoapp.taskgo.core.theme.TaskGoGreen
import com.taskgoapp.taskgo.core.theme.TaskGoTextBlack
import com.taskgoapp.taskgo.core.theme.TaskGoTextGray
import com.taskgoapp.taskgo.core.theme.TaskGoBackgroundWhite
import com.taskgoapp.taskgo.core.theme.FigmaSectionTitle
import com.taskgoapp.taskgo.core.theme.FigmaProductDescription
import com.taskgoapp.taskgo.core.theme.FigmaPrice

data class Product(
    val id: String,
    val name: String,
    val price: Double,
    val description: String,
    val imageUrl: String? = null,
    val isActive: Boolean = true
)

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ManageProductsScreen(
    onBackClick: () -> Unit,
    onCreateProduct: () -> Unit,
    onEditProduct: (String) -> Unit,
    onDeleteProduct: (String) -> Unit
) {
    var searchQuery by remember { mutableStateOf("") }
    
    // Lista vazia - dados v√™m do Firestore
    val products = remember { emptyList<Product>() }
    
    val filteredProducts = remember(products, searchQuery) {
        if (searchQuery.isEmpty()) {
            products
        } else {
            products.filter { 
                it.name.contains(searchQuery, ignoreCase = true) ||
                it.description.contains(searchQuery, ignoreCase = true)
            }
        }
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .background(TaskGoBackgroundWhite)
    ) {
        // Top Bar
        TopAppBar(
            title = {
                Text(
                    text = "Gerenciar Produtos",
                    style = FigmaSectionTitle,
                    color = TaskGoTextBlack
                )
            },
            navigationIcon = {
                IconButton(onClick = onBackClick) {
                    Icon(
                        imageVector = Icons.Filled.ArrowBack,
                        contentDescription = "Voltar",
                        tint = TaskGoTextBlack
                    )
                }
            },
            actions = {
                IconButton(onClick = onCreateProduct) {
                    Icon(
                        imageVector = Icons.Filled.Add,
                        contentDescription = "Criar produto",
                        tint = TaskGoGreen
                    )
                }
            },
            colors = TopAppBarDefaults.topAppBarColors(
                containerColor = TaskGoBackgroundWhite
            )
        )

        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // Barra de pesquisa
            OutlinedTextField(
                value = searchQuery,
                onValueChange = { searchQuery = it },
                placeholder = { Text("Buscar produtos...") },
                leadingIcon = {
                    Icon(
                        imageVector = Icons.Filled.Search,
                        contentDescription = "Buscar",
                        tint = TaskGoTextGray
                    )
                },
                modifier = Modifier.fillMaxWidth(),
                shape = RoundedCornerShape(8.dp),
                colors = OutlinedTextFieldDefaults.colors(
                    focusedBorderColor = TaskGoGreen,
                    unfocusedBorderColor = Color(0xFFD9D9D9),
                    cursorColor = TaskGoGreen
                )
            )
            
            // T√≠tulo da se√ß√£o
            Text(
                text = "Gerencie seus produtos",
                style = FigmaProductDescription,
                color = TaskGoTextBlack
            )
            
            // Lista de produtos
            if (filteredProducts.isEmpty()) {
                Box(
                    modifier = Modifier
                        .fillMaxSize()
                        .weight(1f),
                    contentAlignment = Alignment.Center
                ) {
                    Column(
                        horizontalAlignment = Alignment.CenterHorizontally,
                        verticalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        Text(
                            text = "Nenhum produto cadastrado",
                            color = TaskGoTextGray,
                            fontSize = 16.sp
                        )
                        Text(
                            text = "Crie seu primeiro produto para come√ßar",
                            color = TaskGoTextGray,
                            fontSize = 14.sp,
                            textAlign = TextAlign.Center
                        )
                    }
                }
            } else {
                LazyColumn(
                    verticalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    items(filteredProducts) { product ->
                        ProductCard(
                            product = product,
                            onEditClick = { onEditProduct(product.id) },
                            onDeleteClick = { onDeleteProduct(product.id) }
                        )
                    }
                }
            }
        }
    }
}

@Composable
fun ProductCard(
    product: Product,
    onEditClick: () -> Unit,
    onDeleteClick: () -> Unit
) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        shape = RoundedCornerShape(12.dp),
        colors = CardDefaults.cardColors(
            containerColor = Color.White
        ),
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            // Header com nome e status
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = product.name,
                    style = FigmaSectionTitle,
                    color = TaskGoTextBlack
                )
                
                // Status badge
                Card(
                    shape = RoundedCornerShape(16.dp),
                    colors = CardDefaults.cardColors(
                        containerColor = if (product.isActive) Color(0xFFD4EDDA) else Color(0xFFF8D7DA)
                    )
                ) {
                    Text(
                        text = if (product.isActive) "Ativo" else "Inativo",
                        color = if (product.isActive) Color(0xFF155724) else Color(0xFF721C24),
                        fontSize = 10.sp,
                        fontWeight = FontWeight.Medium,
                        modifier = Modifier.padding(horizontal = 8.dp, vertical = 4.dp)
                    )
                }
            }
            
            Spacer(modifier = Modifier.height(8.dp))
            
            // Pre√ßo
            Text(
                text = "R$ ${String.format("%.2f", product.price)}",
                style = FigmaPrice,
                color = TaskGoGreen
            )
            
            Spacer(modifier = Modifier.height(8.dp))
            
            // Descri√ß√£o
            Text(
                text = product.description,
                style = FigmaProductDescription,
                color = TaskGoTextGray
            )
            
            Spacer(modifier = Modifier.height(12.dp))
            
            // Bot√µes de a√ß√£o
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                OutlinedButton(
                    onClick = onDeleteClick,
                    modifier = Modifier.weight(1f),
                    shape = RoundedCornerShape(8.dp),
                    colors = ButtonDefaults.outlinedButtonColors(
                        contentColor = Color(0xFFDC3545)
                    )
                ) {
                    Text(
                        text = "Excluir",
                        fontSize = 12.sp,
                        fontWeight = FontWeight.Medium
                    )
                }
                
                Button(
                    onClick = onEditClick,
                    modifier = Modifier.weight(1f),
                    shape = RoundedCornerShape(8.dp),
                    colors = ButtonDefaults.buttonColors(
                        containerColor = TaskGoGreen
                    )
                ) {
                    Icon(
                        imageVector = Icons.Filled.Edit,
                        contentDescription = "Editar",
                        tint = Color.White,
                        modifier = Modifier.size(16.dp)
                    )
                    Spacer(modifier = Modifier.width(4.dp))
                    Text(
                        text = "Editar",
                        color = Color.White,
                        fontSize = 12.sp,
                        fontWeight = FontWeight.Medium
                    )
                }
            }
        }
    }
}


```

## [FRONTEND]: feature/products/presentation/MarketplaceViewModel.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.products.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.taskgoapp.taskgo.domain.repository.ProductsRepository
import com.taskgoapp.taskgo.core.model.Product
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.stateIn

@HiltViewModel
class MarketplaceViewModel @Inject constructor(
    private val productsRepository: ProductsRepository
) : ViewModel() {

    val products: StateFlow<List<Product>> = productsRepository
        .observeProducts()
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyList())

    fun getProductById(id: String): Product? {
        // Note: getProductById is not available in ProductsRepository flow,
        // so we'll need to get it from the products list
        return products.value.firstOrNull { it.id == id }
    }
}

```

## [FRONTEND]: feature/products/presentation/MeusProdutosScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.products.presentation
import com.taskgoapp.taskgo.core.theme.*

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Edit
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material.icons.filled.Search
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Star
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import coil.compose.AsyncImage
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.design.TGIcons
import androidx.compose.ui.res.painterResource

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MeusProdutosScreen(
    onBackClick: () -> Unit,
    onCriarProduto: () -> Unit,
    onEditarProduto: (String) -> Unit,
    viewModel: MeusProdutosViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    var searchQuery by remember { mutableStateOf("") }
    var selectedProducts by remember { mutableStateOf(setOf<String>()) }

    Scaffold(
        topBar = {
            AppTopBar(
                title = "Gerencie seus Produtos",
                onBackClick = onBackClick
            )
        },
        floatingActionButton = {
            FloatingActionButton(
                onClick = onCriarProduto,
                containerColor = TaskGoGreen
            ) {
                Icon(
                    imageVector = Icons.Default.Add,
                    contentDescription = "Criar Produto",
                    tint = Color.White
                )
            }
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // Barra de pesquisa
            OutlinedTextField(
                value = searchQuery,
                onValueChange = { searchQuery = it },
                modifier = Modifier.fillMaxWidth(),
                placeholder = { Text("Pesquisar produtos...") },
                leadingIcon = {
                    Icon(
                        imageVector = Icons.Default.Search,
                        contentDescription = "Pesquisar"
                    )
                },
                singleLine = true
            )
            if (uiState.isLoading) {
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    CircularProgressIndicator()
                }
            } else if (uiState.error != null) {
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    colors = CardDefaults.cardColors(
                        containerColor = MaterialTheme.colorScheme.errorContainer
                    )
                ) {
                    Text(
                        text = uiState.error!!,
                        modifier = Modifier.padding(16.dp),
                        color = MaterialTheme.colorScheme.onErrorContainer
                    )
                }
            } else if (uiState.products.isEmpty()) {
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    colors = CardDefaults.cardColors(
                        containerColor = MaterialTheme.colorScheme.surfaceVariant
                    )
                ) {
                    Column(
                        modifier = Modifier.padding(32.dp),
                        horizontalAlignment = Alignment.CenterHorizontally
                    ) {
                        Text(
                            text = "Nenhum produto encontrado",
                            style = MaterialTheme.typography.titleMedium,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                        Text(
                            text = "Clique no bot√£o + para criar seu primeiro produto",
                            style = MaterialTheme.typography.bodyMedium,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                }
            } else {
                // Lista de produtos com select boxes
                LazyColumn(
                    verticalArrangement = Arrangement.spacedBy(16.dp),
                    modifier = Modifier.weight(1f)
                ) {
                    val filteredProducts = uiState.products.filter { 
                        it.title.contains(searchQuery, ignoreCase = true) 
                    }
                    items(filteredProducts.size) { index ->
                        val product = filteredProducts[index]
                        ProductCardWithCheckbox(
                            product = product,
                            isSelected = selectedProducts.contains(product.id),
                            onSelectionChange = { isSelected ->
                                selectedProducts = if (isSelected) {
                                    selectedProducts + product.id
                                } else {
                                    selectedProducts - product.id
                                }
                            },
                            onEdit = { onEditarProduto(product.id) },
                            onDelete = { viewModel.deleteProduct(product.id) }
                        )
                    }
                }
                
                // Bot√µes na parte inferior
                Column(
                    verticalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    Button(
                        onClick = onCriarProduto,
                        modifier = Modifier.fillMaxWidth(),
                        colors = ButtonDefaults.buttonColors(
                            containerColor = TaskGoSuccessGreen
                        )
                    ) {
                        Text(
                            text = "Criar Produto",
                            color = Color.White,
                            fontWeight = FontWeight.Bold
                        )
                    }
                    
                }
            }
        }
    }
}

@Composable
private fun ProductCardWithCheckbox(
    product: com.taskgoapp.taskgo.core.model.Product,
    isSelected: Boolean,
    onSelectionChange: (Boolean) -> Unit,
    onEdit: () -> Unit,
    onDelete: () -> Unit
) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(
            containerColor = if (isSelected) TaskGoSurfaceGrayBg else MaterialTheme.colorScheme.surface
        ),
        shape = RoundedCornerShape(12.dp)
    ) {
        Row(
            modifier = Modifier.padding(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            // Checkbox
            Checkbox(
                checked = isSelected,
                onCheckedChange = onSelectionChange,
                colors = CheckboxDefaults.colors(
                    checkedColor = TaskGoSuccessGreen
                )
            )
            
            Spacer(modifier = Modifier.width(12.dp))
            
            // Product image - melhorado para exibir corretamente
            Box(
                modifier = Modifier
                    .size(80.dp)
                    .clip(RoundedCornerShape(8.dp))
                    .background(
                        color = MaterialTheme.colorScheme.surfaceVariant,
                        shape = RoundedCornerShape(8.dp)
                    ),
                contentAlignment = Alignment.Center
            ) {
                if (product.imageUris.isNotEmpty() && product.imageUris.first().isNotBlank()) {
                    AsyncImage(
                        model = product.imageUris.first(),
                        contentDescription = "Imagem do produto ${product.title}",
                        modifier = Modifier
                            .fillMaxSize()
                            .clip(RoundedCornerShape(8.dp)),
                        contentScale = androidx.compose.ui.layout.ContentScale.Crop
                    )
                } else {
                    Icon(
                        painter = painterResource(TGIcons.Package),
                        contentDescription = "Produto sem imagem",
                        tint = MaterialTheme.colorScheme.onSurfaceVariant,
                        modifier = Modifier.size(40.dp)
                    )
                }
            }

            Spacer(modifier = Modifier.width(16.dp))

            // Product details
            Column(
                modifier = Modifier.weight(1f)
            ) {
                Text(
                    text = product.title,
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Medium
                )
                Text(
                    text = "R$ ${String.format("%.2f", product.price)}",
                    style = MaterialTheme.typography.titleMedium,
                    color = TaskGoSuccessGreen,
                    fontWeight = FontWeight.Bold
                )
                product.description?.let { description ->
                    if (description.isNotEmpty()) {
                        Text(
                            text = description,
                            style = MaterialTheme.typography.bodyMedium,
                            color = MaterialTheme.colorScheme.onSurfaceVariant,
                            maxLines = 2
                        )
                    }
                }
                // Badge de produto em destaque
                if (product.featured == true) {
                    Spacer(modifier = Modifier.height(4.dp))
                    Row(
                        verticalAlignment = Alignment.CenterVertically,
                        horizontalArrangement = Arrangement.spacedBy(4.dp)
                    ) {
                        Icon(
                            imageVector = Icons.Default.Star,
                            contentDescription = "Em destaque",
                            modifier = Modifier.size(14.dp),
                            tint = TaskGoSuccessGreen
                        )
                        Text(
                            text = "Em destaque",
                            style = MaterialTheme.typography.bodySmall,
                            color = TaskGoSuccessGreen,
                            fontWeight = FontWeight.Bold
                        )
                    }
                }
            }

            // Action buttons
            Column(
                horizontalAlignment = Alignment.End
            ) {
                IconButton(onClick = onEdit) {
                    Icon(
                        imageVector = Icons.Default.Edit,
                        contentDescription = "Editar",
                        tint = TaskGoSuccessGreen
                    )
                }
                IconButton(onClick = onDelete) {
                    Icon(
                        imageVector = Icons.Default.Delete,
                        contentDescription = "Deletar",
                        tint = MaterialTheme.colorScheme.error
                    )
                }
            }
        }
    }
}

@Composable
private fun ProductCard(
    product: com.taskgoapp.taskgo.core.model.Product,
    onEdit: () -> Unit,
    onDelete: () -> Unit
) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.surface
        )
    ) {
        Row(
            modifier = Modifier.padding(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            // Product image
            if (product.imageUris.isNotEmpty()) {
                AsyncImage(
                    model = product.imageUris.first(),
                    contentDescription = "Imagem do produto ${product.title}",
                    modifier = Modifier
                        .size(80.dp)
                        .background(
                            color = MaterialTheme.colorScheme.surfaceVariant,
                            shape = MaterialTheme.shapes.medium
                        )
                )
            } else {
                Box(
                    modifier = Modifier
                        .size(80.dp)
                        .background(
                            color = MaterialTheme.colorScheme.surfaceVariant,
                            shape = MaterialTheme.shapes.medium
                        ),
                    contentAlignment = Alignment.Center
                ) {
                    Icon(
                        painter = painterResource(TGIcons.Package),
                        contentDescription = "Produto sem imagem",
                        tint = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
            }

            Spacer(modifier = Modifier.width(16.dp))

            // Product details
            Column(
                modifier = Modifier.weight(1f)
            ) {
                Text(
                    text = product.title,
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Medium
                )
                Text(
                    text = "R$ ${String.format("%.2f", product.price)}",
                    style = MaterialTheme.typography.titleMedium,
                    color = MaterialTheme.colorScheme.primary,
                    fontWeight = FontWeight.Bold
                )
                product.description?.let { description ->
                    if (description.isNotEmpty()) {
                        Text(
                            text = description,
                            style = MaterialTheme.typography.bodyMedium,
                            color = MaterialTheme.colorScheme.onSurfaceVariant,
                            maxLines = 2
                        )
                    }
                }
            }

            // Action buttons
            Column(
                horizontalAlignment = Alignment.End
            ) {
                IconButton(onClick = onEdit) {
                    Icon(
                        imageVector = Icons.Default.Edit,
                        contentDescription = "Editar",
                        tint = MaterialTheme.colorScheme.primary
                    )
                }
                IconButton(onClick = onDelete) {
                    Icon(
                        imageVector = Icons.Default.Delete,
                        contentDescription = "Deletar",
                        tint = MaterialTheme.colorScheme.error
                    )
                }
            }
        }
    }
}

```

## [FRONTEND]: feature/products/presentation/MeusProdutosViewModel.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.products.presentation

import android.content.Context
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.taskgoapp.taskgo.core.data.PreferencesManager
import com.taskgoapp.taskgo.core.model.Product
import com.taskgoapp.taskgo.domain.repository.ProductsRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import dagger.hilt.android.qualifiers.ApplicationContext
import javax.inject.Inject
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch

data class MeusProdutosState(
    val products: List<Product> = emptyList(),
    val isLoading: Boolean = false,
    val error: String? = null
)

@HiltViewModel
class MeusProdutosViewModel @Inject constructor(
    private val productsRepository: ProductsRepository,
    @ApplicationContext private val context: Context
) : ViewModel() {
    
    private val preferencesManager = PreferencesManager(context)

    private val _uiState = MutableStateFlow(MeusProdutosState())
    val uiState: StateFlow<MeusProdutosState> = _uiState.asStateFlow()

    init {
        loadProducts()
    }

    fun loadProducts() {
        viewModelScope.launch {
            try {
                _uiState.value = _uiState.value.copy(isLoading = true)
                val products = productsRepository.getMyProducts()
                
                // N√£o criar produtos de exemplo - app limpo para o primeiro usu√°rio criar manualmente
                _uiState.value = _uiState.value.copy(
                    products = products,
                    isLoading = false,
                    error = null
                )
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = "Erro ao carregar produtos: ${e.message}"
                )
            }
        }
    }

    fun deleteProduct(productId: String) {
        viewModelScope.launch {
            try {
                productsRepository.deleteProduct(productId)
                loadProducts() // Reload the list
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    error = "Erro ao deletar produto: ${e.message}"
                )
            }
        }
    }
}

```

## [FRONTEND]: feature/products/presentation/OrderTrackingScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.products.presentation

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll

import androidx.compose.material3.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.LocationOn
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.R
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.design.TGIcons
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.delay
import com.taskgoapp.taskgo.core.model.PurchaseOrder
import com.taskgoapp.taskgo.core.model.TrackingEvent
import com.taskgoapp.taskgo.core.model.OrderStatus
import androidx.compose.ui.graphics.Color
import java.text.SimpleDateFormat
import java.util.*
import androidx.compose.foundation.shape.CircleShape
import androidx.hilt.navigation.compose.hiltViewModel
import com.taskgoapp.taskgo.core.theme.*
import com.taskgoapp.taskgo.feature.products.presentation.OrderTrackingViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun OrderTrackingScreen(
    orderId: String,
    onNavigateBack: () -> Unit,
    viewModel: OrderTrackingViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    
    LaunchedEffect(orderId) {
        viewModel.loadOrderTracking(orderId)
    }
    
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Rastreamento de Pedido",
                subtitle = "Acompanhe seu pedido em tempo real",
                onBackClick = onNavigateBack,
                backgroundColor = TaskGoGreen,
                titleColor = Color.White,
                subtitleColor = Color.White,
                backIconColor = Color.White
            )
        }
    ) { paddingValues ->
        if (uiState.isLoading) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues),
                contentAlignment = Alignment.Center
            ) {
                CircularProgressIndicator(color = TaskGoGreen)
            }
        } else {
            val error = uiState.error
            val currentOrder = uiState.order
            
            if (error != null) {
                Box(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(paddingValues),
                    contentAlignment = Alignment.Center
                ) {
                    Column(
                        horizontalAlignment = Alignment.CenterHorizontally,
                        verticalArrangement = Arrangement.spacedBy(16.dp)
                    ) {
                        Text(
                            text = "Erro ao carregar rastreamento",
                            style = MaterialTheme.typography.titleMedium,
                            color = TaskGoError
                        )
                        Text(
                            text = error,
                            style = MaterialTheme.typography.bodyMedium,
                            color = TaskGoTextGray
                        )
                        Button(onClick = { viewModel.loadOrderTracking(orderId) }) {
                            Text("Tentar Novamente")
                        }
                    }
                }
            } else if (currentOrder != null) {
                Column(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(paddingValues)
                        .verticalScroll(rememberScrollState())
                ) {
                // Order Header
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
                ) {
                    Column(
                        modifier = Modifier.padding(16.dp)
                    ) {
                        Text(
                            text = "Pedido #${currentOrder.orderNumber}",
                            style = MaterialTheme.typography.titleLarge,
                            fontWeight = FontWeight.Bold
                        )
                        Spacer(modifier = Modifier.height(8.dp))
                        Text(
                            text = "Status: ${getStatusText(currentOrder.status)}",
                            style = MaterialTheme.typography.bodyMedium,
                            color = getStatusColor(currentOrder.status)
                        )
                        if (uiState.trackingCode.isNotEmpty()) {
                            Spacer(modifier = Modifier.height(8.dp))
                            Row(
                                modifier = Modifier.fillMaxWidth(),
                                verticalAlignment = Alignment.CenterVertically
                            ) {
                                Text(
                                    text = "C√≥digo de rastreamento: ",
                                    style = MaterialTheme.typography.bodySmall,
                                    color = TaskGoTextGray
                                )
                                Text(
                                    text = uiState.trackingCode,
                                    style = MaterialTheme.typography.bodySmall,
                                    fontWeight = FontWeight.Bold,
                                    color = TaskGoGreen
                                )
                                if (uiState.carrier != null) {
                                    Spacer(modifier = Modifier.width(8.dp))
                                    Text(
                                        text = "‚Ä¢ ${uiState.carrier}",
                                        style = MaterialTheme.typography.bodySmall,
                                        color = TaskGoTextGray
                                    )
                                }
                            }
                            if (uiState.trackingUrl != null) {
                                Spacer(modifier = Modifier.height(4.dp))
                                TextButton(
                                    onClick = { /* Abrir URL de rastreamento */ },
                                    modifier = Modifier.fillMaxWidth()
                                ) {
                                    Text("Abrir rastreamento completo")
                                }
                            }
                        }
                        if (uiState.isLocalDelivery && uiState.deliveryTime != null) {
                            Spacer(modifier = Modifier.height(8.dp))
                            Row(
                                verticalAlignment = Alignment.CenterVertically
                            ) {
                                Icon(
                                    imageVector = Icons.Default.LocationOn,
                                    contentDescription = null,
                                    tint = TaskGoGreen,
                                    modifier = Modifier.size(16.dp)
                                )
                                Spacer(modifier = Modifier.width(4.dp))
                                Text(
                                    text = "Entrega local ‚Ä¢ Chegada: ${uiState.deliveryTime}",
                                    style = MaterialTheme.typography.bodySmall,
                                    color = TaskGoTextGray
                                )
                            }
                        }
                    }
                }
                
                Spacer(modifier = Modifier.height(16.dp))
                
                // Tracking Timeline
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
                ) {
                    Column(
                        modifier = Modifier.padding(16.dp)
                    ) {
                        Text(
                            text = "Rastreamento",
                            style = MaterialTheme.typography.titleMedium,
                            fontWeight = FontWeight.Bold
                        )
                        Spacer(modifier = Modifier.height(16.dp))
                        
                        if (uiState.trackingEvents.isNotEmpty()) {
                            uiState.trackingEvents.forEachIndexed { index, event ->
                                TrackingEventItem(
                                    event = event,
                                    isLast = index == uiState.trackingEvents.size - 1
                                )
                            }
                        } else {
                            DefaultTimeline(currentStatus = currentOrder.status)
                        }
                    }
                }
                
                Spacer(modifier = Modifier.height(16.dp))
                
                // Order Details
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
                ) {
                    Column(
                        modifier = Modifier.padding(16.dp)
                    ) {
                        Text(
                            text = "Detalhes do Pedido",
                            style = MaterialTheme.typography.titleMedium,
                            fontWeight = FontWeight.Bold
                        )
                        Spacer(modifier = Modifier.height(16.dp))
                        
                        currentOrder.items.forEach { item ->
                            Row(
                                modifier = Modifier.fillMaxWidth(),
                                horizontalArrangement = Arrangement.SpaceBetween
                            ) {
                                Text(
                                    text = "${item.quantity}x Produto",
                                    style = MaterialTheme.typography.bodyMedium
                                )
                                Text(
                                    text = "R$ ${String.format("%.2f", item.price * item.quantity)}",
                                    style = MaterialTheme.typography.bodyMedium,
                                    fontWeight = FontWeight.Medium
                                )
                            }
                            if (item != currentOrder.items.lastOrNull()) {
                                HorizontalDivider(modifier = Modifier.padding(vertical = 8.dp))
                            }
                        }
                        
                        Spacer(modifier = Modifier.height(16.dp))
                        
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.SpaceBetween
                        ) {
                            Text(
                                text = "Total",
                                style = MaterialTheme.typography.titleMedium,
                                fontWeight = FontWeight.Bold
                            )
                            Text(
                                text = "R$ ${String.format("%.2f", currentOrder.total)}",
                                style = MaterialTheme.typography.titleMedium,
                                fontWeight = FontWeight.Bold,
                                color = TaskGoGreen
                            )
                        }
                    }
                }
                }
            } else {
                // Empty state
                Box(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(paddingValues),
                    contentAlignment = Alignment.Center
                ) {
                    Text(
                        text = "Pedido n√£o encontrado",
                        style = MaterialTheme.typography.bodyLarge,
                        color = TaskGoTextGray
                    )
                }
            }
        }
    }
}

private fun getStatusText(status: com.taskgoapp.taskgo.core.model.OrderStatus): String {
    return when (status) {
        com.taskgoapp.taskgo.core.model.OrderStatus.EM_ANDAMENTO -> "Em Andamento"
        com.taskgoapp.taskgo.core.model.OrderStatus.CONCLUIDO -> "Conclu√≠do"
        com.taskgoapp.taskgo.core.model.OrderStatus.CANCELADO -> "Cancelado"
    }
}

private fun getStatusColor(status: com.taskgoapp.taskgo.core.model.OrderStatus): androidx.compose.ui.graphics.Color {
    return when (status) {
        com.taskgoapp.taskgo.core.model.OrderStatus.EM_ANDAMENTO -> TaskGoWarning
        com.taskgoapp.taskgo.core.model.OrderStatus.CONCLUIDO -> TaskGoSuccessGreen
        com.taskgoapp.taskgo.core.model.OrderStatus.CANCELADO -> TaskGoError
    }
}

@Composable
private fun OrderHeaderCard(order: PurchaseOrder) {
    Card(
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.primaryContainer
        )
    ) {
        Column(
            modifier = Modifier.padding(20.dp)
        ) {
            Text(
                text = stringResource(R.string.order_tracking_order_info),
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.Bold,
                color = MaterialTheme.colorScheme.onPrimaryContainer
            )
            
            Spacer(modifier = Modifier.height(16.dp))
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Column {
                    Text(
                        text = "Pedido #${order.orderNumber}",
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Medium,
                        color = MaterialTheme.colorScheme.onPrimaryContainer
                    )
                    
                    Text(
                        text = "ID: ${order.id}",
                        style = MaterialTheme.typography.bodyMedium,
                        color = MaterialTheme.colorScheme.onPrimaryContainer
                    )
                }
                
                Box(
                    modifier = Modifier
                        .size(60.dp)
                        .background(MaterialTheme.colorScheme.onPrimaryContainer),
                    contentAlignment = Alignment.Center
                ) {
                    Icon(
                        painter = painterResource(TGIcons.Cart),
                        contentDescription = null,
                        modifier = Modifier.size(32.dp),
                        tint = MaterialTheme.colorScheme.primaryContainer
                    )
                }
            }
        }
    }
}

@Composable
private fun TrackingTimelineCard(
    trackingEvents: List<TrackingEvent>,
    currentStatus: OrderStatus
) {
    Card(
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                text = stringResource(R.string.order_tracking_timeline_title),
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.Bold
            )
            
            Spacer(modifier = Modifier.height(16.dp))
            
            if (trackingEvents.isNotEmpty()) {
                trackingEvents.forEachIndexed { index, event ->
                    TrackingEventItem(
                        event = event,
                        isLast = index == trackingEvents.size - 1
                    )
                }
            } else {
                // Default timeline based on current status
                DefaultTimeline(currentStatus = currentStatus)
            }
        }
    }
}

@Composable
private fun TrackingEventItem(
    event: TrackingEvent,
    isLast: Boolean
) {
    Row(
        modifier = Modifier.fillMaxWidth()
    ) {
        // Timeline line and dot
        Column(
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Box(
                modifier = Modifier
                    .size(12.dp)
                    .background(
                        color = MaterialTheme.colorScheme.primary,
                        shape = CircleShape
                    )
            )
            
            if (!isLast) {
                Box(
                    modifier = Modifier
                        .width(2.dp)
                        .height(40.dp)
                        .background(MaterialTheme.colorScheme.primary)
                )
            }
        }
        
        Spacer(modifier = Modifier.width(16.dp))
        
        // Event content
        Column(
            modifier = Modifier.weight(1f)
        ) {
            Text(
                text = event.label,
                style = MaterialTheme.typography.bodyMedium,
                fontWeight = FontWeight.Medium,
                color = if (event.done) TaskGoTextBlack else TaskGoTextGray
            )
            
            Text(
                text = formatTrackingDate(event.date),
                style = MaterialTheme.typography.bodySmall,
                color = TaskGoTextGray
            )
        }
    }
}

@Composable
private fun DefaultTimeline(currentStatus: OrderStatus) {
    val timelineSteps = listOf(
        TrackingStep(
            title = "Pedido Criado",
            description = "Seu pedido foi criado e est√° aguardando pagamento",
            isCompleted = true,
            icon = TGIcons.Edit
        ),
        TrackingStep(
            title = "Pagamento Confirmado",
            description = "Pagamento confirmado, aguardando preparo",
            isCompleted = currentStatus != OrderStatus.EM_ANDAMENTO,
            icon = TGIcons.Services
        ),
        TrackingStep(
            title = "Pedido Enviado",
            description = "Seu pedido foi enviado e est√° a caminho",
            isCompleted = currentStatus == OrderStatus.CONCLUIDO,
            icon = TGIcons.Cart
        ),
        TrackingStep(
            title = "Pedido Entregue",
            description = "Seu pedido foi entregue com sucesso",
            isCompleted = currentStatus == OrderStatus.CONCLUIDO,
            icon = TGIcons.Check
        )
    )
    
    timelineSteps.forEachIndexed { index, step ->
        TrackingStepItem(
            step = step,
            isLast = index == timelineSteps.size - 1
        )
    }
}

@Composable
private fun TrackingStepItem(
    step: TrackingStep,
    isLast: Boolean
) {
    Row(
        modifier = Modifier.fillMaxWidth()
    ) {
        // Timeline line and dot
        Column(
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Box(
                modifier = Modifier
                    .size(12.dp)
                    .background(
                        color = if (step.isCompleted) 
                            MaterialTheme.colorScheme.primary 
                        else 
                            MaterialTheme.colorScheme.outline,
                        shape = CircleShape
                    )
            )
            
            if (!isLast) {
                Box(
                    modifier = Modifier
                        .width(2.dp)
                        .height(40.dp)
                        .background(
                            color = if (step.isCompleted) 
                                MaterialTheme.colorScheme.primary 
                            else 
                                MaterialTheme.colorScheme.outline
                        )
                )
            }
        }
        
        Spacer(modifier = Modifier.width(16.dp))
        
        // Step content
        Row(
            verticalAlignment = Alignment.CenterVertically,
            modifier = Modifier.weight(1f)
        ) {
            Icon(
                painter = painterResource(step.icon),
                contentDescription = null,
                modifier = Modifier.size(24.dp),
                tint = if (step.isCompleted) 
                    MaterialTheme.colorScheme.primary 
                else 
                    MaterialTheme.colorScheme.onSurfaceVariant
            )
            
            Spacer(modifier = Modifier.width(12.dp))
            
            Column {
                Text(
                    text = step.title,
                    style = MaterialTheme.typography.bodyMedium,
                    fontWeight = FontWeight.Medium,
                    color = if (step.isCompleted) 
                        MaterialTheme.colorScheme.onSurface 
                    else 
                        MaterialTheme.colorScheme.onSurfaceVariant
                )
                
                Text(
                    text = step.description,
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
        }
    }
}

@Composable
private fun OrderDetailsCard(order: PurchaseOrder) {
    Card(
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                text = stringResource(R.string.order_tracking_details_title),
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.Bold
            )
            
            Spacer(modifier = Modifier.height(16.dp))
            
            // Order items
            order.items.forEach { item ->
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Text(
                        text = "${item.quantity}x Produto",
                        style = MaterialTheme.typography.bodyMedium
                    )
                    
                    Text(
                        text = "R$ ${String.format("%.2f", item.price * item.quantity)}",
                        style = MaterialTheme.typography.bodyMedium,
                        fontWeight = FontWeight.Medium
                    )
                }
                
                if (item != order.items.last()) {
                    HorizontalDivider(modifier = Modifier.padding(vertical = 8.dp))
                }
            }
            
            Spacer(modifier = Modifier.height(16.dp))
            
            // Total
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text(
                    text = stringResource(R.string.order_tracking_total),
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold
                )
                
                Text(
                    text = "R$ ${String.format("%.2f", order.total)}",
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold,
                    color = MaterialTheme.colorScheme.primary
                )
            }
        }
    }
}

private data class TrackingStep(
    val title: String,
    val description: String,
    val isCompleted: Boolean,
    val icon: Int
)

private fun formatTrackingDate(timestamp: Long): String {
    val formatter = SimpleDateFormat("dd/MM/yyyy '√†s' HH:mm", Locale("pt", "BR"))
    return formatter.format(Date(timestamp))
}



```

## [FRONTEND]: feature/products/presentation/OrderTrackingViewModel.kt

```kotlin
package com.taskgoapp.taskgo.feature.products.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.taskgoapp.taskgo.core.model.PurchaseOrder
import com.taskgoapp.taskgo.core.model.TrackingEvent
import com.taskgoapp.taskgo.data.repository.FirestoreTrackingRepository
import com.taskgoapp.taskgo.domain.repository.OrdersRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.launch
import kotlinx.coroutines.tasks.await
import javax.inject.Inject

data class OrderTrackingUiState(
    val order: PurchaseOrder? = null,
    val trackingEvents: List<TrackingEvent> = emptyList(),
    val trackingCode: String = "",
    val carrier: String? = null,
    val trackingUrl: String? = null,
    val isLocalDelivery: Boolean = false,
    val deliveryTime: String? = null,
    val shipmentStatus: String? = null,
    val isLoading: Boolean = true,
    val error: String? = null
)

@HiltViewModel
class OrderTrackingViewModel @Inject constructor(
    private val ordersRepository: OrdersRepository,
    private val trackingRepository: FirestoreTrackingRepository
) : ViewModel() {
    
    private val _uiState = MutableStateFlow(OrderTrackingUiState())
    val uiState: StateFlow<OrderTrackingUiState> = _uiState.asStateFlow()
    
    fun loadOrderTracking(orderId: String) {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoading = true, error = null)
            
            try {
                val order = ordersRepository.getOrder(orderId)
                if (order == null) {
                    _uiState.value = _uiState.value.copy(
                        isLoading = false,
                        error = "Pedido n√£o encontrado"
                    )
                    return@launch
                }
                
                // Buscar informa√ß√µes de shipment
                val shipment = loadShipmentInfo(orderId)
                
                val trackingCode = shipment?.trackingCode ?: trackingRepository.generateTrackingCode(orderId)
                
                // Atualizar estado inicial
                _uiState.value = _uiState.value.copy(
                    order = order,
                    trackingCode = trackingCode,
                    carrier = shipment?.carrier,
                    trackingUrl = shipment?.customTrackingUrl,
                    isLocalDelivery = shipment?.isLocalDelivery ?: false,
                    deliveryTime = shipment?.deliveryTime,
                    shipmentStatus = shipment?.status,
                    isLoading = false
                )
                
                // Observar eventos de rastreamento em tempo real em um job separado
                viewModelScope.launch {
                    trackingRepository.observeTrackingEvents(orderId)
                        .collect { events ->
                            _uiState.value = _uiState.value.copy(
                                trackingEvents = events
                            )
                        }
                }
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = e.message ?: "Erro ao carregar rastreamento"
                )
            }
        }
    }
    
    private suspend fun loadShipmentInfo(orderId: String): ShipmentInfo? {
        return try {
            val firestore = com.taskgoapp.taskgo.core.firebase.FirestoreHelper.getInstance()
            val snapshot = firestore.collection("shipments")
                .whereEqualTo("purchaseOrderId", orderId)
                .limit(1)
                .get()
                .await()
            
            snapshot.documents.firstOrNull()?.let { doc ->
                ShipmentInfo(
                    trackingCode = doc.getString("trackingCode") ?: "",
                    carrier = doc.getString("carrier"),
                    customTrackingUrl = doc.getString("customTrackingUrl"),
                    isLocalDelivery = doc.getBoolean("isLocalDelivery") ?: false,
                    deliveryTime = doc.getString("deliveryTime"),
                    status = doc.getString("status")
                )
            }
        } catch (e: Exception) {
            android.util.Log.e("OrderTrackingVM", "Erro ao buscar shipment: ${e.message}", e)
            null
        }
    }
    
    private data class ShipmentInfo(
        val trackingCode: String,
        val carrier: String?,
        val customTrackingUrl: String?,
        val isLocalDelivery: Boolean,
        val deliveryTime: String?,
        val status: String?
    )
}


```

## [FRONTEND]: feature/products/presentation/ProductDetailScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.products.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.core.theme.*
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import coil.compose.AsyncImage
import coil.request.ImageRequest
import com.taskgoapp.taskgo.R
import com.taskgoapp.taskgo.core.accessibility.AccessibilityStrings
import com.taskgoapp.taskgo.core.design.AppTopBar
import androidx.compose.ui.semantics.semantics
import com.taskgoapp.taskgo.core.accessibility.contentDescription
import com.taskgoapp.taskgo.core.accessibility.testTag
import androidx.compose.ui.res.stringResource
import com.taskgoapp.taskgo.core.model.Product
import com.taskgoapp.taskgo.core.model.ReviewType

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ProductDetailScreen(
    productId: String,
    onBackClick: () -> Unit,
    onAddToCart: () -> Unit,
    variant: String? = null,
    onNavigateToReviews: ((String) -> Unit)? = null,
    viewModel: ProductDetailViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()
    
    LaunchedEffect(productId) {
        viewModel.loadProduct(productId)
    }
    
    // Handle success message
    LaunchedEffect(uiState.showAddToCartSuccess) {
        if (uiState.showAddToCartSuccess) {
            // Show snackbar or navigate
            onAddToCart()
            viewModel.dismissAddToCartSuccess()
        }
    }
    
    Scaffold(
        topBar = {
            AppTopBar(
                title = uiState.product?.title ?: stringResource(R.string.products_title),
                onBackClick = onBackClick
            )
        }
    ) { paddingValues ->
        when {
            uiState.isLoading -> {
                Box(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(paddingValues),
                    contentAlignment = Alignment.Center
                ) {
                    CircularProgressIndicator(
                        modifier = Modifier.semantics {
                            contentDescription(AccessibilityStrings.loadingState())
                        }
                    )
                }
            }
            
            uiState.error != null -> {
                ErrorState(
                    error = uiState.error!!,
                    onRetry = { viewModel.loadProduct(productId) },
                    onDismiss = { viewModel.dismissError() },
                    modifier = Modifier.padding(paddingValues)
                )
            }
            
            uiState.product != null -> {
                ProductDetailContent(
                    product = uiState.product!!,
                    onAddToCart = { viewModel.addToCart(productId) },
                    variant = variant,
                    onNavigateToReviews = onNavigateToReviews,
                    modifier = Modifier.padding(paddingValues)
                )
            }
        }
    }
}

@Composable
private fun ProductDetailContent(
    product: Product,
    onAddToCart: () -> Unit,
    variant: String? = null,
    onNavigateToReviews: ((String) -> Unit)? = null,
    modifier: Modifier = Modifier
) {
    Column(
        modifier = modifier
            .fillMaxSize()
            .verticalScroll(rememberScrollState())
            .padding(16.dp)
    ) {
        if (variant == "gallery") {
            GallerySection(product)
            Spacer(modifier = Modifier.height(16.dp))
        }
        // Product Image
        if (product.imageUris.isNotEmpty()) {
            AsyncImage(
                model = ImageRequest.Builder(LocalContext.current)
                    .data(product.imageUris.first())
                    .crossfade(true)
                    .build(),
                contentDescription = AccessibilityStrings.productImage(product.title),
                modifier = Modifier
                    .fillMaxWidth()
                    .height(200.dp)
                    .semantics {
                        testTag("product_image")
                    }
            )
            Spacer(modifier = Modifier.height(16.dp))
        }
        
        // Product Title
        Text(
            text = product.title,
            style = FigmaTitleLarge,
            color = TaskGoTextBlack,
            modifier = Modifier.semantics {
                testTag("product_title")
            }
        )
        
        Spacer(modifier = Modifier.height(8.dp))
        
        // Product Price
        Text(
            text = "R$ ${String.format("%.2f", product.price)}",
            style = FigmaPrice,
            color = TaskGoPriceGreen,
            modifier = Modifier.semantics {
                testTag("product_price")
            }
        )
        
        Spacer(modifier = Modifier.height(16.dp))
        
        // Seller Info
        Card(
            modifier = Modifier.fillMaxWidth()
        ) {
            Column(
                modifier = Modifier.padding(16.dp)
            ) {
                Text(
                    text = stringResource(R.string.products_seller),
                    style = FigmaProductName,
                    color = TaskGoTextBlack
                )
                Spacer(modifier = Modifier.height(4.dp))
                Text(
                    text = product.sellerName ?: "Vendedor n√£o informado",
                    style = FigmaProductDescription,
                    color = TaskGoTextGray
                )
            }
        }
        
        Spacer(modifier = Modifier.height(16.dp))
        
        // Se√ß√£o de Avalia√ß√µes
        if (onNavigateToReviews != null) {
            com.taskgoapp.taskgo.core.design.reviews.ReviewsSectionCompact(
                targetId = product.id,
                type = com.taskgoapp.taskgo.core.model.ReviewType.PRODUCT,
                onNavigateToReviews = { onNavigateToReviews(product.id) },
                modifier = Modifier.fillMaxWidth()
            )
            Spacer(modifier = Modifier.height(16.dp))
        } else if (variant == "reviews" && onNavigateToReviews != null) {
            ReviewsSection(
                productId = product.id,
                onNavigateToReviews = onNavigateToReviews
            )
            Spacer(modifier = Modifier.height(16.dp))
        }
        
        // Product Description
        if (product.description != null) {
            Card(
                modifier = Modifier.fillMaxWidth()
            ) {
                Column(
                    modifier = Modifier.padding(16.dp)
                ) {
                    Text(
                        text = stringResource(R.string.products_description),
                        style = FigmaProductName,
                        color = TaskGoTextBlack
                    )
                    Spacer(modifier = Modifier.height(8.dp))
                    Text(
                        text = product.description,
                        style = FigmaProductDescription,
                        color = TaskGoTextGray
                    )
                }
            }
        }
        
        Spacer(modifier = Modifier.height(24.dp))
        
        // Add to Cart Button
        Button(
            onClick = onAddToCart,
            modifier = Modifier
                .fillMaxWidth()
                .semantics {
                    contentDescription(AccessibilityStrings.addToCart(product.title))
                    testTag("add_to_cart_button")
                },
            colors = ButtonDefaults.buttonColors(
                containerColor = TaskGoGreen
            )
        ) {
            Text(
                stringResource(R.string.products_add_to_cart),
                style = FigmaButtonText,
                color = Color.White
            )
        }
    }
}

@Composable
private fun ReviewsSection(
    productId: String,
    onNavigateToReviews: (String) -> Unit
) {
    // Usar o componente real de avalia√ß√µes conectado ao backend
    com.taskgoapp.taskgo.core.design.reviews.ReviewsSectionCompact(
        targetId = productId,
        type = com.taskgoapp.taskgo.core.model.ReviewType.PRODUCT,
        onNavigateToReviews = { onNavigateToReviews(productId) },
        modifier = Modifier.fillMaxWidth()
    )
}

@Composable
private fun GallerySection(product: Product) {
    Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(8.dp)) {
        val images = if (product.imageUris.isNotEmpty()) {
            product.imageUris.take(3)
        } else {
            emptyList()
        }
        images.forEach { uri ->
            AsyncImage(
                model = ImageRequest.Builder(LocalContext.current)
                    .data(uri)
                    .crossfade(true)
                    .build(),
                contentDescription = null,
                modifier = Modifier.size(96.dp)
            )
        }
    }
}

@Composable
private fun ErrorState(
    error: String,
    onRetry: () -> Unit,
    onDismiss: () -> Unit,
    modifier: Modifier = Modifier
) {
    Column(
        modifier = modifier
            .fillMaxSize()
            .padding(16.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        Text(
            text = stringResource(R.string.ui_error),
            style = FigmaSectionTitle,
            color = TaskGoError,
            modifier = Modifier.semantics {
                contentDescription(AccessibilityStrings.errorState())
                testTag("error_title")
            }
        )
        
        Spacer(modifier = Modifier.height(8.dp))
        
        Text(
            text = error,
            style = FigmaProductDescription,
            color = TaskGoTextGray,
            modifier = Modifier.semantics {
                testTag("error_message")
            }
        )
        
        Spacer(modifier = Modifier.height(16.dp))
        
        Row(
            horizontalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            Button(
                onClick = onRetry,
                modifier = Modifier.semantics {
                    contentDescription(AccessibilityStrings.BACK_BUTTON)
                    testTag("retry_button")
                },
                colors = ButtonDefaults.buttonColors(
                    containerColor = TaskGoGreen
                )
            ) {
                Text(
                    stringResource(R.string.ui_retry),
                    style = FigmaButtonText,
                    color = Color.White
                )
            }
            
            OutlinedButton(
                onClick = onDismiss,
                modifier = Modifier.semantics {
                    contentDescription(AccessibilityStrings.CANCEL_BUTTON)
                    testTag("dismiss_button")
                }
            ) {
                Text(
                    stringResource(R.string.ui_ok),
                    style = FigmaButtonText
                )
            }
        }
    }
}

```

## [FRONTEND]: feature/products/presentation/ProductDetailViewModel.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.products.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.taskgoapp.taskgo.core.model.Product
import com.taskgoapp.taskgo.domain.repository.ProductsRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class ProductDetailViewModel @Inject constructor(
    private val productsRepository: ProductsRepository
) : ViewModel() {
    
    private val _uiState = MutableStateFlow(ProductDetailUiState())
    val uiState: StateFlow<ProductDetailUiState> = _uiState.asStateFlow()
    
    fun loadProduct(productId: String) {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoading = true)
            
            try {
                val product = productsRepository.getProduct(productId)
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    product = product,
                    error = null
                )
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = e.message
                )
            }
        }
    }
    
    fun addToCart(productId: String, quantity: Int = 1) {
        viewModelScope.launch {
            try {
                productsRepository.addToCart(productId, quantity)
                _uiState.value = _uiState.value.copy(
                    showAddToCartSuccess = true
                )
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    error = "Erro ao adicionar ao carrinho: ${e.message}"
                )
            }
        }
    }
    
    fun dismissAddToCartSuccess() {
        _uiState.value = _uiState.value.copy(showAddToCartSuccess = false)
    }
    
    fun dismissError() {
        _uiState.value = _uiState.value.copy(error = null)
    }
}

data class ProductDetailUiState(
    val isLoading: Boolean = false,
    val product: Product? = null,
    val error: String? = null,
    val showAddToCartSuccess: Boolean = false
)

```

## [FRONTEND]: feature/products/presentation/ProductFormScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.products.presentation

import android.net.Uri
import android.util.Log
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.PickVisualMediaRequest
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Close
import androidx.compose.material3.*
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.res.stringResource
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.dp
import androidx.compose.ui.window.Dialog
import androidx.hilt.navigation.compose.hiltViewModel
import coil.compose.AsyncImage
import com.taskgoapp.taskgo.R
import com.taskgoapp.taskgo.core.design.TGIcons
import androidx.compose.ui.res.painterResource

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ProductFormScreen(
    productId: String?,
    onBack: () -> Unit,
    onSaved: (String) -> Unit,
    viewModel: ProductFormViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    var showImageEditor by remember { mutableStateOf(false) }
    var selectedImageUri by remember { mutableStateOf<Uri?>(null) }

    LaunchedEffect(productId) {
        try {
            Log.d("ProductFormScreen", "Loading product with ID: $productId")
            viewModel.load(productId)
        } catch (e: Exception) {
            Log.e("ProductFormScreen", "Error loading product", e)
        }
    }

    
    val context = androidx.compose.ui.platform.LocalContext.current
    var pendingLauncherAction by remember { mutableStateOf(false) }
    
    val hasImagePermission = remember {
        com.taskgoapp.taskgo.core.permissions.PermissionHandler.hasImageReadPermission(context)
    }
    
    // Photo picker launcher
    val launcher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.PickVisualMedia()
    ) { uri: Uri? ->
        if (uri != null) {
            try {
                Log.d("ProductFormScreen", "Image selected: $uri")
                selectedImageUri = uri
                showImageEditor = true
            } catch (e: Exception) {
                Log.e("ProductFormScreen", "Error selecting image", e)
            }
        }
    }
    
    val imagePermissionLauncher = com.taskgoapp.taskgo.core.permissions.rememberImageReadPermissionLauncher(
        onPermissionGranted = {
            pendingLauncherAction = true
        },
        onPermissionDenied = {
            // Permiss√£o negada
        }
    )
    
    // Executar a√ß√£o do launcher quando permiss√£o for concedida
    LaunchedEffect(pendingLauncherAction) {
        if (pendingLauncherAction && com.taskgoapp.taskgo.core.permissions.PermissionHandler.hasImageReadPermission(context)) {
            launcher.launch(PickVisualMediaRequest(ActivityResultContracts.PickVisualMedia.ImageOnly))
            pendingLauncherAction = false
        }
    }
    
    // Camera support
    var cameraImageUri by remember { mutableStateOf<Uri?>(null) }
    val cameraLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.TakePicture()
    ) { success ->
        if (success && cameraImageUri != null) {
            viewModel.addImage(cameraImageUri!!.toString())
        }
    }
    val cameraPermissionLauncher = com.taskgoapp.taskgo.core.permissions.rememberCameraPermissionLauncher(
        onPermissionGranted = {
            val imageFile = java.io.File(context.cacheDir, "camera_${System.currentTimeMillis()}.jpg")
            cameraImageUri = Uri.fromFile(imageFile)
            cameraLauncher.launch(cameraImageUri!!)
        },
        onPermissionDenied = { /* noop */ }
    )
    
    var showImageSourceDialog by remember { mutableStateOf(false) }
    fun openImagePicker() { 
        showImageSourceDialog = true 
    }

    // Saved effect - navegar de volta para gerenciar produtos
    LaunchedEffect(uiState.saved) {
        if (uiState.saved) {
            try {
                Log.d("ProductFormScreen", "Product saved, navigating to gerenciar_produtos")
                // Pequeno delay para garantir que o produto foi salvo
                kotlinx.coroutines.delay(300)
                onSaved(uiState.id ?: "")
            } catch (e: Exception) {
                Log.e("ProductFormScreen", "Error navigating after save", e)
            }
        }
    }

    val focusManager = androidx.compose.ui.platform.LocalFocusManager.current
    val keyboardController = androidx.compose.ui.platform.LocalSoftwareKeyboardController.current
    
    Scaffold(
        topBar = {
            com.taskgoapp.taskgo.core.design.AppTopBar(
                title = if (uiState.id == null) stringResource(R.string.action_add) else stringResource(R.string.action_edit),
                onBackClick = onBack,
                backgroundColor = com.taskgoapp.taskgo.core.theme.TaskGoGreen,
                titleColor = com.taskgoapp.taskgo.core.theme.TaskGoBackgroundWhite,
                backIconColor = com.taskgoapp.taskgo.core.theme.TaskGoBackgroundWhite
            )
        }
    ) { padding ->
        val focusManager = androidx.compose.ui.platform.LocalFocusManager.current
        val keyboardController = androidx.compose.ui.platform.LocalSoftwareKeyboardController.current
        
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(padding)
                .verticalScroll(rememberScrollState())
                .padding(16.dp)
                .clickable(
                    indication = null,
                    interactionSource = remember { androidx.compose.foundation.interaction.MutableInteractionSource() }
                ) {
                    focusManager.clearFocus()
                    keyboardController?.hide()
                },
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // Photo upload section
            Card(
                modifier = Modifier.fillMaxWidth(),
                colors = CardDefaults.cardColors(
                    containerColor = MaterialTheme.colorScheme.surfaceVariant
                ),
                shape = RoundedCornerShape(12.dp)
            ) {
                Column(
                    modifier = Modifier.padding(16.dp),
                    verticalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    Text(
                        text = "Adicione fotos",
                        style = MaterialTheme.typography.titleMedium,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                    
                    if (uiState.imageUris.isEmpty()) {
                        // Empty state - show add button
                        Box(
                            modifier = Modifier
                                .fillMaxWidth()
                                .height(120.dp)
                                .clip(RoundedCornerShape(8.dp))
                                .background(MaterialTheme.colorScheme.surface)
                                .border(
                                    width = 2.dp,
                                    color = MaterialTheme.colorScheme.outline.copy(alpha = 0.3f),
                                    shape = RoundedCornerShape(8.dp)
                                )
                                .clickable { openImagePicker() },
                            contentAlignment = Alignment.Center
                        ) {
                            Icon(
                                imageVector = Icons.Default.Add,
                                contentDescription = "Adicionar foto",
                                modifier = Modifier.size(48.dp),
                                tint = MaterialTheme.colorScheme.primary
                            )
                        }
                    } else {
                        // Show selected images
                        LazyRow(
                            horizontalArrangement = Arrangement.spacedBy(8.dp)
                        ) {
                            items(uiState.imageUris) { imageUri ->
                                Box(
                                    modifier = Modifier
                                        .size(120.dp)
                                        .clip(RoundedCornerShape(8.dp))
                                        .background(MaterialTheme.colorScheme.surface)
                                        .border(
                                            width = 2.dp,
                                            color = MaterialTheme.colorScheme.outline.copy(alpha = 0.3f),
                                            shape = RoundedCornerShape(8.dp)
                                        )
                                ) {
                                    AsyncImage(
                                        model = imageUri,
                                        contentDescription = "Imagem do produto",
                                        modifier = Modifier.fillMaxSize(),
                                        contentScale = ContentScale.Crop
                                    )
                                    
                                    // Remove button
                                    IconButton(
                                        onClick = { viewModel.removeImage(imageUri) },
                                        modifier = Modifier
                                            .align(Alignment.TopEnd)
                                            .size(24.dp)
                                            .background(
                                                color = MaterialTheme.colorScheme.error,
                                                shape = RoundedCornerShape(12.dp)
                                            )
                                    ) {
                                        Icon(
                                            imageVector = Icons.Default.Close,
                                            contentDescription = "Remover imagem",
                                            tint = Color.White,
                                            modifier = Modifier.size(16.dp)
                                        )
                                    }
                                }
                            }
                            
                            // Add more button
                            item {
                                Box(
                                    modifier = Modifier
                                        .size(120.dp)
                                        .clip(RoundedCornerShape(8.dp))
                                        .background(MaterialTheme.colorScheme.surface)
                                        .border(
                                            width = 2.dp,
                                            color = MaterialTheme.colorScheme.outline.copy(alpha = 0.3f),
                                            shape = RoundedCornerShape(8.dp)
                                        )
                                        .clickable { openImagePicker() },
                                    contentAlignment = Alignment.Center
                                ) {
                                    Icon(
                                        imageVector = Icons.Default.Add,
                                        contentDescription = "Adicionar mais fotos",
                                        modifier = Modifier.size(32.dp),
                                        tint = MaterialTheme.colorScheme.primary
                                    )
                                }
                            }
                        }
                    }
                }
            }

            // Product name input
            Column {
                Text(
                    text = "Nome do produto",
                    style = MaterialTheme.typography.titleMedium,
                    color = MaterialTheme.colorScheme.onSurface
                )
                Spacer(modifier = Modifier.height(8.dp))
                OutlinedTextField(
                    value = uiState.title,
                    onValueChange = { viewModel.onTitleChange(it) },
                    modifier = Modifier.fillMaxWidth(),
                    placeholder = { Text("Digite o nome do produto") },
                    colors = OutlinedTextFieldDefaults.colors(
                        focusedBorderColor = MaterialTheme.colorScheme.primary,
                        unfocusedBorderColor = MaterialTheme.colorScheme.outline.copy(alpha = 0.3f)
                    ),
                    shape = RoundedCornerShape(8.dp)
                )
            }

            // Price input
            Column {
                Text(
                    text = "Pre√ßo",
                    style = MaterialTheme.typography.titleMedium,
                    color = MaterialTheme.colorScheme.onSurface
                )
                Spacer(modifier = Modifier.height(8.dp))
                OutlinedTextField(
                    value = uiState.price,
                    onValueChange = { newValue ->
                        val formatted = com.taskgoapp.taskgo.core.utils.TextFormatters.formatPrice(newValue)
                        viewModel.onPriceChange(formatted)
                    },
                    modifier = Modifier.fillMaxWidth(),
                    placeholder = { Text("R$ 0,00") },
                    colors = OutlinedTextFieldDefaults.colors(
                        focusedBorderColor = MaterialTheme.colorScheme.primary,
                        unfocusedBorderColor = MaterialTheme.colorScheme.outline.copy(alpha = 0.3f)
                    ),
                    shape = RoundedCornerShape(8.dp)
                )
            }

            // Description input
            Column {
                Text(
                    text = "Descri√ß√£o",
                    style = MaterialTheme.typography.titleMedium,
                    color = MaterialTheme.colorScheme.onSurface
                )
                Spacer(modifier = Modifier.height(8.dp))
                OutlinedTextField(
                    value = uiState.description,
                    onValueChange = { viewModel.onDescriptionChange(it) },
                    modifier = Modifier
                        .fillMaxWidth()
                        .heightIn(min = 140.dp),
                    placeholder = { Text("Descreva o produto") },
                    minLines = 4,
                    maxLines = 10,
                    colors = OutlinedTextFieldDefaults.colors(
                        focusedBorderColor = MaterialTheme.colorScheme.primary,
                        unfocusedBorderColor = MaterialTheme.colorScheme.outline.copy(alpha = 0.3f)
                    ),
                    shape = RoundedCornerShape(8.dp)
                )
            }

            // Seller name input
            Column {
                Text(
                    text = "Vendedor",
                    style = MaterialTheme.typography.titleMedium,
                    color = MaterialTheme.colorScheme.onSurface
                )
                Spacer(modifier = Modifier.height(8.dp))
                OutlinedTextField(
                    value = uiState.sellerName,
                    onValueChange = { viewModel.onSellerNameChange(it) },
                    modifier = Modifier.fillMaxWidth(),
                    placeholder = { Text("Nome do vendedor") },
                    colors = OutlinedTextFieldDefaults.colors(
                        focusedBorderColor = MaterialTheme.colorScheme.primary,
                        unfocusedBorderColor = MaterialTheme.colorScheme.outline.copy(alpha = 0.3f)
                    ),
                    shape = RoundedCornerShape(8.dp)
                )
            }

            // Featured product toggle
            Card(
                modifier = Modifier.fillMaxWidth(),
                colors = CardDefaults.cardColors(
                    containerColor = MaterialTheme.colorScheme.surfaceVariant
                ),
                shape = RoundedCornerShape(12.dp)
            ) {
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Column(modifier = Modifier.weight(1f)) {
                        Text(
                            text = "Produto em Destaque",
                            style = MaterialTheme.typography.titleMedium,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                        Text(
                            text = "Seu produto aparecer√° na se√ß√£o de produtos em destaque para usu√°rios pr√≥ximos (raio de 100km)",
                            style = MaterialTheme.typography.bodySmall,
                            color = MaterialTheme.colorScheme.onSurfaceVariant,
                            modifier = Modifier.padding(top = 4.dp)
                        )
                    }
                    Switch(
                        checked = uiState.featured,
                        onCheckedChange = { viewModel.onFeaturedChange(it) }
                    )
                }
            }
            
            // Discount percentage input
            if (uiState.featured) {
                Column {
                    Text(
                        text = "Porcentagem de Desconto",
                        style = MaterialTheme.typography.titleMedium,
                        color = MaterialTheme.colorScheme.onSurface
                    )
                    Spacer(modifier = Modifier.height(8.dp))
                    OutlinedTextField(
                        value = uiState.discountPercentage,
                        onValueChange = { viewModel.onDiscountPercentageChange(it) },
                        modifier = Modifier.fillMaxWidth(),
                        placeholder = { Text("Ex: 10") },
                        suffix = { Text("%") },
                        keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
                        colors = OutlinedTextFieldDefaults.colors(
                            focusedBorderColor = MaterialTheme.colorScheme.primary,
                            unfocusedBorderColor = MaterialTheme.colorScheme.outline.copy(alpha = 0.3f)
                        ),
                        shape = RoundedCornerShape(8.dp)
                    )
                }
            }

            // Save button
            Button(
                onClick = { 
                    try {
                        if (uiState.canSave) viewModel.save() 
                    } catch (e: Exception) {
                        Log.e("ProductFormScreen", "Error saving product", e)
                    }
                },
                enabled = uiState.canSave && !uiState.isSaving,
                modifier = Modifier.fillMaxWidth(),
                colors = ButtonDefaults.buttonColors(
                    containerColor = MaterialTheme.colorScheme.primary
                ),
                shape = RoundedCornerShape(8.dp)
            ) {
                if (uiState.isSaving) {
                    CircularProgressIndicator(
                        modifier = Modifier.size(20.dp),
                        color = MaterialTheme.colorScheme.onPrimary
                    )
                    Spacer(modifier = Modifier.width(8.dp))
                }
                Text(
                    text = if (uiState.id == null) "Criar Produto" else "Salvar Altera√ß√µes",
                    style = MaterialTheme.typography.titleMedium
                )
            }

            // Error display
            uiState.error?.let { error ->
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    colors = CardDefaults.cardColors(
                        containerColor = MaterialTheme.colorScheme.errorContainer
                    )
                ) {
                    Text(
                        text = error,
                        modifier = Modifier.padding(16.dp),
                        color = MaterialTheme.colorScheme.onErrorContainer
                    )
                }
            }
        }
    }

    // Image Source Chooser Dialog
    ProductImageSourceChooser(
        show = showImageSourceDialog,
        onDismiss = { showImageSourceDialog = false },
        onPickFromGallery = {
            if (hasImagePermission) {
                launcher.launch(PickVisualMediaRequest(ActivityResultContracts.PickVisualMedia.ImageOnly))
            } else {
                imagePermissionLauncher?.launch(android.Manifest.permission.READ_MEDIA_IMAGES)
            }
        },
        onCaptureFromCamera = {
            cameraPermissionLauncher?.launch(android.Manifest.permission.CAMERA)
        }
    )

    // Image Editor Dialog
    if (showImageEditor && selectedImageUri != null) {
        ImageEditorDialog(
            imageUri = selectedImageUri!!,
            onConfirm = { finalUri ->
                viewModel.addImage(finalUri.toString())
                showImageEditor = false
                selectedImageUri = null
            },
            onDismiss = {
                showImageEditor = false
                selectedImageUri = null
            }
        )
    }
}

@Composable
private fun ImageEditorDialog(
    imageUri: Uri,
    onConfirm: (Uri) -> Unit,
    onDismiss: () -> Unit
) {
    var cropMode by remember { mutableStateOf(false) }
    var resizeMode by remember { mutableStateOf(false) }
    var finalImageUri by remember { mutableStateOf(imageUri) }
    
    Dialog(onDismissRequest = onDismiss) {
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            shape = RoundedCornerShape(16.dp)
        ) {
            Column(
                modifier = Modifier.padding(24.dp),
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                Text(
                    text = "Editar Imagem",
                    style = MaterialTheme.typography.headlineSmall,
                    modifier = Modifier.padding(bottom = 16.dp)
                )
                
                // Image preview
                Box(
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(200.dp)
                        .clip(RoundedCornerShape(12.dp))
                        .background(MaterialTheme.colorScheme.surfaceVariant)
                ) {
                    AsyncImage(
                        model = finalImageUri,
                        contentDescription = "Imagem selecionada",
                        modifier = Modifier.fillMaxSize(),
                        contentScale = ContentScale.Crop
                    )
                }
                
                Spacer(modifier = Modifier.height(16.dp))
                
                // Edit options
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    OutlinedButton(
                        onClick = { cropMode = !cropMode },
                        modifier = Modifier.weight(1f),
                        colors = ButtonDefaults.outlinedButtonColors(
                            containerColor = if (cropMode) MaterialTheme.colorScheme.primaryContainer else MaterialTheme.colorScheme.surface
                        )
                    ) {
                        Text(if (cropMode) "Cortar ‚úì" else "Cortar")
                    }
                    
                    OutlinedButton(
                        onClick = { resizeMode = !resizeMode },
                        modifier = Modifier.weight(1f),
                        colors = ButtonDefaults.outlinedButtonColors(
                            containerColor = if (resizeMode) MaterialTheme.colorScheme.primaryContainer else MaterialTheme.colorScheme.surface
                        )
                    ) {
                        Text(if (resizeMode) "Redimensionar ‚úì" else "Redimensionar")
                    }
                }
                
                if (cropMode || resizeMode) {
                    Spacer(modifier = Modifier.height(16.dp))
                    Text(
                        text = when {
                            cropMode && resizeMode -> "Modo: Cortar e Redimensionar"
                            cropMode -> "Modo: Cortar - Arraste para selecionar √°rea"
                            resizeMode -> "Modo: Redimensionar - Use os controles abaixo"
                            else -> ""
                        },
                        style = MaterialTheme.typography.bodyMedium,
                        color = MaterialTheme.colorScheme.primary,
                        modifier = Modifier.padding(bottom = 16.dp)
                    )
                    
                    // Crop controls
                    if (cropMode) {
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.spacedBy(8.dp)
                        ) {
                            OutlinedButton(
                                onClick = { /* Implementar crop */ },
                                modifier = Modifier.weight(1f)
                            ) {
                                Text("Aplicar Crop")
                            }
                        }
                    }
                    
                    // Resize controls
                    if (resizeMode) {
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.spacedBy(8.dp)
                        ) {
                            OutlinedButton(
                                onClick = { /* Implementar resize */ },
                                modifier = Modifier.weight(1f)
                            ) {
                                Text("Aplicar Resize")
                            }
                        }
                    }
                }
                
                Spacer(modifier = Modifier.height(24.dp))
                
                // Action buttons
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    OutlinedButton(
                        onClick = onDismiss,
                        modifier = Modifier.weight(1f)
                    ) {
                        Text("Cancelar")
                    }
                    
                    Button(
                        onClick = { onConfirm(finalImageUri) },
                        modifier = Modifier.weight(1f),
                        colors = ButtonDefaults.buttonColors(
                            containerColor = MaterialTheme.colorScheme.primary
                        )
                    ) {
                        Text("OK")
                    }
                }
            }
        }
    }
}

// Camera/Galeria chooser acoplado √† tela de produto
@Composable
private fun ProductImageSourceChooser(
    show: Boolean,
    onDismiss: () -> Unit,
    onPickFromGallery: () -> Unit,
    onCaptureFromCamera: () -> Unit
) {
    if (!show) return
    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Selecionar imagem") },
        text = { Text("Escolha de onde deseja obter a imagem") },
        confirmButton = {
            TextButton(onClick = {
                onDismiss()
                onPickFromGallery()
            }) { Text("Galeria") }
        },
        dismissButton = {
            TextButton(onClick = {
                onDismiss()
                onCaptureFromCamera()
            }) { Text("C√¢mera") }
        }
    )
}


```

## [FRONTEND]: feature/products/presentation/ProductFormViewModel.kt

```kotlin
package com.taskgoapp.taskgo.feature.products.presentation

import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.taskgoapp.taskgo.core.model.Product
import com.taskgoapp.taskgo.core.validation.Validators
import com.taskgoapp.taskgo.domain.repository.ProductsRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withTimeoutOrNull
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.coroutineScope
import java.util.UUID

data class ProductFormState(
    val id: String? = null,
    val title: String = "",
    val price: String = "",
    val description: String = "",
    val category: String = "Geral", // Categoria do produto (obrigat√≥ria para Cloud Function)
    val sellerName: String = "",
    val imageUris: List<String> = emptyList(),
    val featured: Boolean = false, // Produto em destaque
    val discountPercentage: String = "", // Porcentagem de desconto
    val isSaving: Boolean = false,
    val error: String? = null,
    val canSave: Boolean = false,
    val saved: Boolean = false
)

@HiltViewModel
class ProductFormViewModel @Inject constructor(
    private val productsRepository: ProductsRepository,
    private val documentVerificationManager: com.taskgoapp.taskgo.core.security.DocumentVerificationManager,
    private val locationManager: com.taskgoapp.taskgo.core.location.LocationManager,
    private val storageRepository: com.taskgoapp.taskgo.data.repository.FirebaseStorageRepository,
    private val authRepository: com.taskgoapp.taskgo.data.repository.FirebaseAuthRepository,
    private val functionsService: com.taskgoapp.taskgo.data.firebase.FirebaseFunctionsService
) : ViewModel() {

    private val _uiState = MutableStateFlow(ProductFormState())
    val uiState: StateFlow<ProductFormState> = _uiState.asStateFlow()
    
    private val _isVerified = MutableStateFlow(false)
    val isVerified: StateFlow<Boolean> = _isVerified.asStateFlow()
    
    init {
        checkVerificationStatus()
    }
    
    private fun checkVerificationStatus() {
        viewModelScope.launch {
            _isVerified.value = documentVerificationManager.hasDocumentsVerified()
        }
    }

    fun load(productId: String?) {
        if (productId == null) return
        viewModelScope.launch {
            try {
                Log.d("ProductFormViewModel", "Loading product with ID: $productId")
                val p = productsRepository.getProduct(productId)
                if (p != null) {
                    Log.d("ProductFormViewModel", "Product loaded successfully: ${p.title}")
                    _uiState.value = _uiState.value.copy(
                        id = p.id,
                        title = p.title,
                        price = p.price.toString(),
                        description = p.description.orEmpty(),
                        category = p.category ?: "Geral",
                        sellerName = p.sellerName.orEmpty(),
                        imageUris = p.imageUris,
                        featured = p.featured ?: false
                    )
                    validate()
                } else {
                    Log.w("ProductFormViewModel", "Product not found with ID: $productId")
                }
            } catch (e: Exception) {
                Log.e("ProductFormViewModel", "Error loading product", e)
                _uiState.value = _uiState.value.copy(error = "Erro ao carregar produto: ${e.message}")
            }
        }
    }

    fun onTitleChange(value: String) {
        try {
            Log.d("ProductFormViewModel", "Title changed to: $value")
            _uiState.value = _uiState.value.copy(title = value)
            validate()
        } catch (e: Exception) {
            Log.e("ProductFormViewModel", "Error changing title", e)
        }
    }

    fun onPriceChange(value: String) {
        try {
            Log.d("ProductFormViewModel", "Price changed to: $value")
            _uiState.value = _uiState.value.copy(price = value)
            validate()
        } catch (e: Exception) {
            Log.e("ProductFormViewModel", "Error changing price", e)
        }
    }

    fun onDescriptionChange(value: String) {
        try {
            Log.d("ProductFormViewModel", "Description changed to: $value")
            _uiState.value = _uiState.value.copy(description = value)
            validate()
        } catch (e: Exception) {
            Log.e("ProductFormViewModel", "Error changing description", e)
        }
    }

    fun onSellerNameChange(value: String) {
        try {
            Log.d("ProductFormViewModel", "Seller name changed to: $value")
            _uiState.value = _uiState.value.copy(sellerName = value)
            validate()
        } catch (e: Exception) {
            Log.e("ProductFormViewModel", "Error changing seller name", e)
        }
    }

    fun onFeaturedChange(value: Boolean) {
        try {
            Log.d("ProductFormViewModel", "Featured changed to: $value")
            _uiState.value = _uiState.value.copy(featured = value)
        } catch (e: Exception) {
            Log.e("ProductFormViewModel", "Error changing featured", e)
        }
    }
    
    fun onDiscountPercentageChange(value: String) {
        try {
            Log.d("ProductFormViewModel", "Discount percentage changed to: $value")
            _uiState.value = _uiState.value.copy(discountPercentage = value)
        } catch (e: Exception) {
            Log.e("ProductFormViewModel", "Error changing discount percentage", e)
        }
    }

    fun addImage(uri: String) {
        try {
            Log.d("ProductFormViewModel", "Adding image: $uri")
            val updated = _uiState.value.imageUris + uri
            _uiState.value = _uiState.value.copy(imageUris = updated)
            Log.d("ProductFormViewModel", "Updated imageUris: ${_uiState.value.imageUris}")
            validate()
        } catch (e: Exception) {
            Log.e("ProductFormViewModel", "Error adding image", e)
        }
    }

    fun removeImage(uri: String) {
        try {
            Log.d("ProductFormViewModel", "Removing image: $uri")
            val updated = _uiState.value.imageUris.filterNot { it == uri }
            _uiState.value = _uiState.value.copy(imageUris = updated)
            validate()
        } catch (e: Exception) {
            Log.e("ProductFormViewModel", "Error removing image", e)
        }
    }

    private fun validate() {
        try {
            val s = _uiState.value
            val titleOk = s.title.trim().isNotEmpty()
            // Pre√ßo: aceitar formato com separadores (m√≠nimo 3 d√≠gitos) ou valida√ß√£o padr√£o
            val cleanPrice = s.price.replace(Regex("[^0-9]"), "")
            val priceOk = Validators.isValidPrice(s.price) || cleanPrice.length >= 3
            // Imagem n√£o √© obrigat√≥ria na Cloud Function, mas recomendada
            // A valida√ß√£o ser√° feita no backend se necess√°rio
            val imagesOk = true // Removido bloqueio de imagens - Cloud Function aceita array vazio
            // Desconto: v√°lido somente se featured est√° ativo E desconto > 0
            val discountValue = s.discountPercentage.replace(Regex("[^0-9]"), "").toDoubleOrNull()
            val discountOk = !s.featured || (discountValue != null && discountValue > 0.0)

            Log.d("ProductFormViewModel", "Validation - Title: $titleOk, Price: $priceOk, ImagesOk=$imagesOk, Featured: ${s.featured}, DiscountOk: $discountOk, DiscountValue: $discountValue")
            _uiState.value = s.copy(
                canSave = titleOk && priceOk && imagesOk && discountOk,
                error = null
            )
        } catch (e: Exception) {
            Log.e("ProductFormViewModel", "Error during validation", e)
        }
    }

    fun save() {
        val s = _uiState.value
        if (!s.canSave || s.isSaving) return
        
        val currentUser = authRepository.getCurrentUser()
        if (currentUser == null) {
            _uiState.value = _uiState.value.copy(error = "Usu√°rio n√£o autenticado. Fa√ßa login novamente.")
            return
        }
        
        viewModelScope.launch {
            _uiState.value = s.copy(isSaving = true, error = null)
            
            try {
                val userId = currentUser.uid
                val productId = s.id ?: UUID.randomUUID().toString()
                
                // Upload de imagens (igual aos servi√ßos)
                val imageUrls = mutableListOf<String>()
                
                s.imageUris.forEachIndexed { index, imageUri ->
                    // Se j√° √© URL, adiciona diretamente
                    if (imageUri.startsWith("http://") || imageUri.startsWith("https://")) {
                        imageUrls.add(imageUri)
                    } else {
                        // Faz upload
                        val uri = android.net.Uri.parse(imageUri)
                        val result = storageRepository.uploadProductImage(
                            userId = userId,
                            productId = productId,
                            uri = uri,
                            imageIndex = index
                        )
                        result.fold(
                            onSuccess = { url ->
                                imageUrls.add(url)
                            },
                            onFailure = { e ->
                                throw e
                            }
                        )
                    }
                }
                
                // Capturar localiza√ß√£o (obrigat√≥ria)
                val location = locationManager.getCurrentLocation()
                val latitude: Double = location?.latitude
                    ?: throw IllegalStateException("Localiza√ß√£o n√£o dispon√≠vel. Ative o GPS e tente novamente.")
                val longitude: Double = location?.longitude
                    ?: throw IllegalStateException("Localiza√ß√£o n√£o dispon√≠vel. Ative o GPS e tente novamente.")
                
                val currentUser = authRepository.getCurrentUser()
                val product = Product(
                    id = productId,
                    title = s.title.trim(),
                    price = try {
                        // Formato esperado: "8.000,00" ou "8000,00" ou "8000"
                        // Remove tudo exceto d√≠gitos
                        val cleanPrice = s.price.replace(Regex("[^0-9]"), "")
                        if (cleanPrice.isNotEmpty()) {
                            // Se h√° v√≠rgula no formato original, os √∫ltimos 2 d√≠gitos s√£o centavos
                            val hasComma = s.price.contains(",")
                            val priceValue = if (hasComma && cleanPrice.length >= 2) {
                                // Dividir por 100 para converter centavos em reais
                                // Exemplo: "800000" (de "8.000,00") -> 8000.00
                                cleanPrice.toDoubleOrNull()?.div(100.0) ?: 0.0
                            } else {
                                // Se n√£o tem v√≠rgula, tratar como valor inteiro em reais
                                // Exemplo: "8000" -> 8000.0
                                cleanPrice.toDoubleOrNull() ?: 0.0
                            }
                            priceValue
                        } else {
                            0.0
                        }
                    } catch (e: Exception) {
                        Log.e("ProductFormViewModel", "Erro ao converter pre√ßo: ${e.message}", e)
                        0.0
                    },
                    description = s.description.ifBlank { null },
                    sellerId = currentUser?.uid,
                    sellerName = s.sellerName.ifBlank { null },
                    imageUris = imageUrls,
                    category = s.category.ifBlank { "Geral" },
                    featured = s.featured && s.discountPercentage.replace(Regex("[^0-9]"), "").toDoubleOrNull()?.let { it > 0 } == true,
                    discountPercentage = s.discountPercentage.replace(Regex("[^0-9]"), "").toDoubleOrNull()?.let { it / 100 },
                    latitude = latitude,
                    longitude = longitude
                )
                
                Log.d("ProductFormViewModel", "Salvando produto via Cloud Function: id=$productId, title=${product.title}, price=${product.price}")
                
                // Usar Cloud Function createProduct ao inv√©s de escrita direta
                val createResult = if (s.id == null) {
                    // Criar novo produto
                    functionsService.createProduct(
                        title = product.title,
                        description = product.description ?: "",
                        category = product.category ?: "Geral",
                        price = product.price,
                        images = product.imageUris,
                        stock = null,
                        active = true
                    )
                } else {
                    // Atualizar produto existente
                    val updates = mapOf(
                        "title" to product.title,
                        "description" to (product.description ?: ""),
                        "category" to (product.category ?: "Geral"),
                        "price" to product.price,
                        "images" to product.imageUris,
                        "active" to (product.active ?: true)
                    )
                    functionsService.updateProduct(productId, updates)
                }
                
                createResult.fold(
                    onSuccess = {
                        Log.d("ProductFormViewModel", "Produto salvo com sucesso via Cloud Function")
                        _uiState.value = _uiState.value.copy(isSaving = false, saved = true)
                    },
                    onFailure = { error ->
                        Log.e("ProductFormViewModel", "Erro ao salvar produto via Cloud Function: ${error.message}", error)
                        _uiState.value = _uiState.value.copy(
                            isSaving = false,
                            error = "Erro ao salvar produto: ${error.message}"
                        )
                    }
                )
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    isSaving = false,
                    error = "Erro ao salvar produto: ${e.message}"
                )
            }
        }
    }
}



```

## [FRONTEND]: feature/products/presentation/ProductsScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.products.presentation

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.lazy.grid.items
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Star
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.collectAsState
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.draw.clip
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.window.Dialog
import coil.request.ImageRequest
import androidx.hilt.navigation.compose.hiltViewModel
import coil.compose.AsyncImage
import com.taskgoapp.taskgo.R
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.design.TGIcons
import com.taskgoapp.taskgo.core.design.TGIcon
import com.taskgoapp.taskgo.core.model.Product
import com.taskgoapp.taskgo.core.theme.*
import com.taskgoapp.taskgo.core.design.FilterBar
import com.taskgoapp.taskgo.core.design.FilterBottomSheet
import com.taskgoapp.taskgo.core.model.AccountType
import com.google.firebase.auth.FirebaseAuth
import java.text.NumberFormat
import java.util.Locale

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ProductsScreen(
    onNavigateToProductDetail: (String) -> Unit,
    onNavigateToCart: () -> Unit,
    onNavigateToAddProduct: () -> Unit = {},
    onNavigateToNotifications: () -> Unit = {},
    onNavigateToMessages: () -> Unit = {},
    onNavigateToSearch: () -> Unit = {},
    onNavigateToSellerProfile: ((String) -> Unit)? = null,
    modifier: Modifier = Modifier
) {
    val viewModel: ProductsViewModel = hiltViewModel()
    val products by viewModel.products.collectAsState()
    val filterState by viewModel.filterState.collectAsState()
    val categories by viewModel.productCategories.collectAsState()
    val accountType by viewModel.accountType.collectAsState()
    val currentUserId = remember { com.google.firebase.auth.FirebaseAuth.getInstance().currentUser?.uid ?: "" }
    
    var showFilterSheet by remember { mutableStateOf(false) }
    var searchQuery by remember { mutableStateOf("") }
    var showImagePreview by remember { mutableStateOf<String?>(null) }
    
    val isPartner = accountType == com.taskgoapp.taskgo.core.model.AccountType.PARCEIRO || 
                    accountType == com.taskgoapp.taskgo.core.model.AccountType.VENDEDOR || 
                    accountType == com.taskgoapp.taskgo.core.model.AccountType.PRESTADOR
    
    // Adicionar "Todos" no in√≠cio das categorias se n√£o estiver presente
    val categoriesWithAll = remember(categories) {
        if (categories.isEmpty() || categories.first() != "Todos") {
            listOf("Todos") + categories.filter { it != "Todos" }
        } else {
            categories
        }
    }
    
    // Atualizar busca quando o usu√°rio digitar
    LaunchedEffect(searchQuery) {
        viewModel.updateSearchQuery(searchQuery)
    }
    
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Loja",
                subtitle = "Encontre produtos para suas necessidades",
                onBackClick = null, // Sem bot√£o de voltar
                backgroundColor = TaskGoGreen,
                titleColor = Color.White,
                subtitleColor = Color.White,
                backIconColor = Color.White,
                actions = {
                    Row(
                        horizontalArrangement = Arrangement.spacedBy(4.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        IconButton(
                            onClick = onNavigateToSearch,
                            modifier = Modifier.size(36.dp)
                        ) {
                            TGIcon(
                                iconRes = TGIcons.Search,
                                contentDescription = "Buscar",
                                size = TGIcons.Sizes.Medium,
                                tint = Color.White
                            )
                        }
                        IconButton(
                            onClick = onNavigateToNotifications,
                            modifier = Modifier.size(36.dp)
                        ) {
                            TGIcon(
                                iconRes = TGIcons.Bell,
                                contentDescription = "Notifica√ß√µes",
                                size = TGIcons.Sizes.Medium,
                                tint = Color.White
                            )
                        }
                        IconButton(
                            onClick = onNavigateToCart,
                            modifier = Modifier.size(36.dp)
                        ) {
                            TGIcon(
                                iconRes = TGIcons.Cart,
                                contentDescription = "Carrinho",
                                size = TGIcons.Sizes.Medium,
                                tint = Color.White
                            )
                        }
                        IconButton(
                            onClick = onNavigateToMessages,
                            modifier = Modifier.size(36.dp)
                        ) {
                            TGIcon(
                                iconRes = TGIcons.Messages,
                                contentDescription = "Mensagens",
                                size = TGIcons.Sizes.Medium,
                                tint = Color.White
                            )
                        }
                    }
                }
            )
        },
        floatingActionButton = {
            // FAB de adicionar produto (apenas para PARCEIRO/VENDEDOR) no canto inferior direito
            if (isPartner) {
                FloatingActionButton(
                    onClick = onNavigateToAddProduct,
                    containerColor = TaskGoGreen
                ) {
                    Icon(
                        imageVector = Icons.Default.Add,
                        contentDescription = "Adicionar Produto",
                        tint = Color.White
                    )
                }
            }
        }
    ) { paddingValues ->
        Box(modifier = Modifier.fillMaxSize()) {
            Column(
                modifier = modifier
                    .fillMaxSize()
                    .padding(paddingValues)
                    .padding(horizontal = 16.dp),
            verticalArrangement = Arrangement.spacedBy(4.dp)
        ) {
            // Barra de Busca
            com.taskgoapp.taskgo.core.design.SearchBar(
                query = searchQuery,
                onQueryChange = { searchQuery = it },
                placeholder = "Buscar produtos...",
                modifier = Modifier.padding(top = 4.dp)
            )
            
                // Barra de Filtros e bot√µes de ordena√ß√£o (tudo no mesmo scroll)
                FilterBar(
                    categories = categoriesWithAll,
                    selectedCategories = filterState.selectedCategories,
                    onCategorySelected = { category ->
                        if (category == "Todos") {
                            viewModel.updateFilterState(filterState.copy(selectedCategories = emptySet()))
                        } else {
                            viewModel.toggleCategory(category)
                        }
                    },
                    onFilterClick = { showFilterSheet = true },
                    showSortButtons = true,
                    sortBy = filterState.sortBy,
                    onSortByRating = { viewModel.updateFilterState(filterState.copy(sortBy = com.taskgoapp.taskgo.core.design.SortOption.RATING)) },
                    onSortByNewest = { viewModel.updateFilterState(filterState.copy(sortBy = com.taskgoapp.taskgo.core.design.SortOption.NEWEST)) },
                    modifier = Modifier.padding(bottom = 2.dp)
                )
            
            // Grid de produtos
            if (products.isEmpty()) {
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    Text(
                        text = "Nenhum produto encontrado",
                        color = TaskGoTextGray
                    )
                }
            } else {
                LazyVerticalGrid(
                    columns = GridCells.Fixed(2),
                    verticalArrangement = Arrangement.spacedBy(12.dp),
                    horizontalArrangement = Arrangement.spacedBy(12.dp),
                    modifier = Modifier.fillMaxSize()
                ) {
                    items(products) { product ->
                        ProductCard(
                            product = product,
                            onProductClick = { onNavigateToProductDetail(product.id) },
                            onImageClick = { imageUrl ->
                                showImagePreview = imageUrl
                            },
                            onSellerClick = onNavigateToSellerProfile
                        )
                    }
                }
            }
        }
        }
        
        // Bottom Sheet de Filtros
        FilterBottomSheet(
            isOpen = showFilterSheet,
            onDismiss = { showFilterSheet = false },
            filterState = filterState,
            onFilterStateChange = { newState ->
                viewModel.updateFilterState(newState)
            }
        )
    }
    
    // Image Preview Modal
    showImagePreview?.let { imageUrl ->
        ImagePreviewModal(
            imageUrl = imageUrl,
            onDismiss = { showImagePreview = null }
        )
    }
}

@Composable
private fun ProductCard(
    product: Product,
    onProductClick: () -> Unit,
    onImageClick: (String) -> Unit,
    onSellerClick: ((String) -> Unit)? = null,
    modifier: Modifier = Modifier
) {
    val currencyFormat = remember {
        NumberFormat.getCurrencyInstance(Locale("pt", "BR"))
    }
    val imageUri = remember(product.imageUris) {
        product.imageUris.firstOrNull { it.isNotBlank() }
    }
    val context = LocalContext.current
    Card(
        modifier = modifier
            .fillMaxWidth()
            .clip(RoundedCornerShape(16.dp)),
        shape = RoundedCornerShape(16.dp),
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
    ) {
        Column {
            Box(
                modifier = Modifier
                    .fillMaxWidth()
                    .height(150.dp)
                    .background(TaskGoSurfaceGray)
                    .clickable { 
                        if (imageUri != null) {
                            onImageClick(imageUri)
                        } else {
                            onProductClick()
                        }
                    },
                contentAlignment = Alignment.Center
            ) {
                if (imageUri != null) {
                    AsyncImage(
                        model = ImageRequest.Builder(context)
                            .data(imageUri)
                            .crossfade(true)
                            .build(),
                        contentDescription = "Imagem do produto ${product.title}",
                        modifier = Modifier.fillMaxSize(),
                        contentScale = ContentScale.Crop
                    )
                } else {
                    TGIcon(
                        iconRes = TGIcons.Products,
                        contentDescription = null,
                        size = TGIcons.Sizes.Large,
                        tint = TaskGoTextGray
                    )
                }

                if (product.featured == true) {
                    Surface(
                        modifier = Modifier
                            .align(Alignment.TopStart)
                            .padding(8.dp),
                        color = TaskGoOrange,
                        shape = RoundedCornerShape(18.dp)
                    ) {
                        Text(
                            text = "Promo√ß√£o",
                            color = Color.White,
                            style = MaterialTheme.typography.labelSmall,
                            modifier = Modifier.padding(horizontal = 8.dp, vertical = 4.dp)
                        )
                    }
                }
            }

            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(12.dp)
                    .clickable { onProductClick() },
                verticalArrangement = Arrangement.spacedBy(6.dp)
            ) {
                Text(
                    text = product.title,
                    style = FigmaProductName,
                    color = TaskGoTextBlack,
                    maxLines = 1,
                    overflow = TextOverflow.Ellipsis
                )

                product.description?.takeIf { it.isNotBlank() }?.let { description ->
                    Text(
                        text = description,
                        style = MaterialTheme.typography.bodyMedium,
                        color = TaskGoTextGray,
                        maxLines = 2,
                        overflow = TextOverflow.Ellipsis
                    )
                }

                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Column {
                        Text(
                            text = "Pre√ßo",
                            style = MaterialTheme.typography.bodySmall,
                            color = TaskGoTextGray
                        )
                        Text(
                            text = currencyFormat.format(product.price),
                            style = FigmaPrice,
                            color = TaskGoPriceGreen,
                            fontWeight = FontWeight.Bold
                        )
                    }
                    Row(
                        verticalAlignment = Alignment.CenterVertically,
                        horizontalArrangement = Arrangement.spacedBy(4.dp)
                    ) {
                        Icon(
                            imageVector = Icons.Default.Star,
                            contentDescription = "Avalia√ß√£o",
                            tint = TaskGoStarYellow,
                            modifier = Modifier.size(16.dp)
                        )
                        Text(
                            text = "%.1f".format(product.rating ?: 0.0),
                            style = FigmaRatingText,
                            color = TaskGoTextDark
                        )
                    }
                }
            }
        }
    }
}

@Composable
private fun ImagePreviewModal(
    imageUrl: String,
    onDismiss: () -> Unit
) {
    val context = LocalContext.current
    
    Dialog(onDismissRequest = onDismiss) {
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            shape = RoundedCornerShape(16.dp)
        ) {
            Column {
                Box(
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(400.dp)
                ) {
                    AsyncImage(
                        model = ImageRequest.Builder(context)
                            .data(imageUrl)
                            .crossfade(true)
                            .build(),
                        contentDescription = "Preview da imagem",
                        modifier = Modifier.fillMaxSize(),
                        contentScale = ContentScale.Fit
                    )
                }
                
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp),
                    horizontalArrangement = Arrangement.End
                ) {
                    TextButton(onClick = onDismiss) {
                        Text("Fechar")
                    }
                }
            }
        }
    }
}
```

## [FRONTEND]: feature/products/presentation/ProductsViewModel.kt

```kotlin
package com.taskgoapp.taskgo.feature.products.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.taskgoapp.taskgo.core.model.Product
import com.taskgoapp.taskgo.core.model.AccountType
import com.taskgoapp.taskgo.core.design.FilterState
import com.taskgoapp.taskgo.domain.repository.ProductsRepository
import com.taskgoapp.taskgo.domain.repository.CategoriesRepository
import com.taskgoapp.taskgo.domain.repository.UserRepository
import com.taskgoapp.taskgo.data.local.datastore.FilterPreferencesManager
import com.taskgoapp.taskgo.core.location.LocationManager
import com.taskgoapp.taskgo.core.location.calculateDistance
import com.google.firebase.auth.FirebaseAuth
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class ProductsViewModel @Inject constructor(
    private val productsRepository: ProductsRepository,
    private val categoriesRepository: CategoriesRepository,
    private val filterPreferencesManager: FilterPreferencesManager,
    private val locationManager: LocationManager,
    private val userRepository: UserRepository,
    private val firebaseAuth: FirebaseAuth
) : ViewModel() {

    private val _filterState = MutableStateFlow(FilterState())
    val filterState: StateFlow<FilterState> = _filterState.asStateFlow()

    private val _accountType = MutableStateFlow(AccountType.CLIENTE)
    val accountType: StateFlow<AccountType> = _accountType.asStateFlow()
    
    private val _userLocation = MutableStateFlow<android.location.Location?>(null)
    val userLocation: StateFlow<android.location.Location?> = _userLocation.asStateFlow()

    val productCategories: StateFlow<List<String>> = categoriesRepository
        .observeProductCategories()
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyList())

    val allProducts: StateFlow<List<Product>> = productsRepository
        .observeProducts()
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyList())

    val products: StateFlow<List<Product>> = combine(
        allProducts,
        filterState,
        _accountType,
        _userLocation
    ) { products, filters, accountType, userLocation ->
        val currentUserId = firebaseAuth.currentUser?.uid ?: ""
        // Filtrar produtos baseado no tipo de conta
        // Na tela principal de produtos (ProductsScreen), todos devem ver produtos de outros (para comprar)
        // Apenas na tela de gerenciamento (ManageProductsScreen) deve mostrar apenas produtos pr√≥prios
        val filteredByAccountType = when (accountType) {
            AccountType.PARCEIRO, AccountType.VENDEDOR, AccountType.PRESTADOR -> {
                // PARCEIRO/VENDEDOR: mostrar produtos de outros (para comprar na loja principal)
                products.filter { it.sellerId != currentUserId && it.sellerId != null && it.sellerId.isNotBlank() }
            }
            AccountType.CLIENTE -> {
                // CLIENTE: mostrar apenas produtos de outros usu√°rios (para comprar)
                products.filter { it.sellerId != currentUserId && it.sellerId != null && it.sellerId.isNotBlank() }
            }
        }
        applyFiltersSync(filteredByAccountType, filters, userLocation)
    }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyList())

    init {
        loadSavedFilters()
        loadAccountType()
        loadUserLocation()
    }
    
    private fun loadUserLocation() {
        viewModelScope.launch {
            try {
                val location = locationManager.getCurrentLocation()
                _userLocation.value = location
            } catch (e: Exception) {
                android.util.Log.e("ProductsViewModel", "Erro ao obter localiza√ß√£o: ${e.message}", e)
            }
        }
    }

    private fun loadAccountType() {
        viewModelScope.launch {
            userRepository.observeCurrentUser().collect { user ->
                _accountType.value = user?.accountType ?: AccountType.CLIENTE
            }
        }
    }

    private fun loadSavedFilters() {
        viewModelScope.launch {
            filterPreferencesManager.getProductFilters().collect { savedFilters ->
                savedFilters?.let {
                    _filterState.value = it
                }
            }
        }
    }

    fun updateFilterState(newState: FilterState) {
        _filterState.value = newState
        viewModelScope.launch {
            filterPreferencesManager.saveProductFilters(newState)
        }
    }

    fun toggleCategory(category: String) {
        val currentCategories = _filterState.value.selectedCategories
        val newCategories = if (currentCategories.contains(category)) {
            currentCategories - category
        } else {
            currentCategories + category
        }
        updateFilterState(_filterState.value.copy(selectedCategories = newCategories))
    }

    fun updateSearchQuery(query: String) {
        updateFilterState(_filterState.value.copy(searchQuery = query))
    }

    private fun applyFiltersSync(
        products: List<Product>, 
        filters: FilterState,
        userLocation: android.location.Location?
    ): List<Product> {
        var filtered = products.filter { it.active }

        // Busca por texto
        if (filters.searchQuery.isNotBlank()) {
            val query = filters.searchQuery.lowercase()
            filtered = filtered.filter { product ->
                product.title.lowercase().contains(query) ||
                product.description?.lowercase()?.contains(query) == true
            }
        }

        // Filtrar por categorias (quando Product tiver campo de categoria)
        // TODO: Implementar quando Product tiver campo de categoria

        // Filtrar por pre√ßo
        filters.priceRange?.let { range ->
            filtered = filtered.filter { product ->
                val price = product.price
                (range.min == null || price >= range.min) &&
                (range.max == null || price <= range.max)
            }
        }

        // Filtrar por avalia√ß√£o
        filters.minRating?.let { minRating ->
            filtered = filtered.filter { product ->
                product.rating != null && product.rating >= minRating
            }
        }

        // Filtrar por localiza√ß√£o quando houver localiza√ß√£o do usu√°rio.
        // Sem localiza√ß√£o, mantemos a lista filtrada (n√£o esvaziamos a vitrine).
        if (userLocation != null) {
            filtered = filtered.filter { product ->
                val prodLat = product.latitude
                val prodLng = product.longitude
                if (prodLat != null && prodLng != null) {
                    val distance = calculateDistance(
                        userLocation.latitude,
                        userLocation.longitude,
                        prodLat,
                        prodLng
                    )
                    distance <= 100.0 // Raio de 100km
                } else {
                    // Produto sem localiza√ß√£o n√£o √© exibido quando o usu√°rio compartilha localiza√ß√£o
                    false
                }
            }
        }

        // Ordenar
        filtered = when (filters.sortBy) {
            com.taskgoapp.taskgo.core.design.SortOption.PRICE_LOW_TO_HIGH -> 
                filtered.sortedBy { it.price }
            com.taskgoapp.taskgo.core.design.SortOption.PRICE_HIGH_TO_LOW -> 
                filtered.sortedByDescending { it.price }
            com.taskgoapp.taskgo.core.design.SortOption.RATING -> 
                filtered.sortedByDescending { it.rating ?: 0.0 }
            com.taskgoapp.taskgo.core.design.SortOption.NEWEST -> 
                filtered // TODO: Ordenar por data quando dispon√≠vel
            else -> filtered
        }

        return filtered
    }

    fun deleteProduct(productId: String) {
        viewModelScope.launch {
            // Cache local desativado: remover diretamente no backend
            productsRepository.deleteProduct(productId)
        }
    }
}



```

# Features - profile


## [FRONTEND]: feature/profile/presentation/AboutMeScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.profile.presentation

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Star
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.collectAsState
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import coil.compose.AsyncImage
import coil.request.ImageRequest
import androidx.compose.ui.platform.LocalContext
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.theme.*
import com.taskgoapp.taskgo.core.model.AccountType
import com.taskgoapp.taskgo.feature.feed.presentation.FeedScreen
import com.taskgoapp.taskgo.feature.feed.presentation.FeedViewModel
import com.taskgoapp.taskgo.feature.feed.presentation.StoriesViewModel
import com.taskgoapp.taskgo.feature.feed.presentation.components.PostCard
import com.taskgoapp.taskgo.feature.feed.presentation.components.StoriesSectionNew
import com.taskgoapp.taskgo.feature.feed.presentation.components.InlinePostCreator
import com.taskgoapp.taskgo.feature.feed.presentation.components.CreateStoryScreen
import com.google.firebase.auth.FirebaseAuth
import javax.inject.Inject
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.layout.size
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.geometry.Size
import java.util.*
import java.text.NumberFormat
import java.util.Locale

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AboutMeScreen(
    onBackClick: () -> Unit,
    onNavigateToReviews: (String, String) -> Unit = { _, _ -> },
    viewModel: ProfileViewModel = hiltViewModel(),
    dashboardViewModel: DashboardViewModel = hiltViewModel(),
) {
    val uiState by viewModel.uiState.collectAsState()
    val dashboardMetrics by dashboardViewModel.metrics.collectAsState()
    val context = LocalContext.current
    val currentUserId = remember { FirebaseAuth.getInstance().currentUser?.uid ?: "" }
    
    var selectedTabIndex by remember { mutableStateOf(0) }
    // Abas: Cliente apenas Dashboard; Parceiro tem Dashboard e Feed (com Stories e postagens)
    val tabs = remember(uiState.accountType) {
        when (uiState.accountType) {
            AccountType.CLIENTE -> listOf("Dashboard")
            AccountType.PARCEIRO, AccountType.PRESTADOR, AccountType.VENDEDOR -> 
                listOf("Dashboard", "Feed") // Parceiro tem Dashboard e Feed (com Stories e postagens)
            else -> listOf("Dashboard", "Feed") // Fallback para legacy
        }
    }
    
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Meus Dados",
                onBackClick = onBackClick
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            // TabRow - apenas mostrar se houver mais de uma aba
            if (tabs.size > 1) {
                TabRow(
                    selectedTabIndex = selectedTabIndex,
                    modifier = Modifier.fillMaxWidth()
                ) {
                    tabs.forEachIndexed { index, title ->
                        Tab(
                            selected = selectedTabIndex == index,
                            onClick = { selectedTabIndex = index },
                            text = { Text(title) }
                        )
                    }
                }
            }
            
            // Content baseado na aba selecionada
            // Para clientes, sempre mostrar Dashboard (√≠ndice 0)
            when (if (uiState.accountType == AccountType.CLIENTE) 0 else selectedTabIndex) {
                0 -> {
                    // Dashboard - conte√∫do original
                    LazyColumn(
                        modifier = Modifier.fillMaxSize(),
                        contentPadding = PaddingValues(16.dp),
                        verticalArrangement = Arrangement.spacedBy(16.dp)
                    ) {
            // Header com foto e nome
            item {
                Column(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    // Foto do perfil
                    if (!uiState.avatarUri.isNullOrBlank()) {
                        AsyncImage(
                            model = ImageRequest.Builder(LocalContext.current)
                                .data(uiState.avatarUri)
                                .crossfade(true)
                                .build(),
                            contentDescription = "Foto do perfil",
                            modifier = Modifier
                                .size(120.dp)
                                .clip(CircleShape),
                            contentScale = ContentScale.Crop
                        )
                    } else {
                        // Placeholder quando n√£o h√° foto
                        Box(
                            modifier = Modifier
                                .size(120.dp)
                                .clip(CircleShape)
                                .background(TaskGoTextGray.copy(alpha = 0.2f)),
                            contentAlignment = Alignment.Center
                        ) {
                            Text(
                                text = uiState.name.takeIf { it.isNotBlank() }?.take(1)?.uppercase() ?: "U",
                                style = MaterialTheme.typography.headlineMedium,
                                fontWeight = FontWeight.Bold,
                                color = TaskGoTextGray
                            )
                        }
                    }
                    
                    // Nome
                    Text(
                        text = uiState.name.ifBlank { "Usu√°rio" },
                        style = MaterialTheme.typography.headlineSmall,
                        fontWeight = FontWeight.Bold,
                        color = TaskGoTextDark
                    )
                }
            }
            
            // Card com informa√ß√µes
            item {
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    shape = RoundedCornerShape(12.dp),
                    elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
                ) {
                    Column(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(16.dp),
                        verticalArrangement = Arrangement.spacedBy(16.dp)
                    ) {
                        // Nome completo
                        InfoRow(
                            label = "Nome completo",
                            value = uiState.name.ifBlank { "N√£o informado" }
                        )
                        
                        HorizontalDivider()
                        
                        // Tipo da conta
                        InfoRow(
                            label = "Tipo da conta",
                            value = when (uiState.accountType) {
                                com.taskgoapp.taskgo.core.model.AccountType.PARCEIRO -> "Parceiro"
                                com.taskgoapp.taskgo.core.model.AccountType.PRESTADOR -> "Parceiro" // Legacy
                                com.taskgoapp.taskgo.core.model.AccountType.VENDEDOR -> "Parceiro" // Legacy
                                else -> "Cliente"
                            }
                        )
                        
                        HorizontalDivider()
                        
                        // Tempo no TaskGo
                        val timeOnTaskGo = uiState.createdAt?.let { date ->
                            val days = ((System.currentTimeMillis() - date.time) / (1000 * 60 * 60 * 24)).toInt()
                            when {
                                days < 30 -> "$days dias"
                                days < 365 -> "${days / 30} meses"
                                else -> "${days / 365} anos"
                            }
                        } ?: "Rec√©m cadastrado"
                        
                        InfoRow(
                            label = "Tempo no TaskGo",
                            value = timeOnTaskGo
                        )
                        
                        HorizontalDivider()
                        
                        // Avalia√ß√£o
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Text(
                                text = "Avalia√ß√£o",
                                style = MaterialTheme.typography.bodyMedium,
                                fontWeight = FontWeight.Medium,
                                color = TaskGoTextDark,
                                modifier = Modifier.weight(1f)
                            )
                            Row(
                                verticalAlignment = Alignment.CenterVertically,
                                horizontalArrangement = Arrangement.spacedBy(4.dp)
                            ) {
                                repeat(5) { index ->
                                    Icon(
                                        imageVector = Icons.Default.Star,
                                        contentDescription = null,
                                        tint = if (index < (uiState.rating?.toInt() ?: 0)) {
                                            MaterialTheme.colorScheme.primary
                                        } else {
                                            TaskGoTextGray.copy(alpha = 0.3f)
                                        },
                                        modifier = Modifier.size(20.dp)
                                    )
                                }
                            }
                        }
                    }
                }
            }
            
            // Dashboard de M√©tricas
            item {
                DashboardSection(
                    accountType = uiState.accountType,
                    metrics = dashboardMetrics
                )
            }
            
            // Bot√£o Ver Avalia√ß√µes
            item {
                Button(
                    onClick = {
                        onNavigateToReviews(uiState.id, uiState.name.ifBlank { "Usu√°rio" })
                    },
                    modifier = Modifier.fillMaxWidth(),
                    colors = ButtonDefaults.buttonColors(
                        containerColor = TaskGoGreen
                    ),
                    shape = RoundedCornerShape(12.dp)
                ) {
                    Text(
                        text = "Ver Avalia√ß√µes",
                        fontWeight = FontWeight.Bold,
                        modifier = Modifier.padding(vertical = 8.dp)
                    )
                }
            }
                    }
                }
                1 -> {
                    // Feed - mesclar design do dashboard com feed
                    val feedViewModel: FeedViewModel = hiltViewModel()
                    val storiesViewModel: StoriesViewModel = hiltViewModel()
                    val feedUiState by feedViewModel.uiState.collectAsState()
                    val storiesUiState by storiesViewModel.uiState.collectAsState()
                    
                    // Carregar stories e feed quando a aba Feed for selecionada
                    LaunchedEffect(Unit) {
                        storiesViewModel.loadStories()
                        feedViewModel.loadFeed()
                    }
                    
                    LazyColumn(
                        modifier = Modifier.fillMaxSize(),
                        contentPadding = PaddingValues(16.dp),
                        verticalArrangement = Arrangement.spacedBy(16.dp)
                    ) {
                        // Header do Dashboard (mesmo do tab Dashboard)
                        item {
                            Column(
                                modifier = Modifier.fillMaxWidth(),
                                horizontalAlignment = Alignment.CenterHorizontally,
                                verticalArrangement = Arrangement.spacedBy(12.dp)
                            ) {
                                // Foto do perfil
                                if (!uiState.avatarUri.isNullOrBlank()) {
                                    AsyncImage(
                                        model = ImageRequest.Builder(LocalContext.current)
                                            .data(uiState.avatarUri)
                                            .crossfade(true)
                                            .build(),
                                        contentDescription = "Foto do perfil",
                                        modifier = Modifier
                                            .size(120.dp)
                                            .clip(CircleShape),
                                        contentScale = ContentScale.Crop
                                    )
                                } else {
                                    Box(
                                        modifier = Modifier
                                            .size(120.dp)
                                            .clip(CircleShape)
                                            .background(TaskGoTextGray.copy(alpha = 0.2f)),
                                        contentAlignment = Alignment.Center
                                    ) {
                                        Text(
                                            text = uiState.name.takeIf { it.isNotBlank() }?.take(1)?.uppercase() ?: "U",
                                            style = MaterialTheme.typography.headlineMedium,
                                            fontWeight = FontWeight.Bold,
                                            color = TaskGoTextGray
                                        )
                                    }
                                }
                                
                                // Nome
                                Text(
                                    text = uiState.name.ifBlank { "Usu√°rio" },
                                    style = MaterialTheme.typography.headlineSmall,
                                    fontWeight = FontWeight.Bold,
                                    color = TaskGoTextDark
                                )
                            }
                        }
                        
                        // Card com informa√ß√µes resumidas
                        item {
                            Card(
                                modifier = Modifier.fillMaxWidth(),
                                shape = RoundedCornerShape(12.dp),
                                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
                            ) {
                                Column(
                                    modifier = Modifier
                                        .fillMaxWidth()
                                        .padding(16.dp),
                                    verticalArrangement = Arrangement.spacedBy(12.dp)
                                ) {
                                    InfoRow(
                                        label = "Tipo da conta",
                                        value = when (uiState.accountType) {
                                            AccountType.PARCEIRO -> "Parceiro"
                                            AccountType.PRESTADOR -> "Parceiro" // Legacy
                                            AccountType.VENDEDOR -> "Parceiro" // Legacy
                                            else -> "Cliente"
                                        }
                                    )
                                    
                                    HorizontalDivider()
                                    
                                    // Avalia√ß√£o resumida
                                    Row(
                                        modifier = Modifier.fillMaxWidth(),
                                        verticalAlignment = Alignment.CenterVertically
                                    ) {
                                        Text(
                                            text = "Avalia√ß√£o",
                                            style = MaterialTheme.typography.bodyMedium,
                                            fontWeight = FontWeight.Medium,
                                            color = TaskGoTextDark,
                                            modifier = Modifier.weight(1f)
                                        )
                                        Row(
                                            verticalAlignment = Alignment.CenterVertically,
                                            horizontalArrangement = Arrangement.spacedBy(4.dp)
                                        ) {
                                            repeat(5) { index ->
                                                Icon(
                                                    imageVector = Icons.Default.Star,
                                                    contentDescription = null,
                                                    tint = if (index < (uiState.rating?.toInt() ?: 0)) {
                                                        TaskGoGreen
                                                    } else {
                                                        TaskGoTextGray.copy(alpha = 0.3f)
                                                    },
                                                    modifier = Modifier.size(16.dp)
                                                )
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        
                        // Conte√∫do do Feed (sem topbar)
                        item {
                            com.taskgoapp.taskgo.feature.feed.presentation.components.InlinePostCreator(
                                userAvatarUrl = feedUiState.currentUserAvatarUrl,
                                userName = feedUiState.currentUserName,
                                isLoading = feedUiState.isLoading,
                                onPostCreated = { text, mediaUris ->
                                    feedViewModel.createPost(text, mediaUris)
                                },
                                modifier = Modifier.fillMaxWidth()
                            )
                        }
                        
                        // Stories
                        item {
                            var showCreateStory by remember { mutableStateOf(false) }
                            
                            com.taskgoapp.taskgo.feature.feed.presentation.components.StoriesSectionNew(
                                currentUserAvatarUrl = feedUiState.currentUserAvatarUrl,
                                currentUserName = feedUiState.currentUserName,
                                currentUserId = feedViewModel.currentUserId,
                                stories = storiesUiState.stories,
                                onCreateStoryClick = {
                                    showCreateStory = true
                                },
                                onStoryClick = { userId ->
                                    // Ver story se necess√°rio
                                }
                            )
                            
                            if (showCreateStory) {
                                com.taskgoapp.taskgo.feature.feed.presentation.components.CreateStoryScreen(
                                    onDismiss = { showCreateStory = false },
                                    onStoryCreated = {
                                        showCreateStory = false
                                        // Stories ser√£o recarregados automaticamente pelo observeStories
                                    }
                                )
                            }
                        }
                        
                        // Divisor
                        item {
                            HorizontalDivider(
                                modifier = Modifier.fillMaxWidth(),
                                color = TaskGoBackgroundGray
                            )
                        }
                        
                        // Posts
                        if (feedUiState.posts.isEmpty()) {
                            item {
                                Column(
                                    modifier = Modifier
                                        .fillMaxWidth()
                                        .padding(32.dp),
                                    horizontalAlignment = Alignment.CenterHorizontally,
                                    verticalArrangement = Arrangement.spacedBy(8.dp)
                                ) {
                                    Text(
                                        text = "Nenhum post encontrado",
                                        style = MaterialTheme.typography.bodyLarge,
                                        color = TaskGoTextGray
                                    )
                                    Text(
                                        text = "Seja o primeiro a postar na sua regi√£o!",
                                        style = MaterialTheme.typography.bodyMedium,
                                        color = TaskGoTextGray
                                    )
                                }
                            }
                        } else {
                            items(
                                items = feedUiState.posts,
                                key = { it.id }
                            ) { post ->
                                PostCard(
                                    post = post,
                                    onUserClick = { userId ->
                                        // Navegar para perfil se necess√°rio
                                    },
                                    onLikeClick = {
                                        feedViewModel.likePost(post.id)
                                    },
                                    onUnlikeClick = {
                                        feedViewModel.unlikePost(post.id)
                                    },
                                    onDeleteClick = if (post.userId == feedViewModel.currentUserId) {
                                        {
                                            feedViewModel.deletePost(post.id)
                                        }
                                    } else null,
                                    modifier = Modifier.fillMaxWidth()
                                )
                            }
                        }
                    }
                }
            }
        }
    }
}

@Composable
private fun InfoRow(
    label: String,
    value: String,
    modifier: Modifier = Modifier
) {
    Column(modifier = modifier) {
        Text(
            text = label,
            style = MaterialTheme.typography.bodyMedium,
            fontWeight = FontWeight.Medium,
            color = TaskGoTextDark
        )
        Spacer(modifier = Modifier.height(4.dp))
        Text(
            text = value,
            style = MaterialTheme.typography.bodyLarge,
            color = TaskGoTextGray
        )
    }
}

@Composable
private fun DashboardSection(
    accountType: AccountType,
    metrics: DashboardMetrics
) {
    if (metrics.isLoading) {
        Card(
            modifier = Modifier.fillMaxWidth(),
            shape = RoundedCornerShape(12.dp)
        ) {
            Box(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(32.dp),
                contentAlignment = Alignment.Center
            ) {
                CircularProgressIndicator(color = TaskGoGreen)
            }
        }
        return
    }
    
    Card(
        modifier = Modifier.fillMaxWidth(),
        shape = RoundedCornerShape(12.dp),
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(20.dp),
            verticalArrangement = Arrangement.spacedBy(20.dp)
        ) {
            Text(
                text = "Dashboard",
                style = MaterialTheme.typography.titleLarge,
                fontWeight = FontWeight.Bold,
                color = TaskGoTextDark
            )
            
            when (accountType) {
                AccountType.PARCEIRO, AccountType.PRESTADOR, AccountType.VENDEDOR -> {
                    // Unificar dashboards: Parceiro v√™ dashboard combinado de servi√ßos + produtos
                    PartnerDashboard(metrics) // Dashboard unificado para Parceiro
                }
                else -> ClientDashboard(metrics)
            }
        }
    }
}

@Composable
private fun ProviderDashboard(metrics: DashboardMetrics) {
    val currencyFormat = NumberFormat.getCurrencyInstance(Locale("pt", "BR"))
    
    Column(verticalArrangement = Arrangement.spacedBy(16.dp)) {
        // M√©tricas principais em grid
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            MetricCard(
                title = "Servi√ßos",
                value = metrics.servicesCount.toString(),
                icon = "üîß",
                modifier = Modifier.weight(1f)
            )
            MetricCard(
                title = "Ordens",
                value = metrics.ordersReceived.toString(),
                icon = "üìã",
                modifier = Modifier.weight(1f)
            )
        }
        
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            MetricCard(
                title = "Conclu√≠das",
                value = metrics.completedOrders.toString(),
                icon = "‚úÖ",
                modifier = Modifier.weight(1f)
            )
            MetricCard(
                title = "Propostas",
                value = metrics.proposalsSent.toString(),
                icon = "üíº",
                modifier = Modifier.weight(1f)
            )
        }
        
        HorizontalDivider()
        
        // Receita
        Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
            Text(
                text = "Receita",
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.Bold,
                color = TaskGoTextDark
            )
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Column {
                    Text(
                        text = "Total",
                        style = MaterialTheme.typography.bodySmall,
                        color = TaskGoTextGray
                    )
                    Text(
                        text = currencyFormat.format(metrics.totalRevenue),
                        style = MaterialTheme.typography.titleLarge,
                        fontWeight = FontWeight.Bold,
                        color = TaskGoGreen
                    )
                }
                Column(horizontalAlignment = Alignment.End) {
                    Text(
                        text = "Este m√™s",
                        style = MaterialTheme.typography.bodySmall,
                        color = TaskGoTextGray
                    )
                    Text(
                        text = currencyFormat.format(metrics.monthlyRevenue),
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold,
                        color = TaskGoTextDark
                    )
                }
            }
            
            // Gr√°fico simples de receita
            RevenueChart(
                totalRevenue = metrics.totalRevenue,
                monthlyRevenue = metrics.monthlyRevenue,
                modifier = Modifier
                    .fillMaxWidth()
                    .height(100.dp)
            )
        }
    }
}

@Composable
private fun SellerDashboard(metrics: DashboardMetrics) {
    val currencyFormat = NumberFormat.getCurrencyInstance(Locale("pt", "BR"))
    
    Column(verticalArrangement = Arrangement.spacedBy(16.dp)) {
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            MetricCard(
                title = "Produtos",
                value = metrics.productsCount.toString(),
                icon = "üì¶",
                modifier = Modifier.weight(1f)
            )
            MetricCard(
                title = "Vendidos",
                value = metrics.productsSold.toString(),
                icon = "üí∞",
                modifier = Modifier.weight(1f)
            )
        }
        
        HorizontalDivider()
        
        // Vendas
        Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
            Text(
                text = "Vendas",
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.Bold,
                color = TaskGoTextDark
            )
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Column {
                    Text(
                        text = "Total",
                        style = MaterialTheme.typography.bodySmall,
                        color = TaskGoTextGray
                    )
                    Text(
                        text = currencyFormat.format(metrics.totalSales),
                        style = MaterialTheme.typography.titleLarge,
                        fontWeight = FontWeight.Bold,
                        color = TaskGoGreen
                    )
                }
                Column(horizontalAlignment = Alignment.End) {
                    Text(
                        text = "Este m√™s",
                        style = MaterialTheme.typography.bodySmall,
                        color = TaskGoTextGray
                    )
                    Text(
                        text = currencyFormat.format(metrics.monthlySales),
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold,
                        color = TaskGoTextDark
                    )
                }
            }
            
            // Gr√°fico simples de vendas
            RevenueChart(
                totalRevenue = metrics.totalSales,
                monthlyRevenue = metrics.monthlySales,
                modifier = Modifier
                    .fillMaxWidth()
                    .height(100.dp)
            )
        }
    }
}

@Composable
private fun PartnerDashboard(metrics: DashboardMetrics) {
    val currencyFormat = NumberFormat.getCurrencyInstance(Locale("pt", "BR"))
    
    Column(verticalArrangement = Arrangement.spacedBy(16.dp)) {
        // M√©tricas principais em grid - Servi√ßos e Produtos
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            MetricCard(
                title = "Servi√ßos",
                value = metrics.servicesCount.toString(),
                icon = "üîß",
                modifier = Modifier.weight(1f)
            )
            MetricCard(
                title = "Produtos",
                value = metrics.productsCount.toString(),
                icon = "üì¶",
                modifier = Modifier.weight(1f)
            )
        }
        
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            MetricCard(
                title = "Ordens",
                value = metrics.ordersReceived.toString(),
                icon = "üìã",
                modifier = Modifier.weight(1f)
            )
            MetricCard(
                title = "Vendidos",
                value = metrics.productsSold.toString(),
                icon = "üí∞",
                modifier = Modifier.weight(1f)
            )
        }
        
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            MetricCard(
                title = "Conclu√≠das",
                value = metrics.completedOrders.toString(),
                icon = "‚úÖ",
                modifier = Modifier.weight(1f)
            )
            MetricCard(
                title = "Propostas",
                value = metrics.proposalsSent.toString(),
                icon = "üíº",
                modifier = Modifier.weight(1f)
            )
        }
        
        HorizontalDivider()
        
        // Receita Total (Servi√ßos + Vendas)
        Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
            Text(
                text = "Receita Total",
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.Bold,
                color = TaskGoTextDark
            )
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Column {
                    Text(
                        text = "Total (Servi√ßos + Vendas)",
                        style = MaterialTheme.typography.bodySmall,
                        color = TaskGoTextGray
                    )
                    Text(
                        text = currencyFormat.format(metrics.totalRevenue + metrics.totalSales),
                        style = MaterialTheme.typography.titleLarge,
                        fontWeight = FontWeight.Bold,
                        color = TaskGoGreen
                    )
                }
                Column(horizontalAlignment = Alignment.End) {
                    Text(
                        text = "Este m√™s",
                        style = MaterialTheme.typography.bodySmall,
                        color = TaskGoTextGray
                    )
                    Text(
                        text = currencyFormat.format(metrics.monthlyRevenue + metrics.monthlySales),
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold,
                        color = TaskGoTextDark
                    )
                }
            }
            
            // Gr√°fico simples de receita total
            RevenueChart(
                totalRevenue = metrics.totalRevenue + metrics.totalSales,
                monthlyRevenue = metrics.monthlyRevenue + metrics.monthlySales,
                modifier = Modifier
                    .fillMaxWidth()
                    .height(100.dp)
            )
        }
    }
}

@Composable
private fun ClientDashboard(metrics: DashboardMetrics) {
    val currencyFormat = NumberFormat.getCurrencyInstance(Locale("pt", "BR"))
    
    Column(verticalArrangement = Arrangement.spacedBy(16.dp)) {
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            MetricCard(
                title = "Ordens",
                value = metrics.serviceOrdersCreated.toString(),
                icon = "üìã",
                modifier = Modifier.weight(1f)
            )
            MetricCard(
                title = "Compras",
                value = metrics.productsPurchased.toString(),
                icon = "üõí",
                modifier = Modifier.weight(1f)
            )
        }
        
        HorizontalDivider()
        
        // Gastos
        Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
            Text(
                text = "Gastos",
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.Bold,
                color = TaskGoTextDark
            )
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Column {
                    Text(
                        text = "Total",
                        style = MaterialTheme.typography.bodySmall,
                        color = TaskGoTextGray
                    )
                    Text(
                        text = currencyFormat.format(metrics.totalSpent),
                        style = MaterialTheme.typography.titleLarge,
                        fontWeight = FontWeight.Bold,
                        color = TaskGoTextDark
                    )
                }
                Column(horizontalAlignment = Alignment.End) {
                    Text(
                        text = "Este m√™s",
                        style = MaterialTheme.typography.bodySmall,
                        color = TaskGoTextGray
                    )
                    Text(
                        text = currencyFormat.format(metrics.monthlySpent),
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold,
                        color = TaskGoTextDark
                    )
                }
            }
            
            // Gr√°fico simples de gastos
            RevenueChart(
                totalRevenue = metrics.totalSpent,
                monthlyRevenue = metrics.monthlySpent,
                modifier = Modifier
                    .fillMaxWidth()
                    .height(100.dp)
            )
        }
    }
}

@Composable
private fun MetricCard(
    title: String,
    value: String,
    icon: String,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier,
        shape = RoundedCornerShape(12.dp),
        colors = CardDefaults.cardColors(
            containerColor = TaskGoGreen.copy(alpha = 0.1f)
        )
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            Text(
                text = icon,
                style = MaterialTheme.typography.headlineMedium
            )
            Text(
                text = value,
                style = MaterialTheme.typography.headlineMedium,
                fontWeight = FontWeight.Bold,
                color = TaskGoTextDark
            )
            Text(
                text = title,
                style = MaterialTheme.typography.bodySmall,
                color = TaskGoTextGray
            )
        }
    }
}

@Composable
private fun RevenueChart(
    totalRevenue: Double,
    monthlyRevenue: Double,
    modifier: Modifier = Modifier
) {
    Box(
        modifier = modifier
            .fillMaxWidth()
            .background(TaskGoSurfaceGray, RoundedCornerShape(8.dp))
            .padding(12.dp),
        contentAlignment = Alignment.Center
    ) {
        Canvas(modifier = Modifier.fillMaxSize()) {
            val width = size.width
            val height = size.height
            val padding = 8.dp.toPx()
            
            // Gr√°fico de barras simples
            val maxValue = maxOf(totalRevenue, monthlyRevenue).coerceAtLeast(1.0)
            val totalHeight = ((totalRevenue / maxValue) * (height - padding * 2)).toFloat()
            val monthlyHeight = ((monthlyRevenue / maxValue) * (height - padding * 2)).toFloat()
            
            // Barra total
            drawRect(
                color = TaskGoGreen.copy(alpha = 0.6f),
                topLeft = Offset(padding, height - padding - totalHeight),
                size = Size((width - padding * 3) / 2, totalHeight)
            )
            
            // Barra mensal
            drawRect(
                color = TaskGoGreen,
                topLeft = Offset(padding * 2 + (width - padding * 3) / 2, height - padding - monthlyHeight),
                size = Size((width - padding * 3) / 2, monthlyHeight)
            )
        }
        
        // Labels
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceEvenly
        ) {
            Text(
                text = "Total",
                style = MaterialTheme.typography.bodySmall,
                color = TaskGoTextGray
            )
            Text(
                text = "Mensal",
                style = MaterialTheme.typography.bodySmall,
                color = TaskGoTextGray
            )
        }
    }
}



```

## [FRONTEND]: feature/profile/presentation/ContaScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.profile.presentation

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowForward
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.core.design.AppTopBar

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ContaScreen(
    onBackClick: () -> Unit,
    onMeusDados: () -> Unit,
    onMeusServicos: () -> Unit,
    onMeusProdutos: () -> Unit,
    onMeusPedidos: () -> Unit,
    onMinhasAvaliacoes: () -> Unit,
    onGerenciarPropostas: () -> Unit
) {
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Conta",
                onBackClick = onBackClick
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            // Menu items
            Card(
                modifier = Modifier.fillMaxWidth(),
                colors = CardDefaults.cardColors(
                    containerColor = MaterialTheme.colorScheme.surface
                )
            ) {
                Column {
                    // Meus Dados
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(16.dp)
                            .clickable { onMeusDados() },
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(
                            text = "Meus Dados",
                            style = MaterialTheme.typography.bodyLarge,
                            modifier = Modifier.weight(1f)
                        )
                        Icon(
                            imageVector = Icons.AutoMirrored.Filled.ArrowForward,
                            contentDescription = null,
                            tint = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                    
                    HorizontalDivider()
                    
                    // Meus Servi√ßos
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(16.dp)
                            .clickable { onMeusServicos() },
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(
                            text = "Meus Servi√ßos",
                            style = MaterialTheme.typography.bodyLarge,
                            modifier = Modifier.weight(1f)
                        )
                        Icon(
                            imageVector = Icons.AutoMirrored.Filled.ArrowForward,
                            contentDescription = null,
                            tint = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                    
                    HorizontalDivider()
                    
                    // Meus Produtos
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(16.dp)
                            .clickable { onMeusProdutos() },
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(
                            text = "Meus Produtos",
                            style = MaterialTheme.typography.bodyLarge,
                            modifier = Modifier.weight(1f)
                        )
                        Icon(
                            imageVector = Icons.AutoMirrored.Filled.ArrowForward,
                            contentDescription = null,
                            tint = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                    
                    HorizontalDivider()
                    
                    // Meus Pedidos
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(16.dp)
                            .clickable { onMeusPedidos() },
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(
                            text = "Meus Pedidos",
                            style = MaterialTheme.typography.bodyLarge,
                            modifier = Modifier.weight(1f)
                        )
                        Icon(
                            imageVector = Icons.AutoMirrored.Filled.ArrowForward,
                            contentDescription = null,
                            tint = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                    
                    HorizontalDivider()
                    
                    // Minhas Avalia√ß√µes
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(16.dp)
                            .clickable { onMinhasAvaliacoes() },
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(
                            text = "Minhas Avalia√ß√µes",
                            style = MaterialTheme.typography.bodyLarge,
                            modifier = Modifier.weight(1f)
                        )
                        Icon(
                            imageVector = Icons.AutoMirrored.Filled.ArrowForward,
                            contentDescription = null,
                            tint = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                    
                    HorizontalDivider()
                    
                    // Gerenciar Propostas
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(16.dp)
                            .clickable { onGerenciarPropostas() },
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(
                            text = "Gerenciar Propostas",
                            style = MaterialTheme.typography.bodyLarge,
                            modifier = Modifier.weight(1f)
                        )
                        Icon(
                            imageVector = Icons.AutoMirrored.Filled.ArrowForward,
                            contentDescription = null,
                            tint = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                }
            }
        }
    }
}

```

## [FRONTEND]: feature/profile/presentation/DashboardViewModel.kt

```kotlin
package com.taskgoapp.taskgo.feature.profile.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.google.firebase.auth.FirebaseAuth
import com.taskgoapp.taskgo.core.model.AccountType
import com.taskgoapp.taskgo.data.repository.FirestoreOrderRepository
import com.taskgoapp.taskgo.data.repository.FirestoreServicesRepository
import com.taskgoapp.taskgo.data.repository.FirestoreProductsRepository
import com.taskgoapp.taskgo.domain.repository.ProductsRepository
import com.taskgoapp.taskgo.domain.repository.UserRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.launch
import javax.inject.Inject

data class DashboardMetrics(
    // Prestador
    val servicesCount: Int = 0,
    val ordersReceived: Int = 0,
    val proposalsSent: Int = 0,
    val completedOrders: Int = 0,
    val totalRevenue: Double = 0.0,
    val monthlyRevenue: Double = 0.0,
    
    // Vendedor
    val productsCount: Int = 0,
    val productsSold: Int = 0,
    val totalSales: Double = 0.0,
    val monthlySales: Double = 0.0,
    
    // Cliente
    val serviceOrdersCreated: Int = 0,
    val productsPurchased: Int = 0,
    val totalSpent: Double = 0.0,
    val monthlySpent: Double = 0.0,
    
    val isLoading: Boolean = true,
    val error: String? = null
)

@HiltViewModel
class DashboardViewModel @Inject constructor(
    private val firebaseAuth: FirebaseAuth,
    private val userRepository: UserRepository,
    private val servicesRepository: FirestoreServicesRepository,
    private val orderRepository: FirestoreOrderRepository,
    private val productsRepository: ProductsRepository,
    private val firestoreProductsRepository: FirestoreProductsRepository
) : ViewModel() {
    
    private val _metrics = MutableStateFlow(DashboardMetrics())
    val metrics: StateFlow<DashboardMetrics> = _metrics.asStateFlow()
    
    private val _accountType = MutableStateFlow<AccountType?>(null)
    
    init {
        loadAccountType()
    }
    
    private fun loadAccountType() {
        viewModelScope.launch {
            userRepository.observeCurrentUser().collect { user ->
                _accountType.value = user?.accountType
                loadMetrics(user?.accountType ?: AccountType.CLIENTE)
            }
        }
    }
    
    private fun loadMetrics(accountType: AccountType) {
        val currentUser = firebaseAuth.currentUser ?: return
        
        viewModelScope.launch {
            _metrics.value = _metrics.value.copy(isLoading = true, error = null)
            
            try {
                when (accountType) {
                    AccountType.PARCEIRO, AccountType.PRESTADOR, AccountType.VENDEDOR -> {
                        // Parceiro carrega m√©tricas combinadas de servi√ßos + produtos
                        loadPartnerMetrics(currentUser.uid)
                    }
                    else -> loadClientMetrics(currentUser.uid)
                }
            } catch (e: Exception) {
                _metrics.value = _metrics.value.copy(
                    isLoading = false,
                    error = "Erro ao carregar m√©tricas: ${e.message}"
                )
            }
        }
    }
    
    private suspend fun loadProviderMetrics(userId: String) {
        combine(
            servicesRepository.observeProviderServices(userId),
            orderRepository.observeOrders(userId, "provider")
        ) { services, orders ->
            val completedOrders = orders.filter { it.status == "completed" || it.status == "accepted" }
            val proposalsSent = orders.count { it.proposalDetails != null }
            
            // Calcular receita (soma dos valores das propostas aceitas)
            val totalRevenue = completedOrders
                .mapNotNull { it.proposalDetails?.price }
                .sum()
            
            // Receita mensal (√∫ltimos 30 dias)
            val thirtyDaysAgo = System.currentTimeMillis() - (30L * 24 * 60 * 60 * 1000)
            val monthlyRevenue = completedOrders
                .filter { it.updatedAt?.time ?: 0L >= thirtyDaysAgo }
                .mapNotNull { it.proposalDetails?.price }
                .sum()
            
            _metrics.value = DashboardMetrics(
                servicesCount = services.size,
                ordersReceived = orders.size,
                proposalsSent = proposalsSent,
                completedOrders = completedOrders.size,
                totalRevenue = totalRevenue,
                monthlyRevenue = monthlyRevenue,
                isLoading = false,
                error = null
            )
        }.collect { }
    }
    
    private suspend fun loadSellerMetrics(userId: String) {
        combine(
            firestoreProductsRepository.observeProductsBySeller(userId),
            orderRepository.observeOrders(userId, "client")
        ) { myProducts, orders ->
            
            // Calcular vendas (orders com status "completed" ou "accepted")
            val completedOrders = orders.filter { it.status == "completed" || it.status == "accepted" }
            val productsSold = completedOrders.size
            
            // Calcular receita (soma dos valores das propostas aceitas)
            val totalSales = completedOrders
                .mapNotNull { it.proposalDetails?.price }
                .sum()
            
            // Vendas mensais (√∫ltimos 30 dias)
            val thirtyDaysAgo = System.currentTimeMillis() - (30L * 24 * 60 * 60 * 1000)
            val monthlySales = completedOrders
                .filter { it.updatedAt?.time ?: 0L >= thirtyDaysAgo }
                .mapNotNull { it.proposalDetails?.price }
                .sum()
            
            _metrics.value = DashboardMetrics(
                productsCount = myProducts.size,
                productsSold = productsSold,
                totalSales = totalSales,
                monthlySales = monthlySales,
                isLoading = false,
                error = null
            )
        }.collect { }
    }
    
    private suspend fun loadPartnerMetrics(userId: String) {
        // Carregar m√©tricas combinadas de servi√ßos + produtos para Parceiro
        combine(
            servicesRepository.observeProviderServices(userId),
            firestoreProductsRepository.observeProductsBySeller(userId),
            orderRepository.observeOrders(userId, "partner"), // Usar "partner" para buscar ordens de servi√ßo (tratado como provider)
            orderRepository.observeOrders(userId, "client") // Orders como cliente tamb√©m podem incluir produtos vendidos
        ) { services, products, serviceOrders, productOrders ->
            // M√©tricas de servi√ßos
            val completedServiceOrders = serviceOrders.filter { it.status == "completed" || it.status == "accepted" }
            val proposalsSent = serviceOrders.count { it.proposalDetails != null }
            val serviceRevenue = completedServiceOrders
                .mapNotNull { it.proposalDetails?.price }
                .sum()
            
            // M√©tricas de produtos
            val completedProductOrders = productOrders.filter { it.status == "completed" || it.status == "accepted" }
            val productsSold = completedProductOrders.size
            val productSales = completedProductOrders
                .mapNotNull { it.proposalDetails?.price }
                .sum()
            
            // Receitas mensais (√∫ltimos 30 dias)
            val thirtyDaysAgo = System.currentTimeMillis() - (30L * 24 * 60 * 60 * 1000)
            val monthlyServiceRevenue = completedServiceOrders
                .filter { it.updatedAt?.time ?: 0L >= thirtyDaysAgo }
                .mapNotNull { it.proposalDetails?.price }
                .sum()
            val monthlyProductSales = completedProductOrders
                .filter { it.updatedAt?.time ?: 0L >= thirtyDaysAgo }
                .mapNotNull { it.proposalDetails?.price }
                .sum()
            
            _metrics.value = DashboardMetrics(
                servicesCount = services.size,
                productsCount = products.size,
                ordersReceived = serviceOrders.size,
                proposalsSent = proposalsSent,
                completedOrders = completedServiceOrders.size,
                productsSold = productsSold,
                totalRevenue = serviceRevenue, // Receita de servi√ßos
                totalSales = productSales, // Vendas de produtos
                monthlyRevenue = monthlyServiceRevenue,
                monthlySales = monthlyProductSales,
                isLoading = false,
                error = null
            )
        }.collect { }
    }
    
    private suspend fun loadClientMetrics(userId: String) {
        orderRepository.observeOrders(userId, "client").collect { orders ->
            val serviceOrdersCreated = orders.size
            val productsPurchased = orders.count { it.proposalDetails != null }
            
            // Calcular gastos
            val totalSpent = orders
                .filter { it.status == "completed" || it.status == "accepted" }
                .mapNotNull { it.proposalDetails?.price }
                .sum()
            
            // Gastos mensais
            val thirtyDaysAgo = System.currentTimeMillis() - (30L * 24 * 60 * 60 * 1000)
            val monthlySpent = orders
                .filter { (it.updatedAt?.time ?: 0L) >= thirtyDaysAgo }
                .filter { it.status == "completed" || it.status == "accepted" }
                .mapNotNull { it.proposalDetails?.price }
                .sum()
            
            _metrics.value = DashboardMetrics(
                serviceOrdersCreated = serviceOrdersCreated,
                productsPurchased = productsPurchased,
                totalSpent = totalSpent,
                monthlySpent = monthlySpent,
                isLoading = false,
                error = null
            )
        }
    }
    
    fun refresh() {
        _accountType.value?.let { loadMetrics(it) }
    }
}


```

## [FRONTEND]: feature/profile/presentation/ManageProposalsScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.profile.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.Assignment
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.core.design.AppTopBar

@Composable
fun ManageProposalsScreen(
    onNavigateBack: () -> Unit
) {
    val proposals = listOf(
        ProposalItem(
            id = 1,
            serviceTitle = "Montagem de M√≥veis",
            providerName = "Jo√£o Silva",
            price = 150.00,
            status = "Pendente",
            date = "15/12/2024",
            description = "Montagem de guarda-roupa e cama"
        ),
        ProposalItem(
            id = 2,
            serviceTitle = "Limpeza Residencial",
            providerName = "Maria Santos",
            price = 80.00,
            status = "Aceita",
            date = "10/12/2024",
            description = "Limpeza completa da casa"
        ),
        ProposalItem(
            id = 3,
            serviceTitle = "Instala√ß√£o El√©trica",
            providerName = "Pedro Costa",
            price = 200.00,
            status = "Recusada",
            date = "05/12/2024",
            description = "Instala√ß√£o de tomadas e interruptores"
        )
    )
    
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Gerenciar Propostas",
                onBackClick = onNavigateBack
            )
        }
    ) { padding ->
        LazyColumn(
            modifier = Modifier
                .fillMaxSize()
                .padding(padding)
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            item {
                Text(
                    text = "Minhas Propostas",
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold
                )
                Spacer(modifier = Modifier.height(16.dp))
            }
            
            items(proposals) { proposal ->
                Card(
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Column(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(16.dp)
                    ) {
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Icon(
                                imageVector = Icons.AutoMirrored.Filled.Assignment,
                                contentDescription = null,
                                tint = MaterialTheme.colorScheme.primary
                            )
                            Spacer(modifier = Modifier.width(12.dp))
                            Column(
                                modifier = Modifier.weight(1f)
                            ) {
                                Text(
                                    text = proposal.serviceTitle,
                                    style = MaterialTheme.typography.titleSmall,
                                    fontWeight = FontWeight.Bold
                                )
                                Text(
                                    text = "Prestador: ${proposal.providerName}",
                                    style = MaterialTheme.typography.bodyMedium,
                                    color = MaterialTheme.colorScheme.onSurfaceVariant
                                )
                            }
                            AssistChip(
                                onClick = { },
                                label = { Text(proposal.status) }
                            )
                        }
                        
                        Spacer(modifier = Modifier.height(12.dp))
                        
                        Text(
                            text = proposal.description,
                            style = MaterialTheme.typography.bodyMedium
                        )
                        
                        Spacer(modifier = Modifier.height(12.dp))
                        
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.SpaceBetween,
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Column {
                                Text(
                                    text = "Data: ${proposal.date}",
                                    style = MaterialTheme.typography.bodyMedium
                                )
                                Text(
                                    text = "Valor: R$ %.2f".format(proposal.price),
                                    style = MaterialTheme.typography.bodyMedium,
                                    fontWeight = FontWeight.Medium
                                )
                            }
                            
                            Row {
                                IconButton(onClick = { /* Ver detalhes */ }) {
                                    Icon(Icons.Default.Visibility, contentDescription = "Ver detalhes")
                                }
                                if (proposal.status == "Pendente") {
                                    IconButton(onClick = { /* Aceitar */ }) {
                                        Icon(Icons.Default.Check, contentDescription = "Aceitar")
                                    }
                                    IconButton(onClick = { /* Recusar */ }) {
                                        Icon(Icons.Default.Close, contentDescription = "Recusar")
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            if (proposals.isEmpty()) {
                item {
                    Box(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(32.dp),
                        contentAlignment = Alignment.Center
                    ) {
                        Column(
                            horizontalAlignment = Alignment.CenterHorizontally
                        ) {
                            Icon(
                                imageVector = Icons.AutoMirrored.Filled.Assignment,
                                contentDescription = null,
                                modifier = Modifier.size(64.dp),
                                tint = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                            Spacer(modifier = Modifier.height(16.dp))
                            Text(
                                text = "Nenhuma proposta encontrada",
                                style = MaterialTheme.typography.titleMedium,
                                color = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                            Text(
                                text = "Solicite seu primeiro servi√ßo",
                                style = MaterialTheme.typography.bodyMedium,
                                color = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                        }
                    }
                }
            }
        }
    }
}

data class ProposalItem(
    val id: Int,
    val serviceTitle: String,
    val providerName: String,
    val price: Double,
    val status: String,
    val date: String,
    val description: String
)

```

## [FRONTEND]: feature/profile/presentation/MeusDadosScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.profile.presentation
import com.taskgoapp.taskgo.core.theme.*

import android.net.Uri
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import coil.compose.AsyncImage
import com.taskgoapp.taskgo.core.design.TGIcons
import com.taskgoapp.taskgo.core.design.ImageEditor
import com.taskgoapp.taskgo.core.design.SimpleImageCropper

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MeusDadosScreen(
    onBackClick: () -> Unit,
    viewModel: ProfileViewModel = hiltViewModel()
) {
    val state by viewModel.uiState.collectAsState()
    var showPhotoDialog by remember { mutableStateOf(false) }
    var showSuccessMessage by remember { mutableStateOf(false) }
    var selectedImageUris by remember { 
        mutableStateOf(state.profileImages.map { Uri.parse(it) }) 
    }

    // Camera/Galeria + Crop para avatar
    val context = androidx.compose.ui.platform.LocalContext.current
    var tempCameraUri by remember { mutableStateOf<Uri?>(null) }
    val cropLauncher = androidx.activity.compose.rememberLauncherForActivityResult(
        contract = com.canhub.cropper.CropImageContract()
    ) { result ->
        if (result.isSuccessful) {
            result.uriContent?.let { croppedUri ->
                viewModel.onAvatarSelected(croppedUri.toString())
            }
        }
        showPhotoDialog = false
    }
    val galleryLauncher = androidx.activity.compose.rememberLauncherForActivityResult(
        contract = androidx.activity.result.contract.ActivityResultContracts.GetContent()
    ) { uri: Uri? ->
        uri?.let {
            cropLauncher.launch(
                com.canhub.cropper.CropImageContractOptions(
                    uri = it,
                    cropImageOptions = com.taskgoapp.taskgo.core.design.CropImageConfig.createDefaultOptions()
                )
            )
        } ?: run { showPhotoDialog = false }
    }
    val cameraLauncher = androidx.activity.compose.rememberLauncherForActivityResult(
        contract = androidx.activity.result.contract.ActivityResultContracts.TakePicture()
    ) { success ->
        if (success && tempCameraUri != null) {
            cropLauncher.launch(
                com.canhub.cropper.CropImageContractOptions(
                    uri = tempCameraUri,
                    cropImageOptions = com.taskgoapp.taskgo.core.design.CropImageConfig.createDefaultOptions()
                )
            )
        } else {
            showPhotoDialog = false
        }
    }
    val cameraPermissionLauncher = com.taskgoapp.taskgo.core.permissions.rememberCameraPermissionLauncher(
        onPermissionGranted = {
            val imageFile = java.io.File(context.cacheDir, "avatar_${System.currentTimeMillis()}.jpg")
            tempCameraUri = Uri.fromFile(imageFile)
            cameraLauncher.launch(tempCameraUri!!)
        },
        onPermissionDenied = { showPhotoDialog = false }
    )
    val imagePermissionLauncher = com.taskgoapp.taskgo.core.permissions.rememberImageReadPermissionLauncher(
        onPermissionGranted = {
            galleryLauncher.launch("image/*")
        },
        onPermissionDenied = { showPhotoDialog = false }
    )
    if (showPhotoDialog) {
        androidx.compose.material3.AlertDialog(
            onDismissRequest = { showPhotoDialog = false },
            title = { androidx.compose.material3.Text("Selecionar imagem") },
            text = { androidx.compose.material3.Text("Escolha a origem da sua foto de perfil") },
            confirmButton = {
                androidx.compose.material3.TextButton(onClick = {
                    if (com.taskgoapp.taskgo.core.permissions.PermissionHandler.hasImageReadPermission(context)) {
                        galleryLauncher.launch("image/*")
                    } else {
                        imagePermissionLauncher.launch(com.taskgoapp.taskgo.core.permissions.PermissionHandler.getImageReadPermission())
                    }
                }) { androidx.compose.material3.Text("Galeria") }
            },
            dismissButton = {
                androidx.compose.material3.TextButton(onClick = {
                    if (com.taskgoapp.taskgo.core.permissions.PermissionHandler.hasCameraPermission(context)) {
                        val imageFile = java.io.File(context.cacheDir, "avatar_${System.currentTimeMillis()}.jpg")
                        tempCameraUri = Uri.fromFile(imageFile)
                        cameraLauncher.launch(tempCameraUri!!)
                    } else {
                        cameraPermissionLauncher.launch(android.Manifest.permission.CAMERA)
                    }
                }) { androidx.compose.material3.Text("C√¢mera") }
            }
        )
    }

    // Atualizar URIs quando o estado mudar
    LaunchedEffect(state.profileImages) {
        selectedImageUris = state.profileImages.map { Uri.parse(it) }
    }
    
    // Debug do estado
    LaunchedEffect(state.avatarUri) {
        println("DEBUG: LaunchedEffect - avatarUri mudou para: ${state.avatarUri}")
    }

    Scaffold(
        topBar = {
            // Header verde
            Box(
                modifier = Modifier
                    .fillMaxWidth()
                    .background(TaskGoGreenDark) // Verde escuro
                    .padding(16.dp)
            ) {
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    IconButton(onClick = onBackClick) {
                        Icon(
                            painter = painterResource(TGIcons.Back),
                            contentDescription = "Voltar",
                            tint = Color.White
                        )
                    }
                    
                    Text(
                        text = "Conta",
                        style = MaterialTheme.typography.headlineSmall,
                        color = Color.White,
                        fontWeight = FontWeight.Bold,
                        modifier = Modifier.weight(1f)
                    )
                }
            }
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .background(Color(0xFF424242)) // Fundo cinza escuro
        ) {
            LazyColumn(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(horizontal = 20.dp),
                verticalArrangement = Arrangement.spacedBy(20.dp),
                contentPadding = PaddingValues(vertical = 20.dp)
            ) {
                items(listOf("profile", "photos", "fields", "save")) { item ->
                    when (item) {
                        "profile" -> {
                            Column(
                                modifier = Modifier.fillMaxWidth(),
                                horizontalAlignment = Alignment.CenterHorizontally
                            ) {
                                // Foto de perfil circular
                                Box(
                                    modifier = Modifier
                                        .size(100.dp)
                                        .clip(CircleShape)
                                        .background(MaterialTheme.colorScheme.surfaceVariant)
                                        .clickable { showPhotoDialog = true },
                                    contentAlignment = Alignment.Center
                                ) {
                                    println("DEBUG: Estado atual - avatarUri: ${state.avatarUri}")
                                    if (!state.avatarUri.isNullOrBlank()) {
                                        println("DEBUG: Exibindo AsyncImage com URI: ${state.avatarUri}")
                                        AsyncImage(
                                            model = state.avatarUri,
                                            contentDescription = "Foto de perfil",
                                            modifier = Modifier
                                                .size(100.dp)
                                                .clip(CircleShape),
                                            contentScale = ContentScale.Crop
                                        )
                                    } else {
                                        println("DEBUG: Exibindo √≠cone padr√£o - avatarUri est√° vazio")
                                        Icon(
                                            painter = painterResource(TGIcons.Profile),
                                            contentDescription = "Foto de perfil",
                                            modifier = Modifier.size(60.dp),
                                            tint = MaterialTheme.colorScheme.onSurfaceVariant
                                        )
                                    }
                                }
                                
                                Spacer(modifier = Modifier.height(16.dp))
                                
                                // Nome do usu√°rio
                                Text(
                                    text = state.name.ifBlank { "Carlos Amaral" },
                                    style = MaterialTheme.typography.headlineSmall,
                                    fontWeight = FontWeight.Bold,
                                    color = Color.White
                                )
                                
                                // Profiss√£o
                                Text(
                                    text = state.profession.ifBlank { "Montador de M√≥veis" },
                                    style = MaterialTheme.typography.bodyMedium,
                                    color = Color.Gray
                                )
                            }
                        }
                        "photos" -> {
                            Column(
                                modifier = Modifier.fillMaxWidth(),
                                verticalArrangement = Arrangement.spacedBy(16.dp)
                            ) {
                                Text(
                                    text = "Fotos de Perfil",
                                    style = MaterialTheme.typography.titleMedium,
                                    color = Color.White,
                                    fontWeight = FontWeight.Bold
                                )
                                
                                ImageEditor(
                                    selectedImageUris = selectedImageUris,
                                    onImagesChanged = { uris ->
                                        selectedImageUris = uris
                                        viewModel.onProfileImagesChanged(uris.map { it.toString() })
                                    },
                                    maxImages = 5,
                                    placeholderText = "Adicione fotos do seu trabalho"
                                )
                            }
                        }
                        "fields" -> {
                            Column(
                                modifier = Modifier.fillMaxWidth(),
                                verticalArrangement = Arrangement.spacedBy(16.dp)
                            ) {
                                // Campo Nome Completo
                                Column {
                                    Text(
                                        text = "Nome Completo",
                                        style = MaterialTheme.typography.bodyMedium,
                                        color = Color.White,
                                        fontWeight = FontWeight.Medium
                                    )
                                    Spacer(modifier = Modifier.height(8.dp))
                                    OutlinedTextField(
                                        value = state.name,
                                        onValueChange = { viewModel.onNameChange(it) },
                                        modifier = Modifier.fillMaxWidth(),
                                        singleLine = true,
                                        colors = OutlinedTextFieldDefaults.colors(
                                            focusedBorderColor = Color.Gray,
                                            unfocusedBorderColor = Color.Gray,
                                            focusedTextColor = Color.White,
                                            unfocusedTextColor = Color.White,
                                            cursorColor = Color.White
                                        ),
                                        textStyle = MaterialTheme.typography.bodyLarge.copy(color = Color.White)
                                    )
                                }
                                
                                // Campo Email
                                Column {
                                    Text(
                                        text = "Email",
                                        style = MaterialTheme.typography.bodyMedium,
                                        color = Color.White,
                                        fontWeight = FontWeight.Medium
                                    )
                                    Spacer(modifier = Modifier.height(8.dp))
                                    OutlinedTextField(
                                        value = state.email,
                                        onValueChange = { viewModel.onEmailChange(it) },
                                        modifier = Modifier.fillMaxWidth(),
                                        singleLine = true,
                                        colors = OutlinedTextFieldDefaults.colors(
                                            focusedBorderColor = Color.Gray,
                                            unfocusedBorderColor = Color.Gray,
                                            focusedTextColor = Color.White,
                                            unfocusedTextColor = Color.White,
                                            cursorColor = Color.White
                                        ),
                                        textStyle = MaterialTheme.typography.bodyLarge.copy(color = Color.White)
                                    )
                                }
                                
                            }
                        }
                        "save" -> {
                            Button(
                                onClick = { 
                                    viewModel.save()
                                    showSuccessMessage = true
                                },
                                modifier = Modifier.fillMaxWidth(),
                                colors = ButtonDefaults.buttonColors(
                                    containerColor = Color(0xFFD32F2F) // Vermelho escuro
                                )
                            ) {
                                Text(
                                    text = "Salvar Altera√ß√µes",
                                    fontWeight = FontWeight.Bold,
                                    color = Color.White
                                )
                            }
                        }
                    }
                }
            }
        }
    }


    // Mensagem de sucesso
    if (showSuccessMessage) {
        AlertDialog(
            onDismissRequest = { showSuccessMessage = false },
            title = { Text("Sucesso") },
            text = { Text("Dados salvos com sucesso!") },
            confirmButton = {
                TextButton(onClick = { showSuccessMessage = false }) {
                    Text("OK")
                }
            }
        )
    }
}

```

## [FRONTEND]: feature/profile/presentation/MinhasAvaliacoesScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.profile.presentation
import com.taskgoapp.taskgo.core.theme.*

import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Star
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.core.design.AppTopBar

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MinhasAvaliacoesScreen(
    onBackClick: () -> Unit
) {
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Minhas Avalia√ß√µes",
                onBackClick = onBackClick
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // Review item
            Card(
                modifier = Modifier.fillMaxWidth(),
                colors = CardDefaults.cardColors(
                    containerColor = MaterialTheme.colorScheme.surface
                )
            ) {
                Column(
                    modifier = Modifier.padding(16.dp),
                    verticalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Column {
                            Text(
                                text = "Montagem de M√≥veis",
                                style = MaterialTheme.typography.titleMedium,
                                fontWeight = FontWeight.Bold
                            )
                            Text(
                                text = "Rodrigo Silva",
                                style = MaterialTheme.typography.bodyMedium,
                                color = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                        }
                        
                        // Rating stars
                        Row(
                            horizontalArrangement = Arrangement.spacedBy(4.dp)
                        ) {
                            repeat(5) { index ->
                                Icon(
                                    imageVector = Icons.Default.Star,
                                    contentDescription = "Estrela ${index + 1}",
                                    modifier = Modifier.size(20.dp),
                                    tint = if (index < 5) TaskGoStarYellow else Color.Gray
                                )
                            }
                        }
                    }
                    
                    Text(
                        text = "Excelente trabalho montando a estante! Muito profissional e pontual.",
                        style = MaterialTheme.typography.bodyMedium,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                    
                    Text(
                        text = "15/12/2024",
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
            }

            // Another review
            Card(
                modifier = Modifier.fillMaxWidth(),
                colors = CardDefaults.cardColors(
                    containerColor = MaterialTheme.colorScheme.surface
                )
            ) {
                Column(
                    modifier = Modifier.padding(16.dp),
                    verticalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Column {
                            Text(
                                text = "Limpeza Residencial",
                                style = MaterialTheme.typography.titleMedium,
                                fontWeight = FontWeight.Bold
                            )
                            Text(
                                text = "Maria Santos",
                                style = MaterialTheme.typography.bodyMedium,
                                color = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                        }
                        
                        Row(
                            horizontalArrangement = Arrangement.spacedBy(4.dp)
                        ) {
                            repeat(5) { index ->
                                Icon(
                                    imageVector = Icons.Default.Star,
                                    contentDescription = "Estrela ${index + 1}",
                                    modifier = Modifier.size(20.dp),
                                    tint = if (index < 4) TaskGoStarYellow else Color.Gray
                                )
                            }
                        }
                    }
                    
                    Text(
                        text = "Muito boa limpeza, deixou tudo organizado e limpo.",
                        style = MaterialTheme.typography.bodyMedium,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                    
                    Text(
                        text = "10/12/2024",
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
            }
        }
    }
}

```

## [FRONTEND]: feature/profile/presentation/MyDataScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.profile.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.verticalScroll

import androidx.compose.material3.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.DeleteForever
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.google.firebase.auth.FirebaseAuth
import com.taskgoapp.taskgo.core.theme.TaskGoError
import com.taskgoapp.taskgo.R
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.design.TGIcons
import com.taskgoapp.taskgo.core.model.AccountType
import com.taskgoapp.taskgo.core.theme.TaskGoGreen
import androidx.hilt.navigation.compose.hiltViewModel
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import androidx.compose.runtime.rememberCoroutineScope
import java.text.SimpleDateFormat
import java.util.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MyDataScreen(
    onNavigateBack: () -> Unit,
    viewModel: ProfileViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    
    // Evitar renderiza√ß√£o prematura que cause crash por estado nulo
    if (uiState.isLoading && uiState.name.isBlank() && uiState.email.isBlank()) {
        Scaffold(
            topBar = {
                AppTopBar(
                    title = stringResource(R.string.profile_my_data),
                    onBackClick = onNavigateBack
                )
            }
        ) { paddingValues ->
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues),
                contentAlignment = Alignment.Center
            ) {
                CircularProgressIndicator(color = TaskGoGreen)
            }
        }
        return
    }
    // Se ainda n√£o carregou o perfil, mostrar carregando (evita crash por estado vazio)
    if (uiState.isLoading && uiState.name.isBlank() && uiState.email.isBlank()) {
        Scaffold(
            topBar = {
                AppTopBar(
                    title = stringResource(R.string.profile_my_data),
                    onBackClick = onNavigateBack
                )
            }
        ) { paddingValues ->
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues),
                contentAlignment = Alignment.Center
            ) {
                CircularProgressIndicator(color = TaskGoGreen)
            }
        }
        return
    }
    
    var isEditing by remember { mutableStateOf(false) }
    var editedName by remember { mutableStateOf("") }
    var editedEmail by remember { mutableStateOf("") }
    var editedPhone by remember { mutableStateOf("") }
    var showChangePhotoDialog by remember { mutableStateOf(false) }
    var showChangePasswordDialog by remember { mutableStateOf(false) }
    var showSaveSuccess by remember { mutableStateOf(false) }
    var showDeleteAccountConfirmation by remember { mutableStateOf(false) }
    
    LaunchedEffect(uiState) {
        if (!isEditing) {
            editedName = uiState.name
            editedEmail = uiState.email
            editedPhone = uiState.phone
        }
    }
    
    // Calcular tempo no TaskGo baseado em createdAt
    val timeOnTaskGo = remember(uiState.createdAt) {
        uiState.createdAt?.let { createdAt ->
            val now = Date()
            val diff = now.time - createdAt.time
            val days = diff / (1000 * 60 * 60 * 24)
            when {
                days < 30 -> "${days} dias"
                days < 365 -> "${days / 30} meses"
                else -> "${days / 365} anos"
            }
        } ?: "Rec√©m cadastrado"
    }

    Scaffold(
        topBar = {
            AppTopBar(
                title = stringResource(R.string.profile_my_data),
                onBackClick = onNavigateBack
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .verticalScroll(rememberScrollState())
        ) {
            // Profile Photo Section
            ProfilePhotoSection(
                avatarUri = uiState.avatarUri,
                onChangePhoto = { showChangePhotoDialog = true }
            )
            
            Spacer(modifier = Modifier.height(24.dp))
            
            // Personal Information
            PersonalInfoSection(
                uiState = uiState,
                isEditing = isEditing,
                editedName = editedName,
                editedEmail = editedEmail,
                editedPhone = editedPhone,
                onNameChange = { editedName = it },
                onEmailChange = { editedEmail = it },
                onPhoneChange = { editedPhone = it }
            )
            
            Spacer(modifier = Modifier.height(24.dp))
            
            // Account Information
            AccountInfoSection(
                uiState = uiState,
                timeOnTaskGo = timeOnTaskGo
            )
            
            Spacer(modifier = Modifier.height(24.dp))
            
            // Action Buttons
            ActionButtonsSection(
                isEditing = isEditing,
                isSaving = uiState.isSaving,
                onEditClick = { isEditing = true },
                onSaveClick = {
                    viewModel.onNameChange(editedName)
                    viewModel.onEmailChange(editedEmail)
                    viewModel.onPhoneChange(editedPhone)
                    viewModel.save()
                    isEditing = false
                    showSaveSuccess = true
                },
                onCancelClick = {
                    isEditing = false
                    editedName = uiState.name
                    editedEmail = uiState.email
                    editedPhone = uiState.phone
                },
                onChangePassword = { showChangePasswordDialog = true },
                onDeleteAccount = { showDeleteAccountConfirmation = true }
            )
        }
    }
    
    // Change Photo Dialog
    if (showChangePhotoDialog) {
        AlertDialog(
            onDismissRequest = { showChangePhotoDialog = false },
            title = { Text(stringResource(R.string.profile_change_photo_title)) },
            text = { Text(stringResource(R.string.profile_change_photo_message)) },
            confirmButton = {
                TextButton(
                    onClick = { showChangePhotoDialog = false }
                ) {
                    Text(stringResource(R.string.profile_change_photo_confirm))
                }
            }
        )
    }
    
    // Change Password Dialog
    if (showChangePasswordDialog) {
        ChangePasswordDialog(
            onDismiss = { showChangePasswordDialog = false }
        )
    }
    
    // Delete Account Confirmation Dialog
    if (showDeleteAccountConfirmation) {
        DeleteAccountDialog(
            onDismiss = { showDeleteAccountConfirmation = false },
            onConfirm = {
                showDeleteAccountConfirmation = false
                // Navegar para tela de configura√ß√µes de seguran√ßa onde est√° o bot√£o de excluir
                // Ou implementar a exclus√£o diretamente aqui
            }
        )
    }
    
    // Save Success Snackbar
    if (showSaveSuccess) {
        LaunchedEffect(Unit) {
            delay(2000)
            showSaveSuccess = false
        }
        
        Snackbar(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(stringResource(R.string.profile_save_success))
        }
    }
}

@Composable
private fun ProfilePhotoSection(
    avatarUri: String?,
    onChangePhoto: () -> Unit
) {
    Card(
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.primaryContainer
        )
    ) {
        Column(
            modifier = Modifier.padding(20.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            // Profile Photo
            Surface(
                modifier = Modifier.size(100.dp),
                shape = CircleShape,
                color = MaterialTheme.colorScheme.onPrimaryContainer
            ) {
                Box(
                    contentAlignment = Alignment.Center
                ) {
                    if (avatarUri != null && avatarUri.isNotBlank()) {
                        coil.compose.AsyncImage(
                            model = avatarUri,
                            contentDescription = null,
                            modifier = Modifier.fillMaxSize(),
                            contentScale = androidx.compose.ui.layout.ContentScale.Crop
                        )
                    } else {
                        Icon(
                            painter = painterResource(TGIcons.Profile),
                            contentDescription = null,
                            modifier = Modifier.size(60.dp),
                            tint = MaterialTheme.colorScheme.primaryContainer
                        )
                    }
                }
            }
            
            Spacer(modifier = Modifier.height(16.dp))
            
            Text(
                text = stringResource(R.string.profile_photo_title),
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.Bold,
                color = MaterialTheme.colorScheme.onPrimaryContainer
            )
            
            Spacer(modifier = Modifier.height(8.dp))
            
            OutlinedButton(
                onClick = onChangePhoto,
                colors = ButtonDefaults.outlinedButtonColors(
                    contentColor = MaterialTheme.colorScheme.onPrimaryContainer
                )
            ) {
                Icon(
                    painter = painterResource(TGIcons.Edit),
                    contentDescription = null,
                    modifier = Modifier.size(18.dp)
                )
                Spacer(modifier = Modifier.width(8.dp))
                Text(stringResource(R.string.profile_change_photo))
            }
        }
    }
}

@Composable
private fun PersonalInfoSection(
    uiState: ProfileState,
    isEditing: Boolean,
    editedName: String,
    editedEmail: String,
    editedPhone: String,
    onNameChange: (String) -> Unit,
    onEmailChange: (String) -> Unit,
    onPhoneChange: (String) -> Unit
) {
    Card(
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                text = stringResource(R.string.profile_personal_info_title),
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.Bold
            )
            
            Spacer(modifier = Modifier.height(16.dp))
            
            if (isEditing) {
                // Editable fields
                OutlinedTextField(
                    value = editedName,
                    onValueChange = onNameChange,
                    label = { Text(stringResource(R.string.profile_name_label)) },
                    modifier = Modifier.fillMaxWidth()
                )
                
                Spacer(modifier = Modifier.height(16.dp))
                
                OutlinedTextField(
                    value = editedEmail,
                    onValueChange = onEmailChange,
                    label = { Text(stringResource(R.string.profile_email_label)) },
                    modifier = Modifier.fillMaxWidth()
                )
                
                Spacer(modifier = Modifier.height(16.dp))
                
                OutlinedTextField(
                    value = editedPhone,
                    onValueChange = onPhoneChange,
                    label = { Text(stringResource(R.string.profile_phone_label)) },
                    modifier = Modifier.fillMaxWidth()
                )
            } else {
                // Read-only fields
                InfoRow(
                    label = stringResource(R.string.profile_name_label),
                    value = uiState.name.ifBlank { "N√£o informado" }
                )
                
                Spacer(modifier = Modifier.height(12.dp))
                
                InfoRow(
                    label = stringResource(R.string.profile_email_label),
                    value = uiState.email.ifBlank { "N√£o informado" }
                )
                
                Spacer(modifier = Modifier.height(12.dp))
                
                InfoRow(
                    label = stringResource(R.string.profile_phone_label),
                    value = uiState.phone.ifBlank { "N√£o informado" }
                )
            }
        }
    }
}

@Composable
private fun AccountInfoSection(
    uiState: ProfileState,
    timeOnTaskGo: String
) {
    Card(
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                text = stringResource(R.string.profile_account_info_title),
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.Bold
            )
            
            Spacer(modifier = Modifier.height(16.dp))
            
            InfoRow(
                label = stringResource(R.string.profile_account_type_label),
                value = when (uiState.accountType) {
                    AccountType.PARCEIRO -> "Parceiro"
                    AccountType.PRESTADOR -> "Prestador"
                    AccountType.VENDEDOR -> "Vendedor"
                    AccountType.CLIENTE -> "Cliente"
                }
            )
            
            Spacer(modifier = Modifier.height(12.dp))
            
            InfoRow(
                label = stringResource(R.string.profile_time_on_taskgo_label),
                value = timeOnTaskGo
            )
            
            Spacer(modifier = Modifier.height(12.dp))
            
            InfoRow(
                label = stringResource(R.string.profile_rating_label),
                value = if (uiState.rating != null) {
                    "${String.format("%.1f", uiState.rating)}/5.0"
                } else {
                    "Sem avalia√ß√µes"
                }
            )
            
            Spacer(modifier = Modifier.height(12.dp))
            
            InfoRow(
                label = stringResource(R.string.profile_city_label),
                value = uiState.city.ifBlank { "N√£o informado" }
            )
        }
    }
}

@Composable
private fun ActionButtonsSection(
    isEditing: Boolean,
    isSaving: Boolean,
    onEditClick: () -> Unit,
    onSaveClick: () -> Unit,
    onCancelClick: () -> Unit,
    onChangePassword: () -> Unit,
    onDeleteAccount: () -> Unit
) {
    Column(
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        if (isEditing) {
            // Save and Cancel buttons
            Row(
                horizontalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                OutlinedButton(
                    onClick = onCancelClick,
                    modifier = Modifier.weight(1f)
                ) {
                    Text(stringResource(R.string.profile_cancel))
                }
                
                Button(
                    onClick = onSaveClick,
                    modifier = Modifier.weight(1f),
                    enabled = !isSaving
                ) {
                    if (isSaving) {
                        CircularProgressIndicator(
                            modifier = Modifier.size(20.dp),
                            color = MaterialTheme.colorScheme.onPrimary
                        )
                    } else {
                        Text(stringResource(R.string.profile_save))
                    }
                }
            }
        } else {
            // Edit button
            Button(
                onClick = onEditClick,
                modifier = Modifier.fillMaxWidth()
            ) {
                Icon(
                    painter = painterResource(TGIcons.Edit),
                    contentDescription = null,
                    modifier = Modifier.size(18.dp)
                )
                Spacer(modifier = Modifier.width(8.dp))
                Text(stringResource(R.string.profile_edit_info))
            }
        }
        
        // Change Password button
        OutlinedButton(
            onClick = onChangePassword,
            modifier = Modifier.fillMaxWidth()
        ) {
            Icon(
                painter = painterResource(TGIcons.Edit),
                contentDescription = null,
                modifier = Modifier.size(18.dp)
            )
            Spacer(modifier = Modifier.width(8.dp))
            Text(stringResource(R.string.profile_change_password))
        }
        
        // Delete Account button
        OutlinedButton(
            onClick = onDeleteAccount,
            modifier = Modifier.fillMaxWidth(),
            colors = ButtonDefaults.outlinedButtonColors(
                contentColor = MaterialTheme.colorScheme.error
            )
        ) {
            Icon(
                imageVector = androidx.compose.material.icons.Icons.Default.DeleteForever,
                contentDescription = null,
                modifier = Modifier.size(18.dp),
                tint = MaterialTheme.colorScheme.error
            )
            Spacer(modifier = Modifier.width(8.dp))
            Text(
                "Excluir Minha Conta",
                color = MaterialTheme.colorScheme.error
            )
        }
    }
}

@Composable
private fun InfoRow(
    label: String,
    value: String
) {
    Row(
        modifier = Modifier.fillMaxWidth(),
        horizontalArrangement = Arrangement.SpaceBetween,
        verticalAlignment = Alignment.CenterVertically
    ) {
        Text(
            text = label,
            style = MaterialTheme.typography.bodyMedium,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )
        
        Text(
            text = value,
            style = MaterialTheme.typography.bodyMedium,
            fontWeight = FontWeight.Medium
        )
    }
}

@Composable
private fun DeleteAccountDialog(
    onDismiss: () -> Unit,
    onConfirm: () -> Unit
) {
    val auth = FirebaseAuth.getInstance()
    val currentUser = auth.currentUser
    val functionsService = remember {
        com.taskgoapp.taskgo.data.firebase.FirebaseFunctionsService(
            com.google.firebase.functions.FirebaseFunctions.getInstance()
        )
    }
    var isDeleting by remember { mutableStateOf(false) }
    var errorMessage by remember { mutableStateOf<String?>(null) }
    val scope = rememberCoroutineScope()

    AlertDialog(
        onDismissRequest = { if (!isDeleting) onDismiss() },
        title = { 
            Text(
                "Confirmar Exclus√£o",
                color = TaskGoError
            ) 
        },
        text = {
            Column {
                Text(
                    "Tem certeza que deseja excluir permanentemente sua conta? Esta a√ß√£o n√£o pode ser desfeita e todos os seus dados ser√£o removidos.",
                    color = MaterialTheme.colorScheme.onSurface
                )
                if (errorMessage != null) {
                    Spacer(modifier = Modifier.height(8.dp))
                    Text(
                        errorMessage!!,
                        color = TaskGoError,
                        style = MaterialTheme.typography.bodySmall
                    )
                }
            }
        },
        confirmButton = {
            TextButton(
                onClick = {
                    if (currentUser != null && !isDeleting) {
                        isDeleting = true
                        errorMessage = null
                        scope.launch {
                            try {
                                val deleteResult = functionsService.deleteUserAccount()
                                deleteResult.fold(
                                    onSuccess = {
                                        // Fazer logout ap√≥s exclus√£o bem-sucedida
                                        auth.signOut()
                                        onConfirm()
                                    },
                                    onFailure = { error ->
                                        errorMessage = "Erro ao excluir conta: ${error.message}"
                                        isDeleting = false
                                    }
                                )
                            } catch (e: Exception) {
                                errorMessage = "Erro: ${e.message}"
                                isDeleting = false
                            }
                        }
                    }
                },
                enabled = !isDeleting && currentUser != null,
                colors = ButtonDefaults.textButtonColors(contentColor = TaskGoError)
            ) {
                if (isDeleting) {
                    CircularProgressIndicator(
                        modifier = Modifier.size(20.dp),
                        color = TaskGoError
                    )
                } else {
                    Text("Excluir", color = TaskGoError)
                }
            }
        },
        dismissButton = {
            TextButton(
                onClick = onDismiss,
                enabled = !isDeleting
            ) {
                Text("Cancelar")
            }
        }
    )
}

@Composable
private fun ChangePasswordDialog(
    onDismiss: () -> Unit,
    viewModel: com.taskgoapp.taskgo.feature.auth.presentation.AuthViewModel = androidx.hilt.navigation.compose.hiltViewModel()
) {
    var currentPassword by remember { mutableStateOf("") }
    var newPassword by remember { mutableStateOf("") }
    var confirmPassword by remember { mutableStateOf("") }
    val changeState = viewModel.changePasswordState.collectAsState().value

    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text(stringResource(R.string.profile_change_password_title)) },
        text = {
            Column {
                OutlinedTextField(
                    value = currentPassword,
                    onValueChange = { currentPassword = it },
                    label = { Text(stringResource(R.string.profile_current_password)) },
                    modifier = Modifier.fillMaxWidth()
                )

                Spacer(modifier = Modifier.height(8.dp))

                OutlinedTextField(
                    value = newPassword,
                    onValueChange = { newPassword = it },
                    label = { Text(stringResource(R.string.profile_new_password)) },
                    modifier = Modifier.fillMaxWidth()
                )

                Spacer(modifier = Modifier.height(8.dp))

                OutlinedTextField(
                    value = confirmPassword,
                    onValueChange = { confirmPassword = it },
                    label = { Text(stringResource(R.string.profile_confirm_password)) },
                    modifier = Modifier.fillMaxWidth()
                )

                if (changeState.error != null) {
                    Text(changeState.error, color = MaterialTheme.colorScheme.error)
                }
                if (changeState.success) {
                    Text("Senha alterada com sucesso!", color = MaterialTheme.colorScheme.primary)
                }
            }
        },
        confirmButton = {
            TextButton(
                onClick = {
                    if (newPassword == confirmPassword && newPassword.isNotBlank() && currentPassword.isNotBlank()) {
                        viewModel.changePassword(currentPassword, newPassword)
                    }
                },
                enabled = !changeState.isLoading && newPassword == confirmPassword && newPassword.isNotBlank() && currentPassword.isNotBlank()
            ) {
                if (changeState.isLoading) CircularProgressIndicator(modifier = Modifier.size(20.dp))
                else Text(stringResource(R.string.profile_change_password_confirm))
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text(stringResource(R.string.profile_change_password_cancel))
            }
        }
    )
}

```

## [FRONTEND]: feature/profile/presentation/MyProductsScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.profile.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.core.design.AppTopBar

@Composable
fun MyProductsScreen(
    onNavigateBack: () -> Unit
) {
    val products = listOf(
        ProductItem(
            id = 1,
            title = "Furadeira sem fio",
            price = 299.99,
            date = "15/12/2024",
            status = "Entregue",
            quantity = 1
        ),
        ProductItem(
            id = 2,
            title = "Guarda Roupa 6 Portas",
            price = 899.99,
            date = "10/12/2024",
            status = "Em tr√¢nsito",
            quantity = 1
        ),
        ProductItem(
            id = 3,
            title = "Smartphone Galaxy A54",
            price = 1899.99,
            date = "05/12/2024",
            status = "Entregue",
            quantity = 1
        )
    )
    
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Meus Produtos",
                onBackClick = onNavigateBack
            )
        }
    ) { padding ->
        LazyColumn(
            modifier = Modifier
                .fillMaxSize()
                .padding(padding)
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            item {
                Text(
                    text = "Hist√≥rico de Compras",
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold
                )
                Spacer(modifier = Modifier.height(16.dp))
            }
            
            items(products) { product ->
                Card(
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Column(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(16.dp)
                    ) {
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Icon(
                                imageVector = Icons.Default.ShoppingCart,
                                contentDescription = null,
                                tint = MaterialTheme.colorScheme.primary
                            )
                            Spacer(modifier = Modifier.width(12.dp))
                            Column(
                                modifier = Modifier.weight(1f)
                            ) {
                                Text(
                                    text = product.title,
                                    style = MaterialTheme.typography.titleSmall,
                                    fontWeight = FontWeight.Bold
                                )
                                Text(
                                    text = "Quantidade: ${product.quantity}",
                                    style = MaterialTheme.typography.bodyMedium,
                                    color = MaterialTheme.colorScheme.onSurfaceVariant
                                )
                            }
                            AssistChip(
                                onClick = { },
                                label = { Text(product.status) }
                            )
                        }
                        
                        Spacer(modifier = Modifier.height(12.dp))
                        
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.SpaceBetween,
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Column {
                                Text(
                                    text = "Data: ${product.date}",
                                    style = MaterialTheme.typography.bodyMedium
                                )
                                Text(
                                    text = "Valor: R$ %.2f".format(product.price),
                                    style = MaterialTheme.typography.bodyMedium,
                                    fontWeight = FontWeight.Medium
                                )
                            }
                            
                            Row {
                                IconButton(onClick = { /* Ver detalhes */ }) {
                                    Icon(Icons.Default.Visibility, contentDescription = "Ver detalhes")
                                }
                                IconButton(onClick = { /* Rastrear */ }) {
                                    Icon(Icons.Default.LocationOn, contentDescription = "Rastrear")
                                }
                                IconButton(onClick = { /* Avaliar */ }) {
                                    Icon(Icons.Default.Star, contentDescription = "Avaliar")
                                }
                            }
                        }
                    }
                }
            }
            
            if (products.isEmpty()) {
                item {
                    Box(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(32.dp),
                        contentAlignment = Alignment.Center
                    ) {
                        Column(
                            horizontalAlignment = Alignment.CenterHorizontally
                        ) {
                            Icon(
                                imageVector = Icons.Default.ShoppingCart,
                                contentDescription = null,
                                modifier = Modifier.size(64.dp),
                                tint = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                            Spacer(modifier = Modifier.height(16.dp))
                            Text(
                                text = "Nenhum produto encontrado",
                                style = MaterialTheme.typography.titleMedium,
                                color = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                            Text(
                                text = "Fa√ßa sua primeira compra",
                                style = MaterialTheme.typography.bodyMedium,
                                color = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                        }
                    }
                }
            }
        }
    }
}

data class ProductItem(
    val id: Int,
    val title: String,
    val price: Double,
    val date: String,
    val status: String,
    val quantity: Int
)

```

## [FRONTEND]: feature/profile/presentation/MyReviewsScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.profile.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.core.design.AppTopBar

@Composable
fun MyReviewsScreen(
    onNavigateBack: () -> Unit
) {
    val reviews = listOf(
        ReviewItem(
            id = 1,
            serviceTitle = "Montagem de M√≥veis",
            providerName = "Jo√£o Silva",
            rating = 5.0f,
            comment = "Excelente servi√ßo! Muito profissional e pontual.",
            date = "15/12/2024"
        ),
        ReviewItem(
            id = 2,
            serviceTitle = "Limpeza Residencial",
            providerName = "Maria Santos",
            rating = 4.5f,
            comment = "Servi√ßo muito bom, casa ficou impec√°vel.",
            date = "10/12/2024"
        ),
        ReviewItem(
            id = 3,
            serviceTitle = "Instala√ß√£o El√©trica",
            providerName = "Pedro Costa",
            rating = 4.0f,
            comment = "Bom trabalho, mas demorou um pouco mais que o esperado.",
            date = "05/12/2024"
        )
    )
    
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Minhas Avalia√ß√µes",
                onBackClick = onNavigateBack
            )
        }
    ) { padding ->
        LazyColumn(
            modifier = Modifier
                .fillMaxSize()
                .padding(padding)
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            item {
                Text(
                    text = "Avalia√ß√µes Enviadas",
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold
                )
                Spacer(modifier = Modifier.height(16.dp))
            }
            
            items(reviews) { review ->
                Card(
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Column(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(16.dp)
                    ) {
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Icon(
                                imageVector = Icons.Default.Star,
                                contentDescription = null,
                                tint = MaterialTheme.colorScheme.primary
                            )
                            Spacer(modifier = Modifier.width(12.dp))
                            Column(
                                modifier = Modifier.weight(1f)
                            ) {
                                Text(
                                    text = review.serviceTitle,
                                    style = MaterialTheme.typography.titleSmall,
                                    fontWeight = FontWeight.Bold
                                )
                                Text(
                                    text = "Prestador: ${review.providerName}",
                                    style = MaterialTheme.typography.bodyMedium,
                                    color = MaterialTheme.colorScheme.onSurfaceVariant
                                )
                            }
                            Row {
                                repeat(5) { index ->
                                    Icon(
                                        imageVector = if (index < review.rating.toInt()) {
                                            Icons.Default.Star
                                        } else {
                                            Icons.Default.StarBorder
                                        },
                                        contentDescription = null,
                                        tint = MaterialTheme.colorScheme.primary,
                                        modifier = Modifier.size(16.dp)
                                    )
                                }
                            }
                        }
                        
                        Spacer(modifier = Modifier.height(12.dp))
                        
                        Text(
                            text = review.comment,
                            style = MaterialTheme.typography.bodyMedium
                        )
                        
                        Spacer(modifier = Modifier.height(12.dp))
                        
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.SpaceBetween,
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Text(
                                text = "Data: ${review.date}",
                                style = MaterialTheme.typography.bodySmall,
                                color = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                            
                            Row {
                                IconButton(onClick = { /* Editar avalia√ß√£o */ }) {
                                    Icon(Icons.Default.Edit, contentDescription = "Editar")
                                }
                                IconButton(onClick = { /* Excluir avalia√ß√£o */ }) {
                                    Icon(Icons.Default.Delete, contentDescription = "Excluir")
                                }
                            }
                        }
                    }
                }
            }
            
            if (reviews.isEmpty()) {
                item {
                    Box(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(32.dp),
                        contentAlignment = Alignment.Center
                    ) {
                        Column(
                            horizontalAlignment = Alignment.CenterHorizontally
                        ) {
                            Icon(
                                imageVector = Icons.Default.Star,
                                contentDescription = null,
                                modifier = Modifier.size(64.dp),
                                tint = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                            Spacer(modifier = Modifier.height(16.dp))
                            Text(
                                text = "Nenhuma avalia√ß√£o encontrada",
                                style = MaterialTheme.typography.titleMedium,
                                color = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                            Text(
                                text = "Avalie os servi√ßos que voc√™ contratou",
                                style = MaterialTheme.typography.bodyMedium,
                                color = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                        }
                    }
                }
            }
        }
    }
}

data class ReviewItem(
    val id: Int,
    val serviceTitle: String,
    val providerName: String,
    val rating: Float,
    val comment: String,
    val date: String
)

```

## [FRONTEND]: feature/profile/presentation/MyServicesScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.profile.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.core.design.AppTopBar

@Composable
fun MyServicesScreen(
    onNavigateBack: () -> Unit
) {
    val services = listOf(
        ServiceItem(
            id = 1,
            title = "Montagem de M√≥veis",
            provider = "Jo√£o Silva",
            date = "15/12/2024",
            status = "Em andamento",
            price = 150.00
        ),
        ServiceItem(
            id = 2,
            title = "Limpeza Residencial",
            provider = "Maria Santos",
            date = "10/12/2024",
            status = "Conclu√≠do",
            price = 80.00
        ),
        ServiceItem(
            id = 3,
            title = "Instala√ß√£o El√©trica",
            provider = "Pedro Costa",
            date = "05/12/2024",
            status = "Conclu√≠do",
            price = 200.00
        )
    )
    
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Meus Servi√ßos",
                onBackClick = onNavigateBack
            )
        }
    ) { padding ->
        LazyColumn(
            modifier = Modifier
                .fillMaxSize()
                .padding(padding)
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            item {
                Text(
                    text = "Hist√≥rico de Servi√ßos",
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold
                )
                Spacer(modifier = Modifier.height(16.dp))
            }
            
            items(services) { service ->
                Card(
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Column(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(16.dp)
                    ) {
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Icon(
                                imageVector = Icons.Default.Build,
                                contentDescription = null,
                                tint = MaterialTheme.colorScheme.primary
                            )
                            Spacer(modifier = Modifier.width(12.dp))
                            Column(
                                modifier = Modifier.weight(1f)
                            ) {
                                Text(
                                    text = service.title,
                                    style = MaterialTheme.typography.titleSmall,
                                    fontWeight = FontWeight.Bold
                                )
                                Text(
                                    text = "Prestador: ${service.provider}",
                                    style = MaterialTheme.typography.bodyMedium,
                                    color = MaterialTheme.colorScheme.onSurfaceVariant
                                )
                            }
                            AssistChip(
                                onClick = { },
                                label = { Text(service.status) }
                            )
                        }
                        
                        Spacer(modifier = Modifier.height(12.dp))
                        
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.SpaceBetween,
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Column {
                                Text(
                                    text = "Data: ${service.date}",
                                    style = MaterialTheme.typography.bodyMedium
                                )
                                Text(
                                    text = "Valor: R$ %.2f".format(service.price),
                                    style = MaterialTheme.typography.bodyMedium,
                                    fontWeight = FontWeight.Medium
                                )
                            }
                            
                            Row {
                                IconButton(onClick = { /* Ver detalhes */ }) {
                                    Icon(Icons.Default.Visibility, contentDescription = "Ver detalhes")
                                }
                                IconButton(onClick = { /* Avaliar */ }) {
                                    Icon(Icons.Default.Star, contentDescription = "Avaliar")
                                }
                            }
                        }
                    }
                }
            }
            
            if (services.isEmpty()) {
                item {
                    Box(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(32.dp),
                        contentAlignment = Alignment.Center
                    ) {
                        Column(
                            horizontalAlignment = Alignment.CenterHorizontally
                        ) {
                            Icon(
                                imageVector = Icons.Default.Build,
                                contentDescription = null,
                                modifier = Modifier.size(64.dp),
                                tint = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                            Spacer(modifier = Modifier.height(16.dp))
                            Text(
                                text = "Nenhum servi√ßo encontrado",
                                style = MaterialTheme.typography.titleMedium,
                                color = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                            Text(
                                text = "Contrate seu primeiro servi√ßo",
                                style = MaterialTheme.typography.bodyMedium,
                                color = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                        }
                    }
                }
            }
        }
    }
}

data class ServiceItem(
    val id: Int,
    val title: String,
    val provider: String,
    val date: String,
    val status: String,
    val price: Double
)

```

## [FRONTEND]: feature/profile/presentation/ProfileScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.profile.presentation

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowForward
import androidx.compose.material.icons.automirrored.filled.Assignment
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.collectAsState
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.hilt.navigation.compose.hiltViewModel
import coil.compose.AsyncImage
import com.taskgoapp.taskgo.core.theme.TaskGoGreen
import com.taskgoapp.taskgo.core.theme.TaskGoTextDark
import com.taskgoapp.taskgo.core.theme.TaskGoTextGray
import com.taskgoapp.taskgo.core.model.AccountType

@Composable
fun ProfileScreen(
    onNavigateToSettings: () -> Unit,
    onNavigateToMyOrders: () -> Unit,
    onNavigateToMyServices: () -> Unit,
    onNavigateToMyProducts: () -> Unit,
    onNavigateToMyServiceOrders: () -> Unit = {},
    onNavigateToUserReviews: ((String, String) -> Unit)? = null, // userId, userName
    onNavigateToAboutMe: () -> Unit = {},
    modifier: Modifier = Modifier
) {
    val viewModel: ProfileViewModel = hiltViewModel()
    val uiState by viewModel.uiState.collectAsState()
    
    LazyColumn(
        modifier = modifier
            .fillMaxSize()
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        if (uiState.isLoading) {
            item {
                CircularProgressIndicator(
                    modifier = Modifier.padding(32.dp)
                )
            }
        } else if (uiState.error != null) {
            item {
                Text(
                    text = uiState.error ?: "Erro ao carregar perfil",
                    color = MaterialTheme.colorScheme.error,
                    textAlign = TextAlign.Center,
                    modifier = Modifier.fillMaxWidth()
                )
            }
        } else {
            item {
                // Header do perfil com dados reais do Firestore
                ProfileHeader(
                    name = uiState.name,
                    email = uiState.email,
                    avatarUri = uiState.avatarUri,
                    rating = uiState.rating?.toFloat() ?: 0f,
                    servicesCount = 0, // TODO: Adicionar contagem de servi√ßos quando necess√°rio
                    onHeaderClick = {
                        // Abrir tela "Sobre mim" ao clicar no card
                        onNavigateToAboutMe()
                    }
                )
            }
            
            item {
                // Menu de op√ß√µes
                ProfileMenu(
                    onNavigateToSettings = onNavigateToSettings,
                    onNavigateToMyOrders = onNavigateToMyOrders,
                    onNavigateToMyServices = onNavigateToMyServices,
                    onNavigateToMyProducts = onNavigateToMyProducts,
                    onNavigateToMyServiceOrders = onNavigateToMyServiceOrders,
                    accountType = uiState.accountType
                )
            }
        }
    }
}

@Composable
private fun ProfileHeader(
    name: String,
    email: String,
    avatarUri: String?,
    rating: Float,
    servicesCount: Int,
    onHeaderClick: () -> Unit = {},
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier
            .fillMaxWidth()
            .padding(horizontal = 0.dp)
            .clickable { onHeaderClick() },
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(24.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            // Avatar com foto do perfil ou √≠cone padr√£o
            Box(
                modifier = Modifier
                    .size(100.dp)
                    .clip(CircleShape)
                    .background(TaskGoGreen.copy(alpha = 0.1f)),
                contentAlignment = Alignment.Center
            ) {
                if (!avatarUri.isNullOrBlank()) {
                    AsyncImage(
                        model = avatarUri,
                        contentDescription = "Foto do perfil",
                        modifier = Modifier
                            .fillMaxSize()
                            .clip(CircleShape),
                        contentScale = ContentScale.Crop
                    )
                } else {
                    Icon(
                        imageVector = Icons.Default.Person,
                        contentDescription = "Avatar",
                        modifier = Modifier.size(50.dp),
                        tint = TaskGoGreen
                    )
                }
            }
            
            Spacer(modifier = Modifier.height(20.dp))
            
            // Nome do usu√°rio - centralizado
            Text(
                text = name.ifBlank { "Usu√°rio" },
                fontSize = 22.sp,
                fontWeight = FontWeight.Bold,
                color = TaskGoTextDark,
                textAlign = TextAlign.Center,
                modifier = Modifier.fillMaxWidth()
            )
            
            Spacer(modifier = Modifier.height(8.dp))
            
            // Email - centralizado
            Text(
                text = email.ifBlank { "Email n√£o dispon√≠vel" },
                fontSize = 14.sp,
                color = TaskGoTextGray,
                textAlign = TextAlign.Center,
                modifier = Modifier.fillMaxWidth()
            )
            
            Spacer(modifier = Modifier.height(20.dp))
            
            // Estat√≠sticas - centralizadas
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.Center,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Column(
                    horizontalAlignment = Alignment.CenterHorizontally,
                    modifier = Modifier.padding(horizontal = 16.dp)
                ) {
                    Text(
                        text = "‚≠ê $rating",
                        fontSize = 18.sp,
                        fontWeight = FontWeight.SemiBold,
                        color = TaskGoTextDark,
                        textAlign = TextAlign.Center
                    )
                    Spacer(modifier = Modifier.height(4.dp))
                    Text(
                        text = "Avalia√ß√£o",
                        fontSize = 12.sp,
                        color = TaskGoTextGray,
                        textAlign = TextAlign.Center
                    )
                }
                
                // Divisor vertical
                VerticalDivider(
                    modifier = Modifier
                        .height(40.dp)
                        .width(1.dp),
                    color = TaskGoTextGray.copy(alpha = 0.2f)
                )
                
                Column(
                    horizontalAlignment = Alignment.CenterHorizontally,
                    modifier = Modifier.padding(horizontal = 16.dp)
                ) {
                    Text(
                        text = "$servicesCount",
                        fontSize = 18.sp,
                        fontWeight = FontWeight.SemiBold,
                        color = TaskGoTextDark,
                        textAlign = TextAlign.Center
                    )
                    Spacer(modifier = Modifier.height(4.dp))
                    Text(
                        text = "Servi√ßos",
                        fontSize = 12.sp,
                        color = TaskGoTextGray,
                        textAlign = TextAlign.Center
                    )
                }
            }
        }
    }
}

@Composable
private fun ProfileMenu(
    onNavigateToSettings: () -> Unit,
    onNavigateToMyOrders: () -> Unit,
    onNavigateToMyServices: () -> Unit,
    onNavigateToMyProducts: () -> Unit,
    onNavigateToMyServiceOrders: () -> Unit,
    accountType: AccountType = AccountType.CLIENTE,
    modifier: Modifier = Modifier
) {
    val menuItems = when (accountType) {
        AccountType.PARCEIRO, AccountType.PRESTADOR, AccountType.VENDEDOR -> listOf(
            // Unificar menu items para Parceiro: Servi√ßos + Produtos
            ProfileMenuItem(
                title = "Meus Servi√ßos",
                icon = Icons.Default.Build,
                onClick = onNavigateToMyServices
            ),
            ProfileMenuItem(
                title = "Meus Produtos",
                icon = Icons.Default.Inventory,
                onClick = onNavigateToMyProducts
            ),
            ProfileMenuItem(
                title = "Meus Pedidos",
                icon = Icons.Default.ShoppingBag,
                onClick = onNavigateToMyOrders
            ),
            // Removido "Minhas Ordens de Servi√ßo" - parceiros n√£o geram ordens, apenas recebem
            ProfileMenuItem(
                title = "Configura√ß√µes",
                icon = Icons.Default.Settings,
                onClick = onNavigateToSettings
            )
        )
        else -> listOf( // CLIENTE
            ProfileMenuItem(
                title = "Minhas Ordens de Servi√ßo",
                icon = Icons.AutoMirrored.Filled.Assignment,
                onClick = onNavigateToMyServiceOrders
            ),
            ProfileMenuItem(
                title = "Meus Pedidos",
                icon = Icons.Default.ShoppingBag,
                onClick = onNavigateToMyOrders
            ),
            ProfileMenuItem(
                title = "Configura√ß√µes",
                icon = Icons.Default.Settings,
                onClick = onNavigateToSettings
            )
        )
    }
    
    Card(
        modifier = modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
    ) {
        Column {
            menuItems.forEachIndexed { index, item ->
                ProfileMenuRow(
                    item = item,
                    showDivider = index < menuItems.size - 1
                )
            }
        }
    }
}

@Composable
private fun ProfileMenuRow(
    item: ProfileMenuItem,
    showDivider: Boolean,
    modifier: Modifier = Modifier
) {
    Column {
        Row(
            modifier = modifier
                .fillMaxWidth()
                .clickable { item.onClick() }
                .padding(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Icon(
                imageVector = item.icon,
                contentDescription = item.title,
                tint = TaskGoGreen,
                modifier = Modifier.size(24.dp)
            )
            
            Spacer(modifier = Modifier.width(16.dp))
            
            Text(
                text = item.title,
                fontSize = 16.sp,
                color = TaskGoTextDark,
                modifier = Modifier.weight(1f)
            )
            
            Icon(
                imageVector = Icons.AutoMirrored.Filled.ArrowForward,
                contentDescription = "Ir",
                tint = TaskGoTextGray,
                modifier = Modifier.size(20.dp)
            )
        }
        
        if (showDivider) {
            HorizontalDivider(
                color = TaskGoTextGray.copy(alpha = 0.2f),
                thickness = 1.dp
            )
        }
    }
}

data class ProfileMenuItem(
    val title: String,
    val icon: androidx.compose.ui.graphics.vector.ImageVector,
    val onClick: () -> Unit
)
```

## [FRONTEND]: feature/profile/presentation/ProfileViewModel.kt

```kotlin
package com.taskgoapp.taskgo.feature.profile.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import android.content.Context
import android.util.Log
import com.taskgoapp.taskgo.core.data.PreferencesManager
import com.taskgoapp.taskgo.core.model.AccountType
import com.taskgoapp.taskgo.core.model.Address
import com.taskgoapp.taskgo.core.model.UserProfile
import com.taskgoapp.taskgo.data.firestore.models.UserFirestore
import java.util.Date
import com.taskgoapp.taskgo.data.repository.FirebaseAuthRepository
import com.taskgoapp.taskgo.data.repository.FirestoreUserRepository
import com.taskgoapp.taskgo.data.repository.FirebaseStorageRepository
import com.taskgoapp.taskgo.domain.repository.UserRepository
import android.net.Uri
import dagger.hilt.android.lifecycle.HiltViewModel
import dagger.hilt.android.qualifiers.ApplicationContext
import javax.inject.Inject
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.flow.flowOn
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.launch
import kotlinx.coroutines.Dispatchers

data class ProfileState(
    val id: String = "",
    val name: String = "",
    val email: String = "",
    val phone: String = "",
    val city: String = "",
    val profession: String = "",
    val accountType: AccountType = AccountType.CLIENTE,
    val rating: Double? = null,
    val avatarUri: String? = null,
    val profileImages: List<String> = emptyList(),
    val isSaving: Boolean = false,
    val saved: Boolean = false,
    val error: String? = null,
    val isLoading: Boolean = true,
    val createdAt: Date? = null,
    // Novos campos
    val cpf: String = "",
    val rg: String = "",
    val state: String = "",
    val country: String = "Brasil",
    val street: String = "",
    val number: String = "",
    val neighborhood: String = "",
    val zipCode: String = "",
    val complement: String = ""
)

@HiltViewModel
class ProfileViewModel @Inject constructor(
    private val userRepository: UserRepository,
    private val authRepository: FirebaseAuthRepository,
    private val firestoreUserRepository: FirestoreUserRepository,
    private val storageRepository: FirebaseStorageRepository,
    @ApplicationContext private val context: Context
) : ViewModel() {
    
    private val preferencesManager = PreferencesManager(context)
    private val TAG = "ProfileViewModel"

    private val _uiState = MutableStateFlow(ProfileState())
    val uiState: StateFlow<ProfileState> = _uiState.asStateFlow()

    init {
        // Carregar dados do PreferencesManager primeiro
        loadFromPreferences()
        
        // Carregar dados reais do Firebase Auth/Firestore
        loadUserProfile()
        
        // Tamb√©m observar mudan√ßas do UserRepository (para sincroniza√ß√£o)
        viewModelScope.launch {
            userRepository.observeCurrentUser()
                .flowOn(Dispatchers.IO)
                .collectLatest { user ->
                    user?.let { 
                        // Atualizar apenas se os dados do Firebase n√£o estiverem dispon√≠veis
                        if (_uiState.value.name.isBlank() && _uiState.value.email.isBlank()) {
                            setFromUser(it)
                        }
                    }
                }
        }
    }
    
    private fun loadUserProfile() {
        val currentUser = authRepository.getCurrentUser()
        if (currentUser == null) {
            _uiState.value = _uiState.value.copy(
                isLoading = false,
                error = "Usu√°rio n√£o autenticado"
            )
            return
        }

        _uiState.value = _uiState.value.copy(isLoading = true, error = null)
        
        viewModelScope.launch(Dispatchers.IO) {
            try {
                Log.d(TAG, "Carregando perfil do usu√°rio: ${currentUser.uid}")
                
                // CR√çTICO: Buscar diretamente do Firestore, n√£o usar cache local
                val userFirestore = firestoreUserRepository.getUser(currentUser.uid)
                val savedAvatarUri = preferencesManager.getUserAvatarUri()
                val profileImages = preferencesManager.getUserProfileImages()
                
                if (userFirestore != null) {
                    Log.d(TAG, "Usu√°rio encontrado no Firestore: ${userFirestore.displayName}")
                    
                    // CR√çTICO: Verificar se o usu√°rio do Firestore pertence ao usu√°rio autenticado
                    if (userFirestore.uid != currentUser.uid) {
                        Log.e(TAG, "ERRO CR√çTICO: Usu√°rio do Firestore n√£o corresponde ao usu√°rio autenticado: ${userFirestore.uid} != ${currentUser.uid}")
                        _uiState.value = _uiState.value.copy(
                            isLoading = false,
                            error = "Erro ao carregar perfil: dados de usu√°rio incorretos"
                        )
                        return@launch
                    }
                    
                    // CR√çTICO: Usar apenas dados do Firestore do usu√°rio atual
                    val finalAvatarUri = userFirestore.photoURL ?: currentUser.photoUrl?.toString()
                    
                    val roleString = userFirestore.role?.lowercase() ?: ""
                    val accountType = when (roleString) {
                        "provider" -> AccountType.PARCEIRO // Legacy - migrar para partner
                        "seller" -> AccountType.PARCEIRO // Legacy - migrar para partner
                        "partner" -> AccountType.PARCEIRO // Novo role unificado
                        else -> AccountType.CLIENTE
                    }
                    
                    // Atualizar estado com dados do Firestore (fonte de verdade)
                    _uiState.value = _uiState.value.copy(
                        isLoading = false,
                        id = currentUser.uid,
                        name = userFirestore.displayName ?: currentUser.displayName ?: "",
                        email = (userFirestore.email ?: currentUser.email ?: "").ifBlank { currentUser.email ?: "" },
                        phone = userFirestore.phone ?: currentUser.phoneNumber ?: "",
                        avatarUri = finalAvatarUri,
                        profileImages = emptyList(), // N√£o usar cache local
                        cpf = userFirestore.cpf ?: "",
                        rg = userFirestore.rg ?: "",
                        city = userFirestore.address?.city ?: "",
                        state = userFirestore.address?.state ?: "",
                        country = userFirestore.address?.country ?: "Brasil",
                        street = userFirestore.address?.street ?: "",
                        number = userFirestore.address?.number ?: "",
                        neighborhood = userFirestore.address?.neighborhood ?: "",
                        zipCode = userFirestore.address?.zipCode ?: userFirestore.address?.cep ?: "",
                        complement = userFirestore.address?.complement ?: "",
                        createdAt = userFirestore.createdAt,
                        rating = userFirestore.rating,
                        accountType = accountType
                    )
                } else {
                    // Se n√£o existe no Firestore, usar dados do Firebase Auth
                    Log.d(TAG, "Usu√°rio n√£o encontrado no Firestore, usando Firebase Auth")
                    _uiState.value = _uiState.value.copy(
                        isLoading = false,
                        id = currentUser.uid,
                        name = currentUser.displayName ?: "",
                        email = currentUser.email ?: "",
                        phone = currentUser.phoneNumber ?: "",
                        avatarUri = currentUser.photoUrl?.toString(),
                        profileImages = emptyList(), // N√£o usar cache local
                        accountType = AccountType.CLIENTE
                    )
                }
            } catch (e: Exception) {
                Log.e(TAG, "Erro ao carregar perfil: ${e.message}", e)
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = "Erro ao carregar perfil: ${e.message}"
                )
            }
        }
    }
    
    private fun loadFromPreferences() {
        val profileImages = preferencesManager.getUserProfileImages()
        val avatarUri = preferencesManager.getUserAvatarUri()
        Log.d(TAG, "Carregando do PreferencesManager - avatarUri: $avatarUri")
        _uiState.value = _uiState.value.copy(
            profileImages = profileImages,
            avatarUri = avatarUri
        )
    }

    private fun setFromUser(user: UserProfile) {
        // Priorizar avatarUri do PreferencesManager se existir
        val savedAvatarUri = preferencesManager.getUserAvatarUri()
        Log.d(TAG, "setFromUser - savedAvatarUri: $savedAvatarUri, user.avatarUri: ${user.avatarUri}")
        
        _uiState.value = _uiState.value.copy(
            id = user.id,
            name = user.name,
            email = user.email,
            phone = user.phone.orEmpty(),
            city = user.city.orEmpty(),
            profession = user.profession.orEmpty(),
            accountType = user.accountType,
            rating = user.rating,
            avatarUri = savedAvatarUri ?: user.avatarUri,
            profileImages = user.profileImages ?: emptyList()
        )
    }

    fun onNameChange(v: String) { _uiState.value = _uiState.value.copy(name = v) }
    fun onEmailChange(v: String) { _uiState.value = _uiState.value.copy(email = v) }
    fun onPhoneChange(v: String) { _uiState.value = _uiState.value.copy(phone = v) }
    fun onCityChange(v: String) { _uiState.value = _uiState.value.copy(city = v) }
    fun onProfessionChange(v: String) { _uiState.value = _uiState.value.copy(profession = v) }
    fun onAccountTypeChange(v: AccountType) { _uiState.value = _uiState.value.copy(accountType = v) }
    fun onCpfChange(v: String) { _uiState.value = _uiState.value.copy(cpf = v) }
    fun onRgChange(v: String) { _uiState.value = _uiState.value.copy(rg = v) }
    fun onStateChange(v: String) { _uiState.value = _uiState.value.copy(state = v) }
    fun onCountryChange(v: String) { _uiState.value = _uiState.value.copy(country = v) }
    fun onStreetChange(v: String) { _uiState.value = _uiState.value.copy(street = v) }
    fun onNumberChange(v: String) { _uiState.value = _uiState.value.copy(number = v) }
    fun onNeighborhoodChange(v: String) { _uiState.value = _uiState.value.copy(neighborhood = v) }
    fun onZipCodeChange(v: String) { _uiState.value = _uiState.value.copy(zipCode = v) }
    fun onComplementChange(v: String) { _uiState.value = _uiState.value.copy(complement = v) }

    fun onAvatarSelected(uri: String) {
        Log.d(TAG, "onAvatarSelected chamado com URI: $uri")
        val currentUser = authRepository.getCurrentUser()
        if (currentUser == null) {
            Log.e(TAG, "Usu√°rio n√£o autenticado ao selecionar avatar")
            return
        }
        
        viewModelScope.launch(Dispatchers.IO) {
            try {
                // Se a URI √© uma URL HTTP/HTTPS, j√° est√° no Storage, apenas salvar
                if (uri.startsWith("http://") || uri.startsWith("https://")) {
                    _uiState.value = _uiState.value.copy(avatarUri = uri)
                    preferencesManager.saveUserAvatarUri(uri)
                    Log.d(TAG, "Avatar j√° est√° no Storage, apenas atualizado localmente")
                } else {
                    // Fazer upload para Firebase Storage
                    val uriObj = Uri.parse(uri)
                    val uploadResult = storageRepository.uploadProfileImage(currentUser.uid, uriObj)
                    uploadResult.fold(
                        onSuccess = { downloadUrl ->
                            Log.d(TAG, "Avatar enviado para Firebase Storage: $downloadUrl")
                            _uiState.value = _uiState.value.copy(avatarUri = downloadUrl)
                            preferencesManager.saveUserAvatarUri(downloadUrl)
                            // Atualizar no Firestore imediatamente
                            val existingUser = firestoreUserRepository.getUser(currentUser.uid)
                            existingUser?.let {
                                firestoreUserRepository.updateUser(it.copy(photoURL = downloadUrl, updatedAt = Date()))
                            }
                        },
                        onFailure = { e ->
                            Log.e(TAG, "Erro ao fazer upload do avatar: ${e.message}", e)
                            // Mesmo assim, salvar localmente para uso offline
                            _uiState.value = _uiState.value.copy(avatarUri = uri)
                            preferencesManager.saveUserAvatarUri(uri)
                        }
                    )
                }
            } catch (e: Exception) {
                Log.e(TAG, "Erro ao processar avatar: ${e.message}", e)
                // Fallback: salvar localmente
                _uiState.value = _uiState.value.copy(avatarUri = uri)
                preferencesManager.saveUserAvatarUri(uri)
            }
        }
    }

    fun onProfileImagesChanged(images: List<String>) {
        _uiState.value = _uiState.value.copy(profileImages = images)
        viewModelScope.launch(Dispatchers.IO) {
            preferencesManager.saveUserProfileImages(images)
        }
    }

    fun refresh() {
        loadUserProfile()
    }

    fun save() {
        val s = _uiState.value
        val currentUser = authRepository.getCurrentUser()
        if (currentUser == null) {
            _uiState.value = s.copy(error = "Usu√°rio n√£o autenticado")
            return
        }
        
        viewModelScope.launch(Dispatchers.IO) {
            try {
                _uiState.value = s.copy(isSaving = true, saved = false, error = null)
                
                // Salvar imagens e avatar no PreferencesManager
                preferencesManager.saveUserProfileImages(s.profileImages)
                s.avatarUri?.let { preferencesManager.saveUserAvatarUri(it) }
                
                // Criar objeto Address
                val address = if (s.street.isNotEmpty() || s.city.isNotEmpty()) {
                    Address(
                        street = s.street,
                        number = s.number,
                        complement = s.complement.ifBlank { null },
                        neighborhood = s.neighborhood,
                        city = s.city,
                        state = s.state,
                        country = s.country,
                        zipCode = s.zipCode,
                        cep = s.zipCode
                    )
                } else null
                
                // Buscar usu√°rio atual do Firestore ou criar novo
                val existingUser = firestoreUserRepository.getUser(currentUser.uid)
                val role = when (s.accountType) {
                    AccountType.PARCEIRO -> "partner" // Novo role unificado
                    AccountType.PRESTADOR -> "partner" // Legacy - migrar para partner
                    AccountType.VENDEDOR -> "partner" // Legacy - migrar para partner
                    AccountType.CLIENTE -> "client"
                }
                
                val userFirestore = existingUser?.copy(
                    displayName = s.name,
                    email = s.email,
                    phone = s.phone.ifBlank { null },
                    cpf = s.cpf.ifBlank { null },
                    rg = s.rg.ifBlank { null },
                    address = address,
                    photoURL = s.avatarUri,
                    role = role,
                    updatedAt = Date()
                ) ?: UserFirestore(
                    uid = currentUser.uid,
                    email = s.email,
                    displayName = s.name,
                    phone = s.phone.ifBlank { null },
                    cpf = s.cpf.ifBlank { null },
                    rg = s.rg.ifBlank { null },
                    address = address,
                    photoURL = s.avatarUri,
                    role = role,
                    profileComplete = true,
                    verified = currentUser.isEmailVerified,
                    createdAt = Date(),
                    updatedAt = Date()
                )
                
                // Criar UserProfile para salvar localmente PRIMEIRO (instant√¢neo)
                val user = UserProfile(
                    id = currentUser.uid,
                    name = s.name,
                    email = s.email,
                    phone = s.phone.ifBlank { null },
                    city = s.city.ifBlank { null },
                    profession = s.profession.ifBlank { null },
                    accountType = s.accountType,
                    rating = s.rating,
                    avatarUri = s.avatarUri,
                    profileImages = s.profileImages
                )
                
                // Salvar no banco local PRIMEIRO para atualiza√ß√£o instant√¢nea
                userRepository.updateUser(user)
                
                // Depois salvar no Firestore
                firestoreUserRepository.updateUser(userFirestore)
                
                _uiState.value = _uiState.value.copy(isSaving = false, saved = true)
                Log.d(TAG, "Perfil salvo com sucesso no Firestore e banco local")
            } catch (e: Exception) {
                Log.e(TAG, "Erro ao salvar perfil: ${e.message}", e)
                _uiState.value = _uiState.value.copy(isSaving = false, error = e.message ?: "Erro ao salvar perfil")
            }
        }
    }
}



```

## [FRONTEND]: feature/profile/presentation/ProfileViewModelFirestore.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.profile.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.taskgoapp.taskgo.data.repository.FirebaseAuthRepository
import com.taskgoapp.taskgo.data.repository.FirestoreUserRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

data class ProfileUiState(
    val isLoading: Boolean = false,
    val name: String = "",
    val email: String = "",
    val phone: String = "",
    val rating: Double? = null,
    val servicesCount: Int = 0,
    val role: String = "client",
    val error: String? = null
)

@HiltViewModel
class ProfileViewModelFirestore @Inject constructor(
    private val authRepository: FirebaseAuthRepository,
    private val firestoreUserRepository: FirestoreUserRepository
) : ViewModel() {

    private val _uiState = MutableStateFlow(ProfileUiState())
    val uiState: StateFlow<ProfileUiState> = _uiState.asStateFlow()

    init {
        loadUserProfile()
    }

    private fun loadUserProfile() {
        val currentUser = authRepository.getCurrentUser()
        if (currentUser == null) {
            _uiState.value = ProfileUiState(error = "Usu√°rio n√£o autenticado")
            return
        }

        _uiState.value = ProfileUiState(isLoading = true)
        
        viewModelScope.launch {
            try {
                val userFirestore = firestoreUserRepository.getUser(currentUser.uid)
                
                if (userFirestore != null) {
                    _uiState.value = ProfileUiState(
                        isLoading = false,
                        name = userFirestore.displayName ?: currentUser.displayName ?: "",
                        email = userFirestore.email,
                        phone = "", // Pode ser adicionado ao modelo UserFirestore se necess√°rio
                        rating = null, // Pode ser calculado a partir de avalia√ß√µes se necess√°rio
                        servicesCount = 0, // Pode ser contado a partir de servi√ßos do usu√°rio
                        role = userFirestore.role
                    )
                } else {
                    // Se n√£o existe no Firestore, usar dados do Firebase Auth
                    _uiState.value = ProfileUiState(
                        isLoading = false,
                        name = currentUser.displayName ?: "",
                        email = currentUser.email ?: "",
                        phone = currentUser.phoneNumber ?: "",
                        role = "client"
                    )
                }
            } catch (e: Exception) {
                _uiState.value = ProfileUiState(
                    isLoading = false,
                    error = "Erro ao carregar perfil: ${e.message}"
                )
            }
        }
    }

    fun refresh() {
        loadUserProfile()
    }
}


```

## [FRONTEND]: feature/profile/presentation/ProviderProfileScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.profile.presentation

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.collectAsState
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.platform.LocalContext
import androidx.compose.foundation.clickable
import androidx.hilt.navigation.compose.hiltViewModel
import coil.compose.AsyncImage
import coil.request.ImageRequest
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.design.PrimaryButton
import com.taskgoapp.taskgo.core.design.SecondaryButton
import com.taskgoapp.taskgo.core.theme.*
import java.text.NumberFormat
import java.util.Locale

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ProviderProfileScreen(
    providerId: String,
    isStore: Boolean = false,
    onBackClick: () -> Unit,
    onRateClick: (String) -> Unit,
    onMessageClick: (String) -> Unit,
    onServiceClick: (String) -> Unit,
    viewModel: ProviderProfileViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    val services by viewModel.services.collectAsState()
    val reviews by viewModel.reviews.collectAsState()
    
    LaunchedEffect(providerId) {
        viewModel.loadProfile(providerId, isStore)
    }
    
    Scaffold(
        topBar = {
            AppTopBar(
                title = if (isStore) "Perfil da Loja" else "Perfil do Prestador",
                onBackClick = onBackClick
            )
        },
        bottomBar = {
            Surface(
                modifier = Modifier.fillMaxWidth(),
                shadowElevation = 8.dp
            ) {
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp),
                    horizontalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    SecondaryButton(
                        text = "Avaliar",
                        onClick = { onRateClick(providerId) },
                        modifier = Modifier.weight(1f)
                    )
                    PrimaryButton(
                        text = "Enviar Mensagem",
                        onClick = { onMessageClick(providerId) },
                        modifier = Modifier.weight(1f)
                    )
                }
            }
        }
    ) { paddingValues ->
        LazyColumn(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues),
            contentPadding = PaddingValues(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // Header com foto e informa√ß√µes b√°sicas
            item {
                Column(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    // Foto do perfil
                    AsyncImage(
                        model = ImageRequest.Builder(LocalContext.current)
                            .data(uiState.profile?.photoURL)
                            .size(120)
                            .build(),
                        contentDescription = "Foto do perfil",
                        modifier = Modifier
                            .size(120.dp)
                            .clip(CircleShape)
                            .background(TaskGoBorder),
                        contentScale = ContentScale.Crop
                    )
                    
                    // Nome
                    Text(
                        text = uiState.profile?.displayName ?: "Carregando...",
                        style = MaterialTheme.typography.headlineSmall,
                        fontWeight = FontWeight.Bold,
                        color = TaskGoTextBlack
                    )
                    
                    // Tipo (Prestador ou Loja)
                    Text(
                        text = if (isStore) "Loja" else "Prestador de Servi√ßos",
                        style = MaterialTheme.typography.bodyMedium,
                        color = TaskGoTextGray
                    )
                    
                    // Avalia√ß√£o e n√∫mero de avalia√ß√µes
                    Row(
                        horizontalArrangement = Arrangement.spacedBy(8.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Icon(
                            imageVector = Icons.Default.Star,
                            contentDescription = "Avalia√ß√£o",
                            tint = Color(0xFFFFD700),
                            modifier = Modifier.size(20.dp)
                        )
                        Text(
                            text = "${uiState.profile?.rating ?: 0.0}",
                            style = MaterialTheme.typography.titleMedium,
                            fontWeight = FontWeight.Bold
                        )
                        Text(
                            text = "(${reviews.size} avalia√ß√µes)",
                            style = MaterialTheme.typography.bodySmall,
                            color = TaskGoTextGray
                        )
                    }
                }
            }
            
            // Informa√ß√µes de contato
            item {
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface)
                ) {
                    Column(
                        modifier = Modifier.padding(16.dp),
                        verticalArrangement = Arrangement.spacedBy(12.dp)
                    ) {
                        Text(
                            text = "Informa√ß√µes de Contato",
                            style = MaterialTheme.typography.titleMedium,
                            fontWeight = FontWeight.Bold
                        )
                        
                        uiState.profile?.email?.let { email ->
                            Row(
                                verticalAlignment = Alignment.CenterVertically,
                                horizontalArrangement = Arrangement.spacedBy(8.dp)
                            ) {
                                Icon(
                                    imageVector = Icons.Default.Email,
                                    contentDescription = "Email",
                                    modifier = Modifier.size(20.dp),
                                    tint = TaskGoGreen
                                )
                                Text(
                                    text = email,
                                    style = MaterialTheme.typography.bodyMedium
                                )
                            }
                        }
                        
                        uiState.profile?.phone?.let { phone ->
                            Row(
                                verticalAlignment = Alignment.CenterVertically,
                                horizontalArrangement = Arrangement.spacedBy(8.dp)
                            ) {
                                Icon(
                                    imageVector = Icons.Default.Phone,
                                    contentDescription = "Telefone",
                                    modifier = Modifier.size(20.dp),
                                    tint = TaskGoGreen
                                )
                                Text(
                                    text = phone,
                                    style = MaterialTheme.typography.bodyMedium
                                )
                            }
                        }
                        
                        uiState.profile?.address?.let { address ->
                            Row(
                                verticalAlignment = Alignment.Top,
                                horizontalArrangement = Arrangement.spacedBy(8.dp)
                            ) {
                                Icon(
                                    imageVector = Icons.Default.LocationOn,
                                    contentDescription = "Endere√ßo",
                                    modifier = Modifier.size(20.dp),
                                    tint = TaskGoGreen
                                )
                                Column {
                                    Text(
                                        text = "${address.street}, ${address.number}",
                                        style = MaterialTheme.typography.bodyMedium
                                    )
                                    Text(
                                        text = "${address.neighborhood}, ${address.city} - ${address.state}",
                                        style = MaterialTheme.typography.bodySmall,
                                        color = TaskGoTextGray
                                    )
                                }
                            }
                        }
                    }
                }
            }
            
            // Servi√ßos oferecidos (para prestadores) ou Produtos (para lojas)
            if (services.isNotEmpty()) {
                item {
                    Text(
                        text = if (isStore) "Produtos" else "Servi√ßos Oferecidos",
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold
                    )
                }
                
                items(services) { service ->
                    ServiceCard(
                        service = service,
                        isStore = isStore,
                        onClick = { onServiceClick(service.id) }
                    )
                }
            }
            
            // Avalia√ß√µes
            if (reviews.isNotEmpty()) {
                item {
                    Text(
                        text = "Avalia√ß√µes",
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold
                    )
                }
                
                items(reviews) { review ->
                    ReviewCard(review = review)
                }
            }
            
            // Estat√≠sticas
            item {
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface)
                ) {
                    Column(
                        modifier = Modifier.padding(16.dp),
                        verticalArrangement = Arrangement.spacedBy(12.dp)
                    ) {
                        Text(
                            text = "Estat√≠sticas",
                            style = MaterialTheme.typography.titleMedium,
                            fontWeight = FontWeight.Bold
                        )
                        
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.SpaceBetween
                        ) {
                            StatItem(
                                label = if (isStore) "Produtos" else "Servi√ßos",
                                value = services.size.toString()
                            )
                            StatItem(
                                label = "Avalia√ß√µes",
                                value = reviews.size.toString()
                            )
                            StatItem(
                                label = "Avalia√ß√£o M√©dia",
                                value = "${uiState.profile?.rating ?: 0.0}"
                            )
                        }
                    }
                }
            }
        }
    }
}

@Composable
private fun ServiceCard(
    service: com.taskgoapp.taskgo.data.firestore.models.ServiceFirestore,
    isStore: Boolean,
    onClick: () -> Unit
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .clickable { onClick() },
        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            horizontalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            if (service.images.isNotEmpty()) {
                AsyncImage(
                    model = ImageRequest.Builder(LocalContext.current)
                        .data(service.images.first())
                        .size(80)
                        .build(),
                    contentDescription = "Imagem do servi√ßo",
                    modifier = Modifier
                        .size(80.dp)
                        .clip(RoundedCornerShape(8.dp)),
                    contentScale = ContentScale.Crop
                )
            }
            
            Column(
                modifier = Modifier.weight(1f),
                verticalArrangement = Arrangement.spacedBy(4.dp)
            ) {
                Text(
                    text = service.title,
                    style = MaterialTheme.typography.titleSmall,
                    fontWeight = FontWeight.Bold
                )
                Text(
                    text = service.description,
                    style = MaterialTheme.typography.bodySmall,
                    color = TaskGoTextGray,
                    maxLines = 2
                )
                Text(
                    text = NumberFormat.getCurrencyInstance(Locale("pt", "BR")).format(service.price),
                    style = MaterialTheme.typography.titleSmall,
                    color = TaskGoGreen,
                    fontWeight = FontWeight.Bold
                )
            }
        }
    }
}

@Composable
private fun ReviewCard(
    review: com.taskgoapp.taskgo.data.firestore.models.ReviewFirestore
) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface)
    ) {
        Column(
            modifier = Modifier.padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = review.reviewerName.ifEmpty { "Cliente" },
                    style = MaterialTheme.typography.titleSmall,
                    fontWeight = FontWeight.Bold
                )
                Row(
                    horizontalArrangement = Arrangement.spacedBy(4.dp),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    repeat(review.rating.coerceIn(0, 5)) {
                        Icon(
                            imageVector = Icons.Default.Star,
                            contentDescription = "Estrela",
                            modifier = Modifier.size(16.dp),
                            tint = Color(0xFFFFD700)
                        )
                    }
                }
            }
            
            review.comment?.let { comment ->
                Text(
                    text = comment,
                    style = MaterialTheme.typography.bodyMedium,
                    color = TaskGoTextGray
                )
            }
            
            review.createdAt?.let { date ->
                Text(
                    text = java.text.SimpleDateFormat("dd/MM/yyyy", Locale("pt", "BR")).format(date),
                    style = MaterialTheme.typography.bodySmall,
                    color = TaskGoTextGray.copy(alpha = 0.7f)
                )
            }
        }
    }
}

@Composable
private fun StatItem(
    label: String,
    value: String
) {
    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.spacedBy(4.dp)
    ) {
        Text(
            text = value,
            style = MaterialTheme.typography.titleLarge,
            fontWeight = FontWeight.Bold,
            color = TaskGoGreen
        )
        Text(
            text = label,
            style = MaterialTheme.typography.bodySmall,
            color = TaskGoTextGray
        )
    }
}


```

## [FRONTEND]: feature/profile/presentation/ProviderProfileViewModel.kt

```kotlin
package com.taskgoapp.taskgo.feature.profile.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.taskgoapp.taskgo.data.firestore.models.UserFirestore
import com.taskgoapp.taskgo.data.firestore.models.ServiceFirestore
import com.taskgoapp.taskgo.data.firestore.models.ReviewFirestore
import com.taskgoapp.taskgo.data.repository.FirestoreUserRepository
import com.taskgoapp.taskgo.data.repository.FirestoreServicesRepository
import com.taskgoapp.taskgo.data.repository.FirestoreReviewsRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch
import javax.inject.Inject

data class ProviderProfileUiState(
    val isLoading: Boolean = false,
    val error: String? = null,
    val profile: UserFirestore? = null
)

@HiltViewModel
class ProviderProfileViewModel @Inject constructor(
    private val userRepository: FirestoreUserRepository,
    private val servicesRepository: FirestoreServicesRepository,
    private val reviewsRepository: FirestoreReviewsRepository
) : ViewModel() {
    
    private val _uiState = MutableStateFlow(ProviderProfileUiState())
    val uiState: StateFlow<ProviderProfileUiState> = _uiState.asStateFlow()
    
    private val _services = MutableStateFlow<List<ServiceFirestore>>(emptyList())
    val services: StateFlow<List<ServiceFirestore>> = _services.asStateFlow()
    
    private val _reviews = MutableStateFlow<List<ReviewFirestore>>(emptyList())
    val reviews: StateFlow<List<ReviewFirestore>> = _reviews.asStateFlow()
    
    fun loadProfile(providerId: String, isStore: Boolean) {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoading = true, error = null)
            
            try {
                // Carregar perfil do usu√°rio
                val profile = userRepository.getUser(providerId)
                _uiState.value = _uiState.value.copy(profile = profile, isLoading = false)
                
                // Observar servi√ßos do prestador
                if (!isStore) {
                    servicesRepository.observeProviderServices(providerId)
                        .collect { servicesList ->
                            _services.value = servicesList
                        }
                }
                
                // Observar avalia√ß√µes
                reviewsRepository.observeProviderReviews(providerId)
                    .collect { reviewsList ->
                        _reviews.value = reviewsList
                    }
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = e.message ?: "Erro ao carregar perfil"
                )
            }
        }
    }
}


```

## [FRONTEND]: feature/profile/presentation/PublicUserProfileScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.profile.presentation

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.lazy.grid.items
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.collectAsState
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import coil.compose.AsyncImage
import coil.request.ImageRequest
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.design.PrimaryButton
import com.taskgoapp.taskgo.core.design.SecondaryButton
import com.taskgoapp.taskgo.core.theme.*
import com.taskgoapp.taskgo.core.model.AccountType
import com.taskgoapp.taskgo.feature.feed.presentation.UserFeedScreen
import com.google.firebase.auth.FirebaseAuth
import java.text.NumberFormat
import java.util.Locale

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PublicUserProfileScreen(
    userId: String,
    onBackClick: () -> Unit,
    onMessageClick: (String) -> Unit = {},
    onRateClick: (String) -> Unit = {},
    onPostClick: (String) -> Unit = {},
    onServiceClick: (String) -> Unit = {},
    onProductClick: (String) -> Unit = {},
    viewModel: PublicUserProfileViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    val services by viewModel.services.collectAsState()
    val products by viewModel.products.collectAsState()
    val reviews by viewModel.reviews.collectAsState()
    val currentUserId = remember { FirebaseAuth.getInstance().currentUser?.uid ?: "" }
    val isOwnProfile = userId == currentUserId
    
    var selectedTabIndex by remember(userId) { mutableStateOf(0) }
    
    // Determinar tabs baseado no tipo de conta
    // Parceiro mostra tanto Servi√ßos quanto Produtos
    val tabs = remember(uiState.accountType) {
        when (uiState.accountType) {
            AccountType.PARCEIRO, AccountType.PRESTADOR, AccountType.VENDEDOR -> 
                listOf("Feed", "Servi√ßos", "Produtos", "Sobre") // Unificado para Parceiro
            else -> listOf("Feed", "Sobre")
        }
    }
    
    LaunchedEffect(userId) {
        viewModel.loadProfile(userId)
    }
    
    Scaffold(
        topBar = {
            AppTopBar(
                title = uiState.userProfile?.displayName ?: "Perfil",
                onBackClick = onBackClick
            )
        },
        bottomBar = {
            // Barra de a√ß√µes (apenas se n√£o for o pr√≥prio perfil)
            if (!isOwnProfile) {
                Surface(
                    modifier = Modifier.fillMaxWidth(),
                    shadowElevation = 8.dp
                ) {
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(16.dp),
                        horizontalArrangement = Arrangement.spacedBy(12.dp)
                    ) {
                        SecondaryButton(
                            text = "Avaliar",
                            onClick = { onRateClick(userId) },
                            modifier = Modifier.weight(1f)
                        )
                        SecondaryButton(
                            text = "Postar",
                            onClick = { onPostClick(userId) },
                            modifier = Modifier.weight(1f)
                        )
                        PrimaryButton(
                            text = "Mensagem",
                            onClick = { onMessageClick(userId) },
                            modifier = Modifier.weight(1f)
                        )
                    }
                }
            }
        }
    ) { paddingValues ->
        when {
            uiState.isLoading -> {
                Box(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(paddingValues),
                    contentAlignment = Alignment.Center
                ) {
                    CircularProgressIndicator(color = TaskGoGreen)
                }
            }
            
            uiState.error != null -> {
                Column(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(paddingValues)
                        .padding(16.dp),
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.Center
                ) {
                    Text(
                        text = uiState.error ?: "Erro desconhecido",
                        style = MaterialTheme.typography.bodyLarge,
                        color = MaterialTheme.colorScheme.error
                    )
                    Spacer(modifier = Modifier.height(16.dp))
                    Button(
                        onClick = { viewModel.loadProfile(userId) },
                        colors = ButtonDefaults.buttonColors(containerColor = TaskGoGreen)
                    ) {
                        Text("Tentar novamente")
                    }
                }
            }
            
            uiState.userProfile != null -> {
                val userProfile = uiState.userProfile!!
                Column(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(paddingValues)
                ) {
                    // Header do perfil (avatar, nome, tipo, avalia√ß√µes)
                    ProfileHeader(
                        userProfile = userProfile,
                        accountType = uiState.accountType,
                        reviews = reviews,
                        modifier = Modifier.fillMaxWidth()
                    )
                    
                    // TabRow
                    TabRow(
                        selectedTabIndex = selectedTabIndex,
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        tabs.forEachIndexed { index, title ->
                            Tab(
                                selected = selectedTabIndex == index,
                                onClick = { selectedTabIndex = index },
                                text = { Text(title) }
                            )
                        }
                    }
                    
                    // Conte√∫do baseado na aba selecionada
                    when (selectedTabIndex) {
                        0 -> {
                            // Feed - posts do usu√°rio
                            UserFeedScreen(
                                userId = userId,
                                modifier = Modifier.fillMaxSize()
                            )
                        }
                        1 -> {
                            // Aba Servi√ßos - para Parceiro e Prestador
                            when (uiState.accountType) {
                                AccountType.PARCEIRO, AccountType.PRESTADOR, AccountType.VENDEDOR -> {
                                    ServicesTabContent(
                                        services = services,
                                        onServiceClick = onServiceClick,
                                        modifier = Modifier.fillMaxSize()
                                    )
                                }
                                else -> {
                                    // Cliente n√£o tem servi√ßos
                                    EmptyTabContent(
                                        message = "Este usu√°rio n√£o oferece servi√ßos",
                                        modifier = Modifier.fillMaxSize()
                                    )
                                }
                            }
                        }
                        2 -> {
                            // Aba Produtos - para Parceiro e Vendedor
                            when (uiState.accountType) {
                                AccountType.PARCEIRO, AccountType.PRESTADOR, AccountType.VENDEDOR -> {
                                    ProductsTabContent(
                                        products = products,
                                        onProductClick = onProductClick,
                                        modifier = Modifier.fillMaxSize()
                                    )
                                }
                                else -> {
                                    // Cliente n√£o tem produtos
                                    EmptyTabContent(
                                        message = "Este usu√°rio n√£o vende produtos",
                                        modifier = Modifier.fillMaxSize()
                                    )
                                }
                            }
                        }
                        3 -> {
                            // Aba Sobre (ajustado √≠ndice para 4 tabs: Feed, Servi√ßos, Produtos, Sobre)
                            AboutTabContent(
                                userProfile = userProfile,
                                reviews = reviews,
                                modifier = Modifier.fillMaxSize()
                            )
                        }
                    }
                }
            }
        }
    }
}

@Composable
private fun ProfileHeader(
    userProfile: com.taskgoapp.taskgo.data.firestore.models.UserFirestore,
    accountType: AccountType?,
    reviews: List<com.taskgoapp.taskgo.data.firestore.models.ReviewFirestore>,
    modifier: Modifier = Modifier
) {
    val averageRating = remember(reviews) {
        if (reviews.isEmpty()) 0.0
        else reviews.map { it.rating.toDouble() }.average()
    }
    
    Card(
        modifier = modifier.padding(16.dp),
        shape = RoundedCornerShape(12.dp),
        colors = CardDefaults.cardColors(containerColor = TaskGoBackgroundWhite)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            // Avatar
            AsyncImage(
                model = ImageRequest.Builder(LocalContext.current)
                    .data(userProfile.photoURL)
                    .size(120)
                    .build(),
                contentDescription = "Avatar",
                modifier = Modifier
                    .size(120.dp)
                    .clip(CircleShape),
                contentScale = ContentScale.Crop
            )
            
            // Nome
            Text(
                text = userProfile.displayName ?: "Usu√°rio",
                style = MaterialTheme.typography.headlineSmall,
                fontWeight = FontWeight.Bold,
                color = TaskGoTextBlack
            )
            
            // Tipo de conta
            Text(
                text = when (accountType) {
                    AccountType.PARCEIRO -> "Parceiro"
                    AccountType.PRESTADOR -> "Parceiro" // Legacy
                    AccountType.VENDEDOR -> "Parceiro" // Legacy
                    else -> "Cliente"
                },
                style = MaterialTheme.typography.bodyMedium,
                color = TaskGoTextGray
            )
            
            // Avalia√ß√£o (se houver)
            if (reviews.isNotEmpty()) {
                Row(
                    horizontalArrangement = Arrangement.spacedBy(8.dp),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Icon(
                        imageVector = Icons.Default.Star,
                        contentDescription = null,
                        tint = TaskGoStarYellow,
                        modifier = Modifier.size(20.dp)
                    )
                    Text(
                        text = String.format(Locale.getDefault(), "%.1f", averageRating),
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold,
                        color = TaskGoTextBlack
                    )
                    Text(
                        text = "(${reviews.size} avalia√ß√µes)",
                        style = MaterialTheme.typography.bodySmall,
                        color = TaskGoTextGray
                    )
                }
            }
        }
    }
}

@Composable
private fun ServicesTabContent(
    services: List<com.taskgoapp.taskgo.data.firestore.models.ServiceFirestore>,
    onServiceClick: (String) -> Unit,
    modifier: Modifier = Modifier
) {
    if (services.isEmpty()) {
        EmptyTabContent(
            message = "Nenhum servi√ßo oferecido ainda",
            modifier = modifier
        )
    } else {
        LazyColumn(
            modifier = modifier,
            contentPadding = PaddingValues(16.dp),
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            items(services, key = { it.id }) { service ->
                ServiceCard(
                    service = service,
                    onClick = { onServiceClick(service.id) }
                )
            }
        }
    }
}

@Composable
private fun ProductsTabContent(
    products: List<com.taskgoapp.taskgo.data.firestore.models.ProductFirestore>,
    onProductClick: (String) -> Unit,
    modifier: Modifier = Modifier
) {
    if (products.isEmpty()) {
        EmptyTabContent(
            message = "Nenhum produto √† venda ainda",
            modifier = modifier
        )
    } else {
        LazyVerticalGrid(
            columns = GridCells.Fixed(2),
            modifier = modifier,
            contentPadding = PaddingValues(16.dp),
            horizontalArrangement = Arrangement.spacedBy(12.dp),
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            items(products, key = { it.id }) { product ->
                ProductCard(
                    product = product,
                    onClick = { onProductClick(product.id) }
                )
            }
        }
    }
}

@Composable
private fun AboutTabContent(
    userProfile: com.taskgoapp.taskgo.data.firestore.models.UserFirestore,
    reviews: List<com.taskgoapp.taskgo.data.firestore.models.ReviewFirestore>,
    modifier: Modifier = Modifier
) {
    LazyColumn(
        modifier = modifier,
        contentPadding = PaddingValues(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        item {
            Card(
                modifier = Modifier.fillMaxWidth(),
                shape = RoundedCornerShape(12.dp),
                colors = CardDefaults.cardColors(containerColor = TaskGoBackgroundWhite)
            ) {
                Column(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp),
                    verticalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    Text(
                        text = "Informa√ß√µes",
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold,
                        color = TaskGoTextBlack
                    )
                    
                    userProfile.address?.city?.let { city ->
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.spacedBy(8.dp)
                        ) {
                            Icon(
                                imageVector = Icons.Default.LocationOn,
                                contentDescription = null,
                                tint = TaskGoTextGray,
                                modifier = Modifier.size(20.dp)
                            )
                            Text(
                                text = city,
                                style = MaterialTheme.typography.bodyMedium,
                                color = TaskGoTextBlack
                            )
                        }
                    }
                    
                    userProfile.phone?.let { phone ->
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.spacedBy(8.dp)
                        ) {
                            Icon(
                                imageVector = Icons.Default.Phone,
                                contentDescription = null,
                                tint = TaskGoTextGray,
                                modifier = Modifier.size(20.dp)
                            )
                            Text(
                                text = phone,
                                style = MaterialTheme.typography.bodyMedium,
                                color = TaskGoTextBlack
                            )
                        }
                    }
                }
            }
        }
        
        if (reviews.isNotEmpty()) {
            item {
                Text(
                    text = "Avalia√ß√µes (${reviews.size})",
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold,
                    color = TaskGoTextBlack
                )
            }
            
            items(reviews, key = { it.id }) { review ->
                ReviewCard(review = review)
            }
        }
    }
}

@Composable
private fun EmptyTabContent(
    message: String,
    modifier: Modifier = Modifier
) {
    Box(
        modifier = modifier,
        contentAlignment = Alignment.Center
    ) {
        Text(
            text = message,
            style = MaterialTheme.typography.bodyMedium,
            color = TaskGoTextGray
        )
    }
}

@Composable
private fun ServiceCard(
    service: com.taskgoapp.taskgo.data.firestore.models.ServiceFirestore,
    onClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier
            .fillMaxWidth()
            .clickable(onClick = onClick),
        shape = RoundedCornerShape(12.dp),
        colors = CardDefaults.cardColors(containerColor = TaskGoBackgroundWhite)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(12.dp),
            horizontalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            // Imagem do servi√ßo (se houver)
            if (service.images.isNotEmpty()) {
                AsyncImage(
                    model = ImageRequest.Builder(LocalContext.current)
                        .data(service.images.first())
                        .size(80)
                        .build(),
                    contentDescription = null,
                    modifier = Modifier
                        .size(80.dp)
                        .clip(RoundedCornerShape(8.dp)),
                    contentScale = ContentScale.Crop
                )
            }
            
            Column(
                modifier = Modifier.weight(1f),
                verticalArrangement = Arrangement.spacedBy(4.dp)
            ) {
                Text(
                    text = service.title ?: "Servi√ßo",
                    style = MaterialTheme.typography.titleSmall,
                    fontWeight = FontWeight.Bold,
                    color = TaskGoTextBlack
                )
                Text(
                    text = service.description ?: "",
                    style = MaterialTheme.typography.bodySmall,
                    color = TaskGoTextGray,
                    maxLines = 2
                )
            }
        }
    }
}

@Composable
private fun ProductCard(
    product: com.taskgoapp.taskgo.data.firestore.models.ProductFirestore,
    onClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier
            .aspectRatio(0.75f)
            .clickable(onClick = onClick),
        shape = RoundedCornerShape(12.dp),
        colors = CardDefaults.cardColors(containerColor = TaskGoBackgroundWhite)
    ) {
        Column(
            modifier = Modifier.fillMaxSize()
        ) {
            // Imagem do produto
            if (product.imageUrls.isNotEmpty()) {
                AsyncImage(
                    model = ImageRequest.Builder(LocalContext.current)
                        .data(product.imageUrls.first())
                        .size(200)
                        .build(),
                    contentDescription = null,
                    modifier = Modifier
                        .fillMaxWidth()
                        .weight(1f)
                        .clip(RoundedCornerShape(topStart = 12.dp, topEnd = 12.dp)),
                    contentScale = ContentScale.Crop
                )
            } else {
                Box(
                    modifier = Modifier
                        .fillMaxWidth()
                        .weight(1f)
                        .background(MaterialTheme.colorScheme.surfaceVariant),
                    contentAlignment = Alignment.Center
                ) {
                    Icon(
                        imageVector = Icons.Default.Image,
                        contentDescription = null,
                        tint = MaterialTheme.colorScheme.onSurfaceVariant,
                        modifier = Modifier.size(48.dp)
                    )
                }
            }
            
            // Informa√ß√µes
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(8.dp),
                verticalArrangement = Arrangement.spacedBy(4.dp)
            ) {
                Text(
                    text = product.title.ifBlank { "Produto" },
                    style = MaterialTheme.typography.bodyMedium,
                    fontWeight = FontWeight.Bold,
                    color = TaskGoTextBlack,
                    maxLines = 2
                )
                Text(
                    text = NumberFormat.getCurrencyInstance(Locale("pt", "BR")).format(product.price),
                    style = MaterialTheme.typography.titleSmall,
                    fontWeight = FontWeight.Bold,
                    color = TaskGoGreen
                )
            }
        }
    }
}

@Composable
private fun ReviewCard(
    review: com.taskgoapp.taskgo.data.firestore.models.ReviewFirestore,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier.fillMaxWidth(),
        shape = RoundedCornerShape(12.dp),
        colors = CardDefaults.cardColors(containerColor = TaskGoBackgroundWhite)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(12.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = review.reviewerName.ifBlank { "An√¥nimo" },
                    style = MaterialTheme.typography.titleSmall,
                    fontWeight = FontWeight.Bold,
                    color = TaskGoTextBlack
                )
                Row(
                    horizontalArrangement = Arrangement.spacedBy(4.dp),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Icon(
                        imageVector = Icons.Default.Star,
                        contentDescription = null,
                        tint = TaskGoStarYellow,
                        modifier = Modifier.size(16.dp)
                    )
                    Text(
                        text = String.format(Locale.getDefault(), "%.1f", review.rating.toFloat()),
                        style = MaterialTheme.typography.bodySmall,
                        color = TaskGoTextBlack
                    )
                }
            }
            
            review.comment?.let { comment ->
                Text(
                    text = comment,
                    style = MaterialTheme.typography.bodyMedium,
                    color = TaskGoTextBlack
                )
            }
        }
    }
}






```

## [FRONTEND]: feature/profile/presentation/PublicUserProfileViewModel.kt

```kotlin
package com.taskgoapp.taskgo.feature.profile.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.taskgoapp.taskgo.core.model.AccountType
import com.taskgoapp.taskgo.data.firestore.models.ServiceFirestore
import com.taskgoapp.taskgo.data.firestore.models.UserFirestore
import com.taskgoapp.taskgo.data.repository.FirestoreUserRepository
import com.taskgoapp.taskgo.data.repository.FirestoreServicesRepository
import com.taskgoapp.taskgo.data.repository.FirestoreProductsRepository
import com.taskgoapp.taskgo.data.repository.FirestoreReviewsRepository
import com.taskgoapp.taskgo.data.firestore.models.ProductFirestore
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import javax.inject.Inject

data class PublicUserProfileUiState(
    val isLoading: Boolean = false,
    val error: String? = null,
    val userProfile: UserFirestore? = null,
    val accountType: AccountType? = null
)

@HiltViewModel
class PublicUserProfileViewModel @Inject constructor(
    private val userRepository: FirestoreUserRepository,
    private val servicesRepository: FirestoreServicesRepository,
    private val firestoreProductsRepository: FirestoreProductsRepository,
    private val reviewsRepository: FirestoreReviewsRepository
) : ViewModel() {
    
    private val _uiState = MutableStateFlow(PublicUserProfileUiState())
    val uiState: StateFlow<PublicUserProfileUiState> = _uiState.asStateFlow()
    
    // Servi√ßos (para PRESTADOR)
    private val _services = MutableStateFlow<List<ServiceFirestore>>(emptyList())
    val services: StateFlow<List<ServiceFirestore>> = _services.asStateFlow()
    
    // Produtos (para VENDEDOR)
    private val _products = MutableStateFlow<List<ProductFirestore>>(emptyList())
    val products: StateFlow<List<ProductFirestore>> = _products.asStateFlow()
    
    // Avalia√ß√µes
    private val _reviews = MutableStateFlow<List<com.taskgoapp.taskgo.data.firestore.models.ReviewFirestore>>(emptyList())
    val reviews: StateFlow<List<com.taskgoapp.taskgo.data.firestore.models.ReviewFirestore>> = _reviews.asStateFlow()
    
    fun loadProfile(userId: String) {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoading = true, error = null)
            
            try {
                // Carregar perfil do usu√°rio - aguardar resultado
                val profile = kotlinx.coroutines.withContext(kotlinx.coroutines.Dispatchers.IO) {
                    userRepository.getUser(userId)
                }
                
                if (profile == null) {
                    android.util.Log.w("PublicUserProfileVM", "Usu√°rio n√£o encontrado no Firestore: $userId")
                    // Tentar novamente ap√≥s um delay (pode ser que a Cloud Function ainda n√£o tenha criado)
                    kotlinx.coroutines.delay(1000)
                    val retryProfile = kotlinx.coroutines.withContext(kotlinx.coroutines.Dispatchers.IO) {
                        userRepository.getUser(userId)
                    }
                    
                    if (retryProfile == null) {
                        _uiState.value = _uiState.value.copy(
                            isLoading = false,
                            error = "Usu√°rio n√£o encontrado"
                        )
                        return@launch
                    }
                    
                    // Usar o perfil encontrado na segunda tentativa
                    val accountType = when (retryProfile.role.lowercase()) {
                        "provider" -> AccountType.PARCEIRO // Legacy - migrar para partner
                        "seller" -> AccountType.PARCEIRO // Legacy - migrar para partner
                        "partner" -> AccountType.PARCEIRO // Novo role unificado
                        else -> AccountType.CLIENTE
                    }
                    
                    _uiState.value = _uiState.value.copy(
                        userProfile = retryProfile,
                        accountType = accountType,
                        isLoading = false
                    )
                    
                    // Carregar dados espec√≠ficos
                    loadUserSpecificData(userId, accountType)
                    return@launch
                }
                
                // Determinar tipo de conta
                val accountType = when (profile.role.lowercase()) {
                    "provider" -> AccountType.PARCEIRO // Legacy - migrar para partner
                    "seller" -> AccountType.PARCEIRO // Legacy - migrar para partner
                    "partner" -> AccountType.PARCEIRO // Novo role unificado
                    else -> AccountType.CLIENTE
                }
                
                _uiState.value = _uiState.value.copy(
                    userProfile = profile,
                    accountType = accountType,
                    isLoading = false
                )
                
                // Carregar dados espec√≠ficos
                loadUserSpecificData(userId, accountType)
                    
            } catch (e: Exception) {
                android.util.Log.e("PublicUserProfileVM", "Erro ao carregar perfil: ${e.message}", e)
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = e.message ?: "Erro ao carregar perfil"
                )
            }
        }
    }
    
    private fun loadUserSpecificData(userId: String, accountType: AccountType) {
        // Carregar dados espec√≠ficos baseado no tipo de conta em corrotinas separadas
        when (accountType) {
            AccountType.PARCEIRO, AccountType.PRESTADOR, AccountType.VENDEDOR -> {
                // PARCEIRO: Observar tanto servi√ßos quanto produtos (unificado)
                // Observar servi√ßos do parceiro
                viewModelScope.launch {
                    servicesRepository.observeProviderServices(userId)
                        .catch { e ->
                            android.util.Log.e("PublicUserProfileVM", "Erro ao observar servi√ßos: ${e.message}", e)
                            emit(emptyList())
                        }
                        .collect { servicesList ->
                            _services.value = servicesList
                        }
                }
                // Observar produtos do parceiro
                viewModelScope.launch {
                    firestoreProductsRepository.observeProductsBySeller(userId)
                        .catch { e ->
                            android.util.Log.e("PublicUserProfileVM", "Erro ao observar produtos: ${e.message}", e)
                            emit(emptyList())
                        }
                        .collect { productsList ->
                            _products.value = productsList
                        }
                }
            }
            else -> {
                // CLIENTE - n√£o precisa carregar servi√ßos ou produtos
            }
        }
        
        // Observar avalia√ß√µes (para todos os tipos)
        viewModelScope.launch {
            reviewsRepository.observeProviderReviews(userId)
                .catch { e ->
                    android.util.Log.e("PublicUserProfileVM", "Erro ao observar avalia√ß√µes: ${e.message}", e)
                    emit(emptyList())
                }
                .collect { reviewsList ->
                    _reviews.value = reviewsList
                }
        }
    }
}






```

# Features - reviews


## [FRONTEND]: feature/reviews/presentation/CreateReviewScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.reviews.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.design.reviews.RatingStars
import com.taskgoapp.taskgo.core.model.ReviewType
import com.taskgoapp.taskgo.core.theme.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun CreateReviewScreen(
    targetId: String,
    type: ReviewType,
    targetName: String,
    orderId: String? = null,
    onNavigateBack: () -> Unit,
    onReviewCreated: () -> Unit,
    modifier: Modifier = Modifier
) {
    val viewModel: CreateReviewViewModel = hiltViewModel()
    val uiState by viewModel.uiState.collectAsState()
    
    var rating by remember { mutableStateOf(0) }
    var comment by remember { mutableStateOf("") }
    
    LaunchedEffect(Unit) {
        viewModel.initialize(targetId, type, orderId)
    }
    
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Avaliar $targetName",
                onBackClick = onNavigateBack
            )
        }
    ) { paddingValues ->
        Column(
            modifier = modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp)
                .verticalScroll(rememberScrollState()),
            verticalArrangement = Arrangement.spacedBy(24.dp)
        ) {
            // Informa√ß√µes do target
            Card(
                modifier = Modifier.fillMaxWidth()
            ) {
                Column(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp),
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    Text(
                        text = targetName,
                        style = FigmaProductName,
                        color = TaskGoTextBlack,
                        fontWeight = FontWeight.Bold
                    )
                    Text(
                        text = when (type) {
                            ReviewType.PRODUCT -> "Produto"
                            ReviewType.SERVICE -> "Servi√ßo"
                            ReviewType.PROVIDER -> "Prestador"
                        },
                        style = FigmaProductDescription,
                        color = TaskGoTextGray
                    )
                }
            }
            
            // Sele√ß√£o de estrelas
            Card(
                modifier = Modifier.fillMaxWidth()
            ) {
                Column(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(24.dp),
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.spacedBy(16.dp)
                ) {
                    Text(
                        text = "Como foi sua experi√™ncia?",
                        style = FigmaProductName,
                        color = TaskGoTextBlack,
                        fontWeight = FontWeight.Bold
                    )
                    
                    RatingStars(
                        rating = rating,
                        onRatingChange = { rating = it },
                        enabled = true,
                        starSize = 48.dp
                    )
                    
                    if (rating > 0) {
                        Text(
                            text = when (rating) {
                                1 -> "P√©ssimo"
                                2 -> "Ruim"
                                3 -> "Regular"
                                4 -> "Bom"
                                5 -> "Excelente"
                                else -> ""
                            },
                            style = FigmaProductDescription,
                            color = TaskGoTextGray
                        )
                    }
                }
            }
            
            // Campo de coment√°rio
            Card(
                modifier = Modifier.fillMaxWidth()
            ) {
                Column(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp),
                    verticalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    Text(
                        text = "Compartilhe sua opini√£o (opcional)",
                        style = FigmaProductName,
                        color = TaskGoTextBlack,
                        fontWeight = FontWeight.Medium
                    )
                    
                    OutlinedTextField(
                        value = comment,
                        onValueChange = { comment = it },
                        modifier = Modifier.fillMaxWidth(),
                        placeholder = {
                            Text(
                                text = "Conte mais sobre sua experi√™ncia...",
                                color = TaskGoTextGray
                            )
                        },
                        minLines = 4,
                        maxLines = 8,
                        colors = OutlinedTextFieldDefaults.colors(
                            focusedBorderColor = TaskGoGreen,
                            unfocusedBorderColor = TaskGoBorder
                        )
                    )
                }
            }
            
            // Badge de compra verificada (se aplic√°vel)
            if (orderId != null) {
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    colors = CardDefaults.cardColors(
                        containerColor = TaskGoGreen.copy(alpha = 0.1f)
                    )
                ) {
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(16.dp),
                        verticalAlignment = Alignment.CenterVertically,
                        horizontalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        Icon(
                            imageVector = Icons.Default.CheckCircle,
                            contentDescription = null,
                            tint = TaskGoGreen
                        )
                        Text(
                            text = "Compra verificada",
                            style = FigmaProductDescription,
                            color = TaskGoGreen,
                            fontWeight = FontWeight.Medium
                        )
                    }
                }
            }
            
            Spacer(modifier = Modifier.weight(1f))
            
            // Bot√£o de enviar
            Button(
                onClick = {
                    if (rating > 0) {
                        viewModel.createReview(rating, comment.takeIf { it.isNotBlank() })
                    }
                },
                modifier = Modifier.fillMaxWidth(),
                enabled = rating > 0 && !uiState.isLoading,
                colors = ButtonDefaults.buttonColors(
                    containerColor = TaskGoGreen
                )
            ) {
                if (uiState.isLoading) {
                    CircularProgressIndicator(
                        modifier = Modifier.size(20.dp),
                        color = Color.White
                    )
                } else {
                    Text(
                        text = "Enviar Avalia√ß√£o",
                        style = FigmaButtonText,
                        color = Color.White
                    )
                }
            }
            
            // Mensagem de erro
            uiState.error?.let { error ->
                Text(
                    text = error,
                    color = MaterialTheme.colorScheme.error,
                    style = FigmaProductDescription
                )
            }
        }
    }
    
    // Navegar de volta quando avalia√ß√£o for criada
    LaunchedEffect(uiState.reviewCreated) {
        if (uiState.reviewCreated) {
            onReviewCreated()
        }
    }
}


```

## [FRONTEND]: feature/reviews/presentation/ReviewsScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.reviews.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.collectAsState
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.design.reviews.ReviewCard
import com.taskgoapp.taskgo.core.design.reviews.ReviewSummaryCard
import com.taskgoapp.taskgo.core.model.ReviewType
import com.taskgoapp.taskgo.core.theme.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ReviewsScreen(
    targetId: String,
    type: ReviewType,
    targetName: String,
    onNavigateBack: () -> Unit,
    onNavigateToCreateReview: () -> Unit,
    modifier: Modifier = Modifier
) {
    val viewModel: ReviewsViewModel = hiltViewModel()
    val uiState by viewModel.uiState.collectAsState()
    
    LaunchedEffect(targetId, type) {
        viewModel.loadReviews(targetId, type)
    }
    
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Avalia√ß√µes - $targetName",
                onBackClick = onNavigateBack
            )
        },
        floatingActionButton = {
            if (uiState.canReview) {
                FloatingActionButton(
                    onClick = onNavigateToCreateReview,
                    containerColor = TaskGoGreen
                ) {
                    Icon(
                        imageVector = Icons.Default.Add,
                        contentDescription = "Avaliar",
                        tint = androidx.compose.ui.graphics.Color.White
                    )
                }
            }
        }
    ) { paddingValues ->
        LazyColumn(
            modifier = modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // Resumo de avalia√ß√µes
            if (uiState.summary.totalReviews > 0) {
                item {
                    ReviewSummaryCard(summary = uiState.summary)
                }
            }
            
            // Lista de avalia√ß√µes
            if (uiState.isLoading) {
                item {
                    Box(
                        modifier = Modifier.fillMaxWidth(),
                        contentAlignment = Alignment.Center
                    ) {
                        CircularProgressIndicator()
                    }
                }
            } else if (uiState.reviews.isEmpty()) {
                item {
                    Card(
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Column(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(24.dp),
                            horizontalAlignment = Alignment.CenterHorizontally,
                            verticalArrangement = Arrangement.spacedBy(8.dp)
                        ) {
                            Text(
                                text = "Nenhuma avalia√ß√£o ainda",
                                style = FigmaProductName,
                                color = TaskGoTextGray,
                                fontWeight = FontWeight.Bold
                            )
                            Text(
                                text = "Seja o primeiro a avaliar!",
                                style = FigmaProductDescription,
                                color = TaskGoTextGray
                            )
                        }
                    }
                }
            } else {
                items(uiState.reviews) { review ->
                    ReviewCard(
                        review = review,
                        onHelpfulClick = {
                            viewModel.markAsHelpful(review.id)
                        }
                    )
                }
            }
        }
    }
}


```

## [FRONTEND]: feature/reviews/presentation/ReviewsViewModel.kt

```kotlin
package com.taskgoapp.taskgo.feature.reviews.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.google.firebase.auth.FirebaseAuth
import com.taskgoapp.taskgo.core.model.Review
import com.taskgoapp.taskgo.core.model.ReviewType
import com.taskgoapp.taskgo.domain.repository.ReviewsRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import javax.inject.Inject

data class ReviewsUiState(
    val isLoading: Boolean = false,
    val reviews: List<Review> = emptyList(),
    val summary: com.taskgoapp.taskgo.core.model.ReviewSummary = com.taskgoapp.taskgo.core.model.ReviewSummary(0.0, 0),
    val canReview: Boolean = false,
    val error: String? = null
)

@HiltViewModel
class ReviewsViewModel @Inject constructor(
    private val reviewsRepository: ReviewsRepository,
    private val firebaseAuth: FirebaseAuth
) : ViewModel() {
    
    private val _uiState = MutableStateFlow(ReviewsUiState())
    val uiState: StateFlow<ReviewsUiState> = _uiState.asStateFlow()
    
    fun loadReviews(targetId: String, type: ReviewType) {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoading = true, error = null)
            
            try {
                val userId = firebaseAuth.currentUser?.uid
                val canReview = userId != null && reviewsRepository.canUserReview(targetId, type, userId)
                
                reviewsRepository.observeReviews(targetId, type).collect { reviews ->
                    val summary = reviewsRepository.getReviewSummary(targetId, type)
                    _uiState.value = _uiState.value.copy(
                        isLoading = false,
                        reviews = reviews,
                        summary = summary,
                        canReview = canReview
                    )
                }
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = e.message ?: "Erro ao carregar avalia√ß√µes"
                )
            }
        }
    }
    
    fun markAsHelpful(reviewId: String) {
        viewModelScope.launch {
            reviewsRepository.markReviewAsHelpful(reviewId)
        }
    }
}

data class CreateReviewUiState(
    val isLoading: Boolean = false,
    val reviewCreated: Boolean = false,
    val error: String? = null
)

@HiltViewModel
class CreateReviewViewModel @Inject constructor(
    private val reviewsRepository: ReviewsRepository,
    private val firebaseAuth: FirebaseAuth
) : ViewModel() {
    
    private val _uiState = MutableStateFlow(CreateReviewUiState())
    val uiState: StateFlow<CreateReviewUiState> = _uiState.asStateFlow()
    
    private var currentTargetId: String = ""
    private var currentType: ReviewType = ReviewType.PRODUCT
    private var currentOrderId: String? = null
    
    fun initialize(targetId: String, type: ReviewType, orderId: String?) {
        currentTargetId = targetId
        currentType = type
        currentOrderId = orderId
    }
    
    fun createReview(rating: Int, comment: String?) {
        viewModelScope.launch {
            val user = firebaseAuth.currentUser
            if (user == null) {
                _uiState.value = _uiState.value.copy(
                    error = "Voc√™ precisa estar logado para avaliar"
                )
                return@launch
            }
            
            _uiState.value = _uiState.value.copy(isLoading = true, error = null)
            
            val review = Review(
                id = "",
                type = currentType,
                targetId = currentTargetId,
                reviewerId = user.uid,
                reviewerName = user.displayName ?: "Usu√°rio",
                reviewerAvatarUri = user.photoUrl?.toString(),
                rating = rating,
                comment = comment,
                photoUrls = emptyList(),
                createdAt = System.currentTimeMillis(),
                updatedAt = null,
                orderId = currentOrderId,
                helpfulCount = 0,
                verifiedPurchase = currentOrderId != null
            )
            
            when (val result = reviewsRepository.createReview(review)) {
                is com.taskgoapp.taskgo.core.model.Result.Success -> {
                    _uiState.value = _uiState.value.copy(
                        isLoading = false,
                        reviewCreated = true
                    )
                }
                is com.taskgoapp.taskgo.core.model.Result.Error -> {
                    _uiState.value = _uiState.value.copy(
                        isLoading = false,
                        error = result.exception.message ?: "Erro ao criar avalia√ß√£o"
                    )
                }
                else -> {
                    _uiState.value = _uiState.value.copy(
                        isLoading = false,
                        error = "Erro desconhecido"
                    )
                }
            }
        }
    }
}

data class UserReviewsUiState(
    val isLoading: Boolean = false,
    val reviewsAsReviewer: List<Review> = emptyList(), // Avalia√ß√µes que o usu√°rio fez
    val reviewsAsTarget: List<Review> = emptyList(), // Avalia√ß√µes sobre o usu√°rio
    val summaryAsTarget: com.taskgoapp.taskgo.core.model.ReviewSummary = com.taskgoapp.taskgo.core.model.ReviewSummary(0.0, 0),
    val error: String? = null
)

@HiltViewModel
class UserReviewsViewModel @Inject constructor(
    private val reviewsRepository: ReviewsRepository
) : ViewModel() {
    
    private val _uiState = MutableStateFlow(UserReviewsUiState())
    val uiState: StateFlow<UserReviewsUiState> = _uiState.asStateFlow()
    
    fun loadUserReviews(userId: String) {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoading = true, error = null)
            
            try {
                // Usar combine para combinar os dois flows
                kotlinx.coroutines.flow.combine(
                    reviewsRepository.observeUserReviewsAsReviewer(userId),
                    reviewsRepository.observeUserReviewsAsTarget(userId)
                ) { reviewsAsReviewer, reviewsAsTarget ->
                    // Calcular summary a partir das avalia√ß√µes recebidas
                    val summary = if (reviewsAsTarget.isNotEmpty()) {
                        val ratings = reviewsAsTarget.map { it.rating }
                        val averageRating = ratings.average()
                        val ratingDistribution = ratings.groupingBy { it }.eachCount()
                        com.taskgoapp.taskgo.core.model.ReviewSummary(
                            averageRating = averageRating,
                            totalReviews = reviewsAsTarget.size,
                            ratingDistribution = ratingDistribution
                        )
                    } else {
                        com.taskgoapp.taskgo.core.model.ReviewSummary(0.0, 0)
                    }
                    
                    UserReviewsUiState(
                        isLoading = false,
                        reviewsAsReviewer = reviewsAsReviewer,
                        reviewsAsTarget = reviewsAsTarget,
                        summaryAsTarget = summary
                    )
                }.collect { newState ->
                    _uiState.value = newState
                }
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = e.message ?: "Erro ao carregar avalia√ß√µes"
                )
            }
        }
    }
}


```

## [FRONTEND]: feature/reviews/presentation/UserReviewsScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.reviews.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.collectAsState
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.size
import androidx.hilt.navigation.compose.hiltViewModel
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.design.reviews.ReviewCard
import com.taskgoapp.taskgo.core.design.reviews.ReviewSummaryCard
import com.taskgoapp.taskgo.core.design.reviews.RatingStarsDisplay
import com.taskgoapp.taskgo.core.model.Review
import com.taskgoapp.taskgo.core.model.ReviewType
import com.taskgoapp.taskgo.core.theme.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun UserReviewsScreen(
    userId: String,
    userName: String,
    onNavigateBack: () -> Unit,
    modifier: Modifier = Modifier
) {
    val viewModel: UserReviewsViewModel = hiltViewModel()
    val uiState by viewModel.uiState.collectAsState()
    
    var selectedTabIndex by remember { mutableStateOf(0) }
    val tabs = listOf("Recebidas", "Enviadas")
    
    // Filtros e busca
    var searchQuery by remember { mutableStateOf("") }
    var selectedRatingFilter by remember { mutableStateOf<Int?>(null) } // null = todos, 1-5 = filtro por estrelas
    var selectedTypeFilter by remember { mutableStateOf<ReviewType?>(null) }
    var sortOrder by remember { mutableStateOf(SortOrder.RECENT) }
    var showFilters by remember { mutableStateOf(false) }
    
    LaunchedEffect(userId) {
        viewModel.loadUserReviews(userId)
    }
    
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Avalia√ß√µes de $userName",
                onBackClick = onNavigateBack
            )
        }
    ) { paddingValues ->
        Column(
            modifier = modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            // Barra de busca e filtros
            Card(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(horizontal = 16.dp, vertical = 8.dp),
                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
            ) {
                Column(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(12.dp),
                    verticalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    // Campo de busca
                    OutlinedTextField(
                        value = searchQuery,
                        onValueChange = { searchQuery = it },
                        modifier = Modifier.fillMaxWidth(),
                        placeholder = { Text("Buscar avalia√ß√µes...") },
                        leadingIcon = { Icon(Icons.Default.Search, contentDescription = null) },
                        trailingIcon = {
                            if (searchQuery.isNotEmpty()) {
                                IconButton(onClick = { searchQuery = "" }) {
                                    Icon(Icons.Default.Clear, contentDescription = "Limpar busca")
                                }
                            }
                        },
                        singleLine = true
                    )
                    
                    // Bot√µes de filtro
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        // Bot√£o de filtros
                        FilterChip(
                            selected = showFilters,
                            onClick = { showFilters = !showFilters },
                            label = { Text("Filtros") },
                            leadingIcon = {
                                Icon(
                                    Icons.Default.FilterList,
                                    contentDescription = null,
                                    modifier = Modifier.size(18.dp)
                                )
                            }
                        )
                        
                        // Filtro de ordena√ß√£o
                        var expandedSort by remember { mutableStateOf(false) }
                        Box {
                            FilterChip(
                                selected = false,
                                onClick = { expandedSort = true },
                                label = { Text("Ordenar: ${sortOrder.label}") },
                                leadingIcon = {
                                    Icon(
                                        Icons.Default.Sort,
                                        contentDescription = null,
                                        modifier = Modifier.size(18.dp)
                                    )
                                }
                            )
                            DropdownMenu(
                                expanded = expandedSort,
                                onDismissRequest = { expandedSort = false }
                            ) {
                                SortOrder.values().forEach { order ->
                                    DropdownMenuItem(
                                        text = { Text(order.label) },
                                        onClick = {
                                            sortOrder = order
                                            expandedSort = false
                                        }
                                    )
                                }
                            }
                        }
                    }
                    
                    // Painel de filtros expandido
                    if (showFilters) {
                        Column(
                            verticalArrangement = Arrangement.spacedBy(8.dp)
                        ) {
                            HorizontalDivider()
                            
                            // Filtro por avalia√ß√£o
                            Text(
                                text = "Avalia√ß√£o:",
                                style = MaterialTheme.typography.labelMedium,
                                fontWeight = FontWeight.Medium
                            )
                            Row(
                                horizontalArrangement = Arrangement.spacedBy(4.dp)
                            ) {
                                FilterChip(
                                    selected = selectedRatingFilter == null,
                                    onClick = { selectedRatingFilter = null },
                                    label = { Text("Todas") }
                                )
                                (5 downTo 1).forEach { rating ->
                                    FilterChip(
                                        selected = selectedRatingFilter == rating,
                                        onClick = { 
                                            selectedRatingFilter = if (selectedRatingFilter == rating) null else rating
                                        },
                                        label = { 
                                            Row(verticalAlignment = Alignment.CenterVertically) {
                                                Icon(
                                                    Icons.Default.Star,
                                                    contentDescription = null,
                                                    modifier = Modifier.size(16.dp),
                                                    tint = MaterialTheme.colorScheme.primary
                                                )
                                                Text("$rating")
                                            }
                                        }
                                    )
                                }
                            }
                            
                            // Filtro por tipo
                            Text(
                                text = "Tipo:",
                                style = MaterialTheme.typography.labelMedium,
                                fontWeight = FontWeight.Medium,
                                modifier = Modifier.padding(top = 8.dp)
                            )
                            Row(
                                horizontalArrangement = Arrangement.spacedBy(4.dp)
                            ) {
                                FilterChip(
                                    selected = selectedTypeFilter == null,
                                    onClick = { selectedTypeFilter = null },
                                    label = { Text("Todos") }
                                )
                                ReviewType.values().forEach { type ->
                                    FilterChip(
                                        selected = selectedTypeFilter == type,
                                        onClick = { 
                                            selectedTypeFilter = if (selectedTypeFilter == type) null else type
                                        },
                                        label = { Text(type.label) }
                                    )
                                }
                            }
                        }
                    }
                }
            }
            
            // Tabs
            TabRow(
                selectedTabIndex = selectedTabIndex,
                modifier = Modifier.fillMaxWidth()
            ) {
                tabs.forEachIndexed { index, title ->
                    Tab(
                        selected = selectedTabIndex == index,
                        onClick = { selectedTabIndex = index },
                        text = { Text(title) }
                    )
                }
            }
            
            // Content
            when (selectedTabIndex) {
                0 -> {
                    // Avalia√ß√µes sobre o usu√°rio (quando √© prestador/vendedor)
                    ReviewsAboutUserContent(
                        uiState = uiState,
                        userId = userId,
                        searchQuery = searchQuery,
                        ratingFilter = selectedRatingFilter,
                        typeFilter = selectedTypeFilter,
                        sortOrder = sortOrder
                    )
                }
                1 -> {
                    // Avalia√ß√µes que o usu√°rio fez
                    UserReviewsAsReviewerContent(
                        uiState = uiState,
                        userId = userId,
                        searchQuery = searchQuery,
                        ratingFilter = selectedRatingFilter,
                        typeFilter = selectedTypeFilter,
                        sortOrder = sortOrder
                    )
                }
            }
        }
    }
}

enum class SortOrder(val label: String) {
    RECENT("Mais recentes"),
    OLDEST("Mais antigas"),
    HIGHEST_RATING("Maior avalia√ß√£o"),
    LOWEST_RATING("Menor avalia√ß√£o")
}

val ReviewType.label: String
    get() = when (this) {
        ReviewType.PRODUCT -> "Produto"
        ReviewType.SERVICE -> "Servi√ßo"
        ReviewType.PROVIDER -> "Prestador"
    }

@Composable
private fun ReviewsAboutUserContent(
    uiState: UserReviewsUiState,
    userId: String,
    searchQuery: String,
    ratingFilter: Int?,
    typeFilter: ReviewType?,
    sortOrder: SortOrder
) {
    // Filtrar e ordenar avalia√ß√µes
    val filteredReviews = remember(uiState.reviewsAsTarget, searchQuery, ratingFilter, typeFilter, sortOrder) {
        uiState.reviewsAsTarget
            .filter { review ->
                // Filtro de busca
                val matchesSearch = searchQuery.isBlank() || 
                    review.comment?.contains(searchQuery, ignoreCase = true) == true ||
                    review.reviewerName.contains(searchQuery, ignoreCase = true)
                
                // Filtro de avalia√ß√£o
                val matchesRating = ratingFilter == null || review.rating == ratingFilter
                
                // Filtro de tipo
                val matchesType = typeFilter == null || review.type == typeFilter
                
                matchesSearch && matchesRating && matchesType
            }
            .sortedWith(
                when (sortOrder) {
                    SortOrder.RECENT -> compareByDescending { it.createdAt }
                    SortOrder.OLDEST -> compareBy { it.createdAt }
                    SortOrder.HIGHEST_RATING -> compareByDescending { it.rating }
                    SortOrder.LOWEST_RATING -> compareBy { it.rating }
                }
            )
    }
    
    LazyColumn(
        modifier = Modifier.fillMaxSize(),
        contentPadding = PaddingValues(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        // Resumo de avalia√ß√µes
        if (uiState.summaryAsTarget.totalReviews > 0) {
            item {
                ReviewSummaryCard(summary = uiState.summaryAsTarget)
            }
        }
        
        // Contador de resultados
        if (filteredReviews.isNotEmpty() && (searchQuery.isNotBlank() || ratingFilter != null || typeFilter != null)) {
            item {
                Text(
                    text = "${filteredReviews.size} avalia√ß√£o(√µes) encontrada(s)",
                    style = MaterialTheme.typography.bodySmall,
                    color = TaskGoTextGray,
                    modifier = Modifier.padding(vertical = 8.dp)
                )
            }
        }
        
        // Lista de avalia√ß√µes
        if (uiState.isLoading) {
            item {
                Box(
                    modifier = Modifier.fillMaxWidth(),
                    contentAlignment = Alignment.Center
                ) {
                    CircularProgressIndicator()
                }
            }
        } else if (filteredReviews.isEmpty()) {
            item {
                EmptyReviewsState(
                    title = if (searchQuery.isNotBlank() || ratingFilter != null || typeFilter != null) {
                        "Nenhuma avalia√ß√£o encontrada"
                    } else {
                        "Nenhuma avalia√ß√£o ainda"
                    },
                    message = if (searchQuery.isNotBlank() || ratingFilter != null || typeFilter != null) {
                        "Tente ajustar os filtros de busca"
                    } else {
                        "Voc√™ ainda n√£o recebeu avalia√ß√µes como prestador/vendedor"
                    }
                )
            }
        } else {
            items(filteredReviews) { review ->
                ReviewCard(
                    review = review,
                    onHelpfulClick = null // N√£o permitir marcar como √∫til suas pr√≥prias avalia√ß√µes
                )
            }
        }
    }
}

@Composable
private fun UserReviewsAsReviewerContent(
    uiState: UserReviewsUiState,
    userId: String,
    searchQuery: String,
    ratingFilter: Int?,
    typeFilter: ReviewType?,
    sortOrder: SortOrder
) {
    // Filtrar e ordenar avalia√ß√µes
    val filteredReviews = remember(uiState.reviewsAsReviewer, searchQuery, ratingFilter, typeFilter, sortOrder) {
        uiState.reviewsAsReviewer
            .filter { review ->
                // Filtro de busca
                val matchesSearch = searchQuery.isBlank() || 
                    review.comment?.contains(searchQuery, ignoreCase = true) == true
                
                // Filtro de avalia√ß√£o
                val matchesRating = ratingFilter == null || review.rating == ratingFilter
                
                // Filtro de tipo
                val matchesType = typeFilter == null || review.type == typeFilter
                
                matchesSearch && matchesRating && matchesType
            }
            .sortedWith(
                when (sortOrder) {
                    SortOrder.RECENT -> compareByDescending { it.createdAt }
                    SortOrder.OLDEST -> compareBy { it.createdAt }
                    SortOrder.HIGHEST_RATING -> compareByDescending { it.rating }
                    SortOrder.LOWEST_RATING -> compareBy { it.rating }
                }
            )
    }
    
    LazyColumn(
        modifier = Modifier.fillMaxSize(),
        contentPadding = PaddingValues(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        // Estat√≠sticas das avalia√ß√µes feitas
        if (filteredReviews.isNotEmpty()) {
            item {
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
                ) {
                    Column(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(16.dp),
                        horizontalAlignment = Alignment.CenterHorizontally,
                        verticalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        Text(
                            text = "Total de Avalia√ß√µes",
                            style = FigmaProductDescription,
                            color = TaskGoTextGray
                        )
                        Text(
                            text = "${filteredReviews.size}",
                            style = FigmaProductName,
                            fontWeight = FontWeight.Bold,
                            color = TaskGoTextBlack
                        )
                        
                        val averageRating = filteredReviews.map { it.rating.toDouble() }.average()
                        if (averageRating > 0) {
                            Spacer(modifier = Modifier.height(8.dp))
                            RatingStarsDisplay(
                                rating = averageRating,
                                starSize = 20.dp,
                                showRating = true
                            )
                        }
                    }
                }
            }
        }
        
        // Contador de resultados
        if (filteredReviews.isNotEmpty() && (searchQuery.isNotBlank() || ratingFilter != null || typeFilter != null)) {
            item {
                Text(
                    text = "${filteredReviews.size} avalia√ß√£o(√µes) encontrada(s)",
                    style = MaterialTheme.typography.bodySmall,
                    color = TaskGoTextGray,
                    modifier = Modifier.padding(vertical = 8.dp)
                )
            }
        }
        
        // Lista de avalia√ß√µes
        if (uiState.isLoading) {
            item {
                Box(
                    modifier = Modifier.fillMaxWidth(),
                    contentAlignment = Alignment.Center
                ) {
                    CircularProgressIndicator()
                }
            }
        } else if (filteredReviews.isEmpty()) {
            item {
                EmptyReviewsState(
                    title = if (searchQuery.isNotBlank() || ratingFilter != null || typeFilter != null) {
                        "Nenhuma avalia√ß√£o encontrada"
                    } else {
                        "Nenhuma avalia√ß√£o feita"
                    },
                    message = if (searchQuery.isNotBlank() || ratingFilter != null || typeFilter != null) {
                        "Tente ajustar os filtros de busca"
                    } else {
                        "Voc√™ ainda n√£o avaliou nenhum produto ou servi√ßo"
                    }
                )
            }
        } else {
            // Agrupar por tipo (se n√£o houver filtro de tipo)
            val groupedByType = typeFilter == null
            val productReviews = filteredReviews.filter { it.type == ReviewType.PRODUCT }
            val serviceReviews = filteredReviews.filter { it.type == ReviewType.SERVICE }
            val providerReviews = filteredReviews.filter { it.type == ReviewType.PROVIDER }
            
            if (groupedByType) {
                if (productReviews.isNotEmpty()) {
                    item {
                        SectionHeader("Produtos (${productReviews.size})")
                    }
                    items(productReviews) { review ->
                        ReviewCardWithTarget(
                            review = review,
                            targetType = "Produto"
                        )
                    }
                }
                
                if (serviceReviews.isNotEmpty()) {
                    item {
                        SectionHeader("Servi√ßos (${serviceReviews.size})")
                    }
                    items(serviceReviews) { review ->
                        ReviewCardWithTarget(
                            review = review,
                            targetType = "Servi√ßo"
                        )
                    }
                }
                
                if (providerReviews.isNotEmpty()) {
                    item {
                        SectionHeader("Prestadores (${providerReviews.size})")
                    }
                    items(providerReviews) { review ->
                        ReviewCardWithTarget(
                            review = review,
                            targetType = "Prestador"
                        )
                    }
                }
            } else {
                // Se houver filtro de tipo, mostrar todas juntas
                items(filteredReviews) { review ->
                    ReviewCardWithTarget(
                        review = review,
                        targetType = review.type.label
                    )
                }
            }
        }
    }
}

@Composable
private fun ReviewCardWithTarget(
    review: Review,
    targetType: String
) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(defaultElevation = 1.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            // Badge do tipo
            Badge(
                containerColor = TaskGoGreen.copy(alpha = 0.2f),
                contentColor = TaskGoGreen
            ) {
                Text(
                    text = targetType,
                    style = MaterialTheme.typography.labelSmall
                )
            }
            
            // Card de avalia√ß√£o normal
            ReviewCard(
                review = review,
                onHelpfulClick = null
            )
        }
    }
}

@Composable
private fun SectionHeader(title: String) {
    Text(
        text = title,
        style = FigmaProductName,
        fontWeight = FontWeight.Bold,
        color = TaskGoTextBlack,
        modifier = Modifier.padding(vertical = 8.dp)
    )
}

@Composable
private fun EmptyReviewsState(
    title: String,
    message: String
) {
    Card(
        modifier = Modifier.fillMaxWidth()
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(24.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            Icon(
                imageVector = Icons.Default.Star,
                contentDescription = null,
                modifier = Modifier.size(64.dp),
                tint = TaskGoTextGray.copy(alpha = 0.5f)
            )
            Text(
                text = title,
                style = FigmaProductName,
                color = TaskGoTextGray,
                fontWeight = FontWeight.Bold
            )
            Text(
                text = message,
                style = FigmaProductDescription,
                color = TaskGoTextGray
            )
        }
    }
}


```

# Features - search


## [FRONTEND]: feature/search/presentation/UniversalSearchScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.search.presentation

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.collectAsState
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.taskgoapp.taskgo.core.design.*
import com.taskgoapp.taskgo.core.model.Product
import com.taskgoapp.taskgo.core.model.ServiceOrder
import com.taskgoapp.taskgo.core.theme.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun UniversalSearchScreen(
    onNavigateBack: () -> Unit,
    onNavigateToProduct: (String) -> Unit,
    onNavigateToService: (String) -> Unit,
    modifier: Modifier = Modifier
) {
    val viewModel: UniversalSearchViewModel = hiltViewModel()
    val uiState by viewModel.uiState.collectAsState()
    val filterState by viewModel.filterState.collectAsState()
    
    var showFilterSheet by remember { mutableStateOf(false) }
    
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Busca Universal",
                onBackClick = onNavigateBack,
                actions = {
                    IconButton(onClick = { showFilterSheet = true }) {
                        Icon(
                            imageVector = Icons.Default.FilterList,
                            contentDescription = "Filtros",
                            tint = Color.White
                        )
                    }
                }
            )
        }
    ) { paddingValues ->
        Column(
            modifier = modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // Barra de Busca
            SearchBar(
                query = filterState.searchQuery,
                onQueryChange = { viewModel.updateSearchQuery(it) },
                placeholder = "Buscar produtos, servi√ßos, categorias...",
                modifier = Modifier.fillMaxWidth()
            )
            
            // Barra de Filtros R√°pidos
            FilterBar(
                categories = uiState.categories,
                selectedCategories = filterState.selectedCategories,
                onCategorySelected = { category ->
                    if (category == "Todos") {
                        viewModel.updateFilterState(filterState.copy(selectedCategories = emptySet()))
                    } else {
                        viewModel.toggleCategory(category)
                    }
                },
                onFilterClick = { showFilterSheet = true },
                modifier = Modifier.fillMaxWidth()
            )
            
            // Resultados
            when {
                uiState.isLoading -> {
                    Box(
                        modifier = Modifier.fillMaxSize(),
                        contentAlignment = Alignment.Center
                    ) {
                        CircularProgressIndicator()
                    }
                }
                uiState.products.isEmpty() && uiState.services.isEmpty() -> {
                    Box(
                        modifier = Modifier.fillMaxSize(),
                        contentAlignment = Alignment.Center
                    ) {
                        Column(
                            horizontalAlignment = Alignment.CenterHorizontally,
                            verticalArrangement = Arrangement.spacedBy(8.dp)
                        ) {
                            Text(
                                text = "Nenhum resultado encontrado",
                                style = FigmaProductName,
                                color = TaskGoTextGray
                            )
                            Text(
                                text = "Tente ajustar os filtros ou buscar por outros termos",
                                style = FigmaProductDescription,
                                color = TaskGoTextGray
                            )
                        }
                    }
                }
                else -> {
                    LazyColumn(
                        verticalArrangement = Arrangement.spacedBy(16.dp)
                    ) {
                        // Se√ß√£o de Produtos
                        if (uiState.products.isNotEmpty()) {
                            item {
                                Text(
                                    text = "Produtos (${uiState.products.size})",
                                    style = MaterialTheme.typography.titleMedium,
                                    fontWeight = FontWeight.Bold,
                                    color = TaskGoTextBlack
                                )
                            }
                            items(uiState.products) { product ->
                                ProductSearchResultCard(
                                    product = product,
                                    onClick = { onNavigateToProduct(product.id) }
                                )
                            }
                        }
                        
                        // Se√ß√£o de Servi√ßos
                        if (uiState.services.isNotEmpty()) {
                            item {
                                Text(
                                    text = "Servi√ßos (${uiState.services.size})",
                                    style = MaterialTheme.typography.titleMedium,
                                    fontWeight = FontWeight.Bold,
                                    color = TaskGoTextBlack,
                                    modifier = Modifier.padding(top = 8.dp)
                                )
                            }
                            items(uiState.services) { service ->
                                ServiceSearchResultCard(
                                    service = service,
                                    onClick = { onNavigateToService(service.id) }
                                )
                            }
                        }
                    }
                }
            }
        }
        
        // Bottom Sheet de Filtros
        FilterBottomSheet(
            isOpen = showFilterSheet,
            onDismiss = { showFilterSheet = false },
            filterState = filterState,
            onFilterStateChange = { newState ->
                viewModel.updateFilterState(newState)
            }
        )
    }
}

@Composable
private fun ProductSearchResultCard(
    product: Product,
    onClick: () -> Unit
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .clickable { onClick() },
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            horizontalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            // Imagem do produto (placeholder)
            Box(
                modifier = Modifier
                    .size(80.dp)
                    .background(TaskGoSurfaceGray),
                contentAlignment = Alignment.Center
            ) {
                Text(
                    text = "IMG",
                    color = TaskGoTextGray,
                    style = FigmaProductDescription
                )
            }
            
            Column(
                modifier = Modifier.weight(1f),
                verticalArrangement = Arrangement.spacedBy(4.dp)
            ) {
                Text(
                    text = product.title,
                    style = FigmaProductName,
                    color = TaskGoTextBlack,
                    fontWeight = FontWeight.Bold
                )
                product.description?.let {
                    Text(
                        text = it,
                        style = FigmaProductDescription,
                        color = TaskGoTextGray,
                        maxLines = 2
                    )
                }
                Row(
                    horizontalArrangement = Arrangement.spacedBy(8.dp),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Text(
                        text = "R$ ${String.format("%.2f", product.price)}",
                        style = FigmaProductName,
                        color = TaskGoGreen,
                        fontWeight = FontWeight.Bold
                    )
                    product.rating?.let { rating ->
                        Row(
                            horizontalArrangement = Arrangement.spacedBy(4.dp),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Icon(
                                imageVector = Icons.Default.Star,
                                contentDescription = null,
                                tint = Color(0xFFFFD700),
                                modifier = Modifier.size(16.dp)
                            )
                            Text(
                                text = String.format("%.1f", rating),
                                style = FigmaProductDescription,
                                color = TaskGoTextGray
                            )
                        }
                    }
                }
            }
        }
    }
}

@Composable
private fun ServiceSearchResultCard(
    service: ServiceOrder,
    onClick: () -> Unit
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .clickable { onClick() },
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = service.category,
                    style = FigmaProductName,
                    color = TaskGoTextBlack,
                    fontWeight = FontWeight.Bold
                )
                service.rating?.let { rating ->
                    Row(
                        horizontalArrangement = Arrangement.spacedBy(4.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Icon(
                            imageVector = Icons.Default.Star,
                            contentDescription = null,
                            tint = Color(0xFFFFD700),
                            modifier = Modifier.size(16.dp)
                        )
                        Text(
                            text = String.format("%.1f", rating),
                            style = FigmaProductDescription,
                            color = TaskGoTextGray
                        )
                    }
                }
            }
            Text(
                text = service.description,
                style = FigmaProductDescription,
                color = TaskGoTextGray,
                maxLines = 2
            )
            Row(
                horizontalArrangement = Arrangement.spacedBy(8.dp),
                verticalAlignment = Alignment.CenterVertically
            ) {
                Icon(
                    imageVector = Icons.Default.LocationOn,
                    contentDescription = null,
                    tint = TaskGoTextGray,
                    modifier = Modifier.size(16.dp)
                )
                Text(
                    text = "${service.city}, ${service.state}",
                    style = FigmaProductDescription,
                    color = TaskGoTextGray
                )
            }
        }
    }
}


```

## [FRONTEND]: feature/search/presentation/UniversalSearchViewModel.kt

```kotlin
package com.taskgoapp.taskgo.feature.search.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.taskgoapp.taskgo.core.design.FilterState
import com.taskgoapp.taskgo.core.model.Product
import com.taskgoapp.taskgo.core.model.ServiceOrder
import com.taskgoapp.taskgo.domain.repository.ProductsRepository
import com.taskgoapp.taskgo.domain.repository.ServiceRepository
import com.taskgoapp.taskgo.domain.repository.CategoriesRepository
import com.taskgoapp.taskgo.data.local.datastore.FilterPreferencesManager
import com.taskgoapp.taskgo.core.location.LocationManager
import com.taskgoapp.taskgo.core.location.calculateDistance
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import javax.inject.Inject

data class UniversalSearchUiState(
    val isLoading: Boolean = false,
    val products: List<Product> = emptyList(),
    val services: List<ServiceOrder> = emptyList(),
    val categories: List<String> = emptyList()
)

@HiltViewModel
class UniversalSearchViewModel @Inject constructor(
    private val productsRepository: ProductsRepository,
    private val serviceRepository: ServiceRepository,
    private val categoriesRepository: CategoriesRepository,
    private val filterPreferencesManager: FilterPreferencesManager,
    private val locationManager: LocationManager
) : ViewModel() {

    private val _uiState = MutableStateFlow(UniversalSearchUiState())
    val uiState: StateFlow<UniversalSearchUiState> = _uiState.asStateFlow()

    private val _filterState = MutableStateFlow(FilterState())
    val filterState: StateFlow<FilterState> = _filterState.asStateFlow()

    val allProducts = productsRepository
        .observeProducts()
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyList())

    val allServices = serviceRepository
        .observeServiceOrders()
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyList())

    val productCategories = categoriesRepository
        .observeProductCategories()
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyList())

    val serviceCategories = categoriesRepository
        .observeServiceCategories()
        .map { categories -> categories.map { it.name } }
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyList())

    val filteredProducts = combine(
        allProducts,
        filterState
    ) { products, filters ->
        applyFiltersToProductsSync(products, filters)
    }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyList())

    val filteredServices = combine(
        allServices,
        filterState
    ) { services, filters ->
        applyFiltersToServicesSync(services, filters)
    }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyList())

    init {
        viewModelScope.launch {
            combine(
                filteredProducts,
                filteredServices,
                productCategories,
                serviceCategories
            ) { products, services, prodCats, servCats ->
                UniversalSearchUiState(
                    isLoading = false,
                    products = products,
                    services = services,
                    categories = (prodCats + servCats).distinct()
                )
            }.collect { newState ->
                _uiState.value = newState
            }
        }
    }

    fun updateFilterState(newState: FilterState) {
        _filterState.value = newState
        viewModelScope.launch {
            filterPreferencesManager.saveProductFilters(newState)
            filterPreferencesManager.saveServiceFilters(newState)
        }
    }

    fun updateSearchQuery(query: String) {
        updateFilterState(_filterState.value.copy(searchQuery = query))
    }

    fun toggleCategory(category: String) {
        val currentCategories = _filterState.value.selectedCategories
        val newCategories = if (currentCategories.contains(category)) {
            currentCategories - category
        } else {
            currentCategories + category
        }
        updateFilterState(_filterState.value.copy(selectedCategories = newCategories))
    }

    private fun applyFiltersToProductsSync(
        products: List<Product>,
        filters: FilterState
    ): List<Product> {
        var filtered = products

        // Busca por texto
        if (filters.searchQuery.isNotBlank()) {
            val query = filters.searchQuery.lowercase()
            filtered = filtered.filter { product ->
                product.title.lowercase().contains(query) ||
                product.description?.lowercase()?.contains(query) == true ||
                product.sellerName?.lowercase()?.contains(query) == true
            }
        }

        // Filtrar por pre√ßo
        filters.priceRange?.let { range ->
            filtered = filtered.filter { product ->
                val price = product.price
                (range.min == null || price >= range.min) &&
                (range.max == null || price <= range.max)
            }
        }

        // Filtrar por avalia√ß√£o
        filters.minRating?.let { minRating ->
            filtered = filtered.filter { product ->
                product.rating != null && product.rating >= minRating
            }
        }

        // Filtrar por raio usando GPS (ser√° aplicado assincronamente quando necess√°rio)
        // TODO: Implementar filtro ass√≠ncrono quando necess√°rio

        // Ordenar
        filtered = when (filters.sortBy) {
            com.taskgoapp.taskgo.core.design.SortOption.PRICE_LOW_TO_HIGH -> 
                filtered.sortedBy { it.price }
            com.taskgoapp.taskgo.core.design.SortOption.PRICE_HIGH_TO_LOW -> 
                filtered.sortedByDescending { it.price }
            com.taskgoapp.taskgo.core.design.SortOption.RATING -> 
                filtered.sortedByDescending { it.rating ?: 0.0 }
            com.taskgoapp.taskgo.core.design.SortOption.NEWEST -> 
                filtered // TODO: Ordenar por data quando dispon√≠vel
            else -> filtered
        }

        return filtered
    }

    private fun applyFiltersToServicesSync(
        services: List<ServiceOrder>,
        filters: FilterState
    ): List<ServiceOrder> {
        var filtered = services

        // Busca por texto
        if (filters.searchQuery.isNotBlank()) {
            val query = filters.searchQuery.lowercase()
            filtered = filtered.filter { service ->
                service.category.lowercase().contains(query) ||
                service.description.lowercase().contains(query) ||
                service.city.lowercase().contains(query) ||
                service.state.lowercase().contains(query)
            }
        }

        // Filtrar por categorias
        if (filters.selectedCategories.isNotEmpty()) {
            filtered = filtered.filter { service ->
                filters.selectedCategories.contains(service.category)
            }
        }

        // Filtrar por localiza√ß√£o
        filters.location?.let { location ->
            if (location.city != null && location.city.isNotEmpty()) {
                filtered = filtered.filter { service ->
                    service.city.equals(location.city, ignoreCase = true)
                }
            }
            if (location.state != null && location.state.isNotEmpty()) {
                filtered = filtered.filter { service ->
                    service.state.equals(location.state, ignoreCase = true)
                }
            }
        }

        // Filtrar por avalia√ß√£o
        filters.minRating?.let { minRating ->
            filtered = filtered.filter { service ->
                service.rating != null && service.rating >= minRating
            }
        }

        // Ordenar - servi√ßos destacados primeiro
        filtered = when (filters.sortBy) {
            com.taskgoapp.taskgo.core.design.SortOption.NEWEST -> 
                filtered.sortedWith(compareByDescending<ServiceOrder> { it.featured == true }
                    .thenByDescending { it.date })
            com.taskgoapp.taskgo.core.design.SortOption.RATING -> 
                filtered.sortedWith(compareByDescending<ServiceOrder> { it.featured == true }
                    .thenByDescending { it.rating ?: 0.0 })
            com.taskgoapp.taskgo.core.design.SortOption.RELEVANCE -> 
                filtered.sortedByDescending { it.featured == true }
            else -> filtered.sortedByDescending { it.featured == true }
        }

        return filtered
    }
}


```

# Features - services


## [FRONTEND]: feature/services/presentation/AvaliarPrestadorScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.services.presentation
import com.taskgoapp.taskgo.core.theme.*

import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Star
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.core.design.AppTopBar

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AvaliarPrestadorScreen(
    onBackClick: () -> Unit
) {
    var rating by remember { mutableStateOf(5) }
    var review by remember { mutableStateOf("Excelente trabalho montando a estante!") }

    Scaffold(
        topBar = {
            AppTopBar(
                title = "Avaliar Prestador",
                onBackClick = onBackClick
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.spacedBy(24.dp)
        ) {
            // Provider info
            Column(
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                Text(
                    text = "Rodrigo Silva",
                    style = FigmaProductName,
                    color = TaskGoTextBlack,
                    fontWeight = FontWeight.Bold
                )
                Text(
                    text = "Montador de M√≥veis",
                    style = FigmaProductDescription,
                    color = TaskGoTextGray
                )
            }

            // Rating stars
            Row(
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                repeat(5) { index ->
                    Icon(
                        imageVector = Icons.Default.Star,
                        contentDescription = "Estrela ${index + 1}",
                        modifier = Modifier.size(32.dp),
                        tint = if (index < rating) TaskGoStarYellow else Color.Gray
                    )
                }
            }

            // Review text field
            OutlinedTextField(
                value = review,
                onValueChange = { review = it },
                modifier = Modifier.fillMaxWidth(),
                minLines = 4,
                maxLines = 6,
                colors = OutlinedTextFieldDefaults.colors(
                    focusedBorderColor = TaskGoDivider,
                    unfocusedBorderColor = TaskGoDivider
                )
            )

            Spacer(modifier = Modifier.weight(1f))

            // Send button
            Button(
                onClick = { /* TODO: Enviar avalia√ß√£o */ },
                modifier = Modifier.fillMaxWidth(),
                colors = ButtonDefaults.buttonColors(
                    containerColor = TaskGoGreen
                )
            ) {
                Text(
                    text = "Enviar",
                    style = FigmaButtonText,
                    color = Color.White,
                    fontWeight = FontWeight.Bold
                )
            }
        }
    }
}

```

## [FRONTEND]: feature/services/presentation/components/CancelServiceDialog.kt

```kotlin
package com.taskgoapp.taskgo.feature.services.presentation.components

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.core.theme.*

@Composable
fun CancelServiceDialog(
    onDismiss: () -> Unit,
    onConfirm: (reason: String, refundAmount: Double?) -> Unit
) {
    var reason by remember { mutableStateOf("") }
    var hasRefund by remember { mutableStateOf(false) }
    var refundAmountText by remember { mutableStateOf("") }
    var showError by remember { mutableStateOf(false) }
    
    AlertDialog(
        onDismissRequest = onDismiss,
        title = {
            Text(
                text = "Cancelar Servi√ßo",
                style = MaterialTheme.typography.titleLarge,
                fontWeight = FontWeight.Bold,
                color = TaskGoTextDark
            )
        },
        text = {
            Column(
                modifier = Modifier.fillMaxWidth(),
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                OutlinedTextField(
                    value = reason,
                    onValueChange = { 
                        reason = it
                        showError = false
                    },
                    modifier = Modifier.fillMaxWidth(),
                    label = { Text("Motivo do cancelamento *") },
                    placeholder = { Text("Descreva o motivo do cancelamento") },
                    minLines = 3,
                    maxLines = 5,
                    colors = OutlinedTextFieldDefaults.colors(
                        focusedBorderColor = TaskGoGreen,
                        unfocusedBorderColor = TaskGoDivider
                    ),
                    isError = showError && reason.isBlank()
                )
                
                if (showError && reason.isBlank()) {
                    Text(
                        text = "O motivo √© obrigat√≥rio",
                        color = MaterialTheme.colorScheme.error,
                        style = MaterialTheme.typography.bodySmall
                    )
                }
                
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(8.dp),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Checkbox(
                        checked = hasRefund,
                        onCheckedChange = { hasRefund = it }
                    )
                    Text(
                        text = "Houve reembolso?",
                        style = MaterialTheme.typography.bodyMedium,
                        color = TaskGoTextDark
                    )
                }
                
                if (hasRefund) {
                    OutlinedTextField(
                        value = refundAmountText,
                        onValueChange = { 
                            // Permitir apenas n√∫meros e ponto
                            refundAmountText = it.filter { char -> char.isDigit() || char == '.' }
                        },
                        modifier = Modifier.fillMaxWidth(),
                        label = { Text("Valor do reembolso (R$)") },
                        placeholder = { Text("0.00") },
                        singleLine = true,
                        colors = OutlinedTextFieldDefaults.colors(
                            focusedBorderColor = TaskGoGreen,
                            unfocusedBorderColor = TaskGoDivider
                        )
                    )
                }
            }
        },
        confirmButton = {
            Button(
                onClick = {
                    if (reason.isBlank()) {
                        showError = true
                        return@Button
                    }
                    
                    val refund = if (hasRefund && refundAmountText.isNotBlank()) {
                        refundAmountText.toDoubleOrNull()
                    } else {
                        null
                    }
                    
                    onConfirm(reason, refund)
                },
                colors = ButtonDefaults.buttonColors(
                    containerColor = MaterialTheme.colorScheme.error
                ),
                shape = RoundedCornerShape(8.dp)
            ) {
                Text("Cancelar Servi√ßo", fontWeight = FontWeight.Bold)
            }
        },
        dismissButton = {
            TextButton(
                onClick = onDismiss,
                shape = RoundedCornerShape(8.dp)
            ) {
                Text("Voltar", color = TaskGoTextGray)
            }
        },
        shape = RoundedCornerShape(16.dp),
        containerColor = TaskGoBackgroundWhite
    )
}


```

## [FRONTEND]: feature/services/presentation/components/CompleteServiceDialog.kt

```kotlin
package com.taskgoapp.taskgo.feature.services.presentation.components

import android.net.Uri
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.PickVisualMediaRequest
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.lazy.itemsIndexed
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Close
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import coil.compose.AsyncImage
import com.taskgoapp.taskgo.core.permissions.PermissionHandler
import com.taskgoapp.taskgo.core.permissions.rememberImageReadPermissionLauncher
import com.taskgoapp.taskgo.core.theme.*

@Composable
fun CompleteServiceDialog(
    onDismiss: () -> Unit,
    onConfirm: (description: String, time: String, mediaUris: List<Uri>) -> Unit
) {
    var description by remember { mutableStateOf("") }
    var time by remember { mutableStateOf("") }
    var selectedMediaUris by remember { mutableStateOf<List<Uri>>(emptyList()) }
    var showError by remember { mutableStateOf(false) }
    val context = LocalContext.current
    val maxMediaCount = 10
    
    // Verificar permiss√£o reativamente
    val hasImagePermission by remember {
        mutableStateOf(PermissionHandler.hasImageReadPermission(context))
    }
    
    // Launcher para sele√ß√£o m√∫ltipla de m√≠dias
    val mediaLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.PickMultipleVisualMedia(maxItems = maxMediaCount)
    ) { uris: List<Uri> ->
        val currentMedia = selectedMediaUris.toMutableList()
        val availableSlots = maxMediaCount - currentMedia.size
        val newMedia = currentMedia + uris.take(availableSlots)
        selectedMediaUris = newMedia.take(maxMediaCount)
    }
    
    val imagePermissionLauncher = rememberImageReadPermissionLauncher(
        onPermissionGranted = {
            mediaLauncher.launch(PickVisualMediaRequest(ActivityResultContracts.PickVisualMedia.ImageAndVideo))
        },
        onPermissionDenied = {
            // Permiss√£o negada
        }
    )
    
    AlertDialog(
        onDismissRequest = onDismiss,
        title = {
            Text(
                text = "Concluir Servi√ßo",
                style = MaterialTheme.typography.titleLarge,
                fontWeight = FontWeight.Bold,
                color = TaskGoTextDark
            )
        },
        text = {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .verticalScroll(rememberScrollState()),
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                OutlinedTextField(
                    value = description,
                    onValueChange = { 
                        description = it
                        showError = false
                    },
                    modifier = Modifier.fillMaxWidth(),
                    label = { Text("Descri√ß√£o do trabalho realizado *") },
                    placeholder = { Text("Descreva o que foi feito") },
                    minLines = 3,
                    maxLines = 5,
                    colors = OutlinedTextFieldDefaults.colors(
                        focusedBorderColor = TaskGoGreen,
                        unfocusedBorderColor = TaskGoDivider
                    ),
                    isError = showError && description.isBlank()
                )
                
                if (showError && description.isBlank()) {
                    Text(
                        text = "A descri√ß√£o √© obrigat√≥ria",
                        color = MaterialTheme.colorScheme.error,
                        style = MaterialTheme.typography.bodySmall
                    )
                }
                
                OutlinedTextField(
                    value = time,
                    onValueChange = { time = it },
                    modifier = Modifier.fillMaxWidth(),
                    label = { Text("Tempo levado") },
                    placeholder = { Text("Ex: 2 horas, 30 minutos") },
                    singleLine = true,
                    colors = OutlinedTextFieldDefaults.colors(
                        focusedBorderColor = TaskGoGreen,
                        unfocusedBorderColor = TaskGoDivider
                    )
                )
                
                // Se√ß√£o de m√≠dias
                Column(
                    verticalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    Text(
                        text = "Fotos/V√≠deos (opcional)",
                        style = MaterialTheme.typography.labelMedium,
                        color = TaskGoTextDark,
                        fontWeight = FontWeight.Medium
                    )
                    
                    // Preview de m√≠dias selecionadas
                    if (selectedMediaUris.isNotEmpty()) {
                        LazyRow(
                            horizontalArrangement = Arrangement.spacedBy(8.dp),
                            modifier = Modifier.fillMaxWidth()
                        ) {
                            itemsIndexed(selectedMediaUris) { index, uri ->
                                Box(
                                    modifier = Modifier
                                        .size(100.dp)
                                        .clip(RoundedCornerShape(8.dp))
                                ) {
                                    AsyncImage(
                                        model = uri,
                                        contentDescription = "M√≠dia ${index + 1}",
                                        modifier = Modifier.fillMaxSize(),
                                        contentScale = ContentScale.Crop
                                    )
                                    
                                    // Bot√£o remover
                                    IconButton(
                                        onClick = {
                                            selectedMediaUris = selectedMediaUris.filterIndexed { i, _ -> i != index }
                                        },
                                        modifier = Modifier.align(Alignment.TopEnd)
                                    ) {
                                        Box(
                                            modifier = Modifier
                                                .size(24.dp)
                                                .clip(RoundedCornerShape(12.dp))
                                                .background(MaterialTheme.colorScheme.errorContainer),
                                            contentAlignment = Alignment.Center
                                        ) {
                                            Icon(
                                                imageVector = Icons.Default.Close,
                                                contentDescription = "Remover",
                                                tint = MaterialTheme.colorScheme.error,
                                                modifier = Modifier.size(16.dp)
                                            )
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    // Bot√£o adicionar m√≠dia
                    if (selectedMediaUris.size < maxMediaCount) {
                        OutlinedButton(
                            onClick = {
                                if (hasImagePermission) {
                                    mediaLauncher.launch(PickVisualMediaRequest(ActivityResultContracts.PickVisualMedia.ImageAndVideo))
                                } else {
                                    imagePermissionLauncher.launch(PermissionHandler.getImageReadPermission())
                                }
                            },
                            modifier = Modifier.fillMaxWidth(),
                            colors = ButtonDefaults.outlinedButtonColors(
                                contentColor = TaskGoGreen
                            )
                        ) {
                            Icon(
                                imageVector = Icons.Default.Add,
                                contentDescription = null,
                                modifier = Modifier.size(20.dp)
                            )
                            Spacer(modifier = Modifier.width(8.dp))
                            Text("Adicionar Foto/V√≠deo")
                        }
                    }
                    
                    if (selectedMediaUris.size >= maxMediaCount) {
                        Text(
                            text = "M√°ximo de $maxMediaCount m√≠dias atingido",
                            style = MaterialTheme.typography.bodySmall,
                            color = TaskGoTextGray
                        )
                    }
                }
            }
        },
        confirmButton = {
            Button(
                onClick = {
                    if (description.isBlank()) {
                        showError = true
                        return@Button
                    }
                    onConfirm(description, time, selectedMediaUris)
                },
                colors = ButtonDefaults.buttonColors(
                    containerColor = TaskGoGreen
                ),
                shape = RoundedCornerShape(8.dp)
            ) {
                Text("Concluir Servi√ßo", fontWeight = FontWeight.Bold)
            }
        },
        dismissButton = {
            TextButton(
                onClick = onDismiss,
                shape = RoundedCornerShape(8.dp)
            ) {
                Text("Cancelar", color = TaskGoTextGray)
            }
        },
        shape = RoundedCornerShape(16.dp),
        containerColor = TaskGoBackgroundWhite
    )
}


```

## [FRONTEND]: feature/services/presentation/ConfirmarPropostaScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.services.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.CheckCircle
import androidx.compose.material.icons.filled.ErrorOutline
import androidx.compose.material.icons.filled.HourglassEmpty
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.graphics.Color
import androidx.compose.foundation.BorderStroke
import com.taskgoapp.taskgo.core.theme.*

@Composable
fun ConfirmarPropostaScreen(
    onBackClick: () -> Unit,
    onConfirmar: () -> Unit,
    variant: String? = null // null, aceita, recusada, erro, sucesso, pendente
) {
    val statusLabel = when(variant) {
        "aceita" -> "Proposta aceita!"
        "recusada" -> "Proposta recusada"
        "erro" -> "Erro ao processar"
        "sucesso" -> "A√ß√£o conclu√≠da"
        "pendente" -> "Aguardando confirma√ß√£o"
        else -> "Confirmar proposta"
    }
    val statusColor = when(variant) {
        "aceita","sucesso" -> TaskGoSuccess
        "recusada" -> TaskGoError
        "pendente" -> TaskGoWarning
        "erro" -> TaskGoError
        else -> TaskGoPrimary
    }
    val statusIcon = when(variant) {
        "aceita","sucesso" -> Icons.Default.CheckCircle
        "recusada" -> Icons.Default.ErrorOutline
        "pendente" -> Icons.Default.HourglassEmpty
        "erro" -> Icons.Default.ErrorOutline
        else -> null
    }
        Column(
        Modifier.fillMaxSize().padding(32.dp), horizontalAlignment = Alignment.CenterHorizontally
    ) {
        statusIcon?.let { icon ->
            Icon(icon, null, tint=statusColor, modifier=Modifier.size(60.dp))
            Spacer(Modifier.height(10.dp))
        }
        Text(statusLabel, style=FigmaSectionTitle, color=statusColor)
        Spacer(Modifier.height(16.dp))
        Card(Modifier.fillMaxWidth()) {
            Column(Modifier.padding(16.dp)) {
                Text("Servi√ßo: [Dados do servi√ßo]", color=TaskGoTextBlack, style=FigmaProductName)
                Text("Proposta: [Valor da proposta]", color=TaskGoTextBlack, style=FigmaPrice)
                Text("Cliente: [Nome do cliente]", color=TaskGoTextGray, style=FigmaProductDescription)
            }
        }
        Spacer(Modifier.height(24.dp))
        if(variant==null) {
            Row(horizontalArrangement=Arrangement.spacedBy(8.dp)) {
                Button(
                    onClick=onConfirmar,
                    colors = ButtonDefaults.buttonColors(containerColor = TaskGoGreen)
                ) {
                    Text("Aceitar proposta", style=FigmaButtonText, color=TaskGoBackgroundWhite) 
                }
                OutlinedButton(
                    onClick=onBackClick,
                    colors = ButtonDefaults.outlinedButtonColors(
                        containerColor = Color.Transparent
                    ),
                    border = BorderStroke(1.dp, TaskGoGreen)
                ) { 
                    Text("Recusar", style=FigmaButtonText, color=TaskGoGreen) 
                    }
                }
        } else {
            OutlinedButton(
                onClick=onBackClick,
                colors = ButtonDefaults.outlinedButtonColors(
                    containerColor = Color.Transparent
                ),
                border = BorderStroke(1.dp, TaskGoGreen)
            ) {
                Text("Voltar", style=FigmaButtonText, color=TaskGoGreen) 
            }
        }
    }
}

```

## [FRONTEND]: feature/services/presentation/CreateWorkOrderScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.services.presentation

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowDropDown
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.collectAsState
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.taskgoapp.taskgo.R
import com.taskgoapp.taskgo.core.design.*
import com.taskgoapp.taskgo.core.security.DocumentVerificationBlock
import com.taskgoapp.taskgo.core.security.DocumentVerificationManager
import com.taskgoapp.taskgo.core.theme.*
import com.taskgoapp.taskgo.data.firebase.FirebaseFunctionsService
import com.taskgoapp.taskgo.data.repository.FirestoreUserRepository
import com.taskgoapp.taskgo.domain.repository.CategoriesRepository
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch
import dagger.hilt.android.lifecycle.HiltViewModel
import java.text.SimpleDateFormat
import java.util.*
import javax.inject.Inject

data class CreateOrderUiState(
    val isLoading: Boolean = false,
    val error: String? = null,
    val success: Boolean = false
)

@HiltViewModel
class CreateWorkOrderViewModel @Inject constructor(
    private val documentVerificationManager: DocumentVerificationManager,
    private val firebaseFunctionsService: FirebaseFunctionsService,
    private val categoriesRepository: CategoriesRepository,
    private val userRepository: FirestoreUserRepository,
    private val authRepository: com.taskgoapp.taskgo.data.repository.FirebaseAuthRepository
) : ViewModel() {
    private val _isVerified = MutableStateFlow(false)
    val isVerified: StateFlow<Boolean> = _isVerified.asStateFlow()
    
    private val _uiState = MutableStateFlow(CreateOrderUiState())
    val uiState: StateFlow<CreateOrderUiState> = _uiState.asStateFlow()
    
    val serviceCategories = categoriesRepository.observeServiceCategories()
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())
    
    init {
        viewModelScope.launch {
            _isVerified.value = documentVerificationManager.hasDocumentsVerified()
        }
    }
    
    suspend fun createOrder(
        category: String,
        description: String,
        location: String,
        budget: Double?,
        dueDate: String?
    ): Result<String> {
        return try {
            android.util.Log.d("CreateWorkOrderVM", "üîµ Criando ordem de servi√ßo...")
            android.util.Log.d("CreateWorkOrderVM", "   category: $category")
            android.util.Log.d("CreateWorkOrderVM", "   description: ${description.take(50)}...")
            android.util.Log.d("CreateWorkOrderVM", "   location: $location")
            android.util.Log.d("CreateWorkOrderVM", "   budget: $budget")
            android.util.Log.d("CreateWorkOrderVM", "   dueDate: $dueDate")
            
            _uiState.value = _uiState.value.copy(isLoading = true, error = null, success = false)
            
            val result = firebaseFunctionsService.createOrder(
                serviceId = null,
                category = category,
                details = description,
                location = location,
                budget = budget,
                dueDate = dueDate
            )
            
            android.util.Log.d("CreateWorkOrderVM", "   Resultado da CF: isSuccess=${result.isSuccess}")
            
            when {
                result.isSuccess -> {
                    val data = result.getOrNull()
                    android.util.Log.d("CreateWorkOrderVM", "   Dados retornados: $data")
                    val orderId = data?.get("orderId") as? String
                    if (orderId != null) {
                        android.util.Log.d("CreateWorkOrderVM", "‚úÖ Ordem criada com sucesso: orderId=$orderId")
                        _uiState.value = _uiState.value.copy(
                            isLoading = false,
                            success = true,
                            error = null
                        )
                        Result.success(orderId)
                    } else {
                        android.util.Log.e("CreateWorkOrderVM", "‚ùå Resposta inv√°lida: orderId n√£o encontrado")
                        android.util.Log.e("CreateWorkOrderVM", "   Dados recebidos: $data")
                        _uiState.value = _uiState.value.copy(
                            isLoading = false,
                            error = "Erro ao criar ordem: resposta inv√°lida"
                        )
                        Result.failure(Exception("Resposta inv√°lida"))
                    }
                }
                else -> {
                    val exception = result.exceptionOrNull()
                    val error = exception?.message ?: "Erro desconhecido"
                    android.util.Log.e("CreateWorkOrderVM", "‚ùå Erro ao criar ordem: $error", exception)
                    android.util.Log.e("CreateWorkOrderVM", "   Exception type: ${exception?.javaClass?.simpleName}")
                    _uiState.value = _uiState.value.copy(
                        isLoading = false,
                        error = error
                    )
                    Result.failure(exception ?: Exception(error))
                }
            }
        } catch (e: Exception) {
            _uiState.value = _uiState.value.copy(
                isLoading = false,
                error = e.message ?: "Erro ao criar ordem"
            )
            Result.failure(e)
        }
    }
    
    suspend fun getUserAddress(): String? {
        return try {
            val currentUser = authRepository.getCurrentUser()
            if (currentUser != null) {
                val user = userRepository.getUser(currentUser.uid)
                val address = user?.address
                if (address != null) {
                    val parts = mutableListOf<String>()
                    if (address.street.isNotEmpty()) parts.add(address.street)
                    if (address.number.isNotEmpty()) parts.add(address.number)
                    if (address.neighborhood.isNotEmpty()) parts.add(address.neighborhood)
                    if (address.city.isNotEmpty()) parts.add(address.city)
                    if (address.state.isNotEmpty()) parts.add(address.state)
                    parts.joinToString(", ")
                } else null
            } else null
        } catch (e: Exception) {
            null
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun CreateWorkOrderScreen(
    onBackClick: () -> Unit,
    onWorkOrderCreated: () -> Unit,
    onNavigateToIdentityVerification: () -> Unit = {},
    viewModel: CreateWorkOrderViewModel = hiltViewModel()
) {
    val isVerified by viewModel.isVerified.collectAsState()
    val uiState by viewModel.uiState.collectAsState()
    val categories by viewModel.serviceCategories.collectAsState()
    
    var selectedCategories by remember { mutableStateOf<Set<String>>(emptySet()) }
    var description by remember { mutableStateOf("") }
    var address by remember { mutableStateOf("") }
    var city by remember { mutableStateOf("") }
    var state by remember { mutableStateOf("") }
    var budget by remember { mutableStateOf("") }
    var dueDate by remember { mutableStateOf<Date?>(null) }
    var showDatePicker by remember { mutableStateOf(false) }
    
    val dateFormat = remember { SimpleDateFormat("dd/MM/yyyy", Locale("pt", "BR")) }
    
    // Load user address on first composition
    LaunchedEffect(Unit) {
        val userAddress = viewModel.getUserAddress()
        if (userAddress != null && address.isEmpty()) {
            address = userAddress
            // Try to extract city and state from address
            val parts = userAddress.split(",").map { it.trim() }
            if (parts.size >= 2) {
                city = parts[parts.size - 2]
                state = parts[parts.size - 1]
            }
        }
    }
    
    // Show success dialog
    LaunchedEffect(uiState.success) {
        if (uiState.success) {
            onWorkOrderCreated()
        }
    }
    
    DocumentVerificationBlock(
        isVerified = isVerified,
        onVerifyClick = onNavigateToIdentityVerification
    ) {
        Scaffold(
            topBar = {
                AppTopBar(
                    title = stringResource(R.string.services_create_order_title),
                    onBackClick = onBackClick
                )
            }
        ) { paddingValues ->
            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues)
                    .padding(16.dp)
                    .verticalScroll(rememberScrollState()),
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                Text(
                    text = stringResource(R.string.services_create_order_subtitle),
                    style = FigmaProductDescription,
                    color = TaskGoTextGray
                )
                
                // Category Selection (Checkboxes)
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    colors = CardDefaults.cardColors(containerColor = TaskGoSurface)
                ) {
                    Column(
                        modifier = Modifier.padding(16.dp),
                        verticalArrangement = Arrangement.spacedBy(12.dp)
                    ) {
                        Text(
                            text = "Categorias do Servi√ßo *",
                            style = MaterialTheme.typography.titleMedium,
                            fontWeight = FontWeight.Bold
                        )
                        Text(
                            text = "Selecione todas as categorias relacionadas ao servi√ßo que voc√™ precisa",
                            style = MaterialTheme.typography.bodySmall,
                            color = TaskGoTextGray
                        )
                        categories.forEach { category ->
                            Row(
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .clickable { 
                                        selectedCategories = if (selectedCategories.contains(category.name)) {
                                            selectedCategories - category.name
                                        } else {
                                            selectedCategories + category.name
                                        }
                                    },
                                verticalAlignment = Alignment.CenterVertically,
                                horizontalArrangement = Arrangement.SpaceBetween
                            ) {
                                Text(
                                    text = category.name,
                                    style = MaterialTheme.typography.bodyLarge
                                )
                                Checkbox(
                                    checked = selectedCategories.contains(category.name),
                                    onCheckedChange = { 
                                        selectedCategories = if (selectedCategories.contains(category.name)) {
                                            selectedCategories - category.name
                                        } else {
                                            selectedCategories + category.name
                                        }
                                    }
                                )
                            }
                        }
                    }
                }
                
                // Description
                OutlinedTextField(
                    value = description,
                    onValueChange = { description = it },
                    label = { Text("Descri√ß√£o do Servi√ßo *") },
                    placeholder = { Text("Descreva o servi√ßo que voc√™ precisa...") },
                    modifier = Modifier.fillMaxWidth(),
                    minLines = 4,
                    maxLines = 8,
                    colors = OutlinedTextFieldDefaults.colors(
                        focusedBorderColor = TaskGoGreen,
                        unfocusedBorderColor = TaskGoBorder
                    )
                )
                
                // Address
                OutlinedTextField(
                    value = address,
                    onValueChange = { address = it },
                    label = { Text("Endere√ßo *") },
                    placeholder = { Text("Rua, n√∫mero, bairro") },
                    modifier = Modifier.fillMaxWidth(),
                    colors = OutlinedTextFieldDefaults.colors(
                        focusedBorderColor = TaskGoGreen,
                        unfocusedBorderColor = TaskGoBorder
                    )
                )
                
                // City and State
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(16.dp)
                ) {
                    OutlinedTextField(
                        value = city,
                        onValueChange = { city = it },
                        label = { Text("Cidade *") },
                        modifier = Modifier.weight(1f),
                        colors = OutlinedTextFieldDefaults.colors(
                            focusedBorderColor = TaskGoGreen,
                            unfocusedBorderColor = TaskGoBorder
                        )
                    )
                    
                    OutlinedTextField(
                        value = state,
                        onValueChange = { state = it },
                        label = { Text("Estado *") },
                        placeholder = { Text("SP") },
                        modifier = Modifier.weight(1f),
                        colors = OutlinedTextFieldDefaults.colors(
                            focusedBorderColor = TaskGoGreen,
                            unfocusedBorderColor = TaskGoBorder
                        )
                    )
                }
                
                // Budget
                OutlinedTextField(
                    value = budget,
                    onValueChange = { 
                        // Only allow numbers and decimal point
                        if (it.matches(Regex("^\\d*\\.?\\d*$"))) {
                            budget = it
                        }
                    },
                    label = { Text("Or√ßamento (R$)") },
                    placeholder = { Text("0.00") },
                    modifier = Modifier.fillMaxWidth(),
                    leadingIcon = { Text("R$", color = TaskGoTextGray) },
                    colors = OutlinedTextFieldDefaults.colors(
                        focusedBorderColor = TaskGoGreen,
                        unfocusedBorderColor = TaskGoBorder
                    )
                )
                
                // Due Date
                OutlinedTextField(
                    value = dueDate?.let { dateFormat.format(it) } ?: "",
                    onValueChange = {},
                    readOnly = true,
                    label = { Text("Data Desejada") },
                    placeholder = { Text("Selecione uma data") },
                    modifier = Modifier
                        .fillMaxWidth()
                        .clickable { showDatePicker = true },
                    trailingIcon = {
                        IconButton(onClick = { showDatePicker = true }) {
                            Icon(Icons.Default.ArrowDropDown, contentDescription = "Selecionar data")
                        }
                    },
                    colors = OutlinedTextFieldDefaults.colors(
                        focusedBorderColor = TaskGoGreen,
                        unfocusedBorderColor = TaskGoBorder
                    )
                )
                
                // Error message
                uiState.error?.let { error ->
                    Card(
                        modifier = Modifier.fillMaxWidth(),
                        colors = CardDefaults.cardColors(
                            containerColor = MaterialTheme.colorScheme.errorContainer
                        )
                    ) {
                        Text(
                            text = error,
                            color = MaterialTheme.colorScheme.onErrorContainer,
                            modifier = Modifier.padding(12.dp)
                        )
                    }
                }
                
                Spacer(modifier = Modifier.height(8.dp))
                
                // Submit Button
                PrimaryButton(
                    text = if (uiState.isLoading) "Criando..." else stringResource(R.string.services_create_order_submit),
                    onClick = {
                        // Validation
                        if (selectedCategories.isEmpty()) {
                            return@PrimaryButton
                        }
                        if (description.isBlank()) {
                            return@PrimaryButton
                        }
                        if (address.isBlank() || city.isBlank() || state.isBlank()) {
                            return@PrimaryButton
                        }
                        
                        val location = "$address, $city, $state"
                        val budgetValue = budget.toDoubleOrNull()
                        val dueDateString = dueDate?.let { 
                            SimpleDateFormat("yyyy-MM-dd", Locale.US).format(it) 
                        }
                        
                        // Usar a primeira categoria selecionada como categoria principal
                        val primaryCategory = selectedCategories.first()
                        
                        viewModel.viewModelScope.launch {
                            viewModel.createOrder(
                                category = primaryCategory,
                                description = description,
                                location = location,
                                budget = budgetValue,
                                dueDate = dueDateString
                            )
                        }
                    },
                    modifier = Modifier.fillMaxWidth(),
                    enabled = !uiState.isLoading && selectedCategories.isNotEmpty()
                )
            }
        }
    }
    
    // Date Picker - Simple text input for now
    // In a production app, you might want to use a proper date picker library
    var dateInput by remember { mutableStateOf("") }
    
    LaunchedEffect(showDatePicker) {
        if (showDatePicker) {
            dateInput = dueDate?.let { dateFormat.format(it) } ?: ""
        }
    }
    
    if (showDatePicker) {
        AlertDialog(
            onDismissRequest = { showDatePicker = false },
            title = { Text("Selecionar Data") },
            text = {
                Column {
                    Text(
                        text = "Digite a data no formato DD/MM/AAAA",
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                    Spacer(modifier = Modifier.height(8.dp))
                    OutlinedTextField(
                        value = dateInput,
                        onValueChange = { 
                            // Format input as DD/MM/YYYY
                            val filtered = it.filter { char -> char.isDigit() }
                            val formatted = when {
                                filtered.isEmpty() -> ""
                                filtered.length <= 2 -> filtered
                                filtered.length <= 4 -> {
                                    if (filtered.length >= 2) {
                                        "${filtered.substring(0, 2)}/${filtered.substring(2)}"
                                    } else {
                                        filtered
                                    }
                                }
                                else -> {
                                    if (filtered.length >= 2) {
                                        val day = filtered.substring(0, 2)
                                        val month = if (filtered.length >= 4) {
                                            filtered.substring(2, 4)
                                        } else {
                                            filtered.substring(2)
                                        }
                                        val year = if (filtered.length > 4) {
                                            filtered.substring(4, minOf(8, filtered.length))
                                        } else {
                                            ""
                                        }
                                        if (year.isNotEmpty()) {
                                            "$day/$month/$year"
                                        } else {
                                            "$day/$month"
                                        }
                                    } else {
                                        filtered
                                    }
                                }
                            }
                            dateInput = formatted
                        },
                        placeholder = { Text("DD/MM/AAAA") },
                        modifier = Modifier.fillMaxWidth(),
                        keyboardOptions = androidx.compose.foundation.text.KeyboardOptions(
                            keyboardType = KeyboardType.Number
                        )
                    )
                }
            },
            confirmButton = {
                TextButton(
                    onClick = {
                        try {
                            val parsedDate = SimpleDateFormat("dd/MM/yyyy", Locale("pt", "BR")).parse(dateInput)
                            if (parsedDate != null && parsedDate.time >= System.currentTimeMillis()) {
                                dueDate = parsedDate
                                showDatePicker = false
                            }
                        } catch (e: Exception) {
                            // Invalid date format
                        }
                    }
                ) {
                    Text("Confirmar")
                }
            },
            dismissButton = {
                TextButton(onClick = { showDatePicker = false }) {
                    Text("Cancelar")
                }
            }
        )
    }
}



```

## [FRONTEND]: feature/services/presentation/DetalhesPropostaScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.services.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.core.theme.*

@Composable
fun DetalhesPropostaScreen(
    propostaId: String,
    onBackClick: () -> Unit,
    onConfirmar: () -> Unit,
    variant: String? = null // null, aceita, recusada, erro, pendente, sucesso
) {
    val statusLabel = when(variant) {
        "aceita" -> "Proposta aceita"
        "sucesso" -> "Sucesso! Proposta aceita."
        "recusada" -> "Proposta recusada"
        "pendente" -> "Aguardando resposta"
        "erro" -> "Erro ao processar"
        else -> "Detalhes da proposta"
    }
    val statusColor = when(variant) {
        "aceita","sucesso" -> TaskGoSuccess
        "recusada" -> TaskGoError
        "pendente" -> TaskGoWarning
        "erro" -> TaskGoError
        else -> TaskGoPrimary
    }
    Column(
        Modifier.fillMaxSize().padding(24.dp), horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text(statusLabel, style = FigmaSectionTitle, color = statusColor)
        Spacer(Modifier.height(14.dp))
        Card(Modifier.fillMaxWidth()) {
            Column(Modifier.padding(14.dp)) {
                Text("Servi√ßo: [Dados do servi√ßo]", color=TaskGoTextBlack)
                Text("Valor: [Valor da proposta]", color=TaskGoTextBlack)
                Text("Proposta enviada por: [Nome do prestador]", color=TaskGoTextGray)
                if(variant=="recusada"||variant=="erro") {
                    Spacer(Modifier.height(10.dp))
                    Text("Motivo: Proposta recusada pelo cliente.", color=TaskGoError)
                }
                if(variant=="pendente") {
                    Spacer(Modifier.height(10.dp))
                    Text("Aguardando confirma√ß√£o do cliente.", color=TaskGoWarning)
                }
            }
        }
        Spacer(Modifier.height(24.dp))
        if(variant==null||variant=="pendente"){
            Button(onClick=onConfirmar) { Text("Aceitar proposta") }
        }
        OutlinedButton(onClick=onBackClick) { Text("Voltar") }
    }
}

```

## [FRONTEND]: feature/services/presentation/DetalhesServicoScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.services.presentation

import android.util.Log
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.ui.draw.clip
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.automirrored.filled.ArrowForward
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.rememberCoroutineScope
import kotlinx.coroutines.launch
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.viewinterop.AndroidView
import androidx.compose.ui.window.Dialog
import androidx.hilt.navigation.compose.hiltViewModel
import coil.compose.AsyncImage
import coil.request.ImageRequest
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.design.FullScreenVideoPlayer
import com.taskgoapp.taskgo.core.theme.*
import com.google.firebase.auth.FirebaseAuth
import java.text.NumberFormat
import java.util.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun DetalhesServicoScreen(
    serviceId: String,
    onBackClick: () -> Unit,
    onEditService: (String) -> Unit = {},
    onNavigateToReviews: ((String) -> Unit)? = null,
    onNavigateToProviderProfile: ((String) -> Unit)? = null,
    onNavigateToChat: ((String) -> Unit)? = null,
    viewModel: ServiceDetailViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    val context = LocalContext.current
    val scope = rememberCoroutineScope()
    val scrollState = rememberScrollState()
    val currentUserId = remember { FirebaseAuth.getInstance().currentUser?.uid ?: "" }

    LaunchedEffect(serviceId) {
        if (serviceId.isNotBlank()) {
            Log.d("DetalhesServicoScreen", "Carregando servi√ßo: $serviceId")
            viewModel.loadService(serviceId)
        }
    }
    
    // Verificar se o usu√°rio atual √© o dono do servi√ßo
    val canEdit = remember(uiState.service, currentUserId) {
        uiState.service?.providerId == currentUserId && currentUserId.isNotBlank()
    }
    
    fun handleSendMessage(providerId: String) {
        scope.launch {
            try {
                val threadId = viewModel.getOrCreateThreadForProvider(providerId)
                onNavigateToChat?.invoke(threadId)
            } catch (e: Exception) {
                Log.e("DetalhesServicoScreen", "Erro ao criar/buscar thread", e)
                // Mostrar erro ao usu√°rio se necess√°rio
            }
        }
    }

    Scaffold(
        topBar = {
            AppTopBar(
                title = "Detalhes do Servi√ßo",
                onBackClick = onBackClick
            )
        },
        floatingActionButton = {
            if (uiState.service != null && canEdit) {
                FloatingActionButton(
                    onClick = { onEditService(serviceId) },
                    containerColor = TaskGoGreen
                ) {
                    Icon(
                        imageVector = Icons.Default.Edit,
                        contentDescription = "Editar Servi√ßo",
                        tint = Color.White
                    )
                }
            }
        }
    ) { paddingValues ->
        when {
            uiState.isLoading -> {
                Box(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(paddingValues),
                    contentAlignment = Alignment.Center
                ) {
                    CircularProgressIndicator(color = TaskGoGreen)
                }
            }
            uiState.error != null -> {
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp),
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.Center
                ) {
                    Text(
                        text = uiState.error ?: "Erro desconhecido",
                        color = MaterialTheme.colorScheme.error,
                        style = MaterialTheme.typography.bodyLarge
                    )
                }
            }
            uiState.service != null -> {
                val service = uiState.service!!
                val priceFormat = NumberFormat.getCurrencyInstance(Locale("pt", "BR"))
                
                Column(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(paddingValues)
                        .verticalScroll(scrollState)
                ) {
                    // Imagens do servi√ßo
                    if (service.images.isNotEmpty()) {
                        Card(
                            modifier = Modifier
                                .fillMaxWidth()
                                .height(300.dp)
                                .padding(16.dp),
                            shape = RoundedCornerShape(12.dp)
                        ) {
                            LazyRow(
                                horizontalArrangement = Arrangement.spacedBy(8.dp),
                                contentPadding = PaddingValues(8.dp)
                            ) {
                                items(service.images) { imageUrl ->
                                    AsyncImage(
                                        model = ImageRequest.Builder(context)
                                            .data(imageUrl)
                                            .size(600)
                                            .build(),
                                        contentDescription = "Imagem do servi√ßo",
                                        modifier = Modifier
                                            .fillMaxHeight()
                                            .width(280.dp)
                                            .clip(RoundedCornerShape(8.dp)),
                                        contentScale = ContentScale.Crop
                                    )
                                }
                            }
                        }
                    }

                    // Informa√ß√µes principais
                    Card(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(horizontal = 16.dp),
                        colors = CardDefaults.cardColors(containerColor = TaskGoSurface)
                    ) {
                        Column(
                            modifier = Modifier.padding(16.dp),
                            verticalArrangement = Arrangement.spacedBy(12.dp)
                        ) {
                            // T√≠tulo
                            Text(
                                text = service.title.ifEmpty { "Sem t√≠tulo" },
                                style = MaterialTheme.typography.headlineSmall,
                                fontWeight = FontWeight.Bold,
                                color = TaskGoTextBlack
                            )

                            // Pre√ßo
                            Text(
                                text = priceFormat.format(service.price),
                                style = MaterialTheme.typography.headlineMedium,
                                fontWeight = FontWeight.Bold,
                                color = TaskGoPriceGreen
                            )

                            // Categoria - destacada
                            if (service.category.isNotBlank()) {
                                Surface(
                                    color = TaskGoGreen.copy(alpha = 0.15f),
                                    shape = RoundedCornerShape(8.dp)
                                ) {
                                    Text(
                                        text = service.category,
                                        style = MaterialTheme.typography.titleMedium,
                                        color = TaskGoGreen,
                                        modifier = Modifier.padding(horizontal = 12.dp, vertical = 8.dp),
                                        fontWeight = FontWeight.Bold
                                    )
                                }
                            }
                            
                            // Status
                            Surface(
                                color = if (service.active) TaskGoSuccess.copy(alpha = 0.1f) else TaskGoError.copy(alpha = 0.1f),
                                shape = RoundedCornerShape(4.dp)
                            ) {
                                Text(
                                    text = if (service.active) "Ativo" else "Inativo",
                                    style = MaterialTheme.typography.bodySmall,
                                    color = if (service.active) TaskGoSuccess else TaskGoError,
                                    modifier = Modifier.padding(horizontal = 8.dp, vertical = 4.dp),
                                    fontWeight = FontWeight.SemiBold
                                )
                            }
                        }
                    }

                    Spacer(modifier = Modifier.height(16.dp))

                    // Informa√ß√µes do Prestador - SEMPRE mostrar se houver providerId
                    if (service.providerId != null && service.providerId.isNotBlank()) {
                        Card(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(horizontal = 16.dp)
                                .clickable {
                                    onNavigateToProviderProfile?.invoke(service.providerId!!)
                                },
                            colors = CardDefaults.cardColors(containerColor = TaskGoSurface)
                        ) {
                            Row(
                                modifier = Modifier.padding(16.dp),
                                verticalAlignment = Alignment.CenterVertically,
                                horizontalArrangement = Arrangement.spacedBy(12.dp)
                            ) {
                                // Usar UserAvatarNameLoader para carregar dados do prestador
                                com.taskgoapp.taskgo.core.design.UserAvatarNameLoader(
                                    userId = service.providerId,
                                    onUserClick = {
                                        onNavigateToProviderProfile?.invoke(service.providerId!!)
                                    },
                                    avatarSize = 56.dp,
                                    showName = true,
                                    modifier = Modifier.weight(1f)
                                )
                                
                                // √çcone de navega√ß√£o
                                Icon(
                                    imageVector = Icons.AutoMirrored.Filled.ArrowForward,
                                    contentDescription = "Ver perfil",
                                    tint = TaskGoTextGray
                                )
                            }
                        }
                        
                        Spacer(modifier = Modifier.height(16.dp))
                        
                        // Bot√£o Enviar Mensagem (apenas se n√£o for o pr√≥prio usu√°rio)
                        if (service.providerId != currentUserId) {
                            Button(
                                onClick = {
                                    handleSendMessage(service.providerId!!)
                                },
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .padding(horizontal = 16.dp),
                                colors = ButtonDefaults.buttonColors(
                                    containerColor = TaskGoGreen
                                ),
                                shape = RoundedCornerShape(8.dp)
                            ) {
                                Icon(
                                    imageVector = Icons.Default.Message,
                                    contentDescription = null,
                                    tint = Color.White,
                                    modifier = Modifier.size(20.dp)
                                )
                                Spacer(modifier = Modifier.width(8.dp))
                                Text(
                                    text = "Enviar Mensagem",
                                    style = MaterialTheme.typography.titleMedium,
                                    color = Color.White
                                )
                            }
                            
                            Spacer(modifier = Modifier.height(16.dp))
                        }
                    }

                    // Descri√ß√£o
                    if (service.description.isNotBlank()) {
                        Card(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(horizontal = 16.dp),
                            colors = CardDefaults.cardColors(containerColor = TaskGoSurface)
                        ) {
                            Column(
                                modifier = Modifier.padding(16.dp),
                                verticalArrangement = Arrangement.spacedBy(8.dp)
                            ) {
                    Text(
                                    text = "Descri√ß√£o",
                                    style = MaterialTheme.typography.titleMedium,
                                    fontWeight = FontWeight.Bold,
                                    color = TaskGoTextBlack
                    )
                    Text(
                                    text = service.description,
                                    style = MaterialTheme.typography.bodyMedium,
                        color = TaskGoTextGray
                    )
                }
            }
                    }

                    Spacer(modifier = Modifier.height(16.dp))

                    // V√≠deos
                    if (service.videos.isNotEmpty()) {
            Card(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(horizontal = 16.dp),
                            colors = CardDefaults.cardColors(containerColor = TaskGoSurface)
            ) {
                Column(
                                modifier = Modifier.padding(16.dp),
                                verticalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    Text(
                                    text = "V√≠deos",
                                    style = MaterialTheme.typography.titleMedium,
                                    fontWeight = FontWeight.Bold,
                                    color = TaskGoTextBlack
                                )
                                
                                LazyRow(
                                    horizontalArrangement = Arrangement.spacedBy(12.dp)
                                ) {
                                    items(service.videos) { videoUrl ->
                                        VideoThumbnailCard(
                                            videoUrl = videoUrl,
                                            modifier = Modifier.size(200.dp, 150.dp)
                                        )
                                    }
                                }
                            }
                        }
                    }

                    Spacer(modifier = Modifier.height(16.dp))

                    // Tags
                    if (service.tags.isNotEmpty()) {
                        Card(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(horizontal = 16.dp),
                            colors = CardDefaults.cardColors(containerColor = TaskGoSurface)
                        ) {
                            Column(
                                modifier = Modifier.padding(16.dp),
                                verticalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        Text(
                                    text = "Tags",
                                    style = MaterialTheme.typography.titleMedium,
                                    fontWeight = FontWeight.Bold,
                                    color = TaskGoTextBlack
                        )
                        Row(
                                    horizontalArrangement = Arrangement.spacedBy(8.dp),
                                    modifier = Modifier.fillMaxWidth()
                                ) {
                                    service.tags.forEach { tag ->
                                        Surface(
                                            color = TaskGoGreen.copy(alpha = 0.1f),
                                            shape = RoundedCornerShape(16.dp)
                                        ) {
                                            Text(
                                                text = tag,
                                                style = MaterialTheme.typography.bodySmall,
                                                color = TaskGoGreen,
                                                modifier = Modifier.padding(horizontal = 12.dp, vertical = 6.dp),
                                                fontWeight = FontWeight.Medium
                                            )
                                        }
                                    }
                                }
                            }
                        }
                    }

                    Spacer(modifier = Modifier.height(16.dp))

                    // Informa√ß√µes de data
                    Card(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(horizontal = 16.dp),
                        colors = CardDefaults.cardColors(containerColor = TaskGoSurface)
                    ) {
                        Column(
                            modifier = Modifier.padding(16.dp),
                            verticalArrangement = Arrangement.spacedBy(8.dp)
                        ) {
                            if (service.createdAt != null) {
                                Row(
                                    verticalAlignment = Alignment.CenterVertically,
                                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                        ) {
                            Icon(
                                        imageVector = Icons.Default.DateRange,
                                contentDescription = null,
                                        tint = TaskGoTextGray,
                                modifier = Modifier.size(20.dp)
                            )
                            Text(
                                        text = "Criado em: ${java.text.SimpleDateFormat("dd/MM/yyyy", Locale("pt", "BR")).format(service.createdAt)}",
                                        style = MaterialTheme.typography.bodySmall,
                                color = TaskGoTextGray
                            )
                        }
                    }

                            if (service.updatedAt != null) {
                                Row(
                                    verticalAlignment = Alignment.CenterVertically,
                                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                                ) {
                                    Icon(
                                        imageVector = Icons.Default.Refresh,
                                        contentDescription = null,
                                        tint = TaskGoTextGray,
                                        modifier = Modifier.size(20.dp)
                                    )
                                    Text(
                                        text = "Atualizado em: ${java.text.SimpleDateFormat("dd/MM/yyyy", Locale("pt", "BR")).format(service.updatedAt)}",
                                        style = MaterialTheme.typography.bodySmall,
                                        color = TaskGoTextGray
                                    )
                                }
                            }
                        }
                    }

                    Spacer(modifier = Modifier.height(32.dp))
                }
            }
        }
    }
}

@Composable
private fun FullScreenImageViewer(
    images: List<String>,
    initialIndex: Int = 0,
    onDismiss: () -> Unit
) {
    var currentIndex by remember { mutableStateOf(initialIndex) }
    val context = LocalContext.current
    
    Dialog(
        onDismissRequest = onDismiss,
        properties = androidx.compose.ui.window.DialogProperties(
            usePlatformDefaultWidth = false,
            decorFitsSystemWindows = false
        )
    ) {
        Box(
            modifier = Modifier
                .fillMaxSize()
                .background(Color.Black)
        ) {
            // Image
            Box(
                modifier = Modifier.fillMaxSize(),
                contentAlignment = Alignment.Center
            ) {
                AsyncImage(
                    model = ImageRequest.Builder(context)
                        .data(images[currentIndex])
                        .build(),
                    contentDescription = "Imagem em tela cheia",
                    modifier = Modifier.fillMaxSize(),
                    contentScale = ContentScale.Fit
                )
            }
            
            // Navigation arrows (if multiple images)
            if (images.size > 1) {
                // Previous arrow
                if (currentIndex > 0) {
                    IconButton(
                        onClick = { currentIndex-- },
                        modifier = Modifier
                            .align(Alignment.CenterStart)
                            .padding(16.dp)
                    ) {
                        Icon(
                            imageVector = Icons.Default.ArrowBack,
                            contentDescription = "Imagem anterior",
                            tint = Color.White,
                            modifier = Modifier.size(32.dp)
                        )
                    }
                }
                
                // Next arrow
                if (currentIndex < images.size - 1) {
                    IconButton(
                        onClick = { currentIndex++ },
                        modifier = Modifier
                            .align(Alignment.CenterEnd)
                            .padding(16.dp)
                    ) {
                        Icon(
                            imageVector = Icons.Default.ArrowForward,
                            contentDescription = "Pr√≥xima imagem",
                            tint = Color.White,
                            modifier = Modifier.size(32.dp)
                        )
                    }
                }
                
                // Image counter
                Surface(
                    modifier = Modifier
                        .align(Alignment.TopCenter)
                        .padding(top = 16.dp),
                    color = Color.Black.copy(alpha = 0.5f),
                    shape = RoundedCornerShape(16.dp)
                ) {
                    Text(
                        text = "${currentIndex + 1} / ${images.size}",
                        modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp),
                        color = Color.White,
                        style = MaterialTheme.typography.bodyMedium
                    )
                }
            }
            
            // Close button
            IconButton(
                onClick = onDismiss,
                modifier = Modifier
                    .align(Alignment.TopEnd)
                    .padding(16.dp)
            ) {
                Icon(
                    imageVector = Icons.Default.Close,
                    contentDescription = "Fechar",
                    tint = Color.White,
                    modifier = Modifier.size(32.dp)
                )
            }
        }
    }
}

@Composable
private fun VideoThumbnailCard(
    videoUrl: String,
    modifier: Modifier = Modifier
) {
    var showVideoPlayer by remember { mutableStateOf(false) }
    
    Card(
        modifier = modifier.clickable { showVideoPlayer = true },
        shape = RoundedCornerShape(12.dp),
        colors = CardDefaults.cardColors(containerColor = TaskGoBackgroundGray)
    ) {
        Box(
            modifier = Modifier.fillMaxSize(),
            contentAlignment = Alignment.Center
        ) {
            Column(
                horizontalAlignment = Alignment.CenterHorizontally,
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Icon(
                    imageVector = Icons.Default.Videocam,
                    contentDescription = "V√≠deo",
                    modifier = Modifier.size(48.dp),
                    tint = TaskGoGreen
                )
                Text(
                    text = "Tocar v√≠deo",
                    style = MaterialTheme.typography.bodySmall,
                    color = TaskGoTextGray
                )
            }
        }
    }
    
    // Fullscreen video player
    if (showVideoPlayer) {
        FullScreenVideoPlayer(
            videoUrl = videoUrl,
            onDismiss = { showVideoPlayer = false }
        )
    }
}


```

## [FRONTEND]: feature/services/presentation/GerenciarPropostasScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.services.presentation

import androidx.compose.foundation.background
import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.collectAsState
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.theme.*
import java.text.NumberFormat
import java.util.Locale

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun GerenciarPropostasScreen(
    onBackClick: () -> Unit,
    onVerProposta: (String) -> Unit,
    viewModel: GerenciarPropostasViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()

    Scaffold(
        topBar = {
            AppTopBar(
                title = "Gerenciar Propostas",
                onBackClick = onBackClick
            )
        }
    ) { paddingValues ->
        when {
            uiState.isLoading -> {
                Box(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(paddingValues),
                    contentAlignment = Alignment.Center
                ) {
                    CircularProgressIndicator()
                }
            }
            uiState.error != null -> {
                Column(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(paddingValues)
                        .padding(16.dp),
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.Center
                ) {
                    Text(
                        text = uiState.error ?: "Erro ao carregar propostas",
                        color = MaterialTheme.colorScheme.error,
                        textAlign = TextAlign.Center
                    )
                    Spacer(modifier = Modifier.height(16.dp))
                    Button(onClick = { viewModel.refresh() }) {
                        Text("Tentar novamente")
                    }
                }
            }
            uiState.proposals.isEmpty() -> {
                Box(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(paddingValues),
                    contentAlignment = Alignment.Center
                ) {
                    Text(
                        text = "Nenhuma proposta recebida",
                        color = TaskGoTextGray,
                        textAlign = TextAlign.Center
                    )
                }
            }
            else -> {
                LazyColumn(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(paddingValues),
                    contentPadding = PaddingValues(16.dp),
                    verticalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    items(
                        items = uiState.proposals,
                        key = { it.proposalId }
                    ) { proposal ->
                        ProposalItem(
                            proposal = proposal,
                            onClickVer = { onVerProposta(proposal.proposalId) }
                        )
                    }
                }
            }
        }
    }
}

@Composable
private fun ProposalItem(
    proposal: ProposalItemUi,
    onClickVer: () -> Unit
) {
    val initials = proposal.providerName
        .split(" ")
        .take(2)
        .joinToString("") { it.take(1).uppercase() }
        .take(2)

    val priceFormatted = NumberFormat.getCurrencyInstance(Locale("pt", "BR")).format(proposal.price)

    val statusColor = when (proposal.status.lowercase()) {
        "pendente" -> TaskGoGreen
        "aceita" -> Color(0xFF4CAF50)
        "recusada" -> Color(0xFFF44336)
        else -> TaskGoTextGray
    }

    Row(
        modifier = Modifier
            .fillMaxWidth()
            .clickable { onClickVer() }
            .padding(12.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Box(
            modifier = Modifier
                .size(50.dp)
                .background(
                    color = TaskGoBackgroundGray,
                    shape = CircleShape
                ),
            contentAlignment = Alignment.Center
        ) {
            Text(
                text = initials,
                style = FigmaProductName,
                color = TaskGoTextBlack,
                fontWeight = FontWeight.Bold
            )
        }

        Spacer(modifier = Modifier.width(16.dp))

        Column(modifier = Modifier.weight(1f)) {
            Text(
                text = proposal.serviceTitle,
                style = FigmaProductName,
                color = TaskGoTextBlack,
                fontWeight = FontWeight.Medium
            )
            Text(
                text = proposal.providerName,
                style = FigmaProductDescription,
                color = TaskGoTextGray
            )
            Text(
                text = priceFormatted,
                style = FigmaPrice,
                color = TaskGoPriceGreen,
                fontWeight = FontWeight.Bold
            )
            Text(
                text = proposal.status,
                style = FigmaStatusText,
                color = statusColor
            )
        }

        OutlinedButton(
            onClick = onClickVer,
            colors = ButtonDefaults.outlinedButtonColors(
                containerColor = Color.Transparent
            ),
            border = BorderStroke(1.dp, TaskGoGreen)
        ) {
            Text("Ver", style = FigmaButtonText, color = TaskGoGreen)
        }
    }
}

```

## [FRONTEND]: feature/services/presentation/GerenciarPropostasViewModel.kt

```kotlin
package com.taskgoapp.taskgo.feature.services.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.google.firebase.auth.FirebaseAuth
import com.taskgoapp.taskgo.data.firestore.models.OrderFirestore
import com.taskgoapp.taskgo.data.repository.FirestoreOrderRepository
import com.taskgoapp.taskgo.data.repository.FirestoreUserRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.launch
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.Dispatchers
import javax.inject.Inject

data class ProposalItemUi(
    val orderId: String,
    val proposalId: String, // Usar orderId como proposalId j√° que a proposta est√° na ordem
    val providerName: String,
    val providerId: String?,
    val serviceTitle: String,
    val serviceDescription: String,
    val price: Double,
    val status: String,
    val proposedAt: java.util.Date?
)

data class GerenciarPropostasUiState(
    val isLoading: Boolean = false,
    val error: String? = null,
    val proposals: List<ProposalItemUi> = emptyList()
)

@HiltViewModel
class GerenciarPropostasViewModel @Inject constructor(
    private val orderRepository: FirestoreOrderRepository,
    private val userRepository: FirestoreUserRepository,
    private val firebaseAuth: FirebaseAuth
) : ViewModel() {

    private val _uiState = MutableStateFlow(GerenciarPropostasUiState(isLoading = true))
    val uiState: StateFlow<GerenciarPropostasUiState> = _uiState.asStateFlow()

    init {
        loadProposals()
    }

    private fun loadProposals() {
        val currentUser = firebaseAuth.currentUser ?: run {
            _uiState.value = _uiState.value.copy(
                isLoading = false,
                error = "Usu√°rio n√£o autenticado"
            )
            return
        }

        viewModelScope.launch {
            try {
                _uiState.value = _uiState.value.copy(isLoading = true, error = null)

                // Buscar ordens do cliente atual que t√™m propostas
                orderRepository.observeOrders(currentUser.uid, "client")
                    .map { orders ->
                        orders.filter { order ->
                            // Filtrar ordens que t√™m propostas (status = "proposed" ou t√™m proposalDetails)
                            (order.status == "proposed" || order.proposalDetails != null) &&
                            !order.deleted
                        }
                    }
                    .collect { ordersWithProposals ->
                        coroutineScope {
                            // Mapear ordens para propostas (buscar nomes em paralelo)
                            val proposals = ordersWithProposals.mapNotNull { order ->
                                val proposalDetails = order.proposalDetails ?: return@mapNotNull null
                                val providerId = order.providerId

                                ProposalItemUi(
                                    orderId = order.id,
                                    proposalId = order.id, // Usar orderId como ID da proposta
                                    providerName = "Prestador", // Ser√° atualizado abaixo
                                    providerId = providerId,
                                    serviceTitle = order.details.takeIf { it.isNotBlank() } ?: "Servi√ßo",
                                    serviceDescription = proposalDetails.description.takeIf { it.isNotBlank() } ?: order.details,
                                    price = proposalDetails.price,
                                    status = when (order.status) {
                                        "proposed" -> "Pendente"
                                        "accepted" -> "Aceita"
                                        "rejected" -> "Recusada"
                                        else -> order.status.replaceFirstChar { it.uppercaseChar() }
                                    },
                                    proposedAt = order.proposedAt
                                )
                            }

                            // Buscar nomes dos prestadores em paralelo
                            val proposalsWithNames = proposals.map { proposal ->
                                if (proposal.providerId != null) {
                                    async(Dispatchers.IO) {
                                        try {
                                            val provider = userRepository.getUser(proposal.providerId)
                                            proposal.copy(providerName = provider?.displayName ?: "Prestador")
                                        } catch (e: Exception) {
                                            proposal.copy(providerName = "Prestador")
                                        }
                                    }
                                } else {
                                    async { proposal }
                                }
                            }.awaitAll()

                            _uiState.value = _uiState.value.copy(
                                proposals = proposalsWithNames.sortedByDescending { it.proposedAt?.time ?: 0L },
                                isLoading = false,
                                error = null
                            )
                        }
                    }
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = "Erro ao carregar propostas: ${e.message}"
                )
            }
        }
    }

    fun refresh() {
        loadProposals()
    }

    fun clearError() {
        _uiState.value = _uiState.value.copy(error = null)
    }
}


```

## [FRONTEND]: feature/services/presentation/HistoricoServicosScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.services.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Visibility
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.theme.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun HistoricoServicosScreen(
    onBackClick: () -> Unit,
    onVerDetalhes: (String) -> Unit
) {
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Hist√≥rico de Servi√ßos",
                onBackClick = onBackClick
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // Service history item
            Card(
                modifier = Modifier.fillMaxWidth(),
                colors = CardDefaults.cardColors(
                    containerColor = TaskGoSurface
                )
            ) {
                Column(
                    modifier = Modifier.padding(16.dp),
                    verticalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Column {
                            Text(
                                text = "Montagem de M√≥veis",
                                style = FigmaProductName,
                                color = TaskGoTextBlack,
                                fontWeight = FontWeight.Bold
                            )
                            Text(
                                text = "Rodrigo Silva",
                                style = FigmaProductDescription,
                                color = TaskGoTextGray
                            )
                        }
                        
                        Text(
                            text = "R$ 150,00",
                            style = FigmaPrice,
                            color = TaskGoPriceGreen,
                            fontWeight = FontWeight.Bold
                        )
                    }
                    
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(
                            text = "Conclu√≠do em 15/12/2024",
                            style = FigmaStatusText,
                            color = TaskGoTextGray
                        )
                        
                        Button(
                            onClick = { onVerDetalhes("1") },
                            colors = ButtonDefaults.buttonColors(
                                containerColor = TaskGoGreen
                            )
                        ) {
                            Icon(
                                imageVector = Icons.Default.Visibility,
                                contentDescription = null,
                                modifier = Modifier.size(16.dp),
                                tint = TaskGoBackgroundWhite
                            )
                            Spacer(modifier = Modifier.width(4.dp))
                            Text(
                                text = "Ver Detalhes",
                                style = FigmaButtonText,
                                color = TaskGoBackgroundWhite
                            )
                        }
                    }
                }
            }

            // Another service item
            Card(
                modifier = Modifier.fillMaxWidth(),
                colors = CardDefaults.cardColors(
                    containerColor = TaskGoSurface
                )
            ) {
                Column(
                    modifier = Modifier.padding(16.dp),
                    verticalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Column {
                            Text(
                                text = "Limpeza Residencial",
                                style = FigmaProductName,
                                color = TaskGoTextBlack,
                                fontWeight = FontWeight.Bold
                            )
                            Text(
                                text = "Maria Santos",
                                style = FigmaProductDescription,
                                color = TaskGoTextGray
                            )
                        }
                        
                        Text(
                            text = "R$ 80,00",
                            style = FigmaPrice,
                            color = TaskGoPriceGreen,
                            fontWeight = FontWeight.Bold
                        )
                    }
                    
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(
                            text = "Conclu√≠do em 10/12/2024",
                            style = FigmaStatusText,
                            color = TaskGoTextGray
                        )
                        
                        Button(
                            onClick = { onVerDetalhes("2") },
                            colors = ButtonDefaults.buttonColors(
                                containerColor = TaskGoGreen
                            )
                        ) {
                            Icon(
                                imageVector = Icons.Default.Visibility,
                                contentDescription = null,
                                modifier = Modifier.size(16.dp),
                                tint = TaskGoBackgroundWhite
                            )
                            Spacer(modifier = Modifier.width(4.dp))
                            Text(
                                text = "Ver Detalhes",
                                style = FigmaButtonText,
                                color = TaskGoBackgroundWhite
                            )
                        }
                    }
                }
            }
        }
    }
}

```

## [FRONTEND]: feature/services/presentation/LocalProvidersScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.services.presentation

import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.ui.unit.dp
import androidx.compose.material.icons.filled.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.lazy.grid.items
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.collectAsState
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.hilt.navigation.compose.hiltViewModel
import com.taskgoapp.taskgo.R
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.design.TGIcons
import com.taskgoapp.taskgo.core.model.ServiceOrder
import com.taskgoapp.taskgo.core.theme.*
import com.taskgoapp.taskgo.core.design.FilterBar
import com.taskgoapp.taskgo.core.design.FilterBottomSheet
import com.taskgoapp.taskgo.core.data.models.ServiceCategory
import androidx.compose.material.icons.automirrored.filled.ArrowForward
import androidx.compose.ui.text.style.TextAlign

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun LocalProvidersScreen(
    onNavigateToServiceDetail: (String) -> Unit,
    onNavigateToCreateWorkOrder: () -> Unit,
    onBackClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    android.util.Log.d("LocalProvidersScreen", "=== Iniciando LocalProvidersScreen ===")
    
    val viewModel: LocalProvidersViewModel = hiltViewModel()
    val uiState by viewModel.uiState.collectAsState()
    val filterState by viewModel.filterState.collectAsState()
    val filteredProviders by viewModel.filteredProviders.collectAsState()
    val categories by viewModel.serviceCategories.collectAsState()
    
    android.util.Log.d("LocalProvidersScreen", "Estado carregado - isLoading: ${uiState.isLoading}, error: ${uiState.error}, filteredProviders: ${filteredProviders.size}")
    
    var searchQuery by remember { mutableStateOf("") }
    var showFilterSheet by remember { mutableStateOf(false) }
    var selectedCategory by remember { mutableStateOf<String?>(null) }
    val categoriesFull by viewModel.serviceCategoriesFull.collectAsState()
    
    // Atualizar busca no ViewModel quando searchQuery mudar
    LaunchedEffect(searchQuery) {
        viewModel.updateSearchQuery(searchQuery)
    }
    
    // Adicionar "Todos" no in√≠cio das categorias
    val categoriesWithAll = remember(categories) {
        listOf("Todos") + categories.filter { it != "Todos" }
    }
    
    // Separar prestadores em destaque (top 3) e outros (resto)
    val providersWithLargeBanner = remember(filteredProviders) {
        filteredProviders.take(3).map { providerWithScore ->
            ProviderBanner(
                id = providerWithScore.provider.uid,
                name = providerWithScore.provider.displayName ?: "Prestador",
                category = providerWithScore.provider.preferredCategories?.firstOrNull() ?: "Servi√ßos",
                description = "Prestador com excelente avalia√ß√£o",
                rating = providerWithScore.provider.rating?.toFloat() ?: 0f,
                bannerType = BannerType.LARGE,
                imageUrl = providerWithScore.provider.photoURL
            )
        }
    }
    
    val providersWithSmallBanner = remember(filteredProviders) {
        filteredProviders.drop(3).map { providerWithScore ->
            ProviderBanner(
                id = providerWithScore.provider.uid,
                name = providerWithScore.provider.displayName ?: "Prestador",
                category = providerWithScore.provider.preferredCategories?.firstOrNull() ?: "Servi√ßos",
                description = "Prestador com excelente avalia√ß√£o",
                rating = providerWithScore.provider.rating?.toFloat() ?: 0f,
                bannerType = BannerType.SMALL,
                imageUrl = providerWithScore.provider.photoURL
            )
        }
    }
    
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Prestadores Locais",
                subtitle = "Encontre prestadores de servi√ßos na sua regi√£o",
                onBackClick = onBackClick,
                backgroundColor = TaskGoGreen,
                titleColor = Color.White,
                subtitleColor = Color.White,
                backIconColor = Color.White
            )
        }
    ) { paddingValues ->
        Column(
            modifier = modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(horizontal = 16.dp),
            verticalArrangement = Arrangement.spacedBy(4.dp)
        ) {
            // Barra de Busca
            com.taskgoapp.taskgo.core.design.SearchBar(
                query = searchQuery,
                onQueryChange = { searchQuery = it },
                placeholder = "Buscar prestadores...",
                modifier = Modifier.padding(top = 4.dp)
            )
            
            // Barra de Filtros
            FilterBar(
                categories = categoriesWithAll,
                selectedCategories = filterState.selectedCategories,
                onCategorySelected = { category ->
                    if (category == "Todos") {
                        viewModel.updateFilterState(filterState.copy(selectedCategories = emptySet()))
                    } else {
                        viewModel.toggleCategory(category)
                    }
                },
                onFilterClick = { showFilterSheet = true },
                modifier = Modifier.padding(bottom = 2.dp)
            )
            
            // Conte√∫do principal com scroll
            if (uiState.isLoading) {
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    CircularProgressIndicator()
                }
            } else if (uiState.error != null) {
                Text(
                    text = uiState.error ?: "Erro ao carregar prestadores",
                    color = MaterialTheme.colorScheme.error
                )
            } else if (selectedCategory == null) {
                // Mostrar cards de categoria
                if (categoriesFull.isEmpty()) {
                    Box(
                        modifier = Modifier.fillMaxSize(),
                        contentAlignment = Alignment.Center
                    ) {
                        Text(
                            text = "Nenhuma categoria dispon√≠vel",
                            color = TaskGoTextGray
                        )
                    }
                } else {
                    LazyColumn(
                        verticalArrangement = Arrangement.spacedBy(12.dp),
                        modifier = Modifier.fillMaxSize(),
                        contentPadding = PaddingValues(bottom = 32.dp)
                    ) {
                        items(categoriesFull) { category ->
                            LocalProvidersCategoryCard(
                                category = category,
                                onCategoryClick = { 
                                    selectedCategory = category.name
                                    viewModel.updateSelectedCategory(category.name)
                                }
                            )
                        }
                    }
                }
            } else if (filteredProviders.isEmpty()) {
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    Column(
                        horizontalAlignment = Alignment.CenterHorizontally,
                        verticalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        Text(
                            text = "Nenhum prestador encontrado",
                            color = TaskGoTextGray
                        )
                        TextButton(onClick = { 
                            selectedCategory = null
                            viewModel.updateSelectedCategory(null)
                        }) {
                            Text("Voltar")
                        }
                    }
                }
            } else {
                LazyColumn(
                    verticalArrangement = Arrangement.spacedBy(8.dp),
                    modifier = Modifier.fillMaxSize()
                ) {
                    item {
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.SpaceBetween,
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Text(
                                text = selectedCategory ?: "",
                                style = MaterialTheme.typography.titleLarge,
                                fontWeight = FontWeight.Bold,
                                color = TaskGoTextDark
                            )
                            TextButton(onClick = { 
                                selectedCategory = null
                                viewModel.updateSelectedCategory(null)
                            }) {
                                Text("Voltar")
                            }
                        }
                    }
                    // Se√ß√£o de Banners Grandes (Retrato) - Scroll Horizontal
                    if (providersWithLargeBanner.isNotEmpty()) {
                        android.util.Log.d("LocalProvidersScreen", "Renderizando ${providersWithLargeBanner.size} banners grandes")
                        item {
                            Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
                                Text(
                                    text = "Prestadores em Destaque",
                                    style = MaterialTheme.typography.titleMedium,
                                    fontWeight = FontWeight.Bold,
                                    color = TaskGoTextDark
                                )
                                LazyRow(
                                    horizontalArrangement = Arrangement.spacedBy(12.dp),
                                    modifier = Modifier.fillMaxWidth()
                                ) {
                                    items(providersWithLargeBanner.size) { index ->
                                        if (index < providersWithLargeBanner.size) {
                                            val provider = providersWithLargeBanner[index]
                                            android.util.Log.d("LocalProvidersScreen", "Renderizando banner grande $index: ${provider.name}")
                                            LargeBannerCard(
                                                provider = provider,
                                                onProviderClick = { 
                                                    android.util.Log.d("LocalProvidersScreen", "Banner grande clicado: ${provider.id}")
                                                    onNavigateToServiceDetail(provider.id) 
                                                }
                                            )
                                        } else {
                                            android.util.Log.e("LocalProvidersScreen", "√çndice fora dos limites: $index")
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        android.util.Log.d("LocalProvidersScreen", "Nenhum banner grande para exibir")
                    }
                    
                    // Se√ß√£o de Banners Pequenos (Quadrado) - Grid Vertical
                    if (providersWithSmallBanner.isNotEmpty()) {
                        android.util.Log.d("LocalProvidersScreen", "Renderizando ${providersWithSmallBanner.size} banners pequenos")
                        item {
                            Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
                                Text(
                                    text = "Outros Prestadores",
                                    style = MaterialTheme.typography.titleMedium,
                                    fontWeight = FontWeight.Bold,
                                    color = TaskGoTextDark
                                )
                                LazyVerticalGrid(
                                    columns = GridCells.Fixed(2),
                                    horizontalArrangement = Arrangement.spacedBy(12.dp),
                                    verticalArrangement = Arrangement.spacedBy(12.dp)
                                ) {
                                    items(providersWithSmallBanner.size) { index ->
                                        if (index < providersWithSmallBanner.size) {
                                            val provider = providersWithSmallBanner[index]
                                            android.util.Log.d("LocalProvidersScreen", "Renderizando banner pequeno $index: ${provider.name}")
                                            SmallBannerCard(
                                                provider = provider,
                                                onProviderClick = { 
                                                    android.util.Log.d("LocalProvidersScreen", "Banner pequeno clicado: ${provider.id}")
                                                    onNavigateToServiceDetail(provider.id)
                                                }
                                            )
                                        } else {
                                            android.util.Log.e("LocalProvidersScreen", "√çndice fora dos limites: $index")
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        android.util.Log.d("LocalProvidersScreen", "Nenhum banner pequeno para exibir")
                    }
                }
            }
        }
        
        // Bottom Sheet de Filtros
        FilterBottomSheet(
            isOpen = showFilterSheet,
            onDismiss = { showFilterSheet = false },
            filterState = filterState,
            onFilterStateChange = { newState ->
                viewModel.updateFilterState(newState)
            }
        )
    }
}

@Composable
private fun LocalProvidersCategoryCard(
    category: ServiceCategory,
    onCategoryClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier
            .fillMaxWidth()
            .clickable { onCategoryClick() },
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            Box(
                modifier = Modifier
                    .size(56.dp)
                    .background(TaskGoGreen.copy(alpha = 0.1f), RoundedCornerShape(12.dp)),
                contentAlignment = Alignment.Center
            ) {
                Icon(
                    imageVector = when (category.icon) {
                        "build" -> Icons.Default.Build
                        "home" -> Icons.Default.Home
                        "eco" -> Icons.Default.Eco
                        "flash_on" -> Icons.Default.FlashOn
                        "plumbing" -> Icons.Default.Plumbing
                        "format_paint" -> Icons.Default.FormatPaint
                        "cleaning_services" -> Icons.Default.CleaningServices
                        else -> Icons.Default.List
                    },
                    contentDescription = category.name,
                    tint = TaskGoGreen,
                    modifier = Modifier.size(28.dp)
                )
            }
            Column(modifier = Modifier.weight(1f)) {
                Text(
                    text = category.name,
                    fontSize = 18.sp,
                    fontWeight = FontWeight.SemiBold,
                    color = TaskGoTextDark
                )
                Text(
                    text = category.description,
                    fontSize = 14.sp,
                    color = TaskGoTextGray,
                    maxLines = 2
                )
            }
            Icon(
                imageVector = Icons.AutoMirrored.Filled.ArrowForward,
                contentDescription = "Ver mais",
                tint = TaskGoTextGray
            )
        }
    }
}

// Modelo de dados para prestadores com banners
data class ProviderBanner(
    val id: String,
    val name: String,
    val category: String,
    val description: String,
    val rating: Float,
    val bannerType: BannerType,
    val imageUrl: String?
)

enum class BannerType {
    LARGE, SMALL
}

// Card de Banner Grande (Retrato) - Scroll Horizontal
@Composable
private fun LargeBannerCard(
    provider: ProviderBanner,
    onProviderClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier
            .width(280.dp)
            .height(400.dp)
            .clickable { onProviderClick() },
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),
        shape = RoundedCornerShape(12.dp)
    ) {
        Box(modifier = Modifier.fillMaxSize()) {
            // Imagem de fundo ou placeholder
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .background(TaskGoGreen.copy(alpha = 0.1f))
            )
            
            // Conte√∫do do card
            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(16.dp),
                verticalArrangement = Arrangement.SpaceBetween
            ) {
                Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
                    Text(
                        text = provider.name,
                        style = MaterialTheme.typography.titleLarge,
                        fontWeight = FontWeight.Bold,
                        color = TaskGoTextDark
                    )
                    Text(
                        text = provider.category,
                        style = MaterialTheme.typography.bodyMedium,
                        color = TaskGoGreen,
                        fontWeight = FontWeight.SemiBold
                    )
                }
                
                Column(verticalArrangement = Arrangement.spacedBy(4.dp)) {
                    Text(
                        text = provider.description,
                        style = MaterialTheme.typography.bodySmall,
                        color = TaskGoTextDark.copy(alpha = 0.7f),
                        maxLines = 3,
                        overflow = TextOverflow.Ellipsis
                    )
                    Row(
                        verticalAlignment = Alignment.CenterVertically,
                        horizontalArrangement = Arrangement.spacedBy(4.dp)
                    ) {
                        Text(
                            text = "‚≠ê ${String.format("%.1f", provider.rating)}",
                            style = MaterialTheme.typography.bodySmall,
                            color = TaskGoTextDark,
                            fontWeight = FontWeight.SemiBold
                        )
                    }
                }
            }
        }
    }
}

// Card de Banner Pequeno (Quadrado) - Grid Vertical
@Composable
private fun SmallBannerCard(
    provider: ProviderBanner,
    onProviderClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier
            .fillMaxWidth()
            .height(180.dp)
            .clickable { onProviderClick() },
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),
        shape = RoundedCornerShape(12.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(12.dp),
            verticalArrangement = Arrangement.SpaceBetween
        ) {
            Column(verticalArrangement = Arrangement.spacedBy(4.dp)) {
                Text(
                    text = provider.name,
                    style = MaterialTheme.typography.titleSmall,
                    fontWeight = FontWeight.Bold,
                    color = TaskGoTextDark,
                    maxLines = 1,
                    overflow = TextOverflow.Ellipsis
                )
                Text(
                    text = provider.category,
                    style = MaterialTheme.typography.bodySmall,
                    color = TaskGoGreen,
                    fontWeight = FontWeight.Medium
                )
            }
            
            Column(verticalArrangement = Arrangement.spacedBy(4.dp)) {
                Text(
                    text = provider.description,
                    style = MaterialTheme.typography.bodySmall,
                    color = TaskGoTextDark.copy(alpha = 0.7f),
                    maxLines = 2,
                    overflow = TextOverflow.Ellipsis
                )
                Text(
                    text = "‚≠ê ${String.format("%.1f", provider.rating)}",
                    style = MaterialTheme.typography.bodySmall,
                    color = TaskGoTextDark,
                    fontWeight = FontWeight.SemiBold
                )
            }
        }
    }
}


```

## [FRONTEND]: feature/services/presentation/LocalProvidersViewModel.kt

```kotlin
package com.taskgoapp.taskgo.feature.services.presentation

import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.taskgoapp.taskgo.data.repository.FirestoreProvidersRepository
import com.taskgoapp.taskgo.data.repository.ProviderWithScore
import com.taskgoapp.taskgo.core.design.FilterState
import com.taskgoapp.taskgo.domain.repository.CategoriesRepository
import com.taskgoapp.taskgo.data.local.datastore.FilterPreferencesManager
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import javax.inject.Inject

data class LocalProvidersUiState(
    val isLoading: Boolean = false,
    val featuredProviders: List<ProviderWithScore> = emptyList(),
    val error: String? = null
)

@HiltViewModel
class LocalProvidersViewModel @Inject constructor(
    private val providersRepository: FirestoreProvidersRepository,
    private val categoriesRepository: CategoriesRepository,
    private val filterPreferencesManager: FilterPreferencesManager
) : ViewModel() {
    
    private val _uiState = MutableStateFlow(LocalProvidersUiState())
    val uiState: StateFlow<LocalProvidersUiState> = _uiState.asStateFlow()
    
    private val _filterState = MutableStateFlow(FilterState())
    val filterState: StateFlow<FilterState> = _filterState.asStateFlow()
    
    val serviceCategories: StateFlow<List<String>> = categoriesRepository
        .observeServiceCategories()
        .map { categories -> categories.map { it.name } }
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyList())
    
    val serviceCategoriesFull: StateFlow<List<com.taskgoapp.taskgo.core.data.models.ServiceCategory>> = categoriesRepository
        .observeServiceCategories()
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyList())
    
    private val _selectedCategory = MutableStateFlow<String?>(null)
    val selectedCategory: StateFlow<String?> = _selectedCategory.asStateFlow()
    
    private val _allProviders = MutableStateFlow<List<ProviderWithScore>>(emptyList())
    
    val filteredProviders: StateFlow<List<ProviderWithScore>> = combine(
        _allProviders,
        filterState
    ) { providers, filters ->
        applyFiltersSync(providers, filters)
    }.stateIn(
        viewModelScope,
        SharingStarted.WhileSubscribed(5_000),
        emptyList()
    )
    
    init {
        loadFeaturedProviders()
        loadSavedFilters()
    }
    
    private fun loadSavedFilters() {
        viewModelScope.launch {
            filterPreferencesManager.getServiceFilters().collect { savedFilters ->
                savedFilters?.let {
                    _filterState.value = it
                }
            }
        }
    }
    
    fun updateFilterState(newState: FilterState) {
        _filterState.value = newState
        viewModelScope.launch {
            filterPreferencesManager.saveServiceFilters(newState)
        }
    }
    
    fun toggleCategory(category: String) {
        val currentCategories = _filterState.value.selectedCategories
        val newCategories = if (currentCategories.contains(category)) {
            currentCategories - category
        } else {
            currentCategories + category
        }
        updateFilterState(_filterState.value.copy(selectedCategories = newCategories))
    }
    
    fun updateSearchQuery(query: String) {
        updateFilterState(_filterState.value.copy(searchQuery = query))
    }
    
    private fun applyFiltersSync(providers: List<ProviderWithScore>, filters: FilterState): List<ProviderWithScore> {
        var filtered = providers
        
        // Busca por texto
        if (filters.searchQuery.isNotBlank()) {
            val query = filters.searchQuery.lowercase()
            filtered = filtered.filter { providerWithScore ->
                val provider = providerWithScore.provider
                provider.displayName?.lowercase()?.contains(query) == true ||
                provider.preferredCategories?.any { it.lowercase().contains(query) } == true
            }
        }
        
        // Filtrar por categorias
        if (filters.selectedCategories.isNotEmpty()) {
            filtered = filtered.filter { providerWithScore ->
                val provider = providerWithScore.provider
                provider.preferredCategories?.any { category ->
                    filters.selectedCategories.contains(category)
                } == true
            }
        }
        
        // Filtrar por avalia√ß√£o m√≠nima
        filters.minRating?.let { minRating ->
            filtered = filtered.filter { providerWithScore ->
                val rating = providerWithScore.provider.rating ?: 0.0
                rating >= minRating
            }
        }
        
        // Ordenar
        filtered = when (filters.sortBy) {
            com.taskgoapp.taskgo.core.design.SortOption.RATING -> 
                filtered.sortedByDescending { it.provider.rating ?: 0.0 }
            com.taskgoapp.taskgo.core.design.SortOption.RELEVANCE -> 
                filtered.sortedByDescending { it.score } // Ordenar por score do algoritmo
            else -> filtered
        }
        
        return filtered
    }
    
    private fun loadFeaturedProviders() {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoading = true, error = null)
            try {
                val providers = providersRepository.getFeaturedProviders(limit = 50)
                Log.d("LocalProvidersViewModel", "Prestadores em destaque carregados: ${providers.size}")
                _allProviders.value = providers
                _uiState.value = _uiState.value.copy(
                    featuredProviders = providers,
                    isLoading = false
                )
            } catch (e: Exception) {
                Log.e("LocalProvidersViewModel", "Erro ao carregar prestadores: ${e.message}", e)
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = "Erro ao carregar prestadores: ${e.message}"
                )
            }
        }
    }
    
    fun refresh() {
        loadFeaturedProviders()
    }
    
    fun updateSelectedCategory(category: String?) {
        _selectedCategory.value = category
    }
}


```

## [FRONTEND]: feature/services/presentation/LocalServiceOrdersScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.services.presentation

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.LocationOn
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.collectAsState
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.hilt.navigation.compose.hiltViewModel
import coil.compose.AsyncImage
import coil.request.ImageRequest
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.design.FilterBar
import com.taskgoapp.taskgo.core.design.FilterBottomSheet
import com.taskgoapp.taskgo.core.theme.*
import com.taskgoapp.taskgo.data.firestore.models.OrderFirestore
import com.taskgoapp.taskgo.core.data.models.ServiceCategory
import androidx.compose.material.icons.automirrored.filled.ArrowForward
import java.text.NumberFormat
import java.util.Locale

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun LocalServiceOrdersScreen(
    onBackClick: () -> Unit,
    onOrderClick: (String) -> Unit,
    viewModel: LocalServiceOrdersViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    val orders by viewModel.orders.collectAsState()
    val filterState by viewModel.filterState.collectAsState()
    val categories by viewModel.categories.collectAsState()
    val categoriesFull by viewModel.serviceCategoriesFull.collectAsState()
    
    var showFilterSheet by remember { mutableStateOf(false) }
    var searchQuery by remember { mutableStateOf("") }
    var selectedCategory by remember { mutableStateOf<String?>(null) }
    
    val categoriesWithAll = remember(categories) {
        if (categories.isEmpty() || categories.first() != "Todos") {
            listOf("Todos") + categories.filter { it != "Todos" }
        } else {
            categories
        }
    }
    
    LaunchedEffect(searchQuery) {
        viewModel.updateSearchQuery(searchQuery)
    }
    
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Ordens de Servi√ßo Locais",
                subtitle = "Encontre oportunidades na sua regi√£o",
                onBackClick = onBackClick
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(horizontal = 16.dp),
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            // Barra de Busca
            com.taskgoapp.taskgo.core.design.SearchBar(
                query = searchQuery,
                onQueryChange = { searchQuery = it },
                placeholder = "Buscar ordens de servi√ßo...",
                modifier = Modifier.padding(top = 4.dp)
            )
            
            // Barra de Filtros
            FilterBar(
                categories = categoriesWithAll,
                selectedCategories = filterState.selectedCategories,
                onCategorySelected = { category ->
                    if (category == "Todos") {
                        viewModel.updateFilterState(filterState.copy(selectedCategories = emptySet()))
                    } else {
                        viewModel.toggleCategory(category)
                    }
                },
            onFilterClick = { showFilterSheet = true },
            showSortButtons = true,
            sortBy = filterState.sortBy,
            onSortByRating = { viewModel.updateFilterState(filterState.copy(sortBy = com.taskgoapp.taskgo.core.design.SortOption.RATING)) },
            onSortByNewest = { viewModel.updateFilterState(filterState.copy(sortBy = com.taskgoapp.taskgo.core.design.SortOption.NEWEST)) },
            modifier = Modifier.padding(vertical = 2.dp)
            )
            
            val errorMessage = uiState.error
            
            // Mostrar categorias primeiro, depois ordens ao selecionar categoria
            if (uiState.isLoading) {
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    CircularProgressIndicator(color = TaskGoGreen)
                }
            } else if (errorMessage != null) {
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    Column(
                        horizontalAlignment = Alignment.CenterHorizontally,
                        verticalArrangement = Arrangement.spacedBy(16.dp)
                    ) {
                        Text(
                            text = errorMessage,
                            color = MaterialTheme.colorScheme.error
                        )
                        Button(
                            onClick = { viewModel.refresh() },
                            colors = ButtonDefaults.buttonColors(containerColor = TaskGoGreen)
                        ) {
                            Text("Tentar Novamente")
                        }
                    }
                }
            } else if (selectedCategory == null) {
                // Mostrar cards de categorias
                LazyColumn(
                    verticalArrangement = Arrangement.spacedBy(12.dp),
                    modifier = Modifier.fillMaxSize()
                ) {
                    items(categoriesFull) { category ->
                        LocalServiceOrdersCategoryCard(
                            category = category,
                            onCategoryClick = { 
                                selectedCategory = category.name
                                viewModel.updateSelectedCategory(category.name)
                            }
                        )
                    }
                }
            } else {
                // Mostrar ordens filtradas por categoria
                val filteredOrders = orders.filter { 
                    it.category?.equals(selectedCategory, ignoreCase = true) == true
                }
                
                if (filteredOrders.isEmpty()) {
                    Box(
                        modifier = Modifier.fillMaxSize(),
                        contentAlignment = Alignment.Center
                    ) {
                        Column(
                            horizontalAlignment = Alignment.CenterHorizontally,
                            verticalArrangement = Arrangement.spacedBy(8.dp)
                        ) {
                            Text(
                                text = "Nenhuma ordem encontrada",
                                style = MaterialTheme.typography.titleMedium,
                                color = TaskGoTextGray
                            )
                            Text(
                                text = "N√£o h√° ordens de servi√ßo dispon√≠veis para esta categoria",
                                style = MaterialTheme.typography.bodyMedium,
                                color = TaskGoTextGray
                            )
                            TextButton(onClick = { 
                                selectedCategory = null
                                viewModel.updateSelectedCategory(null)
                            }) {
                                Text("Voltar")
                            }
                        }
                    }
                } else {
                    LazyColumn(
                        verticalArrangement = Arrangement.spacedBy(12.dp),
                        modifier = Modifier.fillMaxSize()
                    ) {
                        item {
                            Row(
                                modifier = Modifier.fillMaxWidth(),
                                horizontalArrangement = Arrangement.SpaceBetween,
                                verticalAlignment = Alignment.CenterVertically
                            ) {
                                Text(
                                    text = selectedCategory ?: "",
                                    fontSize = 20.sp,
                                    fontWeight = FontWeight.Bold
                                )
                                TextButton(onClick = { 
                                    selectedCategory = null
                                    viewModel.updateSelectedCategory(null)
                                }) {
                                    Text("Voltar")
                                }
                            }
                        }
                        items(filteredOrders) { order ->
                            ServiceOrderCard(
                                order = order,
                                isOwnOrder = uiState.currentUserId == order.clientId,
                                onClick = { onOrderClick(order.id) }
                            )
                        }
                    }
                }
            }
        }
        
        // Bottom Sheet de Filtros
        FilterBottomSheet(
            isOpen = showFilterSheet,
            onDismiss = { showFilterSheet = false },
            filterState = filterState,
            onFilterStateChange = { newState ->
                viewModel.updateFilterState(newState)
            }
        )
    }
}

@Composable
private fun ServiceOrderCard(
    order: OrderFirestore,
    isOwnOrder: Boolean,
    onClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    val currencyFormat = NumberFormat.getCurrencyInstance(Locale("pt", "BR"))
    val cardColor = if (isOwnOrder) {
        TaskGoGreen.copy(alpha = 0.1f)
    } else {
        MaterialTheme.colorScheme.surface
    }
    
    Card(
        modifier = modifier
            .fillMaxWidth()
            .clickable { onClick() },
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),
        colors = CardDefaults.cardColors(containerColor = cardColor)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            horizontalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            // Imagem (placeholder por enquanto)
            Box(
                modifier = Modifier
                    .size(100.dp)
                    .clip(RoundedCornerShape(8.dp))
                    .background(TaskGoGreen.copy(alpha = 0.2f)),
                contentAlignment = Alignment.Center
            ) {
                Text("üìã", fontSize = 32.sp)
            }
            
            Column(
                modifier = Modifier.weight(1f),
                verticalArrangement = Arrangement.spacedBy(4.dp)
            ) {
                // T√≠tulo
                Text(
                    text = order.details.takeIf { it.isNotBlank() } ?: "Ordem de Servi√ßo",
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold,
                    color = TaskGoTextDark,
                    maxLines = 2,
                    overflow = TextOverflow.Ellipsis
                )
                
                // Localiza√ß√£o
                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.spacedBy(4.dp)
                ) {
                    Icon(
                        imageVector = Icons.Default.LocationOn,
                        contentDescription = null,
                        modifier = Modifier.size(16.dp),
                        tint = TaskGoTextGray
                    )
                    Text(
                        text = order.location.takeIf { it.isNotBlank() } ?: "Localiza√ß√£o n√£o informada",
                        style = MaterialTheme.typography.bodySmall,
                        color = TaskGoTextGray,
                        maxLines = 1,
                        overflow = TextOverflow.Ellipsis
                    )
                }
                
                // Valor
                if (order.budget > 0) {
                    Text(
                        text = currencyFormat.format(order.budget),
                        style = MaterialTheme.typography.titleLarge,
                        fontWeight = FontWeight.Bold,
                        color = TaskGoGreen
                    )
                } else {
                    Text(
                        text = "Or√ßamento a combinar",
                        style = MaterialTheme.typography.bodyMedium,
                        color = TaskGoTextGray
                    )
                }
                
                // Badge se for pr√≥pria ordem
                if (isOwnOrder) {
                    Surface(
                        color = TaskGoGreen.copy(alpha = 0.2f),
                        shape = RoundedCornerShape(4.dp)
                    ) {
                        Text(
                            text = "Sua ordem",
                            modifier = Modifier.padding(horizontal = 8.dp, vertical = 4.dp),
                            style = MaterialTheme.typography.labelSmall,
                            color = TaskGoGreen,
                            fontWeight = FontWeight.Bold
                        )
                    }
                }
            }
        }
    }
}

@Composable
private fun LocalServiceOrdersCategoryCard(
    category: ServiceCategory,
    onCategoryClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier
            .fillMaxWidth()
            .clickable { onCategoryClick() },
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            Box(
                modifier = Modifier
                    .size(56.dp)
                    .background(TaskGoGreen.copy(alpha = 0.1f), RoundedCornerShape(12.dp)),
                contentAlignment = Alignment.Center
            ) {
                Icon(
                    imageVector = when (category.icon) {
                        "build" -> Icons.Default.Build
                        "home" -> Icons.Default.Home
                        "eco" -> Icons.Default.Eco
                        "flash_on" -> Icons.Default.FlashOn
                        "plumbing" -> Icons.Default.Plumbing
                        "format_paint" -> Icons.Default.FormatPaint
                        "cleaning_services" -> Icons.Default.CleaningServices
                        else -> Icons.Default.List
                    },
                    contentDescription = category.name,
                    tint = TaskGoGreen,
                    modifier = Modifier.size(28.dp)
                )
            }
            Column(modifier = Modifier.weight(1f)) {
                Text(
                    text = category.name,
                    fontSize = 18.sp,
                    fontWeight = FontWeight.SemiBold,
                    color = TaskGoTextDark
                )
                Text(
                    text = category.description,
                    fontSize = 14.sp,
                    color = TaskGoTextGray,
                    maxLines = 2
                )
            }
            Icon(
                imageVector = Icons.AutoMirrored.Filled.ArrowForward,
                contentDescription = "Ver mais",
                tint = TaskGoTextGray
            )
        }
    }
}


```

## [FRONTEND]: feature/services/presentation/LocalServiceOrdersViewModel.kt

```kotlin
package com.taskgoapp.taskgo.feature.services.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.google.firebase.auth.FirebaseAuth
import com.taskgoapp.taskgo.core.design.FilterState
import com.taskgoapp.taskgo.core.location.LocationManager
import com.taskgoapp.taskgo.data.firestore.models.OrderFirestore
import com.taskgoapp.taskgo.data.repository.FirestoreOrderRepository
import com.taskgoapp.taskgo.domain.repository.CategoriesRepository
import com.taskgoapp.taskgo.domain.repository.UserRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.flatMapLatest
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.flow.collect
import kotlinx.coroutines.launch
import javax.inject.Inject

data class LocalServiceOrdersUiState(
    val isLoading: Boolean = true,
    val error: String? = null,
    val currentUserId: String = ""
)

@HiltViewModel
class LocalServiceOrdersViewModel @Inject constructor(
    private val orderRepository: FirestoreOrderRepository,
    private val categoriesRepository: CategoriesRepository,
    private val locationManager: LocationManager,
    private val userRepository: UserRepository,
    private val firebaseAuth: FirebaseAuth
) : ViewModel() {
    
    private val _uiState = MutableStateFlow(LocalServiceOrdersUiState())
    val uiState: StateFlow<LocalServiceOrdersUiState> = _uiState.asStateFlow()
    
    private val _filterState = MutableStateFlow(FilterState())
    val filterState: StateFlow<FilterState> = _filterState.asStateFlow()
    
    private val _userLocation = MutableStateFlow<Pair<String?, String?>>(null to null)
    
    val categories: StateFlow<List<String>> = categoriesRepository
        .observeServiceCategories()
        .map { it.map { cat -> cat.name } }
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyList())
    
    val serviceCategoriesFull: StateFlow<List<com.taskgoapp.taskgo.core.data.models.ServiceCategory>> = categoriesRepository
        .observeServiceCategories()
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyList())
    
    private val _selectedCategory = MutableStateFlow<String?>(null)
    val selectedCategory: StateFlow<String?> = _selectedCategory.asStateFlow()
    
    val orders: StateFlow<List<OrderFirestore>> = combine(
        _userLocation,
        _filterState,
        _selectedCategory
    ) { location, filters, selectedCategory ->
        Triple(location, filters, selectedCategory)
    }.flatMapLatest { (location, filters, selectedCategory) ->
        // ‚úÖ observeLocalServiceOrders agora usa LocationStateManager automaticamente
        // Usar categoria selecionada se houver, sen√£o usar do filtro
        val categoryToFilter = selectedCategory ?: filters.selectedCategories.firstOrNull()
        orderRepository.observeLocalServiceOrders(category = categoryToFilter)
            .map { allOrders ->
                applyFilters(allOrders, filters)
            }
    }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyList())
    
    init {
        loadUserLocation()
        val currentUser = firebaseAuth.currentUser
        if (currentUser != null) {
            _uiState.value = _uiState.value.copy(
                currentUserId = currentUser.uid,
                isLoading = false
            )
        } else {
            _uiState.value = _uiState.value.copy(
                isLoading = false,
                error = "Usu√°rio n√£o autenticado"
            )
        }
    }
    
    private fun loadUserLocation() {
        viewModelScope.launch {
            try {
                val location = locationManager.getCurrentLocation()
                if (location != null) {
                    val address = locationManager.getAddressFromLocation(
                        location.latitude,
                        location.longitude
                    )
                    _userLocation.value = address?.locality to address?.adminArea
                } else {
                    // Usar localiza√ß√£o do perfil do usu√°rio como fallback
                    loadUserLocationFromProfile()
                }
            } catch (e: Exception) {
                // Usar localiza√ß√£o do perfil do usu√°rio como fallback
                loadUserLocationFromProfile()
            }
        }
    }
    
    private fun loadUserLocationFromProfile() {
        viewModelScope.launch {
            try {
                userRepository.observeCurrentUser().collect { user ->
                    // UserProfile agora tem state diretamente (adicionado na vers√£o 88)
                    _userLocation.value = user?.city to user?.state
                }
            } catch (e: Exception) {
                // Se n√£o conseguir obter localiza√ß√£o, usar null
                _userLocation.value = null to null
            }
        }
    }
    
    private fun applyFilters(
        orders: List<OrderFirestore>,
        filters: FilterState
    ): List<OrderFirestore> {
        var filtered = orders
        
        // Filtrar por busca
        if (filters.searchQuery.isNotBlank()) {
            val query = filters.searchQuery.lowercase()
            filtered = filtered.filter {
                it.details.lowercase().contains(query) ||
                it.location.lowercase().contains(query)
            }
        }
        
        // Filtrar por categoria
        if (filters.selectedCategories.isNotEmpty()) {
            filtered = filtered.filter { order ->
                filters.selectedCategories.any { category ->
                    order.details.lowercase().contains(category.lowercase())
                }
            }
        }
        
        return filtered
    }
    
    fun updateFilterState(newState: FilterState) {
        _filterState.value = newState
    }
    
    fun toggleCategory(category: String) {
        val currentCategories = _filterState.value.selectedCategories
        val newCategories = if (currentCategories.contains(category)) {
            currentCategories - category
        } else {
            currentCategories + category
        }
        updateFilterState(_filterState.value.copy(selectedCategories = newCategories))
    }
    
    fun updateSearchQuery(query: String) {
        updateFilterState(_filterState.value.copy(searchQuery = query))
    }
    
    fun refresh() {
        loadUserLocation()
    }
    
    fun updateSelectedCategory(category: String?) {
        _selectedCategory.value = category
        if (category != null) {
            updateFilterState(_filterState.value.copy(selectedCategories = setOf(category)))
        } else {
            updateFilterState(_filterState.value.copy(selectedCategories = emptySet()))
        }
    }
}


```

## [FRONTEND]: feature/services/presentation/MeusServicosScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.services.presentation

import android.util.Log
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material.icons.filled.Edit
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import coil.compose.AsyncImage
import coil.request.ImageRequest
import androidx.compose.ui.platform.LocalContext
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.theme.*
import com.taskgoapp.taskgo.data.firestore.models.ServiceFirestore
import com.taskgoapp.taskgo.data.firestore.models.OrderFirestore
import com.taskgoapp.taskgo.feature.home.presentation.FilterTypeChip

enum class ServiceTab {
    SOLICITADOS, EM_ANDAMENTO, CONCLUIDOS, CANCELADOS
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MeusServicosScreen(
    onBackClick: () -> Unit,
    onCriarServico: () -> Unit,
    onEditarServico: (String) -> Unit,
    onViewService: (String) -> Unit = { serviceId -> onEditarServico(serviceId) },
    onOrderClick: ((String) -> Unit)? = null,
    viewModel: MyServicesViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    val context = LocalContext.current
    var selectedTab by remember { mutableStateOf(ServiceTab.SOLICITADOS) }

    LaunchedEffect(Unit) {
        Log.d("MeusServicosScreen", "=== Iniciando MeusServicosScreen ===")
    }

    // Filtrar ordens baseado na aba selecionada
    val filteredOrders = when (selectedTab) {
        ServiceTab.SOLICITADOS -> uiState.orders.filter { order ->
            order.status.lowercase() in listOf("pending", "proposed")
        }
        ServiceTab.EM_ANDAMENTO -> uiState.orders.filter { order ->
            order.status.lowercase() in listOf("accepted", "payment_pending", "paid", "in_progress")
        }
        ServiceTab.CONCLUIDOS -> uiState.orders.filter { order ->
            order.status.lowercase() == "completed"
        }
        ServiceTab.CANCELADOS -> uiState.orders.filter { order ->
            order.status.lowercase() == "cancelled"
        }
    }

    Scaffold(
        topBar = {
            AppTopBar(
                title = "Meus Servi√ßos",
                onBackClick = onBackClick
            )
        },
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            // Abas
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(horizontal = 16.dp, vertical = 12.dp),
                horizontalArrangement = Arrangement.spacedBy(6.dp)
            ) {
                ServiceTabChip(
                    text = "Solicitados",
                    selected = selectedTab == ServiceTab.SOLICITADOS,
                    onClick = { selectedTab = ServiceTab.SOLICITADOS },
                    modifier = Modifier.weight(1f)
                )
                ServiceTabChip(
                    text = "Em Andamento",
                    selected = selectedTab == ServiceTab.EM_ANDAMENTO,
                    onClick = { selectedTab = ServiceTab.EM_ANDAMENTO },
                    modifier = Modifier.weight(1f)
                )
                ServiceTabChip(
                    text = "Conclu√≠dos",
                    selected = selectedTab == ServiceTab.CONCLUIDOS,
                    onClick = { selectedTab = ServiceTab.CONCLUIDOS },
                    modifier = Modifier.weight(1f)
                )
                ServiceTabChip(
                    text = "Cancelados",
                    selected = selectedTab == ServiceTab.CANCELADOS,
                    onClick = { selectedTab = ServiceTab.CANCELADOS },
                    modifier = Modifier.weight(1f)
                )
            }

            // Conte√∫do
            when {
                uiState.isLoading -> {
                    Box(
                        modifier = Modifier.fillMaxSize(),
                        contentAlignment = Alignment.Center
                    ) {
                        CircularProgressIndicator(color = TaskGoGreen)
                    }
                }
                uiState.error != null -> {
                    Column(
                        modifier = Modifier
                            .fillMaxSize()
                            .padding(16.dp),
                        horizontalAlignment = Alignment.CenterHorizontally,
                        verticalArrangement = Arrangement.Center
                    ) {
                        Text(
                            text = uiState.error ?: "Erro desconhecido",
                            color = MaterialTheme.colorScheme.error,
                            style = MaterialTheme.typography.bodyLarge
                        )
                        Spacer(modifier = Modifier.height(16.dp))
                        Button(
                            onClick = { viewModel.refreshServices() },
                            colors = ButtonDefaults.buttonColors(containerColor = TaskGoGreen)
                        ) {
                            Text("Tentar Novamente")
                        }
                    }
                }
                filteredOrders.isEmpty() -> {
                    EmptyOrdersState(
                        tab = selectedTab,
                        modifier = Modifier.fillMaxSize()
                    )
                }
                else -> {
                    LazyColumn(
                        modifier = Modifier
                            .fillMaxSize()
                            .padding(horizontal = 16.dp),
                        verticalArrangement = Arrangement.spacedBy(12.dp),
                        contentPadding = PaddingValues(bottom = 16.dp)
                    ) {
                        items(
                            items = filteredOrders,
                            key = { it.id }
                        ) { order ->
                            ServiceOrderItemCard(
                                order = order,
                                onServiceClick = { 
                                    if (order.serviceId.isNotEmpty()) {
                                        onViewService(order.serviceId)
                                    }
                                },
                                onOrderClick = onOrderClick
                            )
                        }
                    }
                }
            }
        }
    }
}

@Composable
private fun ServiceOrderItemCard(
    order: OrderFirestore,
    onServiceClick: () -> Unit,
    onOrderClick: ((String) -> Unit)? = null,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier
            .fillMaxWidth()
            .clickable { 
                // Se onOrderClick est√° dispon√≠vel, usar para navegar para detalhes da ordem
                // Caso contr√°rio, usar onServiceClick como fallback
                if (onOrderClick != null && order.id.isNotEmpty()) {
                    onOrderClick(order.id)
                } else {
                    onServiceClick()
                }
            },
        shape = RoundedCornerShape(12.dp),
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Column(modifier = Modifier.weight(1f)) {
                    Text(
                        text = order.category ?: "Servi√ßo",
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold,
                        color = TaskGoTextDark
                    )
                    if (order.dueDate != null) {
                        Spacer(modifier = Modifier.height(4.dp))
                        Text(
                            text = "Prazo: ${order.dueDate}",
                            style = MaterialTheme.typography.bodySmall,
                            color = TaskGoTextGray
                        )
                    }
                }
                
                // Status chip
                StatusChip(status = order.status)
            }
            
            Text(
                text = order.details.ifEmpty { "Sem descri√ß√£o" },
                style = MaterialTheme.typography.bodyMedium,
                color = TaskGoTextDark,
                maxLines = 3
            )
            
            if (order.location.isNotEmpty()) {
                Text(
                    text = "üìç ${order.location}",
                    style = MaterialTheme.typography.bodySmall,
                    color = TaskGoTextGray
                )
            }
            
            if (order.budget > 0) {
                Text(
                    text = "Or√ßamento: R$ ${String.format("%.2f", order.budget)}",
                    style = MaterialTheme.typography.bodyMedium,
                    fontWeight = FontWeight.Medium,
                    color = TaskGoGreen
                )
            }
            
            if (order.proposalDetails != null) {
                Text(
                    text = "Proposta: R$ ${String.format("%.2f", order.proposalDetails.price)}",
                    style = MaterialTheme.typography.bodyMedium,
                    fontWeight = FontWeight.Medium,
                    color = TaskGoGreen
                )
            }
        }
    }
}

@Composable
private fun StatusChip(status: String) {
    val (color, backgroundColor, text) = when (status.lowercase()) {
        "pending" -> Triple(
            MaterialTheme.colorScheme.primary,
            MaterialTheme.colorScheme.primaryContainer,
            "Pendente"
        )
        "proposed" -> Triple(
            MaterialTheme.colorScheme.secondary,
            MaterialTheme.colorScheme.secondaryContainer,
            "Proposta Enviada"
        )
        "accepted" -> Triple(
            TaskGoGreen,
            TaskGoGreen.copy(alpha = 0.1f),
            "Aceita"
        )
        "payment_pending", "paid" -> Triple(
            MaterialTheme.colorScheme.tertiary,
            MaterialTheme.colorScheme.tertiaryContainer,
            "Pagamento"
        )
        "in_progress" -> Triple(
            TaskGoGreen,
            TaskGoGreen.copy(alpha = 0.1f),
            "Em Andamento"
        )
        "completed" -> Triple(
            MaterialTheme.colorScheme.tertiary,
            MaterialTheme.colorScheme.tertiaryContainer,
            "Conclu√≠do"
        )
        "cancelled" -> Triple(
            MaterialTheme.colorScheme.error,
            MaterialTheme.colorScheme.errorContainer,
            "Cancelada"
        )
        else -> Triple(
            TaskGoTextGray,
            TaskGoTextGray.copy(alpha = 0.1f),
            status
        )
    }
    
    Surface(
        shape = RoundedCornerShape(16.dp),
        color = backgroundColor
    ) {
        Text(
            text = text,
            modifier = Modifier.padding(horizontal = 12.dp, vertical = 4.dp),
            style = MaterialTheme.typography.labelSmall,
            color = color,
            fontWeight = FontWeight.Medium
        )
    }
}

@Composable
private fun ServiceItemCard(
    service: ServiceFirestore,
    onEditClick: () -> Unit,
    onDeleteClick: () -> Unit,
    onServiceClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    val context = LocalContext.current
    
    Card(
        modifier = modifier
            .fillMaxWidth()
            .clickable { onServiceClick() },
        shape = RoundedCornerShape(12.dp),
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Column(modifier = Modifier.weight(1f)) {
                    Text(
                        text = service.title.ifEmpty { "Sem t√≠tulo" },
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold,
                        color = TaskGoTextDark
                    )
                    Spacer(modifier = Modifier.height(4.dp))
                    Text(
                        text = "R$ ${String.format("%.2f", service.price)}",
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold,
                        color = TaskGoGreen
                    )
                }
                
                // Status chip
                Surface(
                    shape = RoundedCornerShape(16.dp),
                    color = if (service.active) 
                        TaskGoGreen.copy(alpha = 0.1f) 
                    else 
                        MaterialTheme.colorScheme.errorContainer.copy(alpha = 0.1f)
                ) {
                    Text(
                        text = if (service.active) "Ativo" else "Inativo",
                        modifier = Modifier.padding(horizontal = 12.dp, vertical = 4.dp),
                        style = MaterialTheme.typography.labelSmall,
                        color = if (service.active) TaskGoGreen else MaterialTheme.colorScheme.error,
                        fontWeight = FontWeight.Medium
                    )
                }
            }
            
            // Service image preview
            if (service.images.isNotEmpty()) {
                Box(
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(200.dp)
                ) {
                    AsyncImage(
                        model = ImageRequest.Builder(context)
                            .data(service.images.first())
                            .crossfade(true)
                            .build(),
                        contentDescription = "Imagem do servi√ßo ${service.title}",
                        modifier = Modifier.fillMaxSize(),
                        contentScale = androidx.compose.ui.layout.ContentScale.Crop
                    )
                }
            }
            
            Text(
                text = service.description.ifEmpty { "Sem descri√ß√£o" },
                style = MaterialTheme.typography.bodyMedium,
                color = TaskGoTextDark,
                maxLines = 3
            )
            
            Row(
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                if (service.images.isNotEmpty()) {
                    Text(
                        text = "üì∑ ${service.images.size}",
                        style = MaterialTheme.typography.bodySmall,
                        color = TaskGoTextGray
                    )
                }
                if (service.videos.isNotEmpty()) {
                    Text(
                        text = "üé• ${service.videos.size}",
                        style = MaterialTheme.typography.bodySmall,
                        color = TaskGoTextGray
                    )
                }
            }
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                OutlinedButton(
                    onClick = onDeleteClick,
                    modifier = Modifier.weight(1f),
                    colors = ButtonDefaults.outlinedButtonColors(
                        contentColor = MaterialTheme.colorScheme.error
                    )
                ) {
                    Icon(
                        imageVector = Icons.Default.Delete,
                        contentDescription = "Excluir",
                        modifier = Modifier.size(18.dp)
                    )
                    Spacer(modifier = Modifier.width(4.dp))
                    Text("Excluir")
                }
                
                Button(
                    onClick = onEditClick,
                    modifier = Modifier.weight(1f),
                    colors = ButtonDefaults.buttonColors(
                        containerColor = TaskGoGreen
                    )
                ) {
                    Icon(
                        imageVector = Icons.Default.Edit,
                        contentDescription = "Editar",
                        modifier = Modifier.size(18.dp)
                    )
                    Spacer(modifier = Modifier.width(4.dp))
                    Text("Editar")
                }
            }
        }
    }
}

@Composable
private fun ServiceTabChip(
    text: String,
    selected: Boolean,
    onClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    FilterChip(
        selected = selected,
        onClick = onClick,
        modifier = modifier.height(40.dp),
        label = {
            Text(
                text = text,
                style = MaterialTheme.typography.labelMedium,
                color = if (selected) TaskGoBackgroundWhite else TaskGoTextBlack,
                maxLines = 1,
                overflow = TextOverflow.Ellipsis
            )
        },
        colors = FilterChipDefaults.filterChipColors(
            selectedContainerColor = TaskGoGreen,
            selectedLabelColor = TaskGoBackgroundWhite,
            containerColor = TaskGoSurfaceGray,
            labelColor = TaskGoTextBlack
        )
    )
}

@Composable
private fun EmptyOrdersState(
    tab: ServiceTab,
    modifier: Modifier = Modifier
) {
    Column(
        modifier = modifier
            .fillMaxSize()
            .padding(32.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        Text(
            text = when (tab) {
                ServiceTab.SOLICITADOS -> "üìã"
                ServiceTab.EM_ANDAMENTO -> "‚öôÔ∏è"
                ServiceTab.CONCLUIDOS -> "‚úÖ"
                ServiceTab.CANCELADOS -> "‚ùå"
            },
            style = MaterialTheme.typography.displayMedium
        )
        Spacer(modifier = Modifier.height(16.dp))
        Text(
            text = when (tab) {
                ServiceTab.SOLICITADOS -> "Nenhum servi√ßo solicitado"
                ServiceTab.EM_ANDAMENTO -> "Nenhum servi√ßo em andamento"
                ServiceTab.CONCLUIDOS -> "Nenhum servi√ßo conclu√≠do"
                ServiceTab.CANCELADOS -> "Nenhum servi√ßo cancelado"
            },
            style = MaterialTheme.typography.titleLarge,
            fontWeight = FontWeight.Bold,
            color = TaskGoTextBlack
        )
        Spacer(modifier = Modifier.height(8.dp))
        Text(
            text = when (tab) {
                ServiceTab.SOLICITADOS -> "Aguardando solicita√ß√µes de clientes"
                ServiceTab.EM_ANDAMENTO -> "Voc√™ ainda n√£o tem servi√ßos em andamento"
                ServiceTab.CONCLUIDOS -> "Hist√≥rico de servi√ßos conclu√≠dos aparecer√° aqui"
                ServiceTab.CANCELADOS -> "Servi√ßos cancelados aparecer√£o aqui"
            },
            style = MaterialTheme.typography.bodyMedium,
            color = TaskGoTextGray
        )
    }
}

```

## [FRONTEND]: feature/services/presentation/MyServiceOrdersScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.services.presentation

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material.icons.filled.Edit
import androidx.compose.ui.graphics.Color
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.collectAsState
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.theme.*
import com.taskgoapp.taskgo.feature.home.presentation.FilterTypeChip
import java.text.SimpleDateFormat
import java.util.*

enum class ServiceOrderTab {
    ACTIVE, CANCELLED
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MyServiceOrdersScreen(
    onBackClick: () -> Unit,
    onEditOrder: (String) -> Unit,
    onCreateOrder: () -> Unit = {},
    viewModel: MyServiceOrdersViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    var selectedTab by remember { mutableStateOf(ServiceOrderTab.ACTIVE) }
    
    // CR√çTICO: For√ßar recarregamento quando a tela √© aberta
    // Isso garante que ordens rec√©m-criadas apare√ßam imediatamente
    LaunchedEffect(Unit) {
        android.util.Log.d("MyServiceOrdersScreen", "üîÑ Tela aberta, for√ßando recarregamento de ordens...")
        viewModel.refreshOrders()
    }
    
    // Filtrar ordens baseado na aba selecionada
    val filteredOrders = when (selectedTab) {
        ServiceOrderTab.ACTIVE -> uiState.orders.filter { 
            it.status.lowercase() != "cancelled" && it.status.lowercase() != "cancelada"
        }
        ServiceOrderTab.CANCELLED -> uiState.orders.filter { 
            it.status.lowercase() == "cancelled" || it.status.lowercase() == "cancelada"
        }
    }
    
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Minhas Ordens de Servi√ßo",
                onBackClick = onBackClick
            )
        },
        floatingActionButton = {
            if (selectedTab == ServiceOrderTab.ACTIVE) {
                FloatingActionButton(
                    onClick = onCreateOrder,
                    containerColor = TaskGoGreen
                ) {
                    Icon(
                        imageVector = Icons.Default.Add,
                        contentDescription = "Criar Ordem de Servi√ßo",
                        tint = Color.White
                    )
                }
            }
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            // Abas Ativas/Canceladas
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                FilterTypeChip(
                    text = "Ativas",
                    selected = selectedTab == ServiceOrderTab.ACTIVE,
                    onClick = { selectedTab = ServiceOrderTab.ACTIVE },
                    modifier = Modifier.weight(1f)
                )
                FilterTypeChip(
                    text = "Canceladas",
                    selected = selectedTab == ServiceOrderTab.CANCELLED,
                    onClick = { selectedTab = ServiceOrderTab.CANCELLED },
                    modifier = Modifier.weight(1f)
                )
            }
            
            // Conte√∫do das ordens
            if (uiState.isLoading) {
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    CircularProgressIndicator()
                }
            } else if (uiState.error != null) {
                Card(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp),
                    colors = CardDefaults.cardColors(
                        containerColor = MaterialTheme.colorScheme.errorContainer
                    )
                ) {
                    Text(
                        text = uiState.error ?: "Erro ao carregar ordens",
                        modifier = Modifier.padding(16.dp),
                        color = MaterialTheme.colorScheme.onErrorContainer
                    )
                }
            } else if (filteredOrders.isEmpty()) {
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    Column(
                        horizontalAlignment = Alignment.CenterHorizontally,
                        verticalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        Text(
                            text = when (selectedTab) {
                                ServiceOrderTab.ACTIVE -> "Nenhuma ordem de servi√ßo ativa encontrada"
                                ServiceOrderTab.CANCELLED -> "Nenhuma ordem de servi√ßo cancelada encontrada"
                            },
                            style = MaterialTheme.typography.titleMedium,
                            color = TaskGoTextGray
                        )
                        if (selectedTab == ServiceOrderTab.ACTIVE) {
                            Text(
                                text = "Crie sua primeira ordem de servi√ßo",
                                style = MaterialTheme.typography.bodyMedium,
                                color = TaskGoTextGray
                            )
                        }
                    }
                }
            } else {
                LazyColumn(
                    modifier = Modifier.fillMaxSize(),
                    contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp),
                    verticalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    items(filteredOrders) { order ->
                        ServiceOrderCard(
                            order = order,
                            onEditClick = { 
                                if (selectedTab == ServiceOrderTab.ACTIVE) {
                                    onEditOrder(order.id) 
                                }
                            },
                            onDeleteClick = { 
                                if (selectedTab == ServiceOrderTab.ACTIVE) {
                                    viewModel.deleteOrder(order.id) 
                                }
                            },
                            showActions = selectedTab == ServiceOrderTab.ACTIVE
                        )
                    }
                }
            }
        }
    }
}

@Composable
private fun ServiceOrderCard(
    order: ServiceOrderItem,
    onEditClick: () -> Unit,
    onDeleteClick: () -> Unit,
    showActions: Boolean = true
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .clickable { onEditClick() },
        shape = RoundedCornerShape(12.dp),
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Column(modifier = Modifier.weight(1f)) {
                    Text(
                        text = order.category,
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold,
                        color = TaskGoTextDark
                    )
                    if (order.dueDate != null) {
                        Text(
                            text = "Prazo: ${formatDate(order.dueDate)}",
                            style = MaterialTheme.typography.bodySmall,
                            color = TaskGoTextGray
                        )
                    }
                }
                StatusChip(status = order.status)
            }
            
            Text(
                text = order.details,
                style = MaterialTheme.typography.bodyMedium,
                color = TaskGoTextDark,
                maxLines = 3
            )
            
            if (order.location.isNotEmpty()) {
                Text(
                    text = "üìç ${order.location}",
                    style = MaterialTheme.typography.bodySmall,
                    color = TaskGoTextGray
                )
            }
            
            if (order.budget != null && order.budget > 0) {
                Text(
                    text = "Or√ßamento: R$ ${String.format("%.2f", order.budget)}",
                    style = MaterialTheme.typography.bodyMedium,
                    fontWeight = FontWeight.Medium,
                    color = TaskGoGreen
                )
            }
            
            if (showActions) {
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    OutlinedButton(
                        onClick = onDeleteClick,
                        modifier = Modifier.weight(1f),
                        colors = ButtonDefaults.outlinedButtonColors(
                            contentColor = MaterialTheme.colorScheme.error
                        )
                    ) {
                        Icon(
                            imageVector = Icons.Default.Delete,
                            contentDescription = "Excluir",
                            modifier = Modifier.size(18.dp)
                        )
                        Spacer(modifier = Modifier.width(4.dp))
                        Text("Excluir")
                    }
                    
                    Button(
                        onClick = onEditClick,
                        modifier = Modifier.weight(1f),
                        colors = ButtonDefaults.buttonColors(
                            containerColor = TaskGoGreen
                        )
                    ) {
                        Icon(
                            imageVector = Icons.Default.Edit,
                            contentDescription = "Editar",
                            modifier = Modifier.size(18.dp)
                        )
                        Spacer(modifier = Modifier.width(4.dp))
                        Text("Editar")
                    }
                }
            }
        }
    }
}

@Composable
private fun StatusChip(status: String) {
    val (color, backgroundColor) = when (status.lowercase()) {
        "pending" -> MaterialTheme.colorScheme.primary to MaterialTheme.colorScheme.primaryContainer
        "accepted" -> TaskGoGreen to TaskGoGreen.copy(alpha = 0.1f)
        "completed" -> MaterialTheme.colorScheme.tertiary to MaterialTheme.colorScheme.tertiaryContainer
        "cancelled" -> MaterialTheme.colorScheme.error to MaterialTheme.colorScheme.errorContainer
        else -> TaskGoTextGray to TaskGoTextGray.copy(alpha = 0.1f)
    }
    
    Surface(
        shape = RoundedCornerShape(16.dp),
        color = backgroundColor
    ) {
        Text(
            text = when (status.lowercase()) {
                "pending" -> "Pendente"
                "accepted" -> "Aceita"
                "completed" -> "Conclu√≠da"
                "cancelled" -> "Cancelada"
                else -> status
            },
            modifier = Modifier.padding(horizontal = 12.dp, vertical = 4.dp),
            style = MaterialTheme.typography.labelSmall,
            color = color,
            fontWeight = FontWeight.Medium
        )
    }
}

private fun formatDate(date: Date): String {
    val format = SimpleDateFormat("dd/MM/yyyy", Locale("pt", "BR"))
    return format.format(date)
}

data class ServiceOrderItem(
    val id: String,
    val category: String,
    val details: String,
    val location: String,
    val budget: Double?,
    val dueDate: Date?,
    val status: String,
    val createdAt: Date?
)


```

## [FRONTEND]: feature/services/presentation/MyServiceOrdersViewModel.kt

```kotlin
package com.taskgoapp.taskgo.feature.services.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.google.firebase.auth.FirebaseAuth
import com.taskgoapp.taskgo.data.repository.FirestoreOrderRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.launch
import java.text.ParseException
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale
import javax.inject.Inject

data class MyServiceOrdersState(
    val orders: List<ServiceOrderItem> = emptyList(),
    val isLoading: Boolean = false,
    val error: String? = null
)

@HiltViewModel
class MyServiceOrdersViewModel @Inject constructor(
    private val orderRepository: FirestoreOrderRepository,
    private val firebaseAuth: FirebaseAuth
) : ViewModel() {
    
    private val _uiState = MutableStateFlow(MyServiceOrdersState(isLoading = true))
    val uiState: StateFlow<MyServiceOrdersState> = _uiState.asStateFlow()
    
    init {
        loadOrders()
    }
    
    private fun loadOrders() {
        val currentUser = firebaseAuth.currentUser
        if (currentUser == null) {
            android.util.Log.e("MyServiceOrdersVM", "Usu√°rio n√£o autenticado")
            _uiState.value = _uiState.value.copy(
                isLoading = false,
                error = "Usu√°rio n√£o autenticado"
            )
            return
        }
        
        android.util.Log.d("MyServiceOrdersVM", "üîµ Carregando ordens para cliente: ${currentUser.uid}")
        
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoading = true, error = null)
            
            try {
                // CR√çTICO: Observar cole√ß√£o p√∫blica 'orders' onde clientId == userId
                // A Cloud Function createOrder salva na cole√ß√£o p√∫blica, n√£o na subcole√ß√£o
                orderRepository.observeOrders(currentUser.uid, "client")
                    .catch { e ->
                        android.util.Log.e("MyServiceOrdersVM", "‚ùå Erro ao observar ordens: ${e.message}", e)
                        _uiState.value = _uiState.value.copy(
                            isLoading = false,
                            error = "Erro ao carregar ordens: ${e.message}"
                        )
                    }
                    .collect { orders ->
                        android.util.Log.d("MyServiceOrdersVM", "üì¶ Ordens recebidas: ${orders.size}")
                        orders.forEach { order ->
                            android.util.Log.d("MyServiceOrdersVM", "   - Order ${order.id}: status=${order.status}, category=${order.category}")
                        }
                        
                        val orderItems = orders.map { order ->
                            ServiceOrderItem(
                                id = order.id,
                                category = order.category ?: order.serviceId?.takeIf { it.isNotBlank() } ?: "Servi√ßo",
                                details = order.details,
                                location = order.location,
                                budget = order.budget,
                                dueDate = parseDueDate(order.dueDate),
                                status = order.status ?: "pending",
                                createdAt = order.createdAt
                            )
                        }
                        android.util.Log.d("MyServiceOrdersVM", "‚úÖ ${orderItems.size} ordens processadas e atualizadas na UI")
                        _uiState.value = _uiState.value.copy(
                            orders = orderItems,
                            isLoading = false,
                            error = null
                        )
                    }
            } catch (e: Exception) {
                android.util.Log.e("MyServiceOrdersVM", "‚ùå Erro ao carregar ordens: ${e.message}", e)
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = "Erro ao carregar ordens: ${e.message}"
                )
            }
        }
    }
    
    fun deleteOrder(orderId: String) {
        viewModelScope.launch {
            try {
                // Soft delete - atualizar status para cancelled
                val result = orderRepository.updateOrderStatus(orderId, "cancelled")
                when (result) {
                    is com.taskgoapp.taskgo.core.model.Result.Error -> {
                        _uiState.value = _uiState.value.copy(
                            error = "Erro ao excluir ordem: ${result.exception.message ?: "Erro desconhecido"}"
                        )
                    }
                    is com.taskgoapp.taskgo.core.model.Result.Success -> {
                        // Sucesso - a lista ser√° atualizada automaticamente via observeOrders
                    }
                    is com.taskgoapp.taskgo.core.model.Result.Loading -> {
                        // Nada a fazer
                    }
                }
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    error = "Erro ao excluir ordem: ${e.message}"
                )
            }
        }
    }
    
    /**
     * For√ßa recarregamento das ordens
     * √ötil ap√≥s criar uma nova ordem para garantir que aparece na lista
     */
    fun refreshOrders() {
        android.util.Log.d("MyServiceOrdersVM", "üîÑ For√ßando recarregamento de ordens...")
        loadOrders()
    }
}

private val possibleDateFormats = listOf(
    "dd/MM/yyyy",
    "yyyy-MM-dd",
    "yyyy-MM-dd'T'HH:mm:ss'Z'",
    "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"
)

private fun parseDueDate(dueDate: String?): Date? {
    if (dueDate.isNullOrBlank()) return null
    
    for (pattern in possibleDateFormats) {
        try {
            val formatter = SimpleDateFormat(pattern, Locale.getDefault())
            return formatter.parse(dueDate)
        } catch (ignored: ParseException) {
        }
    }
    return null
}


```

## [FRONTEND]: feature/services/presentation/MyServicesViewModel.kt

```kotlin
package com.taskgoapp.taskgo.feature.services.presentation

import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.google.firebase.auth.FirebaseAuth
import com.taskgoapp.taskgo.data.firestore.models.OrderFirestore
import com.taskgoapp.taskgo.data.repository.FirestoreOrderRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.launch
import javax.inject.Inject

data class MyServicesUiState(
    val isLoading: Boolean = false,
    val orders: List<OrderFirestore> = emptyList(),
    val error: String? = null
)

@HiltViewModel
class MyServicesViewModel @Inject constructor(
    private val orderRepository: FirestoreOrderRepository,
    private val firebaseAuth: FirebaseAuth
) : ViewModel() {

    private val _uiState = MutableStateFlow(MyServicesUiState())
    val uiState: StateFlow<MyServicesUiState> = _uiState.asStateFlow()

    init {
        loadOrders()
    }

    private fun loadOrders() {
        val currentUser = firebaseAuth.currentUser
        if (currentUser == null) {
            _uiState.value = _uiState.value.copy(
                error = "Usu√°rio n√£o autenticado",
                isLoading = false
            )
            return
        }

        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoading = true, error = null)
            
            orderRepository.observeOrders(currentUser.uid, "provider")
                .catch { e ->
                    Log.e("MyServicesViewModel", "Erro ao carregar ordens", e)
                    _uiState.value = _uiState.value.copy(
                        error = "Erro ao carregar ordens: ${e.message}",
                        isLoading = false
                    )
                }
                .collect { orders ->
                    Log.d("MyServicesViewModel", "Ordens carregadas: ${orders.size}")
                    _uiState.value = _uiState.value.copy(
                        orders = orders,
                        isLoading = false,
                        error = null
                    )
                }
        }
    }

    fun refreshServices() {
        loadOrders()
    }
}


```

## [FRONTEND]: feature/services/presentation/ProposalDetailScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.services.presentation

import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Star
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.taskgoapp.taskgo.core.design.TGIcons
import com.taskgoapp.taskgo.core.theme.TaskGoGreen
import com.taskgoapp.taskgo.core.theme.TaskGoTextBlack
import com.taskgoapp.taskgo.core.theme.TaskGoTextGray
import com.taskgoapp.taskgo.core.theme.TaskGoBackgroundWhite
import androidx.compose.material3.ExperimentalMaterial3Api

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ProposalDetailScreen(
    proposalId: String,
    onBackClick: () -> Unit,
    onAcceptProposal: (String) -> Unit,
    onRejectProposal: (String) -> Unit
) {
    // Dados v√™m do Firestore - iniciar vazio
    val proposal = remember(proposalId) {
        null as Proposal?
    }
    
    // Se n√£o h√° proposta, mostrar estado vazio
    if (proposal == null) {
        Box(
            modifier = Modifier.fillMaxSize(),
            contentAlignment = Alignment.Center
        ) {
            Column(
                horizontalAlignment = Alignment.CenterHorizontally,
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Text(
                    text = "Proposta n√£o encontrada",
                    color = TaskGoTextGray,
                    fontSize = 16.sp
                )
                Text(
                    text = "Esta proposta n√£o existe ou foi removida",
                    color = TaskGoTextGray,
                    fontSize = 14.sp,
                    textAlign = TextAlign.Center
                )
            }
        }
        return
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .background(TaskGoBackgroundWhite)
    ) {
        // Top Bar
        TopAppBar(
            title = {
                Text(
                    text = "Detalhes da Proposta",
                    color = TaskGoTextBlack,
                    fontSize = 18.sp,
                    fontWeight = FontWeight.Bold
                )
            },
            navigationIcon = {
                IconButton(onClick = onBackClick) {
                    Icon(
                        imageVector = Icons.Filled.ArrowBack,
                        contentDescription = "Voltar",
                        tint = TaskGoTextBlack
                    )
                }
            },
            colors = TopAppBarDefaults.topAppBarColors(
                containerColor = TaskGoBackgroundWhite
            )
        )

        Column(
            modifier = Modifier
                .fillMaxSize()
                .verticalScroll(rememberScrollState())
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // Card do prestador
            Card(
                modifier = Modifier.fillMaxWidth(),
                shape = RoundedCornerShape(12.dp),
                colors = CardDefaults.cardColors(
                    containerColor = Color.White
                ),
                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
            ) {
                Column(
                    modifier = Modifier.padding(20.dp)
                ) {
                    // Avatar e informa√ß√µes do prestador
                    Row(
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        // Avatar
                        Box(
                            modifier = Modifier
                                .size(60.dp)
                                .background(
                                    color = TaskGoGreen.copy(alpha = 0.1f),
                                    shape = CircleShape
                                ),
                            contentAlignment = Alignment.Center
                        ) {
                            Text(
                                text = proposal.providerName.split(" ").map { it.first() }.joinToString(""),
                                color = TaskGoGreen,
                                fontSize = 20.sp,
                                fontWeight = FontWeight.Bold
                            )
                        }
                        
                        Spacer(modifier = Modifier.width(16.dp))
                        
                        Column {
                            Text(
                                text = proposal.providerName,
                                color = TaskGoTextBlack,
                                fontSize = 18.sp,
                                fontWeight = FontWeight.Bold
                            )
                            Row(
                                verticalAlignment = Alignment.CenterVertically
                            ) {
                                Icon(
                                    imageVector = Icons.Filled.Star,
                                    contentDescription = "Avalia√ß√£o",
                                    tint = Color(0xFFFFD700),
                                    modifier = Modifier.size(16.dp)
                                )
                                Spacer(modifier = Modifier.width(4.dp))
                                Text(
                                    text = "${proposal.providerRating} (100+ servi√ßos)",
                                    color = TaskGoTextGray,
                                    fontSize = 14.sp
                                )
                            }
                        }
                    }
                }
            }
            
            // Card de informa√ß√µes do servi√ßo
            Card(
                modifier = Modifier.fillMaxWidth(),
                shape = RoundedCornerShape(12.dp),
                colors = CardDefaults.cardColors(
                    containerColor = Color.White
                ),
                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
            ) {
                Column(
                    modifier = Modifier.padding(20.dp)
                ) {
                    Text(
                        text = "Detalhes do Servi√ßo",
                        color = TaskGoTextBlack,
                        fontSize = 16.sp,
                        fontWeight = FontWeight.Bold
                    )
                    
                    Spacer(modifier = Modifier.height(12.dp))
                    
                    Text(
                        text = proposal.serviceTitle,
                        color = TaskGoTextBlack,
                        fontSize = 14.sp,
                        fontWeight = FontWeight.Medium
                    )
                    
                        Spacer(modifier = Modifier.height(8.dp))
                    
                    Text(
                        text = proposal.serviceDescription,
                        color = TaskGoTextGray,
                        fontSize = 12.sp,
                        lineHeight = 18.sp
                    )
                }
            }
            
            // Card de informa√ß√µes da solicita√ß√£o
            Card(
                modifier = Modifier.fillMaxWidth(),
                shape = RoundedCornerShape(12.dp),
                colors = CardDefaults.cardColors(
                    containerColor = Color.White
                ),
                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
            ) {
                Column(
                    modifier = Modifier.padding(20.dp)
                ) {
                    Text(
                        text = "Informa√ß√µes da Solicita√ß√£o",
                        color = TaskGoTextBlack,
                        fontSize = 16.sp,
                        fontWeight = FontWeight.Bold
                    )
                    
                    Spacer(modifier = Modifier.height(12.dp))
                    
                    InfoRow("Data solicitada:", proposal.date)
                    InfoRow("Local:", proposal.location)
                    InfoRow("Or√ßamento:", "R$ ${String.format("%.2f", proposal.budget)}")
                }
            }
            
            // Card de or√ßamento
            Card(
                modifier = Modifier.fillMaxWidth(),
                shape = RoundedCornerShape(12.dp),
                colors = CardDefaults.cardColors(
                    containerColor = TaskGoGreen.copy(alpha = 0.1f)
                ),
                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
            ) {
                Column(
                    modifier = Modifier.padding(20.dp),
                    horizontalAlignment = Alignment.CenterHorizontally
                ) {
                    Text(
                        text = "Or√ßamento",
                        color = TaskGoTextGray,
                        fontSize = 14.sp
                    )
                    Spacer(modifier = Modifier.height(4.dp))
                    Text(
                        text = "R$ ${String.format("%.2f", proposal.budget)}",
                        color = TaskGoTextBlack,
                        fontSize = 28.sp,
                        fontWeight = FontWeight.Bold
                    )
                }
            }
            
            if (proposal.status == ProposalStatus.PENDING) {
                // Bot√µes de a√ß√£o
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    OutlinedButton(
                        onClick = { onRejectProposal(proposal.id) },
                        modifier = Modifier.weight(1f),
                        shape = RoundedCornerShape(8.dp),
                        colors = ButtonDefaults.outlinedButtonColors(
                            contentColor = Color(0xFFDC3545)
                        )
                    ) {
                        Text(
                            text = "Rejeitar Proposta",
                            fontSize = 14.sp,
                            fontWeight = FontWeight.Medium
                        )
                    }
                    
                    Button(
                        onClick = { onAcceptProposal(proposal.id) },
                        modifier = Modifier.weight(1f),
                        shape = RoundedCornerShape(8.dp),
                        colors = ButtonDefaults.buttonColors(
                            containerColor = TaskGoGreen
                        )
                    ) {
                        Text(
                            text = "Aceitar Proposta",
                            color = Color.White,
                            fontSize = 14.sp,
                            fontWeight = FontWeight.Medium
                        )
                    }
                }
            } else {
                // Status da proposta
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    shape = RoundedCornerShape(8.dp),
                    colors = CardDefaults.cardColors(
                        containerColor = when (proposal.status) {
                            ProposalStatus.ACCEPTED -> Color(0xFFD4EDDA)
                            ProposalStatus.REJECTED -> Color(0xFFF8D7DA)
                            else -> Color(0xFFFFF3CD)
                        }
                    )
                ) {
                    Text(
                        text = when (proposal.status) {
                            ProposalStatus.ACCEPTED -> "Proposta Aceita"
                            ProposalStatus.REJECTED -> "Proposta Rejeitada"
                            else -> "Proposta Pendente"
                        },
                        color = when (proposal.status) {
                            ProposalStatus.ACCEPTED -> Color(0xFF155724)
                            ProposalStatus.REJECTED -> Color(0xFF721C24)
                            else -> Color(0xFF856404)
                        },
                        fontSize = 16.sp,
                        fontWeight = FontWeight.Bold,
                        textAlign = TextAlign.Center,
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(16.dp)
                    )
                }
            }
        }
    }
}

@Composable
fun InfoRow(
    label: String,
    value: String
) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 4.dp)
    ) {
        Text(
            text = label,
            color = TaskGoTextGray,
            fontSize = 12.sp,
            modifier = Modifier.weight(1f)
        )
        Text(
            text = value,
            color = TaskGoTextBlack,
            fontSize = 12.sp,
            fontWeight = FontWeight.Medium
        )
    }
}
```

## [FRONTEND]: feature/services/presentation/ProposalsReceivedScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.services.presentation

import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Star
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.taskgoapp.taskgo.core.design.TGIcons
import com.taskgoapp.taskgo.core.theme.TaskGoGreen
import com.taskgoapp.taskgo.core.theme.TaskGoTextBlack
import com.taskgoapp.taskgo.core.theme.TaskGoTextGray
import com.taskgoapp.taskgo.core.theme.TaskGoBackgroundWhite

data class Proposal(
    val id: String,
    val providerName: String,
    val providerRating: Double,
    val serviceTitle: String,
    val serviceDescription: String,
    val budget: Double,
    val location: String,
    val date: String,
    val status: ProposalStatus
)

enum class ProposalStatus {
    PENDING, ACCEPTED, REJECTED
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ProposalsReceivedScreen(
    onBackClick: () -> Unit,
    onProposalClick: (String) -> Unit,
    onAcceptProposal: (String) -> Unit,
    onRejectProposal: (String) -> Unit
) {
    // Lista vazia - dados v√™m do Firestore
    val proposals = remember { emptyList<Proposal>() }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .background(TaskGoBackgroundWhite)
    ) {
        // Top Bar
        TopAppBar(
            title = {
                Text(
                    text = "Propostas Recebidas",
                    color = TaskGoTextBlack,
                    fontSize = 18.sp,
                    fontWeight = FontWeight.Bold
                )
            },
            navigationIcon = {
                IconButton(onClick = onBackClick) {
                    Icon(
                        imageVector = Icons.Filled.ArrowBack,
                        contentDescription = "Voltar",
                        tint = TaskGoTextBlack
                    )
                }
            },
            colors = TopAppBarDefaults.topAppBarColors(
                containerColor = TaskGoBackgroundWhite
            )
        )

        // Lista de propostas
        if (proposals.isEmpty()) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(16.dp),
                contentAlignment = Alignment.Center
            ) {
                Column(
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    Text(
                        text = "Nenhuma proposta recebida",
                        color = TaskGoTextGray,
                        fontSize = 16.sp
                    )
                    Text(
                        text = "Quando voc√™ receber propostas, elas aparecer√£o aqui",
                        color = TaskGoTextGray,
                        fontSize = 14.sp,
                        textAlign = TextAlign.Center
                    )
                }
            }
        } else {
        LazyColumn(
            modifier = Modifier
                .fillMaxSize()
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            items(proposals) { proposal ->
                ProposalCard(
                    proposal = proposal,
                    onProposalClick = { onProposalClick(proposal.id) },
                    onAcceptProposal = { onAcceptProposal(proposal.id) },
                    onRejectProposal = { onRejectProposal(proposal.id) }
                )
                }
            }
        }
    }
}

@Composable
fun ProposalCard(
    proposal: Proposal,
    onProposalClick: () -> Unit,
    onAcceptProposal: () -> Unit,
    onRejectProposal: () -> Unit
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .clickable { onProposalClick() },
        shape = RoundedCornerShape(12.dp),
        colors = CardDefaults.cardColors(
            containerColor = Color.White
        ),
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            // Header com nome e avalia√ß√£o
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Column {
                    Text(
                        text = proposal.providerName,
                        color = TaskGoTextBlack,
                        fontSize = 16.sp,
                        fontWeight = FontWeight.Bold
                    )
                    Row(
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Icon(
                            imageVector = Icons.Filled.Star,
                            contentDescription = "Avalia√ß√£o",
                            tint = Color(0xFFFFD700),
                            modifier = Modifier.size(16.dp)
                        )
                        Spacer(modifier = Modifier.width(4.dp))
                        Text(
                            text = "${proposal.providerRating} (100+ servi√ßos)",
                            color = TaskGoTextGray,
                            fontSize = 12.sp
                        )
                    }
                }
                
                // Status
                Card(
                    shape = RoundedCornerShape(16.dp),
                    colors = CardDefaults.cardColors(
                        containerColor = when (proposal.status) {
                            ProposalStatus.PENDING -> Color(0xFFFFF3CD)
                            ProposalStatus.ACCEPTED -> Color(0xFFD4EDDA)
                            ProposalStatus.REJECTED -> Color(0xFFF8D7DA)
                        }
                    )
                ) {
                    Text(
                        text = when (proposal.status) {
                            ProposalStatus.PENDING -> "Pendente"
                            ProposalStatus.ACCEPTED -> "Aceita"
                            ProposalStatus.REJECTED -> "Rejeitada"
                        },
                        color = when (proposal.status) {
                            ProposalStatus.PENDING -> Color(0xFF856404)
                            ProposalStatus.ACCEPTED -> Color(0xFF155724)
                            ProposalStatus.REJECTED -> Color(0xFF721C24)
                        },
                        fontSize = 10.sp,
                        fontWeight = FontWeight.Medium,
                        modifier = Modifier.padding(horizontal = 8.dp, vertical = 4.dp)
                    )
                }
            }
            
            Spacer(modifier = Modifier.height(12.dp))
            
            // T√≠tulo do servi√ßo
            Text(
                text = proposal.serviceTitle,
                color = TaskGoTextBlack,
                fontSize = 14.sp,
                fontWeight = FontWeight.Medium
            )
            
            Spacer(modifier = Modifier.height(8.dp))
            
            // Descri√ß√£o
            Text(
                text = proposal.serviceDescription,
                color = TaskGoTextGray,
                fontSize = 12.sp,
                lineHeight = 16.sp
            )
            
            Spacer(modifier = Modifier.height(12.dp))
            
            // Informa√ß√µes adicionais
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Column {
                    Text(
                        text = "Data solicitada: ${proposal.date}",
                        color = TaskGoTextGray,
                        fontSize = 10.sp
                    )
                    Text(
                        text = "Local: ${proposal.location}",
                        color = TaskGoTextGray,
                        fontSize = 10.sp
                    )
                }
                
                Text(
                    text = "R$ ${String.format("%.2f", proposal.budget)}",
                    color = TaskGoGreen,
                    fontSize = 16.sp,
                    fontWeight = FontWeight.Bold
                )
            }
            
            if (proposal.status == ProposalStatus.PENDING) {
                Spacer(modifier = Modifier.height(16.dp))
                
                // Bot√µes de a√ß√£o
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    OutlinedButton(
                        onClick = onRejectProposal,
                        modifier = Modifier.weight(1f),
                        shape = RoundedCornerShape(8.dp),
                        colors = ButtonDefaults.outlinedButtonColors(
                            contentColor = Color(0xFFDC3545)
                        )
                    ) {
                        Text(
                            text = "Rejeitar",
                            fontSize = 14.sp,
                            fontWeight = FontWeight.Medium
                        )
                    }
                    
                    Button(
                        onClick = onAcceptProposal,
                        modifier = Modifier.weight(1f),
                        shape = RoundedCornerShape(8.dp),
                        colors = ButtonDefaults.buttonColors(
                            containerColor = TaskGoGreen
                        )
                    ) {
                        Text(
                            text = "Aceitar",
                            color = Color.White,
                            fontSize = 14.sp,
                            fontWeight = FontWeight.Medium
                        )
                    }
                }
            }
        }
    }
}

```

## [FRONTEND]: feature/services/presentation/ProposalsViewModel.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.services.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.taskgoapp.taskgo.core.model.Proposal
import com.taskgoapp.taskgo.core.model.ServiceOrder
import com.taskgoapp.taskgo.domain.repository.ServiceRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch
import javax.inject.Inject

data class ProposalsUiState(
    val isLoading: Boolean = false,
    val error: String? = null,
    val proposals: List<Proposal> = emptyList(),
    val orderId: String? = null
)

@HiltViewModel
class ProposalsViewModel @Inject constructor(
    private val serviceRepository: ServiceRepository
) : ViewModel() {

    private val _uiState = MutableStateFlow(ProposalsUiState())
    val uiState: StateFlow<ProposalsUiState> = _uiState.asStateFlow()

    fun getProposalsForOrder(orderId: String): StateFlow<List<Proposal>> {
        return serviceRepository
            .observeProposals(orderId)
            .stateIn(
                viewModelScope,
                SharingStarted.WhileSubscribed(5_000),
                emptyList()
            )
    }

    fun loadProposals(orderId: String) {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(
                isLoading = true,
                error = null,
                orderId = orderId
            )
            try {
                // Os dados v√™m automaticamente via Flow do reposit√≥rio
                _uiState.value = _uiState.value.copy(isLoading = false)
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = e.message ?: "Erro ao carregar propostas"
                )
            }
        }
    }

    fun acceptProposal(proposalId: String) {
        viewModelScope.launch {
            try {
                serviceRepository.acceptProposal(proposalId)
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    error = e.message ?: "Erro ao aceitar proposta"
                )
            }
        }
    }
    
    fun rejectProposal(proposalId: String) {
        viewModelScope.launch {
            try {
                serviceRepository.rejectProposal(proposalId)
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    error = e.message ?: "Erro ao rejeitar proposta"
                )
            }
        }
    }

    fun refresh(orderId: String) {
        loadProposals(orderId)
    }

    fun clearError() {
        _uiState.value = _uiState.value.copy(error = null)
    }
}


```

## [FRONTEND]: feature/services/presentation/RateProviderScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.services.presentation

import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Star
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.taskgoapp.taskgo.core.design.TGIcons
import com.taskgoapp.taskgo.core.theme.TaskGoGreen
import com.taskgoapp.taskgo.core.theme.TaskGoTextBlack
import com.taskgoapp.taskgo.core.theme.TaskGoTextGray
import com.taskgoapp.taskgo.core.theme.TaskGoBackgroundWhite

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun RateProviderScreen(
    providerName: String,
    serviceTitle: String,
    onBackClick: () -> Unit,
    onRatingSubmitted: (Int, String) -> Unit
) {
    var rating by remember { mutableStateOf(0) }
    var comment by remember { mutableStateOf("") }
    var isSubmitting by remember { mutableStateOf(false) }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .background(TaskGoBackgroundWhite)
    ) {
        // Top Bar
        TopAppBar(
            title = {
                Text(
                    text = "Avaliar Prestador",
                    color = TaskGoTextBlack,
                    fontSize = 18.sp,
                    fontWeight = FontWeight.Bold
                )
            },
            navigationIcon = {
                IconButton(onClick = onBackClick) {
                    Icon(
                        imageVector = Icons.Filled.ArrowBack,
                        contentDescription = "Voltar",
                        tint = TaskGoTextBlack
                    )
                }
            },
            colors = TopAppBarDefaults.topAppBarColors(
                containerColor = TaskGoBackgroundWhite
            )
        )

        Column(
            modifier = Modifier
                .fillMaxSize()
                .verticalScroll(rememberScrollState())
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(24.dp)
        ) {
            // Card do prestador
            Card(
                modifier = Modifier.fillMaxWidth(),
                shape = RoundedCornerShape(12.dp),
                colors = CardDefaults.cardColors(
                    containerColor = Color.White
                ),
                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
            ) {
                Column(
                    modifier = Modifier.padding(20.dp),
                    horizontalAlignment = Alignment.CenterHorizontally
                ) {
                    // Avatar
                    Box(
                        modifier = Modifier
                            .size(80.dp)
                            .background(
                                color = TaskGoGreen.copy(alpha = 0.1f),
                                shape = CircleShape
                            ),
                        contentAlignment = Alignment.Center
                    ) {
                        Text(
                            text = providerName.split(" ").map { it.first() }.joinToString(""),
                            color = TaskGoGreen,
                            fontSize = 24.sp,
                            fontWeight = FontWeight.Bold
                        )
                    }
                    
                    Spacer(modifier = Modifier.height(16.dp))
                    
                    Text(
                        text = providerName,
                        color = TaskGoTextBlack,
                        fontSize = 18.sp,
                        fontWeight = FontWeight.Bold
                    )
                    
                    Spacer(modifier = Modifier.height(8.dp))
                    
                    Text(
                        text = serviceTitle,
                        color = TaskGoTextGray,
                        fontSize = 14.sp,
                        textAlign = TextAlign.Center
                    )
                }
            }
            
            // Avalia√ß√£o com estrelas
            Card(
                modifier = Modifier.fillMaxWidth(),
                shape = RoundedCornerShape(12.dp),
                colors = CardDefaults.cardColors(
                    containerColor = Color.White
                ),
                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
            ) {
                Column(
                    modifier = Modifier.padding(20.dp),
                    horizontalAlignment = Alignment.CenterHorizontally
                ) {
                    Text(
                        text = "Como foi o servi√ßo?",
                        color = TaskGoTextBlack,
                        fontSize = 16.sp,
                        fontWeight = FontWeight.Bold
                    )
                    
                    Spacer(modifier = Modifier.height(16.dp))
                    
                    // Estrelas
                    Row(
                        horizontalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        repeat(5) { index ->
                            IconButton(
                                onClick = { rating = index + 1 }
                            ) {
                                Icon(
                                    imageVector = Icons.Filled.Star,
                                    contentDescription = "Estrela ${index + 1}",
                                    tint = if (index < rating) Color(0xFFFFD700) else Color(0xFFE0E0E0),
                                    modifier = Modifier.size(40.dp)
                                )
                            }
                        }
                    }
                    
                    Spacer(modifier = Modifier.height(8.dp))
                    
                    Text(
                        text = when (rating) {
                            0 -> "Toque nas estrelas para avaliar"
                            1 -> "P√©ssimo"
                            2 -> "Ruim"
                            3 -> "Regular"
                            4 -> "Bom"
                            5 -> "Excelente"
                            else -> ""
                        },
                        color = if (rating == 0) TaskGoTextGray else TaskGoTextBlack,
                        fontSize = 14.sp,
                        textAlign = TextAlign.Center
                    )
                }
            }
            
            // Coment√°rio
            Card(
                modifier = Modifier.fillMaxWidth(),
                shape = RoundedCornerShape(12.dp),
                colors = CardDefaults.cardColors(
                    containerColor = Color.White
                ),
                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
            ) {
                Column(
                    modifier = Modifier.padding(20.dp)
                ) {
                    Text(
                        text = "Coment√°rio (opcional)",
                        color = TaskGoTextBlack,
                        fontSize = 16.sp,
                        fontWeight = FontWeight.Bold
                    )
                    
                    Spacer(modifier = Modifier.height(12.dp))
                    
                    OutlinedTextField(
                        value = comment,
                        onValueChange = { comment = it },
                        placeholder = { 
                            Text(
                                "Conte como foi sua experi√™ncia com o prestador...",
                                color = TaskGoTextGray
                            ) 
                        },
                        modifier = Modifier
                            .fillMaxWidth()
                            .height(120.dp),
                        shape = RoundedCornerShape(8.dp),
                        colors = OutlinedTextFieldDefaults.colors(
                            focusedBorderColor = TaskGoGreen,
                            unfocusedBorderColor = Color(0xFFD9D9D9),
                            cursorColor = TaskGoGreen
                        ),
                        maxLines = 4
                    )
                }
            }
            
            // Bot√£o de envio
            Button(
                onClick = { 
                    isSubmitting = true
                    onRatingSubmitted(rating, comment)
                },
                modifier = Modifier
                    .fillMaxWidth()
                    .height(56.dp),
                shape = RoundedCornerShape(8.dp),
                colors = ButtonDefaults.buttonColors(
                    containerColor = TaskGoGreen
                ),
                enabled = !isSubmitting && rating > 0
            ) {
                if (isSubmitting) {
                    CircularProgressIndicator(
                        color = Color.White,
                        modifier = Modifier.size(20.dp)
                    )
                } else {
                    Text(
                        text = "Enviar Avalia√ß√£o",
                        color = Color.White,
                        fontSize = 16.sp,
                        fontWeight = FontWeight.Bold
                    )
                }
            }
        }
    }
}

```

## [FRONTEND]: feature/services/presentation/ReviewsScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.services.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.R
import com.taskgoapp.taskgo.core.design.*
import com.taskgoapp.taskgo.core.data.models.Review
import com.taskgoapp.taskgo.core.data.models.Provider
import com.taskgoapp.taskgo.core.theme.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ReviewsScreen(
    onBackClick: () -> Unit,
    onProposalAccepted: (Long) -> Unit
) {
    val reviews = remember { 
        listOf(
            Review(
                id = 1L,
                provider = Provider(
                    id = 1L,
                    name = "Carlos Amaral",
                    profession = "Montador de M√≥veis",
                    rating = 4.9,
                    reviewCount = 250,
                    serviceCount = "100+ servi√ßos",
                    city = "S√£o Paulo"
                ),
                rating = 5.0,
                comment = "Excelente trabalho, muito profissional e r√°pido!",
                reviewer = com.taskgoapp.taskgo.core.data.models.User(
                    id = 1L,
                    name = "Jo√£o Silva",
                    email = "joao@email.com",
                    phone = "11999999999",
                    accountType = com.taskgoapp.taskgo.core.data.models.AccountType.CLIENT,
                    timeOnTaskGo = "2 anos",
                    rating = 4.8,
                    reviewCount = 156,
                    city = "S√£o Paulo"
                ),
                date = java.time.LocalDateTime.now().minusDays(5)
            ),
            Review(
                id = 2L,
                provider = Provider(
                    id = 2L,
                    name = "Ana Paula",
                    profession = "Arquiteta",
                    rating = 4.7,
                    reviewCount = 180,
                    serviceCount = "80+ servi√ßos",
                    city = "Rio de Janeiro"
                ),
                rating = 4.0,
                comment = "Bom trabalho, mas demorou um pouco mais que o esperado.",
                reviewer = com.taskgoapp.taskgo.core.data.models.User(
                    id = 2L,
                    name = "Maria Santos",
                    email = "maria@email.com",
                    phone = "11888888888",
                    accountType = com.taskgoapp.taskgo.core.data.models.AccountType.CLIENT,
                    timeOnTaskGo = "1 ano",
                    rating = 4.6,
                    reviewCount = 89,
                    city = "Rio de Janeiro"
                ),
                date = java.time.LocalDateTime.now().minusDays(8)
            )
        )
    }
    
    Scaffold(
        topBar = {
            AppTopBar(
                title = stringResource(R.string.reviews_title),
                onBackClick = onBackClick
            )
        }
    ) { paddingValues ->
        LazyColumn(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            item {
                Text(
                    text = stringResource(R.string.reviews_subtitle),
                    style = FigmaProductDescription,
                    color = TaskGoTextGray
                )
            }
            
            if (reviews.isEmpty()) {
                item {
                    Box(
                        modifier = Modifier.fillMaxWidth(),
                        contentAlignment = Alignment.Center
                    ) {
                        Column(
                            horizontalAlignment = Alignment.CenterHorizontally
                        ) {
                            Text(
                                text = stringResource(R.string.reviews_empty),
                                style = FigmaProductName,
                                color = TaskGoTextBlack,
                                fontWeight = FontWeight.Medium
                            )
                            Text(
                                text = stringResource(R.string.reviews_empty_message),
                                style = FigmaProductDescription,
                                color = TaskGoTextGray
                            )
                        }
                    }
                }
            } else {
                items(reviews.size) { index ->
                    val review = reviews[index]
                    Card(
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Column(
                            modifier = Modifier.padding(16.dp)
                        ) {
                            Row(
                                modifier = Modifier.fillMaxWidth(),
                                horizontalArrangement = Arrangement.SpaceBetween,
                                verticalAlignment = Alignment.CenterVertically
                            ) {
                                Text(
                                    text = review.provider.name,
                                    style = FigmaProductName,
                                    color = TaskGoTextBlack,
                                    fontWeight = FontWeight.Medium
                                )
                                RatingBar(
                                    rating = review.rating.toFloat(),
                                    showCount = false
                                )
                            }
                            Text(
                                text = review.provider.profession,
                                style = FigmaProductDescription,
                                color = TaskGoTextGray
                            )
                            Spacer(modifier = Modifier.height(8.dp))
                            Text(
                                text = review.comment,
                                style = FigmaProductDescription,
                                color = TaskGoTextBlack
                            )
                        }
                    }
                }
            }
        }
    }
}



```

## [FRONTEND]: feature/services/presentation/ServiceDetailViewModel.kt

```kotlin
package com.taskgoapp.taskgo.feature.services.presentation

import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.taskgoapp.taskgo.data.firestore.models.ServiceFirestore
import com.taskgoapp.taskgo.data.firestore.models.UserFirestore
import com.taskgoapp.taskgo.data.repository.FirestoreServicesRepository
import com.taskgoapp.taskgo.data.repository.FirestoreUserRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

data class ServiceDetailUiState(
    val isLoading: Boolean = true,
    val service: ServiceFirestore? = null,
    val provider: UserFirestore? = null,
    val error: String? = null
)

@HiltViewModel
class ServiceDetailViewModel @Inject constructor(
    private val servicesRepository: FirestoreServicesRepository,
    private val userRepository: FirestoreUserRepository,
    private val messageRepository: com.taskgoapp.taskgo.data.repository.MessageRepositoryImpl
) : ViewModel() {

    private val _uiState = MutableStateFlow(ServiceDetailUiState())
    val uiState: StateFlow<ServiceDetailUiState> = _uiState.asStateFlow()

    fun loadService(serviceId: String) {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoading = true, error = null)
            try {
                val service = servicesRepository.getService(serviceId)
                if (service != null) {
                    Log.d("ServiceDetailViewModel", "Servi√ßo carregado: ${service.title}")
                    
                    // Buscar informa√ß√µes do prestador
                    var provider: UserFirestore? = null
                    if (service.providerId != null && service.providerId.isNotBlank()) {
                        try {
                            provider = userRepository.getUser(service.providerId)
                            Log.d("ServiceDetailViewModel", "Prestador carregado: ${provider?.displayName}")
                        } catch (e: Exception) {
                            Log.e("ServiceDetailViewModel", "Erro ao carregar prestador", e)
                        }
                    }
                    
                    _uiState.value = _uiState.value.copy(
                        service = service,
                        provider = provider,
                        isLoading = false,
                        error = null
                    )
                } else {
                    Log.e("ServiceDetailViewModel", "Servi√ßo n√£o encontrado: $serviceId")
                    _uiState.value = _uiState.value.copy(
                        error = "Servi√ßo n√£o encontrado",
                        isLoading = false
                    )
                }
            } catch (e: Exception) {
                Log.e("ServiceDetailViewModel", "Erro ao carregar servi√ßo", e)
                _uiState.value = _uiState.value.copy(
                    error = "Erro ao carregar servi√ßo: ${e.message}",
                    isLoading = false
                )
            }
        }
    }
    
    suspend fun getOrCreateThreadForProvider(providerId: String): String {
        val msgRepo = messageRepository as? com.taskgoapp.taskgo.data.repository.MessageRepositoryImpl
            ?: throw IllegalStateException("MessageRepository n√£o √© MessageRepositoryImpl")
        
        return msgRepo.getOrCreateThreadForProvider(providerId, userRepository)
    }
}


```

## [FRONTEND]: feature/services/presentation/ServiceFormScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.services.presentation

import android.net.Uri
import android.util.Log
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.PickVisualMediaRequest
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Close
import androidx.compose.material.icons.filled.Videocam
import androidx.compose.material3.*
import androidx.compose.material3.MenuAnchorType
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalFocusManager
import androidx.compose.ui.platform.LocalSoftwareKeyboardController
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import coil.compose.AsyncImage
import coil.request.ImageRequest
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.design.ImageEditor
import com.taskgoapp.taskgo.core.design.EnhancedOutlinedTextField
import com.taskgoapp.taskgo.core.theme.*
import com.taskgoapp.taskgo.core.data.models.ServiceCategory
import com.taskgoapp.taskgo.core.model.AccountType
import com.google.firebase.auth.FirebaseAuth

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ServiceFormScreen(
    serviceId: String?,
    onBack: () -> Unit,
    onSaved: () -> Unit,
    viewModel: ServiceFormViewModel = hiltViewModel(),
) {
    val uiState by viewModel.uiState.collectAsState()
    val context = LocalContext.current
    val scrollState = rememberScrollState()

    // Carregar servi√ßo se estiver editando ou carregar categorias preferidas se for novo
    LaunchedEffect(serviceId) {
        if (serviceId != null) {
            viewModel.loadService(serviceId)
        } else {
            viewModel.loadUserPreferredCategories()
        }
    }

    // Navegar quando salvo
    LaunchedEffect(uiState.isSaved) {
        if (uiState.isSaved) {
            onSaved()
        }
    }

    // Categorias padr√£o
    val categories = remember {
        listOf(
            ServiceCategory(1, "Montagem", "build", "Servi√ßos de montagem"),
            ServiceCategory(2, "Reforma", "home", "Reformas e constru√ß√µes"),
            ServiceCategory(3, "Jardinagem", "eco", "Jardinagem"),
            ServiceCategory(4, "El√©trica", "flash_on", "Servi√ßos el√©tricos"),
            ServiceCategory(5, "Encanamento", "plumbing", "Encanamento"),
            ServiceCategory(6, "Pintura", "format_paint", "Pintura"),
            ServiceCategory(7, "Limpeza", "cleaning_services", "Limpeza"),
            ServiceCategory(8, "Outros", "more_horiz", "Outros")
        )
    }

    Scaffold(
        topBar = {
            AppTopBar(
                title = if (serviceId == null) "Novo Servi√ßo" else "Editar Servi√ßo",
                onBackClick = onBack,
                backgroundColor = TaskGoGreen,
                titleColor = TaskGoBackgroundWhite,
                backIconColor = TaskGoBackgroundWhite
            )
        }
    ) { paddingValues ->
        val focusManager = androidx.compose.ui.platform.LocalFocusManager.current
        val keyboardController = androidx.compose.ui.platform.LocalSoftwareKeyboardController.current
        
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .verticalScroll(scrollState)
                .padding(16.dp)
                .clickable(
                    indication = null,
                    interactionSource = remember { androidx.compose.foundation.interaction.MutableInteractionSource() }
                ) {
                    focusManager.clearFocus()
                    keyboardController?.hide()
                },
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // T√≠tulo
            EnhancedOutlinedTextField(
                value = uiState.title,
                onValueChange = { viewModel.updateTitle(it) },
                label = { Text("T√≠tulo do Servi√ßo *") },
                modifier = Modifier.fillMaxWidth(),
                singleLine = true
            )

            // Descri√ß√£o
            OutlinedTextField(
                value = uiState.description,
                onValueChange = { viewModel.updateDescription(it) },
                label = { Text("Descri√ß√£o *") },
                modifier = Modifier.fillMaxWidth(),
                minLines = 4,
                maxLines = 8,
                colors = OutlinedTextFieldDefaults.colors(
                    focusedBorderColor = TaskGoGreen,
                    unfocusedBorderColor = TaskGoTextGray
                ),
                textStyle = androidx.compose.ui.text.TextStyle(
                    lineHeight = androidx.compose.ui.unit.TextUnit(24f, androidx.compose.ui.unit.TextUnitType.Sp)
                )
            )

            // Categoria principal (para compatibilidade) - APENAS se N√ÉO for prestador
            if (uiState.accountType != AccountType.PRESTADOR) {
                var expanded by remember { mutableStateOf(false) }
                ExposedDropdownMenuBox(
                    expanded = expanded,
                    onExpandedChange = { expanded = !expanded }
                ) {
                    OutlinedTextField(
                        value = uiState.category.ifEmpty { "Selecione uma categoria principal" },
                        onValueChange = {},
                        readOnly = true,
                        label = { Text("Categoria Principal *") },
                        trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = expanded) },
                        modifier = Modifier
                            .fillMaxWidth()
                            .menuAnchor(MenuAnchorType.PrimaryNotEditable),
                        colors = OutlinedTextFieldDefaults.colors(
                            focusedBorderColor = TaskGoGreen,
                            unfocusedBorderColor = TaskGoTextGray
                        )
                    )
                    ExposedDropdownMenu(
                        expanded = expanded,
                        onDismissRequest = { expanded = false }
                    ) {
                        categories.forEach { category ->
                            DropdownMenuItem(
                                text = { Text(category.name) },
                                onClick = {
                                    viewModel.updateCategory(category.name)
                                    expanded = false
                                }
                            )
                        }
                    }
                }
            }
            
            // Categorias que o prestador oferece (checkboxes)
            Card(
                modifier = Modifier.fillMaxWidth(),
                colors = CardDefaults.cardColors(containerColor = TaskGoSurface)
            ) {
                Column(
                    modifier = Modifier.padding(16.dp),
                    verticalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    Text(
                        text = "Categorias que voc√™ oferece",
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold
                    )
                    Text(
                        text = "Selecione todas as categorias de servi√ßos que voc√™ pode realizar",
                        style = MaterialTheme.typography.bodySmall,
                        color = TaskGoTextGray
                    )
                    categories.forEach { category ->
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .clickable { viewModel.toggleCategory(category.name) },
                            verticalAlignment = Alignment.CenterVertically,
                            horizontalArrangement = Arrangement.SpaceBetween
                        ) {
                            Text(
                                text = category.name,
                                style = MaterialTheme.typography.bodyLarge
                            )
                            Checkbox(
                                checked = uiState.selectedCategories.contains(category.name),
                                onCheckedChange = { viewModel.toggleCategory(category.name) }
                            )
                        }
                    }
                }
            }

            // Pre√ßo (n√£o exibir para prestadores)
            if (uiState.accountType != com.taskgoapp.taskgo.core.model.AccountType.PRESTADOR) {
                OutlinedTextField(
                    value = uiState.price,
                    onValueChange = { newValue ->
                        val formatted = com.taskgoapp.taskgo.core.utils.TextFormatters.formatPrice(newValue)
                        viewModel.updatePrice(formatted)
                    },
                    label = { Text("Pre√ßo (R$) *") },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = true,
                    prefix = { Text("R$ ") },
                    colors = OutlinedTextFieldDefaults.colors(
                        focusedBorderColor = TaskGoGreen,
                        unfocusedBorderColor = TaskGoTextGray
                    )
                )
            }

            // Imagens
            Card(
                modifier = Modifier.fillMaxWidth(),
                colors = CardDefaults.cardColors(containerColor = TaskGoSurface)
            ) {
                Column(
                    modifier = Modifier.padding(16.dp),
                    verticalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    Text(
                        text = "Imagens",
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold
                    )
                    ImageEditor(
                        selectedImageUris = uiState.imageUris,
                        onImagesChanged = { viewModel.updateImageUris(it) },
                        maxImages = 10
                    )
                }
            }

            // V√≠deos
            Card(
                modifier = Modifier.fillMaxWidth(),
                colors = CardDefaults.cardColors(containerColor = TaskGoSurface)
            ) {
                Column(
                    modifier = Modifier.padding(16.dp),
                    verticalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    Text(
                        text = "V√≠deos (MP4)",
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold
                    )
                    VideoPicker(
                        selectedVideoUris = uiState.videoUris,
                        onVideosChanged = { viewModel.updateVideoUris(it) },
                        maxVideos = 3
                    )
                }
            }

            // Status Ativo/Inativo
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = "Servi√ßo Ativo",
                    style = MaterialTheme.typography.titleMedium
                )
                Switch(
                    checked = uiState.isActive,
                    onCheckedChange = { viewModel.toggleActive() }
                )
            }

            // Progresso de upload
            if (uiState.isSaving && uiState.uploadProgress > 0f) {
                Column(
                    modifier = Modifier.fillMaxWidth(),
                    verticalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    Text(
                        text = "Enviando m√≠dia... ${(uiState.uploadProgress * 100).toInt()}%",
                        style = MaterialTheme.typography.bodySmall,
                        color = TaskGoTextGray
                    )
                    LinearProgressIndicator(
                        progress = { uiState.uploadProgress },
                        modifier = Modifier.fillMaxWidth(),
                        color = TaskGoGreen
                    )
                }
            }

            // Erro
            uiState.error?.let { error ->
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    colors = CardDefaults.cardColors(containerColor = TaskGoError.copy(alpha = 0.1f))
                ) {
                    Text(
                        text = error,
                        modifier = Modifier.padding(16.dp),
                        color = TaskGoError
                    )
                }
            }

            // Bot√£o Salvar
            Button(
                onClick = { viewModel.saveService(onSaved) },
                enabled = viewModel.canSave() && !uiState.isSaving,
                modifier = Modifier
                    .fillMaxWidth()
                    .height(56.dp),
                colors = ButtonDefaults.buttonColors(containerColor = TaskGoGreen)
            ) {
                if (uiState.isSaving) {
                    CircularProgressIndicator(
                        modifier = Modifier.size(20.dp),
                        color = Color.White
                    )
                    Spacer(modifier = Modifier.width(8.dp))
                }
                Text(
                    text = if (serviceId == null) "Criar Servi√ßo" else "Salvar Altera√ß√µes",
                    fontWeight = FontWeight.Bold
                )
            }
        }
    }
}

@Composable
private fun VideoPicker(
    selectedVideoUris: List<Uri>,
    onVideosChanged: (List<Uri>) -> Unit,
    maxVideos: Int = 3
) {
    val context = LocalContext.current
    var pendingAction by remember { mutableStateOf(false) }
    
    val videoLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.GetContent()
    ) { uri: Uri? ->
        uri?.let {
            val newVideos = selectedVideoUris + it
            onVideosChanged(newVideos.take(maxVideos))
        }
    }

    LazyRow(
        horizontalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        items(selectedVideoUris) { videoUri ->
            Box(
                modifier = Modifier
                    .size(120.dp)
                    .clip(RoundedCornerShape(8.dp))
                    .background(TaskGoBackgroundGray)
                    .border(2.dp, TaskGoTextGray.copy(alpha = 0.3f), RoundedCornerShape(8.dp))
            ) {
                Column(
                    modifier = Modifier.fillMaxSize(),
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.Center
                ) {
                    Icon(
                        imageVector = Icons.Default.Videocam,
                        contentDescription = "V√≠deo",
                        modifier = Modifier.size(48.dp),
                        tint = TaskGoTextGray
                    )
                    Text(
                        text = "V√≠deo MP4",
                        style = MaterialTheme.typography.bodySmall,
                        color = TaskGoTextGray
                    )
                }
                
                IconButton(
                    onClick = { onVideosChanged(selectedVideoUris - videoUri) },
                    modifier = Modifier
                        .align(Alignment.TopEnd)
                        .size(24.dp)
                ) {
                    Icon(
                        imageVector = Icons.Default.Close,
                        contentDescription = "Remover",
                        tint = TaskGoError,
                        modifier = Modifier.size(16.dp)
                    )
                }
            }
        }
        
        if (selectedVideoUris.size < maxVideos) {
            item {
                Box(
                    modifier = Modifier
                        .size(120.dp)
                        .clip(RoundedCornerShape(8.dp))
                        .background(TaskGoSurface)
                        .border(2.dp, TaskGoGreen.copy(alpha = 0.5f), RoundedCornerShape(8.dp))
                        .clickable { videoLauncher.launch("video/*") },
                    contentAlignment = Alignment.Center
                ) {
                    Column(
                        horizontalAlignment = Alignment.CenterHorizontally,
                        verticalArrangement = Arrangement.spacedBy(4.dp)
                    ) {
                        Icon(
                            imageVector = Icons.Default.Add,
                            contentDescription = "Adicionar v√≠deo",
                            modifier = Modifier.size(32.dp),
                            tint = TaskGoGreen
                        )
                        Text(
                            text = "Adicionar\nV√≠deo",
                            style = MaterialTheme.typography.bodySmall,
                            color = TaskGoGreen
                        )
                    }
                }
            }
        }
    }
}


```

## [FRONTEND]: feature/services/presentation/ServiceFormViewModel.kt

```kotlin
package com.taskgoapp.taskgo.feature.services.presentation

import android.net.Uri
import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.google.firebase.auth.FirebaseAuth
import com.taskgoapp.taskgo.data.firestore.models.ServiceFirestore
import com.taskgoapp.taskgo.data.repository.FirebaseStorageRepository
import com.taskgoapp.taskgo.data.repository.FirestoreServicesRepository
import com.taskgoapp.taskgo.data.repository.FirestoreUserRepository
import com.taskgoapp.taskgo.domain.usecase.SettingsUseCase
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import java.util.Date
import javax.inject.Inject

data class ServiceFormState(
    val serviceId: String? = null,
    val title: String = "",
    val description: String = "",
    val category: String = "",
    val selectedCategories: Set<String> = emptySet(), // Categorias que o prestador oferece
    val price: String = "",
    val tags: List<String> = emptyList(),
    val imageUris: List<Uri> = emptyList(),
    val videoUris: List<Uri> = emptyList(),
    val uploadedImageUrls: List<String> = emptyList(),
    val uploadedVideoUrls: List<String> = emptyList(),
    val isActive: Boolean = true,
    val isLoading: Boolean = false,
    val isSaving: Boolean = false,
    val uploadProgress: Float = 0f,
    val error: String? = null,
    val isSaved: Boolean = false,
    val accountType: com.taskgoapp.taskgo.core.model.AccountType? = null
)

@HiltViewModel
class ServiceFormViewModel @Inject constructor(
    private val servicesRepository: FirestoreServicesRepository,
    private val storageRepository: FirebaseStorageRepository,
    private val firebaseAuth: FirebaseAuth,
    private val locationManager: com.taskgoapp.taskgo.core.location.LocationManager,
    private val firestoreUserRepository: FirestoreUserRepository,
    private val settingsUseCase: SettingsUseCase
) : ViewModel() {

    private val _uiState = MutableStateFlow(ServiceFormState())
    val uiState: StateFlow<ServiceFormState> = _uiState.asStateFlow()

    fun loadService(serviceId: String) {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoading = true, error = null)
            try {
                val service = servicesRepository.getService(serviceId)
                val currentUser = firebaseAuth.currentUser
                
                // Verificar se o servi√ßo pertence ao usu√°rio atual
                if (service != null && currentUser != null && service.providerId != currentUser.uid) {
                    _uiState.value = _uiState.value.copy(
                        error = "Voc√™ n√£o tem permiss√£o para editar este servi√ßo",
                        isLoading = false
                    )
                    return@launch
                }
                
                var preferredCategories = emptySet<String>()
                
                // Carregar categorias preferidas do usu√°rio
                if (currentUser != null) {
                    try {
                        val user = firestoreUserRepository.getUser(currentUser.uid)
                        preferredCategories = user?.preferredCategories?.toSet() ?: emptySet()
                    } catch (e: Exception) {
                        Log.w("ServiceFormViewModel", "Erro ao carregar categorias preferidas: ${e.message}")
                    }
                }
                
                if (service != null) {
                    _uiState.value = _uiState.value.copy(
                        serviceId = service.id,
                        title = service.title,
                        description = service.description,
                        category = service.category,
                        selectedCategories = preferredCategories,
                        price = service.price.toString(),
                        tags = service.tags,
                        uploadedImageUrls = service.images,
                        uploadedVideoUrls = service.videos,
                        isActive = service.active,
                        isLoading = false
                    )
                    Log.d("ServiceFormViewModel", "Servi√ßo carregado: ${service.title}, categorias: $preferredCategories")
                } else {
                    _uiState.value = _uiState.value.copy(
                        selectedCategories = preferredCategories,
                        error = "Servi√ßo n√£o encontrado",
                        isLoading = false
                    )
                }
            } catch (e: Exception) {
                Log.e("ServiceFormViewModel", "Erro ao carregar servi√ßo", e)
                _uiState.value = _uiState.value.copy(
                    error = "Erro ao carregar servi√ßo: ${e.message}",
                    isLoading = false
                )
            }
        }
    }
    
    fun loadUserPreferredCategories() {
        viewModelScope.launch {
            val currentUser = firebaseAuth.currentUser ?: return@launch
            try {
                val user = firestoreUserRepository.getUser(currentUser.uid)
                val preferredCategories = user?.preferredCategories?.toSet() ?: emptySet()
                
                // Converter role (String) para AccountType (enum)
                val accountType = when (user?.role) {
                    "provider" -> com.taskgoapp.taskgo.core.model.AccountType.PRESTADOR
                    "seller" -> com.taskgoapp.taskgo.core.model.AccountType.VENDEDOR
                    "client" -> com.taskgoapp.taskgo.core.model.AccountType.CLIENTE
                    else -> com.taskgoapp.taskgo.core.model.AccountType.CLIENTE
                }
                
                _uiState.value = _uiState.value.copy(
                    selectedCategories = preferredCategories,
                    accountType = accountType
                )
                Log.d("ServiceFormViewModel", "Categorias preferidas carregadas: $preferredCategories, AccountType: $accountType")
            } catch (e: Exception) {
                Log.w("ServiceFormViewModel", "Erro ao carregar categorias preferidas: ${e.message}")
            }
        }
    }

    fun updateTitle(title: String) {
        _uiState.value = _uiState.value.copy(title = title)
    }

    fun updateDescription(description: String) {
        _uiState.value = _uiState.value.copy(description = description)
    }

    fun updateCategory(category: String) {
        _uiState.value = _uiState.value.copy(category = category)
    }
    
    fun toggleCategory(category: String) {
        val current = _uiState.value.selectedCategories
        val updated = if (current.contains(category)) {
            current - category
        } else {
            current + category
        }
        _uiState.value = _uiState.value.copy(selectedCategories = updated)
    }

    fun updatePrice(price: String) {
        _uiState.value = _uiState.value.copy(price = price)
    }

    fun updateImageUris(uris: List<Uri>) {
        _uiState.value = _uiState.value.copy(imageUris = uris)
    }

    fun updateVideoUris(uris: List<Uri>) {
        _uiState.value = _uiState.value.copy(videoUris = uris)
    }

    fun toggleActive() {
        _uiState.value = _uiState.value.copy(isActive = !_uiState.value.isActive)
    }

    fun canSave(): Boolean {
        val state = _uiState.value
        val basicFieldsValid = state.title.isNotBlank() &&
                state.description.isNotBlank() &&
                state.category.isNotBlank()
        
        // Pre√ßo s√≥ √© obrigat√≥rio se N√ÉO for prestador
        val priceValid = if (state.accountType == com.taskgoapp.taskgo.core.model.AccountType.PRESTADOR) {
            true // Prestadores n√£o precisam de pre√ßo
        } else {
            state.price.isNotBlank() &&
            state.price.toDoubleOrNull() != null &&
            state.price.toDouble() > 0
        }
        
        return basicFieldsValid && priceValid
    }

    fun saveService(onSuccess: () -> Unit) {
        val currentUser = firebaseAuth.currentUser
        if (currentUser == null) {
            _uiState.value = _uiState.value.copy(error = "Usu√°rio n√£o autenticado")
            return
        }

        if (!canSave()) {
            _uiState.value = _uiState.value.copy(error = "Preencha todos os campos obrigat√≥rios")
            return
        }

        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isSaving = true, error = null, uploadProgress = 0f)

            try {
                val providerId = currentUser.uid
                val serviceId = _uiState.value.serviceId ?: "temp_${System.currentTimeMillis()}"
                
                // Upload de imagens
                val imageUrls = mutableListOf<String>()
                val totalUploads = _uiState.value.imageUris.size + _uiState.value.videoUris.size
                var completedUploads = 0

                _uiState.value.imageUris.forEachIndexed { index, uri ->
                    val result = storageRepository.uploadServiceImage(
                        providerId = providerId,
                        serviceId = serviceId,
                        uri = uri,
                        imageIndex = index
                    )
                    result.fold(
                        onSuccess = { url ->
                            imageUrls.add(url)
                            completedUploads++
                            _uiState.value = _uiState.value.copy(
                                uploadProgress = completedUploads.toFloat() / totalUploads.coerceAtLeast(1)
                            )
                        },
                        onFailure = { e ->
                            Log.e("ServiceFormViewModel", "Erro ao fazer upload de imagem", e)
                            throw e
                        }
                    )
                }

                // Upload de v√≠deos
                val videoUrls = mutableListOf<String>()
                _uiState.value.videoUris.forEachIndexed { index, uri ->
                    val result = storageRepository.uploadServiceVideo(
                        providerId = providerId,
                        serviceId = serviceId,
                        uri = uri,
                        videoIndex = index
                    )
                    result.fold(
                        onSuccess = { url ->
                            videoUrls.add(url)
                            completedUploads++
                            _uiState.value = _uiState.value.copy(
                                uploadProgress = completedUploads.toFloat() / totalUploads.coerceAtLeast(1)
                            )
                        },
                        onFailure = { e ->
                            Log.e("ServiceFormViewModel", "Erro ao fazer upload de v√≠deo", e)
                            throw e
                        }
                    )
                }

                // Combinar URLs novas com as j√° existentes
                val allImageUrls = _uiState.value.uploadedImageUrls + imageUrls
                val allVideoUrls = _uiState.value.uploadedVideoUrls + videoUrls

                // Capturar localiza√ß√£o do usu√°rio para filtrar por regi√£o
                var latitude: Double? = null
                var longitude: Double? = null
                try {
                    val location = locationManager.getCurrentLocation()
                    location?.let {
                        latitude = it.latitude
                        longitude = it.longitude
                        Log.d("ServiceFormViewModel", "Localiza√ß√£o capturada: ($latitude, $longitude)")
                    } ?: Log.w("ServiceFormViewModel", "Localiza√ß√£o n√£o dispon√≠vel")
                } catch (e: Exception) {
                    Log.w("ServiceFormViewModel", "Erro ao capturar localiza√ß√£o: ${e.message}")
                }

                // Criar ou atualizar servi√ßo
                // Prestadores n√£o t√™m pre√ßo, ent√£o usar 0.0
                val priceValue = if (_uiState.value.accountType == com.taskgoapp.taskgo.core.model.AccountType.PRESTADOR) {
                    0.0
                } else {
                    try {
                        val unformatted = com.taskgoapp.taskgo.core.utils.TextFormatters.unformatPrice(_uiState.value.price)
                        if (unformatted.isNotEmpty()) {
                            unformatted.replace(",", ".").toDoubleOrNull() ?: 0.0
                        } else {
                            0.0
                        }
                    } catch (e: Exception) {
                        android.util.Log.e("ServiceFormViewModel", "Erro ao converter pre√ßo: ${e.message}", e)
                        0.0
                    }
                }
                
                val service = ServiceFirestore(
                    id = serviceId,
                    providerId = providerId,
                    title = _uiState.value.title.trim(),
                    description = _uiState.value.description.trim(),
                    category = _uiState.value.category,
                    price = priceValue,
                    images = allImageUrls,
                    videos = allVideoUrls,
                    tags = _uiState.value.tags,
                    active = _uiState.value.isActive,
                    createdAt = if (_uiState.value.serviceId == null) Date() else null,
                    updatedAt = Date(),
                    latitude = latitude,
                    longitude = longitude
                )

                // Atualizar preferredCategories do usu√°rio se houver categorias selecionadas
                if (_uiState.value.selectedCategories.isNotEmpty()) {
                    try {
                        val categoriesList = _uiState.value.selectedCategories.toList()
                        val categoriesJson = com.google.gson.Gson().toJson(categoriesList)
                        settingsUseCase.updateCategories(categoriesJson)
                        Log.d("ServiceFormViewModel", "Categorias preferidas atualizadas: $categoriesList")
                    } catch (e: Exception) {
                        Log.w("ServiceFormViewModel", "Erro ao atualizar categorias preferidas: ${e.message}")
                        // N√£o falhar o salvamento do servi√ßo se a atualiza√ß√£o de categorias falhar
                    }
                }
                
                if (_uiState.value.serviceId == null) {
                    // Criar novo servi√ßo
                    val result = servicesRepository.createService(service)
                    result.fold(
                        onSuccess = { newServiceId ->
                            Log.d("ServiceFormViewModel", "Servi√ßo criado com sucesso: $newServiceId")
                            _uiState.value = _uiState.value.copy(
                                isSaving = false,
                                isSaved = true,
                                serviceId = newServiceId,
                                uploadProgress = 1f
                            )
                            onSuccess()
                        },
                        onFailure = { e ->
                            Log.e("ServiceFormViewModel", "Erro ao criar servi√ßo", e)
                            _uiState.value = _uiState.value.copy(
                                isSaving = false,
                                error = "Erro ao criar servi√ßo: ${e.message}"
                            )
                        }
                    )
                } else {
                    // Atualizar servi√ßo existente
                    val result = servicesRepository.updateService(serviceId, service)
                    result.fold(
                        onSuccess = {
                            Log.d("ServiceFormViewModel", "Servi√ßo atualizado com sucesso: $serviceId")
                            _uiState.value = _uiState.value.copy(
                                isSaving = false,
                                isSaved = true,
                                uploadProgress = 1f
                            )
                            onSuccess()
                        },
                        onFailure = { e ->
                            Log.e("ServiceFormViewModel", "Erro ao atualizar servi√ßo", e)
                            _uiState.value = _uiState.value.copy(
                                isSaving = false,
                                error = "Erro ao atualizar servi√ßo: ${e.message}"
                            )
                        }
                    )
                }
            } catch (e: Exception) {
                Log.e("ServiceFormViewModel", "Erro ao salvar servi√ßo", e)
                _uiState.value = _uiState.value.copy(
                    isSaving = false,
                    error = "Erro ao salvar servi√ßo: ${e.message}"
                )
            }
        }
    }
}


```

## [FRONTEND]: feature/services/presentation/ServiceHistoryScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.services.presentation

import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Star
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.taskgoapp.taskgo.core.design.TGIcons
import com.taskgoapp.taskgo.core.theme.TaskGoGreen
import com.taskgoapp.taskgo.core.theme.TaskGoTextBlack
import com.taskgoapp.taskgo.core.theme.TaskGoTextGray
import com.taskgoapp.taskgo.core.theme.TaskGoBackgroundWhite

data class ServiceHistoryItem(
    val id: String,
    val serviceTitle: String,
    val providerName: String,
    val clientLocation: String,
    val serviceDate: String,
    val status: ServiceStatus,
    val rating: Double? = null
)

enum class ServiceStatus {
    COMPLETED, IN_PROGRESS, CANCELLED, PENDING
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ServiceHistoryScreen(
    onBackClick: () -> Unit,
    onServiceClick: (String) -> Unit,
    onRateService: (String) -> Unit
) {
    // Lista vazia - dados v√™m do Firestore
    val serviceHistory = remember { emptyList<ServiceHistoryItem>() }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .background(TaskGoBackgroundWhite)
    ) {
        // Top Bar
        TopAppBar(
            title = {
                Text(
                    text = "Hist√≥rico de Servi√ßos",
                    color = TaskGoTextBlack,
                    fontSize = 18.sp,
                    fontWeight = FontWeight.Bold
                )
            },
            navigationIcon = {
                IconButton(onClick = onBackClick) {
                    Icon(
                        imageVector = Icons.Filled.ArrowBack,
                        contentDescription = "Voltar",
                        tint = TaskGoTextBlack
                    )
                }
            },
            colors = TopAppBarDefaults.topAppBarColors(
                containerColor = TaskGoBackgroundWhite
            )
        )

        // Lista de servi√ßos
        if (serviceHistory.isEmpty()) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(16.dp),
                contentAlignment = Alignment.Center
            ) {
                Column(
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    Text(
                        text = "Nenhum hist√≥rico de servi√ßos",
                        color = TaskGoTextGray,
                        fontSize = 16.sp
                    )
                    Text(
                        text = "Quando voc√™ completar servi√ßos, eles aparecer√£o aqui",
                        color = TaskGoTextGray,
                        fontSize = 14.sp,
                        textAlign = TextAlign.Center
                    )
                }
            }
        } else {
            LazyColumn(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(16.dp),
                verticalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                items(serviceHistory) { service ->
                    ServiceHistoryCard(
                        service = service,
                        onServiceClick = { onServiceClick(service.id) },
                        onRateService = { onRateService(service.id) }
                    )
                }
            }
        }
    }
}

@Composable
fun ServiceHistoryCard(
    service: ServiceHistoryItem,
    onServiceClick: () -> Unit,
    onRateService: () -> Unit
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .clickable { onServiceClick() },
        shape = RoundedCornerShape(12.dp),
        colors = CardDefaults.cardColors(
            containerColor = Color.White
        ),
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            // Header com status
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = service.serviceTitle,
                    color = TaskGoTextBlack,
                    fontSize = 16.sp,
                    fontWeight = FontWeight.Bold
                )
                
                // Status badge
                Card(
                    shape = RoundedCornerShape(16.dp),
                    colors = CardDefaults.cardColors(
                        containerColor = when (service.status) {
                            ServiceStatus.COMPLETED -> Color(0xFFD4EDDA)
                            ServiceStatus.IN_PROGRESS -> Color(0xFFFFF3CD)
                            ServiceStatus.CANCELLED -> Color(0xFFF8D7DA)
                            ServiceStatus.PENDING -> Color(0xFFE2E3E5)
                        }
                    )
                ) {
                    Text(
                        text = when (service.status) {
                            ServiceStatus.COMPLETED -> "Conclu√≠do"
                            ServiceStatus.IN_PROGRESS -> "Em Andamento"
                            ServiceStatus.CANCELLED -> "Cancelado"
                            ServiceStatus.PENDING -> "Pendente"
                        },
                        color = when (service.status) {
                            ServiceStatus.COMPLETED -> Color(0xFF155724)
                            ServiceStatus.IN_PROGRESS -> Color(0xFF856404)
                            ServiceStatus.CANCELLED -> Color(0xFF721C24)
                            ServiceStatus.PENDING -> Color(0xFF6C757D)
                        },
                        fontSize = 10.sp,
                        fontWeight = FontWeight.Medium,
                        modifier = Modifier.padding(horizontal = 8.dp, vertical = 4.dp)
                    )
                }
            }
            
            Spacer(modifier = Modifier.height(8.dp))
            
            // Prestador
            Text(
                text = "Prestador: ${service.providerName}",
                color = TaskGoTextGray,
                fontSize = 14.sp
            )
            
            Spacer(modifier = Modifier.height(4.dp))
            
            // Localiza√ß√£o
            Text(
                text = "Cliente: ${service.clientLocation}",
                color = TaskGoTextGray,
                fontSize = 12.sp
            )
            
            Spacer(modifier = Modifier.height(4.dp))
            
            // Data
            Text(
                text = "Data: ${service.serviceDate}",
                color = TaskGoTextGray,
                fontSize = 12.sp
            )
            
            if (service.status == ServiceStatus.COMPLETED) {
                Spacer(modifier = Modifier.height(12.dp))
                
                // Avalia√ß√£o
                Row(
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Text(
                        text = "Avalia√ß√£o: ",
                        color = TaskGoTextGray,
                        fontSize = 12.sp
                    )
                    
                    if (service.rating != null) {
                        Row(
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            repeat(5) { index ->
                                Icon(
                                    imageVector = Icons.Filled.Star,
                                    contentDescription = "Estrela",
                                    tint = if (index < service.rating.toInt()) Color(0xFFFFD700) else Color(0xFFE0E0E0),
                                    modifier = Modifier.size(14.dp)
                                )
                            }
                            Spacer(modifier = Modifier.width(4.dp))
                            Text(
                                text = "${service.rating}",
                                color = TaskGoTextGray,
                                fontSize = 12.sp,
                                fontWeight = FontWeight.Medium
                            )
                        }
                    } else {
                        TextButton(
                            onClick = onRateService,
                            colors = ButtonDefaults.textButtonColors(
                                contentColor = TaskGoGreen
                            )
                        ) {
                            Text(
                                text = "Avaliar",
                                fontSize = 12.sp,
                                fontWeight = FontWeight.Medium
                            )
                        }
                    }
                }
            }
        }
    }
}

```

## [FRONTEND]: feature/services/presentation/ServiceHistoryViewModel.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.services.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.taskgoapp.taskgo.core.model.ServiceOrder
import com.taskgoapp.taskgo.domain.repository.ServiceRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch
import java.text.SimpleDateFormat
import java.util.*
import javax.inject.Inject

data class ServiceHistoryUiState(
    val isLoading: Boolean = false,
    val error: String? = null,
    val serviceHistory: List<ServiceHistoryItem> = emptyList()
)

@HiltViewModel
class ServiceHistoryViewModel @Inject constructor(
    private val serviceRepository: ServiceRepository
) : ViewModel() {

    private val _uiState = MutableStateFlow(ServiceHistoryUiState())
    val uiState: StateFlow<ServiceHistoryUiState> = _uiState.asStateFlow()

    // Converter ServiceOrder para ServiceHistoryItem
    val serviceHistory: StateFlow<List<ServiceHistoryItem>> = serviceRepository
        .observeServiceOrders()
        .map { orders ->
            orders.map { order ->
                ServiceHistoryItem(
                    id = order.id,
                    serviceTitle = order.description,
                    providerName = "Prestador", // TODO: Buscar do reposit√≥rio quando dispon√≠vel
                    clientLocation = "${order.city}, ${order.state}",
                    serviceDate = formatDate(order.date),
                    status = ServiceStatus.COMPLETED, // TODO: Determinar status do reposit√≥rio
                    rating = null
                )
            }
        }
        .stateIn(
            viewModelScope,
            SharingStarted.WhileSubscribed(5_000),
            emptyList()
        )

    init {
        loadHistory()
    }

    private fun loadHistory() {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoading = true, error = null)
            try {
                // Os dados v√™m automaticamente via Flow do reposit√≥rio
                _uiState.value = _uiState.value.copy(isLoading = false)
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = e.message ?: "Erro ao carregar hist√≥rico"
                )
            }
        }
    }

    private fun formatDate(timestamp: Long): String {
        val date = Date(timestamp)
        val formatter = SimpleDateFormat("d 'de' MMMM 'de' yyyy", Locale("pt", "BR"))
        return formatter.format(date)
    }

    fun refresh() {
        loadHistory()
    }

    fun clearError() {
        _uiState.value = _uiState.value.copy(error = null)
    }
}


```

## [FRONTEND]: feature/services/presentation/ServiceOrderDetailScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.services.presentation

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.LocationOn
import androidx.compose.material.icons.filled.CalendarToday
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.collectAsState
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.google.firebase.auth.FirebaseAuth
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.feature.services.presentation.components.CancelServiceDialog
import com.taskgoapp.taskgo.feature.services.presentation.components.CompleteServiceDialog
import com.taskgoapp.taskgo.core.theme.*
import java.text.NumberFormat
import java.util.Locale

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ServiceOrderDetailScreen(
    orderId: String,
    onBackClick: () -> Unit,
    onSendProposal: (String) -> Unit,
    onNavigateToChat: ((String) -> Unit)? = null,
    viewModel: ServiceOrderDetailViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    val currencyFormat = NumberFormat.getCurrencyInstance(Locale("pt", "BR"))
    val currentUserId = remember { FirebaseAuth.getInstance().currentUser?.uid ?: "" }
    
    var showCancelDialog by remember { mutableStateOf(false) }
    var showCompleteDialog by remember { mutableStateOf(false) }
    
    LaunchedEffect(orderId) {
        viewModel.loadOrder(orderId)
    }
    
    // Mostrar dialogs
    if (showCancelDialog) {
        CancelServiceDialog(
            onDismiss = { showCancelDialog = false },
            onConfirm = { reason, refundAmount ->
                viewModel.cancelOrder(reason, refundAmount)
                showCancelDialog = false
            }
        )
    }
    
    if (showCompleteDialog) {
        CompleteServiceDialog(
            onDismiss = { showCompleteDialog = false },
            onConfirm = { description, time, mediaUris ->
                viewModel.completeOrder(description, time, mediaUris, currentUserId)
                showCompleteDialog = false
            }
        )
    }
    
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Detalhes da Ordem",
                onBackClick = onBackClick
            )
        }
    ) { paddingValues ->
        val errorMessage = uiState.error
        if (uiState.isLoading) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues),
                contentAlignment = Alignment.Center
            ) {
                CircularProgressIndicator(color = TaskGoGreen)
            }
        } else if (errorMessage != null) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues),
                contentAlignment = Alignment.Center
            ) {
                Column(
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.spacedBy(16.dp)
                ) {
                    Text(
                            text = errorMessage,
                        color = MaterialTheme.colorScheme.error
                    )
                    Button(
                        onClick = { viewModel.loadOrder(orderId) },
                        colors = ButtonDefaults.buttonColors(containerColor = TaskGoGreen)
                    ) {
                        Text("Tentar Novamente")
                    }
                }
            }
        } else {
            val order = uiState.order
            if (order == null) {
                Box(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(paddingValues),
                    contentAlignment = Alignment.Center
                ) {
                    Text("Ordem n√£o encontrada", color = TaskGoTextGray)
                }
            } else {
                Column(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(paddingValues)
                        .verticalScroll(rememberScrollState())
                        .padding(16.dp),
                    verticalArrangement = Arrangement.spacedBy(16.dp)
                ) {
                    // Card de Informa√ß√µes
                    Card(
                        modifier = Modifier.fillMaxWidth(),
                        shape = RoundedCornerShape(12.dp),
                        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
                    ) {
                        Column(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(16.dp),
                            verticalArrangement = Arrangement.spacedBy(12.dp)
                        ) {
                            // T√≠tulo/Descri√ß√£o
                            Text(
                                text = "Descri√ß√£o",
                                style = MaterialTheme.typography.titleMedium,
                                fontWeight = FontWeight.Bold,
                                color = TaskGoTextDark
                            )
                            Text(
                                text = order.details.takeIf { it.isNotBlank() } ?: "Sem descri√ß√£o",
                                style = MaterialTheme.typography.bodyLarge,
                                color = TaskGoTextGray
                            )
                            
                            HorizontalDivider()
                            
                            // Localiza√ß√£o
                            Row(
                                verticalAlignment = Alignment.CenterVertically,
                                horizontalArrangement = Arrangement.spacedBy(8.dp)
                            ) {
                                Icon(
                                    imageVector = Icons.Default.LocationOn,
                                    contentDescription = null,
                                    tint = TaskGoGreen
                                )
                                Column {
                                    Text(
                                        text = "Localiza√ß√£o",
                                        style = MaterialTheme.typography.bodySmall,
                                        color = TaskGoTextGray
                                    )
                                    Text(
                                        text = order.location.takeIf { it.isNotBlank() } ?: "N√£o informada",
                                        style = MaterialTheme.typography.bodyLarge,
                                        fontWeight = FontWeight.Medium,
                                        color = TaskGoTextDark
                                    )
                                }
                            }
                            
                            HorizontalDivider()
                            
                            // Or√ßamento
                            Column {
                                Text(
                                    text = "Or√ßamento",
                                    style = MaterialTheme.typography.bodySmall,
                                    color = TaskGoTextGray
                                )
                                Text(
                                    text = if (order.budget > 0) {
                                        currencyFormat.format(order.budget)
                                    } else {
                                        "A combinar"
                                    },
                                    style = MaterialTheme.typography.titleLarge,
                                    fontWeight = FontWeight.Bold,
                                    color = TaskGoGreen
                                )
                            }
                            
                            // Data de vencimento
                            order.dueDate?.let { dueDate ->
                                HorizontalDivider()
                                Row(
                                    verticalAlignment = Alignment.CenterVertically,
                                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                                ) {
                                    Icon(
                                        imageVector = Icons.Default.CalendarToday,
                                        contentDescription = null,
                                        tint = TaskGoTextGray
                                    )
                                    Column {
                                        Text(
                                            text = "Prazo",
                                            style = MaterialTheme.typography.bodySmall,
                                            color = TaskGoTextGray
                                        )
                                        Text(
                                            text = dueDate,
                                            style = MaterialTheme.typography.bodyLarge,
                                            fontWeight = FontWeight.Medium,
                                            color = TaskGoTextDark
                                        )
                                    }
                                }
                            }
                        }
                    }
                    
                    // Bot√µes de a√ß√£o baseados no status
                    when (order.status) {
                        "in_progress" -> {
                            // Bot√µes para servi√ßo em andamento
                            if (onNavigateToChat != null) {
                                OutlinedButton(
                                    onClick = { onNavigateToChat(order.id) },
                                    modifier = Modifier.fillMaxWidth(),
                                    colors = ButtonDefaults.outlinedButtonColors(
                                        contentColor = TaskGoGreen
                                    ),
                                    shape = RoundedCornerShape(12.dp)
                                ) {
                                    Text(
                                        text = "Abrir Chat",
                                        fontWeight = FontWeight.Bold
                                    )
                                }
                            }
                            
                            Row(
                                modifier = Modifier.fillMaxWidth(),
                                horizontalArrangement = Arrangement.spacedBy(8.dp)
                            ) {
                                Button(
                                    onClick = { showCancelDialog = true },
                                    modifier = Modifier.weight(1f),
                                    colors = ButtonDefaults.buttonColors(
                                        containerColor = MaterialTheme.colorScheme.error
                                    ),
                                    shape = RoundedCornerShape(12.dp),
                                    enabled = !uiState.isCancelling
                                ) {
                                    Text(
                                        text = if (uiState.isCancelling) "Cancelando..." else "Cancelar Servi√ßo",
                                        fontWeight = FontWeight.Bold
                                    )
                                }
                                
                                Button(
                                    onClick = { showCompleteDialog = true },
                                    modifier = Modifier.weight(1f),
                                    colors = ButtonDefaults.buttonColors(
                                        containerColor = TaskGoGreen
                                    ),
                                    shape = RoundedCornerShape(12.dp),
                                    enabled = !uiState.isCompleting
                                ) {
                                    Text(
                                        text = if (uiState.isCompleting) "Concluindo..." else "Concluir Servi√ßo",
                                        fontWeight = FontWeight.Bold
                                    )
                                }
                            }
                        }
                        "pending", "proposed" -> {
                            // Bot√£o Enviar Or√ßamento (para prestadores)
                            Button(
                                onClick = {
                                    onSendProposal(order.id)
                                },
                                modifier = Modifier.fillMaxWidth(),
                                colors = ButtonDefaults.buttonColors(
                                    containerColor = TaskGoGreen
                                ),
                                shape = RoundedCornerShape(12.dp)
                            ) {
                                Text(
                                    text = "Enviar Or√ßamento",
                                    fontWeight = FontWeight.Bold,
                                    modifier = Modifier.padding(vertical = 8.dp)
                                )
                            }
                        }
                    }
                }
            }
        }
    }
}


```

## [FRONTEND]: feature/services/presentation/ServiceOrderDetailViewModel.kt

```kotlin
package com.taskgoapp.taskgo.feature.services.presentation

import android.net.Uri
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.taskgoapp.taskgo.core.model.PostLocation
import com.taskgoapp.taskgo.core.model.Result
import com.taskgoapp.taskgo.data.firestore.models.OrderFirestore
import com.taskgoapp.taskgo.data.repository.FeedMediaRepository
import com.taskgoapp.taskgo.data.repository.FirestoreOrderRepository
import com.taskgoapp.taskgo.domain.usecase.CreatePostUseCase
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

data class ServiceOrderDetailUiState(
    val isLoading: Boolean = false,
    val order: OrderFirestore? = null,
    val error: String? = null,
    val isCancelling: Boolean = false,
    val isCompleting: Boolean = false
)

@HiltViewModel
class ServiceOrderDetailViewModel @Inject constructor(
    private val orderRepository: FirestoreOrderRepository,
    private val feedMediaRepository: FeedMediaRepository,
    private val createPostUseCase: CreatePostUseCase
) : ViewModel() {
    
    private val _uiState = MutableStateFlow(ServiceOrderDetailUiState())
    val uiState: StateFlow<ServiceOrderDetailUiState> = _uiState.asStateFlow()
    
    fun loadOrder(orderId: String) {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoading = true, error = null)
            try {
                val order = orderRepository.getOrder(orderId)
                _uiState.value = _uiState.value.copy(
                    order = order,
                    isLoading = false,
                    error = if (order == null) "Ordem n√£o encontrada" else null
                )
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = "Erro ao carregar ordem: ${e.message}"
                )
            }
        }
    }
    
    fun cancelOrder(reason: String, refundAmount: Double?) {
        val order = _uiState.value.order ?: return
        
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isCancelling = true, error = null)
            
            try {
                val result = orderRepository.cancelOrder(order.id, reason, refundAmount)
                
                // Type-safe check: Kotlin smart cast preserva Result.Success<Unit> dentro do bloco
                when (result) {
                    is com.taskgoapp.taskgo.core.model.Result.Success -> {
                        // result √© automaticamente Result.Success<Unit> aqui devido ao smart cast
                        // Recarregar ordem para atualizar estado
                        loadOrder(order.id)
                        _uiState.value = _uiState.value.copy(isCancelling = false)
                    }
                    is com.taskgoapp.taskgo.core.model.Result.Error -> {
                        _uiState.value = _uiState.value.copy(
                            isCancelling = false,
                            error = result.exception.message ?: "Erro ao cancelar ordem"
                        )
                    }
                    is com.taskgoapp.taskgo.core.model.Result.Loading -> {
                        // Nada a fazer, j√° est√° em loading
                    }
                }
            } catch (e: Exception) {
                android.util.Log.e("ServiceOrderDetailViewModel", "Erro ao cancelar ordem: ${e.message}", e)
                _uiState.value = _uiState.value.copy(
                    isCancelling = false,
                    error = "Erro ao cancelar ordem: ${e.message}"
                )
            }
        }
    }
    
    fun completeOrder(
        description: String,
        time: String,
        mediaUris: List<Uri>,
        userId: String
    ) {
        val order = _uiState.value.order ?: return
        
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isCompleting = true, error = null)
            
            try {
                // 1. Fazer upload das m√≠dias
                val mediaUrls: List<String> = if (mediaUris.isNotEmpty()) {
                    // Determinar tipos de m√≠dia
                    val mediaTypes = mediaUris.map { uri ->
                        val path = uri.toString().lowercase()
                        when {
                            path.contains("video") || path.contains(".mp4") || path.contains(".mov") -> "video"
                            else -> "image"
                        }
                    }
                    
                    val uploadResult = feedMediaRepository.uploadPostMediaBatch(
                        mediaUris,
                        userId,
                        mediaTypes
                    )
                    
                    // Type-safe check: Kotlin smart cast preserva Result.Success<List<String>> dentro do bloco
                    when (uploadResult) {
                        is com.taskgoapp.taskgo.core.model.Result.Success -> {
                            // uploadResult √© automaticamente Result.Success<List<String>> aqui devido ao smart cast
                            uploadResult.data
                        }
                        is com.taskgoapp.taskgo.core.model.Result.Error -> {
                            _uiState.value = _uiState.value.copy(
                                isCompleting = false,
                                error = "Erro ao fazer upload das m√≠dias: ${uploadResult.exception.message}"
                            )
                            return@launch
                        }
                        is com.taskgoapp.taskgo.core.model.Result.Loading -> {
                            // Nada a fazer, aguardar
                            emptyList<String>()
                        }
                    }
                } else {
                    emptyList()
                }
                
                // 2. Atualizar ordem com dados de conclus√£o
                val result = orderRepository.completeOrder(
                    orderId = order.id,
                    description = description,
                    time = time,
                    mediaUrls = mediaUrls
                )
                
                // Type-safe check: Kotlin smart cast preserva Result.Success<Unit> dentro do bloco
                when (result) {
                    is com.taskgoapp.taskgo.core.model.Result.Success -> {
                        // result √© automaticamente Result.Success<Unit> aqui devido ao smart cast
                        // 3. Criar post no feed
                        if (mediaUrls.isNotEmpty() && description.isNotBlank()) {
                            // Usar localiza√ß√£o da ordem ou padr√£o
                            val postText = "$description\n\nTempo: $time"
                            val location = PostLocation(
                                city = order.location.split(",").getOrNull(0) ?: "",
                                state = order.location.split(",").getOrNull(1)?.trim() ?: "",
                                latitude = 0.0, // Pode ser melhorado com geocoding se necess√°rio
                                longitude = 0.0
                            )
                            
                            val mediaTypes = mediaUris.map { uri ->
                                val path = uri.toString().lowercase()
                                when {
                                    path.contains("video") || path.contains(".mp4") || path.contains(".mov") -> "video"
                                    else -> "image"
                                }
                            }
                            
                            createPostUseCase(
                                text = postText,
                                mediaUrls = mediaUrls,
                                mediaTypes = mediaTypes,
                                location = location
                            )
                        }
                        
                        // Recarregar ordem para atualizar estado
                        loadOrder(order.id)
                        _uiState.value = _uiState.value.copy(isCompleting = false)
                    }
                    is com.taskgoapp.taskgo.core.model.Result.Error -> {
                        _uiState.value = _uiState.value.copy(
                            isCompleting = false,
                            error = result.exception.message ?: "Erro ao concluir ordem"
                        )
                    }
                    is com.taskgoapp.taskgo.core.model.Result.Loading -> {
                        // Nada a fazer, j√° est√° em loading
                    }
                }
            } catch (e: Exception) {
                android.util.Log.e("ServiceOrderDetailViewModel", "Erro ao concluir ordem: ${e.message}", e)
                _uiState.value = _uiState.value.copy(
                    isCompleting = false,
                    error = "Erro ao concluir ordem: ${e.message}"
                )
            }
        }
    }
    
    fun clearError() {
        _uiState.value = _uiState.value.copy(error = null)
    }
}


```

## [FRONTEND]: feature/services/presentation/ServicesScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.services.presentation

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Star
import androidx.compose.material.icons.filled.*
import androidx.compose.material.icons.automirrored.filled.ArrowForward
import androidx.compose.material3.*
import androidx.compose.material3.IconButton
import androidx.compose.runtime.*
import androidx.compose.runtime.collectAsState
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.draw.clip
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.hilt.navigation.compose.hiltViewModel
import coil.compose.AsyncImage
import coil.request.ImageRequest as CoilImageRequest
import com.taskgoapp.taskgo.R
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.design.FilterBar
import com.taskgoapp.taskgo.core.design.FilterBottomSheet
import com.taskgoapp.taskgo.core.design.TGIcons
import com.taskgoapp.taskgo.core.design.TGIcon
import com.taskgoapp.taskgo.core.model.AccountType
import com.taskgoapp.taskgo.core.model.ServiceOrder
import com.taskgoapp.taskgo.core.theme.*
import com.taskgoapp.taskgo.data.firestore.models.ServiceFirestore
import com.taskgoapp.taskgo.data.firestore.models.OrderFirestore
import com.taskgoapp.taskgo.data.firestore.models.UserFirestore
import com.taskgoapp.taskgo.core.data.models.ServiceCategory
import com.google.firebase.auth.FirebaseAuth
import androidx.compose.ui.platform.LocalContext
import coil.request.ImageRequest
import java.text.NumberFormat
import java.util.Locale

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ServicesScreen(
    onNavigateToServiceDetail: (String) -> Unit,
    onNavigateToCreateWorkOrder: () -> Unit,
    onNavigateToNotifications: () -> Unit = {},
    onNavigateToCart: () -> Unit = {},
    onNavigateToMessages: () -> Unit = {},
    onNavigateToSearch: () -> Unit = {},
    modifier: Modifier = Modifier
) {
    val viewModel: ServicesViewModel = hiltViewModel()
    val currentUserId = remember { FirebaseAuth.getInstance().currentUser?.uid ?: "" }
    val uiState by viewModel.uiState.collectAsState()
    val serviceOrders by viewModel.serviceOrders.collectAsState()
    val filterState by viewModel.filterState.collectAsState()
    val categories by viewModel.serviceCategories.collectAsState()
    val categoriesFull by viewModel.serviceCategoriesFull.collectAsState()
    val accountType by viewModel.accountType.collectAsState()
    val providerServices by viewModel.availableServices.collectAsState()
    val serviceOrdersFirestore by viewModel.serviceOrdersFirestore.collectAsState()
    val filteredProviders by viewModel.filteredProviders.collectAsState()
    
    var showFilterSheet by remember { mutableStateOf(false) }
    var searchQuery by remember { mutableStateOf("") }
    var selectedCategory by remember { mutableStateOf<String?>(null) }
    val isProvider = accountType == AccountType.PARCEIRO || accountType == AccountType.PRESTADOR // Suporta legacy
    val subtitleText = if (isProvider) {
        "Acompanhe as ordens de servi√ßo solicitadas pelos clientes"
    } else {
        "Encontre prestadores de servi√ßos dispon√≠veis na sua regi√£o"
    }
    
    // Atualizar busca quando o usu√°rio digitar
    LaunchedEffect(searchQuery) {
        viewModel.updateSearchQuery(searchQuery)
    }
    
    // Adicionar "Todos" no in√≠cio das categorias
    val categoriesWithAll = remember(categories) {
        listOf("Todos") + categories.filter { it != "Todos" }
    }
    
    Scaffold(
        topBar = {
            AppTopBar(
                title = stringResource(R.string.services_title),
                subtitle = subtitleText,
                onBackClick = null,
                backgroundColor = TaskGoGreen,
                titleColor = Color.White,
                backIconColor = Color.White,
                actions = {
                    Row(
                        horizontalArrangement = Arrangement.spacedBy(4.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        IconButton(
                            onClick = onNavigateToSearch,
                            modifier = Modifier.size(36.dp)
                        ) {
                            TGIcon(
                                iconRes = TGIcons.Search,
                                contentDescription = "Buscar",
                                size = TGIcons.Sizes.Medium,
                                tint = Color.White
                            )
                        }
                        IconButton(
                            onClick = onNavigateToNotifications,
                            modifier = Modifier.size(36.dp)
                        ) {
                            TGIcon(
                                iconRes = TGIcons.Bell,
                                contentDescription = "Notifica√ß√µes",
                                size = TGIcons.Sizes.Medium,
                                tint = Color.White
                            )
                        }
                        IconButton(
                            onClick = onNavigateToCart,
                            modifier = Modifier.size(36.dp)
                        ) {
                            TGIcon(
                                iconRes = TGIcons.Cart,
                                contentDescription = "Carrinho",
                                size = TGIcons.Sizes.Medium,
                                tint = Color.White
                            )
                        }
                        IconButton(
                            onClick = onNavigateToMessages,
                            modifier = Modifier.size(36.dp)
                        ) {
                            TGIcon(
                                iconRes = TGIcons.Messages,
                                contentDescription = "Mensagens",
                                size = TGIcons.Sizes.Medium,
                                tint = Color.White
                            )
                        }
                    }
                }
            )
        }
    ) { paddingValues ->
        Column(
            modifier = modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(horizontal = 16.dp),
            verticalArrangement = Arrangement.spacedBy(4.dp)
        ) {
            // Bot√£o "Criar Ordem de Servi√ßo" (apenas para cliente e vendedor)
            if (accountType == AccountType.CLIENTE || accountType == AccountType.VENDEDOR) { // VENDEDOR legacy
                Button(
                    onClick = onNavigateToCreateWorkOrder,
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(vertical = 12.dp),
                    colors = ButtonDefaults.buttonColors(
                        containerColor = TaskGoGreen
                    ),
                    shape = RoundedCornerShape(8.dp)
                ) {
                    Icon(
                        imageVector = Icons.Default.Add,
                        contentDescription = null,
                        tint = Color.White,
                        modifier = Modifier.size(20.dp)
                    )
                    Spacer(modifier = Modifier.width(8.dp))
                    Text(
                        text = "Criar Ordem de Servi√ßo",
                        color = Color.White,
                        fontWeight = FontWeight.Bold
                    )
                }
            }
            // Barra de Busca
            com.taskgoapp.taskgo.core.design.SearchBar(
                query = searchQuery,
                onQueryChange = { searchQuery = it },
                placeholder = "Buscar servi√ßos...",
                modifier = Modifier.padding(top = 4.dp)
            )
            
            // Barra de Filtros e bot√µes de ordena√ß√£o (apenas para CLIENTE, n√£o para PARCEIRO)
            if (!isProvider) {
                FilterBar(
                    categories = categoriesWithAll,
                    selectedCategories = filterState.selectedCategories,
                    onCategorySelected = { category ->
                        if (category == "Todos") {
                            viewModel.updateFilterState(filterState.copy(selectedCategories = emptySet()))
                        } else {
                            viewModel.toggleCategory(category)
                        }
                    },
                    onFilterClick = { showFilterSheet = true },
                    showSortButtons = true,
                    sortBy = filterState.sortBy,
                    onSortByRating = { viewModel.updateFilterState(filterState.copy(sortBy = com.taskgoapp.taskgo.core.design.SortOption.RATING)) },
                    onSortByNewest = { viewModel.updateFilterState(filterState.copy(sortBy = com.taskgoapp.taskgo.core.design.SortOption.NEWEST)) },
                    modifier = Modifier.padding(vertical = 2.dp)
                )
            }
            
            // Lista de categorias (Cliente/Vendedor) ou ordens por categoria (Prestador)
            if (uiState.isLoading) {
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    CircularProgressIndicator()
                }
            } else if (uiState.error != null) {
                Text(
                    text = uiState.error ?: "Erro ao carregar servi√ßos",
                    color = MaterialTheme.colorScheme.error
                )
            } else if (!isProvider && selectedCategory == null) {
                // Mostrar categorias em grid para Cliente/Vendedor (sempre mostrar, mesmo se vazio)
                LazyColumn(
                    verticalArrangement = Arrangement.spacedBy(12.dp),
                    contentPadding = PaddingValues(bottom = 32.dp),
                    modifier = Modifier.fillMaxSize()
                ) {
                    if (categoriesFull.isEmpty()) {
                        item {
                            Box(
                                modifier = Modifier.fillMaxSize(),
                                contentAlignment = Alignment.Center
                            ) {
                                Text(
                                    text = "Carregando categorias...",
                                    color = TaskGoTextGray,
                                    textAlign = TextAlign.Center
                                )
                            }
                        }
                    } else {
                        items(categoriesFull) { category ->
                            ServiceCategoryCard(
                                category = category,
                                onCategoryClick = { 
                                    selectedCategory = category.name
                                    viewModel.updateSelectedCategory(category.name)
                                }
                            )
                        }
                    }
                }
            } else if (!isProvider && selectedCategory != null) {
                // Mostrar prestadores que t√™m a categoria selecionada em preferredCategories
                if (filteredProviders.isEmpty()) {
                    Box(
                        modifier = Modifier.fillMaxSize(),
                        contentAlignment = Alignment.Center
                    ) {
                        Column(
                            horizontalAlignment = Alignment.CenterHorizontally,
                            verticalArrangement = Arrangement.spacedBy(8.dp)
                        ) {
                            Text(
                                text = "Nenhum prestador encontrado",
                                color = TaskGoTextGray,
                                textAlign = TextAlign.Center
                            )
                            Text(
                                text = "N√£o h√° prestadores cadastrados nesta categoria",
                                color = TaskGoTextGray,
                                textAlign = TextAlign.Center,
                                style = MaterialTheme.typography.bodySmall
                            )
                            TextButton(onClick = { 
                                selectedCategory = null
                                viewModel.updateSelectedCategory(null)
                            }) {
                                Text("Voltar")
                            }
                        }
                    }
                } else {
                    LazyColumn(
                        verticalArrangement = Arrangement.spacedBy(12.dp),
                        contentPadding = PaddingValues(bottom = 32.dp),
                        modifier = Modifier.fillMaxSize()
                    ) {
                        item {
                            Row(
                                modifier = Modifier.fillMaxWidth(),
                                horizontalArrangement = Arrangement.SpaceBetween,
                                verticalAlignment = Alignment.CenterVertically
                            ) {
                                Text(
                                    text = selectedCategory ?: "",
                                    fontSize = 20.sp,
                                    fontWeight = FontWeight.Bold
                                )
                                TextButton(onClick = { 
                                    selectedCategory = null
                                    viewModel.updateSelectedCategory(null)
                                }) {
                                    Text("Voltar")
                                }
                            }
                        }
                        items(filteredProviders) { provider ->
                            ProviderCard(
                                provider = provider,
                                onProviderClick = { onNavigateToServiceDetail(provider.uid) }
                            )
                        }
                    }
                }
            } else if (isProvider) {
                // Para PARCEIRO: mostrar diretamente as ordens de servi√ßo (filtradas por preferredCategories, raio 100km)
                // As ordens j√° s√£o filtradas automaticamente por preferredCategories no ViewModel
                // O Firestore listener j√° faz atualiza√ß√£o autom√°tica em tempo real
                if (serviceOrdersFirestore.isEmpty()) {
                    Box(
                        modifier = Modifier.fillMaxSize(),
                        contentAlignment = Alignment.Center
                    ) {
                        Column(
                            horizontalAlignment = Alignment.CenterHorizontally,
                            verticalArrangement = Arrangement.spacedBy(8.dp)
                        ) {
                            Text(
                                text = "Nenhuma ordem de servi√ßo dispon√≠vel",
                                color = TaskGoTextGray,
                                textAlign = TextAlign.Center,
                                fontSize = 16.sp,
                                fontWeight = FontWeight.Medium
                            )
                            Text(
                                text = "As novas ordens ser√£o exibidas automaticamente quando dispon√≠veis",
                                color = TaskGoTextGray,
                                textAlign = TextAlign.Center,
                                style = MaterialTheme.typography.bodySmall
                            )
                        }
                    }
                } else {
                    LazyColumn(
                        verticalArrangement = Arrangement.spacedBy(12.dp),
                        contentPadding = PaddingValues(bottom = 32.dp),
                        modifier = Modifier.fillMaxSize()
                    ) {
                        items(serviceOrdersFirestore) { order ->
                            val isOwnOrder = currentUserId == order.clientId
                            ServiceOrderCardFirestore(
                                order = order,
                                isOwnOrder = isOwnOrder,
                                onServiceClick = { onNavigateToServiceDetail(order.id) }
                            )
                        }
                    }
                }
            }
        }
        
        // Bottom Sheet de Filtros
        FilterBottomSheet(
            isOpen = showFilterSheet,
            onDismiss = { showFilterSheet = false },
            filterState = filterState,
            onFilterStateChange = { newState ->
                viewModel.updateFilterState(newState)
            },
            showPriceFilter = isProvider // Filtro de pre√ßo apenas para Prestadores
        )
    }
}

@Composable
private fun ServiceOrderCardFirestore(
    order: OrderFirestore,
    isOwnOrder: Boolean,
    onServiceClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    val currencyFormat = NumberFormat.getCurrencyInstance(Locale("pt", "BR"))
    val cardColor = if (isOwnOrder) {
        TaskGoGreen.copy(alpha = 0.15f)
    } else {
        MaterialTheme.colorScheme.surface
    }
    
    Card(
        modifier = modifier
            .fillMaxWidth()
            .clickable { onServiceClick() },
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),
        colors = CardDefaults.cardColors(containerColor = cardColor)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            horizontalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            // Imagem placeholder
            Box(
                modifier = Modifier
                    .size(80.dp)
                    .clip(RoundedCornerShape(8.dp))
                    .background(TaskGoGreen.copy(alpha = 0.2f)),
                contentAlignment = Alignment.Center
            ) {
                Text("üìã", fontSize = 24.sp)
            }
            
            Column(
                modifier = Modifier.weight(1f),
                verticalArrangement = Arrangement.spacedBy(4.dp)
            ) {
                // T√≠tulo
                Text(
                    text = order.details.takeIf { it.isNotBlank() } ?: order.category ?: "Ordem de Servi√ßo",
                    fontSize = 16.sp,
                    fontWeight = FontWeight.Bold,
                    color = TaskGoTextDark,
                    maxLines = 2,
                    overflow = TextOverflow.Ellipsis
                )
                
                // Localiza√ß√£o
                Text(
                    text = order.location.takeIf { it.isNotBlank() } ?: "Localiza√ß√£o n√£o informada",
                    fontSize = 12.sp,
                    color = TaskGoTextGray,
                    maxLines = 1,
                    overflow = TextOverflow.Ellipsis
                )
                
                // Valor
                Text(
                    text = if (order.budget > 0) {
                        currencyFormat.format(order.budget)
                    } else {
                        "Or√ßamento a combinar"
                    },
                    fontSize = 16.sp,
                    fontWeight = FontWeight.Bold,
                    color = TaskGoGreen
                )
                
                // Badge se for pr√≥pria ordem
                if (isOwnOrder) {
                    Surface(
                        color = TaskGoGreen.copy(alpha = 0.3f),
                        shape = RoundedCornerShape(4.dp)
                    ) {
                        Text(
                            text = "Sua ordem",
                            modifier = Modifier.padding(horizontal = 6.dp, vertical = 2.dp),
                            fontSize = 10.sp,
                            color = TaskGoGreen,
                            fontWeight = FontWeight.Bold
                        )
                    }
                }
            }
        }
    }
}

@Composable
private fun ServiceOrderCard(
    title: String,
    description: String,
    price: String,
    rating: Float,
    onServiceClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier
            .fillMaxWidth()
            .clickable { onServiceClick() },
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                text = title,
                fontSize = 18.sp,
                fontWeight = FontWeight.SemiBold,
                color = TaskGoTextDark
            )
            
            Spacer(modifier = Modifier.height(8.dp))
            
            Text(
                text = description,
                fontSize = 14.sp,
                color = TaskGoTextDark.copy(alpha = 0.7f)
            )
            
            Spacer(modifier = Modifier.height(8.dp))
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = price,
                    fontSize = 16.sp,
                    fontWeight = FontWeight.Bold,
                    color = TaskGoGreen
                )
                
                Text(
                    text = "‚≠ê $rating",
                    fontSize = 14.sp,
                    color = TaskGoTextDark.copy(alpha = 0.7f)
                )
            }
        }
    }
}

@Composable
private fun ProviderServiceCard(
    service: ServiceFirestore,
    onServiceClick: () -> Unit,
    onProviderClick: ((String) -> Unit)? = null,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier
            .fillMaxWidth()
            .clickable { onServiceClick() },
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
    ) {
        Column {
            if (service.images.isNotEmpty()) {
                AsyncImage(
                    model = ImageRequest.Builder(LocalContext.current)
                        .data(service.images.first())
                        .crossfade(true)
                        .build(),
                    contentDescription = service.title,
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(160.dp)
                        .clip(RoundedCornerShape(topStart = 12.dp, topEnd = 12.dp)),
                    contentScale = ContentScale.Crop
                )
            } else {
                Box(
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(160.dp)
                        .clip(RoundedCornerShape(topStart = 12.dp, topEnd = 12.dp))
                        .background(TaskGoSurfaceGray),
                    contentAlignment = Alignment.Center
                ) {
                    Icon(
                        painter = painterResource(id = TGIcons.Services),
                        contentDescription = null,
                        tint = TaskGoTextGray
                    )
                }
            }

            Column(modifier = Modifier.padding(16.dp)) {
                Text(
                    text = service.title,
                    fontSize = 18.sp,
                    fontWeight = FontWeight.SemiBold,
                    color = TaskGoTextDark,
                    maxLines = 2,
                    overflow = TextOverflow.Ellipsis
                )

                Spacer(modifier = Modifier.height(6.dp))

                Text(
                    text = service.description,
                    fontSize = 14.sp,
                    color = TaskGoTextDark.copy(alpha = 0.8f),
                    maxLines = 3,
                    overflow = TextOverflow.Ellipsis
                )

                Spacer(modifier = Modifier.height(10.dp))

                // Informa√ß√µes do prestador (clic√°vel)
                if (service.providerId.isNotBlank() && onProviderClick != null) {
                    com.taskgoapp.taskgo.core.design.UserAvatarNameLoader(
                        userId = service.providerId,
                        onUserClick = { onProviderClick(service.providerId) },
                        avatarSize = 32.dp,
                        showName = true,
                        modifier = Modifier.padding(bottom = 8.dp)
                    )
                }

                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Text(
                        text = NumberFormat.getCurrencyInstance(Locale("pt", "BR")).format(service.price),
                        fontSize = 16.sp,
                        fontWeight = FontWeight.Bold,
                        color = TaskGoGreen
                    )
                    Row(
                        verticalAlignment = Alignment.CenterVertically,
                        horizontalArrangement = Arrangement.spacedBy(4.dp)
                    ) {
                        Icon(
                            imageVector = Icons.Default.Star,
                            contentDescription = "Avalia√ß√£o",
                            tint = TaskGoStarYellow,
                            modifier = Modifier.size(16.dp)
                        )
                        Text(
                            text = "%.1f".format(service.rating ?: 0.0),
                            style = FigmaRatingText,
                            color = TaskGoTextDark
                        )
                    }
                }
            }
        }
    }
}

@Composable
fun ServiceCategoryCard(
    category: ServiceCategory,
    onCategoryClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier
            .fillMaxWidth()
            .clickable { onCategoryClick() },
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            Box(
                modifier = Modifier
                    .size(56.dp)
                    .background(TaskGoGreen.copy(alpha = 0.1f), RoundedCornerShape(12.dp)),
                contentAlignment = Alignment.Center
            ) {
                Icon(
                    imageVector = when (category.icon) {
                        "build" -> Icons.Default.Build
                        "home" -> Icons.Default.Home
                        "eco" -> Icons.Default.Eco
                        "flash_on" -> Icons.Default.FlashOn
                        "plumbing" -> Icons.Default.Plumbing
                        "format_paint" -> Icons.Default.FormatPaint
                        "cleaning_services" -> Icons.Default.CleaningServices
                        else -> Icons.Default.List
                    },
                    contentDescription = category.name,
                    tint = TaskGoGreen,
                    modifier = Modifier.size(28.dp)
                )
            }
            Column(modifier = Modifier.weight(1f)) {
                Text(
                    text = category.name,
                    fontSize = 18.sp,
                    fontWeight = FontWeight.SemiBold,
                    color = TaskGoTextDark
                )
                Text(
                    text = category.description,
                    fontSize = 14.sp,
                    color = TaskGoTextGray,
                    maxLines = 2
                )
            }
            Icon(
                imageVector = Icons.AutoMirrored.Filled.ArrowForward,
                contentDescription = "Ver mais",
                tint = TaskGoTextGray
            )
        }
    }
}

@Composable
private fun ProviderCard(
    provider: UserFirestore,
    onProviderClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier
            .fillMaxWidth()
            .clickable { onProviderClick() },
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            horizontalArrangement = Arrangement.spacedBy(12.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            // Foto do prestador
            if (provider.photoURL != null && provider.photoURL.isNotBlank()) {
                AsyncImage(
                    model = CoilImageRequest.Builder(LocalContext.current)
                        .data(provider.photoURL)
                        .crossfade(true)
                        .build(),
                    contentDescription = provider.displayName,
                    modifier = Modifier
                        .size(80.dp)
                        .clip(RoundedCornerShape(8.dp)),
                    contentScale = ContentScale.Crop
                )
            } else {
                Box(
                    modifier = Modifier
                        .size(80.dp)
                        .clip(RoundedCornerShape(8.dp))
                        .background(TaskGoGreen.copy(alpha = 0.2f)),
                    contentAlignment = Alignment.Center
                ) {
                    Text("üë§", fontSize = 32.sp)
                }
            }
            
            Column(
                modifier = Modifier.weight(1f),
                verticalArrangement = Arrangement.spacedBy(4.dp)
            ) {
                Text(
                    text = provider.displayName ?: "Parceiro",
                    fontSize = 18.sp,
                    fontWeight = FontWeight.SemiBold,
                    color = TaskGoTextDark
                )
                
                // Categorias que o prestador oferece
                provider.preferredCategories?.takeIf { it.isNotEmpty() }?.let { categories ->
                    Text(
                        text = categories.joinToString(", "),
                        fontSize = 14.sp,
                        color = TaskGoTextGray,
                        maxLines = 2,
                        overflow = TextOverflow.Ellipsis
                    )
                }
                
                // Rating
                if (provider.rating != null && provider.rating > 0) {
                    Row(
                        verticalAlignment = Alignment.CenterVertically,
                        horizontalArrangement = Arrangement.spacedBy(4.dp)
                    ) {
                        Icon(
                            imageVector = Icons.Default.Star,
                            contentDescription = "Avalia√ß√£o",
                            tint = TaskGoStarYellow,
                            modifier = Modifier.size(16.dp)
                        )
                        Text(
                            text = "%.1f".format(provider.rating),
                            fontSize = 14.sp,
                            color = TaskGoTextDark
                        )
                    }
                }
            }
        }
    }
}
```

## [FRONTEND]: feature/services/presentation/ServicesViewModel.kt

```kotlin
package com.taskgoapp.taskgo.feature.services.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.taskgoapp.taskgo.core.design.FilterState
import com.taskgoapp.taskgo.core.location.LocationManager
import com.taskgoapp.taskgo.core.model.AccountType
import com.taskgoapp.taskgo.core.model.ServiceOrder
import com.taskgoapp.taskgo.data.firestore.models.ServiceFirestore
import com.taskgoapp.taskgo.data.local.datastore.FilterPreferencesManager
import com.taskgoapp.taskgo.data.repository.FirestoreServicesRepository
import com.taskgoapp.taskgo.data.repository.FirestoreOrderRepository
import com.taskgoapp.taskgo.data.repository.FirestoreProvidersRepository
import com.taskgoapp.taskgo.data.repository.FirestoreUserRepository
import com.taskgoapp.taskgo.data.firestore.models.OrderFirestore
import com.taskgoapp.taskgo.domain.repository.CategoriesRepository
import com.taskgoapp.taskgo.domain.repository.ServiceRepository
import com.taskgoapp.taskgo.domain.repository.UserRepository
import com.taskgoapp.taskgo.domain.repository.PreferencesRepository
import com.google.firebase.auth.FirebaseAuth
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.flatMapLatest
import kotlinx.coroutines.flow.firstOrNull
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch
import javax.inject.Inject

data class ServicesUiState(
    val isLoading: Boolean = false,
    val error: String? = null,
    val serviceOrders: List<ServiceOrder> = emptyList()
)

@HiltViewModel
class ServicesViewModel @Inject constructor(
    private val serviceRepository: ServiceRepository,
    private val categoriesRepository: CategoriesRepository,
    private val filterPreferencesManager: FilterPreferencesManager,
    private val locationManager: LocationManager,
    private val userRepository: UserRepository,
    private val firestoreServicesRepository: FirestoreServicesRepository,
    private val orderRepository: FirestoreOrderRepository,
    private val providersRepository: FirestoreProvidersRepository,
    private val firebaseAuth: FirebaseAuth,
    private val preferencesRepository: PreferencesRepository,
    private val firestoreUserRepository: FirestoreUserRepository
) : ViewModel() {

    private val _uiState = MutableStateFlow(ServicesUiState())
    val uiState: StateFlow<ServicesUiState> = _uiState.asStateFlow()

    private val _filterState = MutableStateFlow(FilterState())
    val filterState: StateFlow<FilterState> = _filterState.asStateFlow()

    private val _accountType = MutableStateFlow(AccountType.CLIENTE)
    val accountType: StateFlow<AccountType> = _accountType.asStateFlow()

    val serviceCategories: StateFlow<List<String>> = categoriesRepository
        .observeServiceCategories()
        .map { categories -> categories.map { it.name } }
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyList())
    
    private val preferredCategories: StateFlow<List<String>> = preferencesRepository
        .observeCategories()
        .map { parsePreferredCategories(it) }
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyList())

    val serviceCategoriesFull: StateFlow<List<com.taskgoapp.taskgo.core.data.models.ServiceCategory>> = combine(
        categoriesRepository.observeServiceCategories(),
        preferredCategories
    ) { categories, preferences ->
        if (preferences.isEmpty()) {
            categories
        } else {
            categories.sortedBy { category ->
                val idx = preferences.indexOfFirst { it.equals(category.name, ignoreCase = true) }
                if (idx == -1) preferences.size + categories.indexOf(category) else idx
            }
        }
    }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyList())

    // Para prestadores, observar todas as ordens pendentes
    private val _selectedCategoryForOrders = MutableStateFlow<String?>(null)
    
    // CR√çTICO: Armazenar cidade e estado separadamente para usar nas queries por localiza√ß√£o
    private val _userCity = MutableStateFlow<String?>(null)
    private val _userState = MutableStateFlow<String?>(null)
    
    init {
        // Carregar localiza√ß√£o do usu√°rio ao inicializar
        loadUserLocation()
    }
    
    private fun loadUserLocation() {
        viewModelScope.launch {
            try {
                // Tentar obter localiza√ß√£o GPS primeiro
                val location = locationManager.getCurrentLocation()
                if (location != null) {
                    val address = locationManager.getAddressFromLocation(
                        location.latitude,
                        location.longitude
                    )
                    _userCity.value = address?.locality
                    _userState.value = address?.adminArea
                    android.util.Log.d("ServicesViewModel", "üìç Localiza√ß√£o GPS obtida: city=${_userCity.value}, state=${_userState.value}")
                } else {
                    // Fallback: usar localiza√ß√£o do perfil
                    loadUserLocationFromProfile()
                }
            } catch (e: Exception) {
                android.util.Log.e("ServicesViewModel", "Erro ao obter localiza√ß√£o GPS: ${e.message}", e)
                loadUserLocationFromProfile()
            }
        }
    }
    
    private fun loadUserLocationFromProfile() {
        viewModelScope.launch {
            try {
                userRepository.observeCurrentUser().collect { user ->
                    _userCity.value = user?.city
                    // UserProfile agora tem state diretamente (adicionado na vers√£o 88)
                    _userState.value = user?.state
                    android.util.Log.d("ServicesViewModel", "Localizacao do perfil obtida: city=${_userCity.value}, state=${_userState.value}")
                }
            } catch (e: Exception) {
                android.util.Log.e("ServicesViewModel", "Erro ao obter localizacao do perfil: ${e.message}", e)
            }
        }
    }
    
    val allOrdersFirestore: StateFlow<List<OrderFirestore>> = combine(
        _accountType,
        _selectedCategoryForOrders,
        preferredCategories,
        _userCity,
        _userState
    ) { accountType, category, preferredCategoriesList, userCity, userState ->
        if (accountType == AccountType.PARCEIRO || accountType == AccountType.PRESTADOR) { // Suporta legacy PRESTADOR
            // CR√çTICO: Usar cidade e estado para observar ordens da regi√£o correta
            
            // Se h√° categorias preferidas e nenhuma categoria espec√≠fica foi selecionada,
            // filtrar ordens por preferredCategories
            if (category != null && category.isNotBlank()) {
                // ‚úÖ observeLocalServiceOrders agora usa LocationStateManager automaticamente
                orderRepository.observeLocalServiceOrders(category = category)
            } else if (preferredCategoriesList.isNotEmpty()) {
                // Filtrar ordens pelas categorias preferidas do Parceiro
                // Como observeLocalServiceOrders aceita apenas uma categoria, vamos buscar todas e filtrar depois
                orderRepository.observeLocalServiceOrders(category = null)
            } else {
                // Buscar todas as ordens pendentes (sem filtro de categoria)
                orderRepository.observeLocalServiceOrders(category = null)
            }
        } else {
            kotlinx.coroutines.flow.flowOf(emptyList<OrderFirestore>())
        }
    }.flatMapLatest { it }
        .map { orders ->
            // Filtrar ordens por preferredCategories se houver e nenhuma categoria espec√≠fica foi selecionada
            val accountTypeValue = _accountType.value
            val preferredCategoriesList = preferredCategories.value
            val selectedCategory = _selectedCategoryForOrders.value
            // REMOVIDO: _userLocation n√£o existe, usar _userCity e _userState para localiza√ß√£o
            val userCityValue = _userCity.value
            val userStateValue = _userState.value
            
            var filtered = orders
            
            // Filtrar por categorias preferidas
            if ((accountTypeValue == AccountType.PARCEIRO || accountTypeValue == AccountType.PRESTADOR) 
                && selectedCategory == null 
                && preferredCategoriesList.isNotEmpty()) {
                filtered = filtered.filter { order -> 
                    preferredCategoriesList.contains(order.category) 
                }
            }
            
            // REMOVIDO: Filtro por GPS usando _userLocation que n√£o existe
            // TODO: Implementar filtro por GPS quando necess√°rio usando LocationManager diretamente
            // Por enquanto, o filtro por localiza√ß√£o j√° √© feito via observeLocalServiceOrders com city/state
            
            filtered
        }
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyList())
    
    val allServiceOrders: StateFlow<List<ServiceOrder>> = serviceRepository
        .observeServiceOrders()
        .stateIn(
            viewModelScope,
            SharingStarted.WhileSubscribed(5_000),
            emptyList()
        )

    val serviceOrders: StateFlow<List<ServiceOrder>> = combine(
        allServiceOrders,
        filterState,
        preferredCategories
    ) { orders, filters, preferences ->
        applyFiltersSync(orders, filters, preferences)
    }.stateIn(
        viewModelScope,
        SharingStarted.WhileSubscribed(5_000),
        emptyList()
    )
    
    // Ordens Firestore para prestadores (com category)
    val serviceOrdersFirestore: StateFlow<List<com.taskgoapp.taskgo.data.firestore.models.OrderFirestore>> = 
        combine(
            allOrdersFirestore,
            filterState,
            preferredCategories
        ) { orders, filters, preferences ->
            applyOrderFilters(orders, filters, preferences)
        }.stateIn(
            viewModelScope,
            SharingStarted.WhileSubscribed(5_000),
            emptyList()
        )

    private val rawProviderServices: StateFlow<List<ServiceFirestore>> = firestoreServicesRepository
        .observeAllActiveServices()
        .stateIn(
            viewModelScope,
            SharingStarted.WhileSubscribed(5_000),
            emptyList()
        )
    
    // Prestadores para filtrar por preferredCategories
    private val _allProviders = MutableStateFlow<List<com.taskgoapp.taskgo.data.firestore.models.UserFirestore>>(emptyList())
    
    init {
        loadProviders()
    }
    
    private fun loadProviders() {
        viewModelScope.launch {
            try {
                // CR√çTICO: Carregar prestadores filtrados por localiza√ß√£o e categoria
                val user = userRepository.observeCurrentUser().firstOrNull()
                val userCity = user?.city?.takeIf { it.isNotBlank() }
                val userState = user?.state?.takeIf { it.isNotBlank() }
                
                val providers = if (userCity != null && userState != null) {
                    // Buscar prestadores por localiza√ß√£o (sem filtro de categoria inicial)
                    // O filtro por categoria ser√° aplicado no combine
                    providersRepository.getProvidersByLocationAndCategory(
                        city = userCity,
                        state = userState,
                        category = null, // Categoria ser√° filtrada no combine
                        limit = 100
                    )
                } else {
                    // Fallback: buscar todos os prestadores em destaque
                    providersRepository.getFeaturedProviders(limit = 100)
                }
                _allProviders.value = providers.map { it.provider }
            } catch (e: Exception) {
                android.util.Log.e("ServicesViewModel", "Erro ao carregar prestadores: ${e.message}", e)
            }
        }
    }

    val availableServices: StateFlow<List<ServiceFirestore>> = combine(
        rawProviderServices,
        _allProviders,
        filterState,
        preferredCategories
    ) { services, providers, filters, preferences ->
        applyServiceFilters(services, providers, filters, preferences)
    }.stateIn(
        viewModelScope,
        SharingStarted.WhileSubscribed(5_000),
        emptyList()
    )
    
    // Prestadores filtrados por categoria (para cliente/vendedor)
    val filteredProviders: StateFlow<List<com.taskgoapp.taskgo.data.firestore.models.UserFirestore>> = combine(
        _allProviders,
        filterState
    ) { providers, filters ->
        if (filters.selectedCategories.isEmpty()) {
            emptyList()
        } else {
            providers.filter { provider ->
                provider.preferredCategories?.any { category ->
                    filters.selectedCategories.contains(category)
                } == true
            }
        }
    }.stateIn(
        viewModelScope,
        SharingStarted.WhileSubscribed(5_000),
        emptyList()
    )

    init {
        loadServices()
        loadSavedFilters()
        observeAccountType()
        // REMOVIDO: loadUserLocation() duplicado que usava _userLocation inexistente
        // A fun√ß√£o loadUserLocation() que usa _userCity e _userState j√° est√° sendo chamada no primeiro init
    }

    private fun loadSavedFilters() {
        viewModelScope.launch {
            filterPreferencesManager.getServiceFilters().collect { savedFilters ->
                savedFilters?.let {
                    _filterState.value = it
                }
            }
        }
    }

    private fun observeAccountType() {
        viewModelScope.launch {
            userRepository.observeCurrentUser().collect { user ->
                _accountType.value = user?.accountType ?: AccountType.CLIENTE
            }
        }
    }

    fun updateFilterState(newState: FilterState) {
        _filterState.value = newState
        viewModelScope.launch {
            filterPreferencesManager.saveServiceFilters(newState)
        }
    }

    fun toggleCategory(category: String) {
        val currentCategories = _filterState.value.selectedCategories
        val newCategories = if (currentCategories.contains(category)) {
            currentCategories - category
        } else {
            currentCategories + category
        }
        updateFilterState(_filterState.value.copy(selectedCategories = newCategories))
    }

    fun updateSearchQuery(query: String) {
        updateFilterState(_filterState.value.copy(searchQuery = query))
    }
    
    fun updateSelectedCategory(category: String?) {
        _selectedCategoryForOrders.value = category
    }

    private fun applyFiltersSync(
        orders: List<ServiceOrder>,
        filters: FilterState,
        preferences: List<String>
    ): List<ServiceOrder> {
        var filtered = orders

        // Busca por texto
        if (filters.searchQuery.isNotBlank()) {
            val query = filters.searchQuery.lowercase()
            filtered = filtered.filter { order ->
                order.category.lowercase().contains(query) ||
                order.description.lowercase().contains(query)
            }
        }

        // Filtrar por categorias
        if (filters.selectedCategories.isNotEmpty()) {
            filtered = filtered.filter { order ->
                filters.selectedCategories.contains(order.category)
            }
        }

        // Filtrar por localiza√ß√£o
        filters.location?.let { location ->
            if (location.city != null && location.city.isNotEmpty()) {
                filtered = filtered.filter { order ->
                    order.city.equals(location.city, ignoreCase = true)
                }
            }
            if (location.state != null && location.state.isNotEmpty()) {
                filtered = filtered.filter { order ->
                    order.state.equals(location.state, ignoreCase = true)
                }
            }
            
            // Filtrar por raio usando GPS (ser√° aplicado assincronamente quando necess√°rio)
            // Por enquanto, apenas filtra por cidade se especificada
            // TODO: Implementar filtro ass√≠ncrono quando necess√°rio usando LaunchedEffect
        }

        // Filtrar por avalia√ß√£o
        filters.minRating?.let { minRating ->
            filtered = filtered.filter { order ->
                order.rating != null && order.rating >= minRating
            }
        }

        // Ordenar
        filtered = when (filters.sortBy) {
            com.taskgoapp.taskgo.core.design.SortOption.NEWEST -> 
                filtered.sortedByDescending { it.date }
            com.taskgoapp.taskgo.core.design.SortOption.RATING -> 
                filtered.sortedByDescending { it.rating ?: 0.0 }
            com.taskgoapp.taskgo.core.design.SortOption.RELEVANCE -> 
                filtered // Manter ordem original
            else -> filtered
        }

        return filtered
    }

    private fun applyOrderFilters(
        orders: List<OrderFirestore>,
        filters: FilterState,
        preferences: List<String>
    ): List<OrderFirestore> {
        var filtered = orders

        if (filters.searchQuery.isNotBlank()) {
            val query = filters.searchQuery.lowercase()
            filtered = filtered.filter { order ->
                order.details.lowercase().contains(query) ||
                    order.location.lowercase().contains(query) ||
                    (order.category ?: "").lowercase().contains(query)
            }
        }

        if (filters.selectedCategories.isNotEmpty()) {
            filtered = filtered.filter { order ->
                filters.selectedCategories.contains(order.category)
            }
        }

        filters.priceRange?.let { range ->
            filtered = filtered.filter { order ->
                val minOk = range.min?.let { order.budget >= it } ?: true
                val maxOk = range.max?.let { order.budget <= it } ?: true
                minOk && maxOk
            }
        }

        filtered = when (filters.sortBy) {
            com.taskgoapp.taskgo.core.design.SortOption.NEWEST ->
                filtered.sortedByDescending { it.createdAt?.time ?: 0L }
            com.taskgoapp.taskgo.core.design.SortOption.RATING ->
                filtered // Ordens ainda n√£o possuem rating agregado
            else -> filtered
        }

        if (preferences.isNotEmpty()) {
            filtered = filtered.sortedBy { order ->
                val idx = preferences.indexOfFirst { it.equals(order.category, ignoreCase = true) }
                if (idx == -1) preferences.size else idx
            }
        }

        return filtered
    }

    private fun applyServiceFilters(
        services: List<ServiceFirestore>,
        providers: List<com.taskgoapp.taskgo.data.firestore.models.UserFirestore>,
        filters: FilterState,
        preferences: List<String>
    ): List<ServiceFirestore> {
        var filtered = services

        if (filters.searchQuery.isNotBlank()) {
            val query = filters.searchQuery.lowercase()
            filtered = filtered.filter { service ->
                service.title.lowercase().contains(query) ||
                    service.description.lowercase().contains(query) ||
                    service.category.lowercase().contains(query)
            }
        }

        if (filters.selectedCategories.isNotEmpty()) {
            // Filtrar servi√ßos cuja categoria corresponde OU prestador tem a categoria em preferredCategories
            val providerIdsWithCategory = providers
                .filter { provider ->
                    provider.preferredCategories?.any { category ->
                        filters.selectedCategories.contains(category)
                    } == true
                }
                .map { it.uid }
                .toSet()
            
            filtered = filtered.filter { service ->
                filters.selectedCategories.contains(service.category) ||
                providerIdsWithCategory.contains(service.providerId)
            }
        }

        filters.priceRange?.let { range ->
            filtered = filtered.filter { service ->
                val minOk = range.min?.let { service.price >= it } ?: true
                val maxOk = range.max?.let { service.price <= it } ?: true
                minOk && maxOk
            }
        }

        filtered = when (filters.sortBy) {
            com.taskgoapp.taskgo.core.design.SortOption.PRICE_LOW_TO_HIGH ->
                filtered.sortedBy { it.price }
            com.taskgoapp.taskgo.core.design.SortOption.PRICE_HIGH_TO_LOW ->
                filtered.sortedByDescending { it.price }
            com.taskgoapp.taskgo.core.design.SortOption.NEWEST ->
                filtered.sortedByDescending { it.createdAt?.time ?: 0L }
            com.taskgoapp.taskgo.core.design.SortOption.RATING ->
                filtered // Placeholder: servi√ßos ainda n√£o possuem rating
            else -> filtered
        }

        if (preferences.isNotEmpty()) {
            filtered = filtered.sortedBy { service ->
                val idx = preferences.indexOfFirst { it.equals(service.category, ignoreCase = true) }
                if (idx == -1) preferences.size else idx
            }
        }

        return filtered
    }

    private fun parsePreferredCategories(raw: String): List<String> {
        if (raw.isBlank() || raw == "[]") return emptyList()
        return raw
            .removePrefix("[")
            .removeSuffix("]")
            .split(",")
            .map { it.trim().removeSurrounding("\"") }
            .filter { it.isNotBlank() }
    }

    private fun loadServices() {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoading = true, error = null)
            try {
                // Os dados v√™m automaticamente via Flow do reposit√≥rio
                _uiState.value = _uiState.value.copy(isLoading = false)
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = e.message ?: "Erro ao carregar servi√ßos"
                )
            }
        }
    }

    fun refresh() {
        loadServices()
    }

    fun clearError() {
        _uiState.value = _uiState.value.copy(error = null)
    }
}


```

# Features - settings


## [FRONTEND]: feature/settings/presentation/AboutScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.settings.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.core.design.*
import com.taskgoapp.taskgo.core.theme.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AboutScreen(
    onBackClick: () -> Unit,
    onNavigateToPrivacyPolicy: () -> Unit = {},
    onNavigateToTermsOfService: () -> Unit = {}
) {
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Sobre",
                onBackClick = onBackClick
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp)
                .verticalScroll(rememberScrollState()),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // App Header
            Card(
                modifier = Modifier.fillMaxWidth(),
                colors = CardDefaults.cardColors(
                    containerColor = TaskGoBackgroundGray
                )
            ) {
                Column(
                    modifier = Modifier.padding(20.dp),
                    horizontalAlignment = Alignment.CenterHorizontally
                ) {
                    // App Icon
                    Surface(
                        modifier = Modifier.size(80.dp),
                        shape = MaterialTheme.shapes.large,
                        color = TaskGoTextBlack
                    ) {
                        Box(
                            contentAlignment = Alignment.Center
                        ) {
                            Icon(
                                imageVector = Icons.Default.Apps,
                                contentDescription = null,
                                modifier = Modifier.size(48.dp),
                                tint = TaskGoGreen
                            )
                        }
                    }
                    
                    Spacer(modifier = Modifier.height(16.dp))
                    
                    Text(
                        text = "TaskGo",
                        style = FigmaTitleLarge,
                        color = TaskGoTextBlack,
                        fontWeight = FontWeight.Bold
                    )
                    
                    Text(
                        text = "Vers√£o 1.0.0",
                        style = FigmaSectionTitle,
                        color = TaskGoTextBlack
                    )
                    
                    Spacer(modifier = Modifier.height(8.dp))
                    
                    Text(
                        text = "Conectando voc√™ aos melhores prestadores de servi√ßos",
                        style = FigmaProductDescription,
                        color = TaskGoTextBlack,
                        modifier = Modifier.padding(horizontal = 16.dp)
                    )
                }
            }
            
            // App Description
            Card(
                modifier = Modifier.fillMaxWidth(),
                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
            ) {
                Column(
                    modifier = Modifier.padding(16.dp)
                ) {
                    Text(
                        text = "Sobre o TaskGo",
                        style = FigmaSectionTitle,
                        color = TaskGoTextBlack,
                        fontWeight = FontWeight.Bold
                    )
                    
                    Spacer(modifier = Modifier.height(12.dp))
                    
                    Text(
                        text = "O TaskGo √© uma plataforma inovadora que conecta clientes a prestadores de servi√ßos qualificados e confi√°veis. Nossa miss√£o √© simplificar a contrata√ß√£o de servi√ßos, oferecendo uma experi√™ncia segura, transparente e eficiente.",
                        style = FigmaProductDescription,
                        color = TaskGoTextGray
                    )
                    
                    Spacer(modifier = Modifier.height(12.dp))
                    
                    Text(
                        text = "Com o TaskGo, voc√™ pode encontrar profissionais para diversos tipos de servi√ßos, desde reformas e manuten√ß√µes at√© servi√ßos especializados, tudo com avalia√ß√µes verificadas e garantia de qualidade.",
                        style = FigmaProductDescription,
                        color = TaskGoTextGray
                    )
                }
            }
            
            // Features
            Card(
                modifier = Modifier.fillMaxWidth(),
                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
            ) {
                Column(
                    modifier = Modifier.padding(16.dp)
                ) {
                    Text(
                        text = "Principais Funcionalidades",
                        style = FigmaSectionTitle,
                        color = TaskGoTextBlack,
                        fontWeight = FontWeight.Bold
                    )
                    
                    Spacer(modifier = Modifier.height(16.dp))
                    
                    val features = listOf(
                        "Busca inteligente de prestadores",
                        "Sistema de avalia√ß√µes e coment√°rios",
                        "Chat integrado para comunica√ß√£o",
                        "Pagamentos seguros (Pix, cart√µes)",
                        "Rastreamento de servi√ßos em tempo real",
                        "Hist√≥rico completo de transa√ß√µes",
                        "Suporte 24/7 via IA e humanos"
                    )
                    
                    features.forEach { feature ->
                        Row(
                            verticalAlignment = Alignment.CenterVertically,
                            modifier = Modifier.padding(vertical = 4.dp)
                        ) {
                            Icon(
                                imageVector = Icons.Default.Check,
                                contentDescription = null,
                                modifier = Modifier.size(16.dp),
                                tint = TaskGoGreen
                            )
                            Spacer(modifier = Modifier.width(8.dp))
                            Text(
                                text = feature,
                                style = FigmaProductDescription,
                                color = TaskGoTextBlack
                            )
                        }
                    }
                }
            }
            
            // Company Information
            Card(
                modifier = Modifier.fillMaxWidth(),
                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
            ) {
                Column(
                    modifier = Modifier.padding(16.dp)
                ) {
                    Text(
                        text = "Informa√ß√µes da Empresa",
                        style = FigmaSectionTitle,
                        color = TaskGoTextBlack,
                        fontWeight = FontWeight.Bold
                    )
                    
                    Spacer(modifier = Modifier.height(16.dp))
                    
                    // Company Name
                    Row(
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Icon(
                            imageVector = Icons.Default.Business,
                            contentDescription = null,
                            tint = TaskGoGreen
                        )
                        Spacer(modifier = Modifier.width(12.dp))
                        Column {
                            Text(
                                text = "Empresa",
                                style = FigmaProductName,
                                color = TaskGoTextBlack,
                                fontWeight = FontWeight.Medium
                            )
                            Text(
                                text = "TaskGo Tecnologia Ltda.",
                                style = FigmaProductDescription,
                                color = TaskGoTextGray
                            )
                        }
                    }
                    
                    Spacer(modifier = Modifier.height(12.dp))
                    
                    // CNPJ
                    Row(
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Icon(
                            imageVector = Icons.Default.Description,
                            contentDescription = null,
                            tint = TaskGoGreen
                        )
                        Spacer(modifier = Modifier.width(12.dp))
                        Column {
                            Text(
                                text = "CNPJ",
                                style = FigmaProductName,
                                color = TaskGoTextBlack,
                                fontWeight = FontWeight.Medium
                            )
                            Text(
                                text = "12.345.678/0001-90",
                                style = FigmaProductDescription,
                                color = TaskGoTextGray
                            )
                        }
                    }
                    
                    Spacer(modifier = Modifier.height(12.dp))
                    
                    // Address
                    Row(
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Icon(
                            imageVector = Icons.Default.LocationOn,
                            contentDescription = null,
                            tint = TaskGoGreen
                        )
                        Spacer(modifier = Modifier.width(12.dp))
                        Column {
                            Text(
                                text = "Endere√ßo",
                                style = FigmaProductName,
                                color = TaskGoTextBlack,
                                fontWeight = FontWeight.Medium
                            )
                            Text(
                                text = "Rua das Tecnologias, 123\nBairro da Inova√ß√£o\nS√£o Paulo - SP, 01234-567",
                                style = FigmaProductDescription,
                                color = TaskGoTextGray
                            )
                        }
                    }
                    
                    Spacer(modifier = Modifier.height(12.dp))
                    
                    // Website
                    Row(
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Icon(
                            imageVector = Icons.Default.Language,
                            contentDescription = null,
                            tint = TaskGoGreen
                        )
                        Spacer(modifier = Modifier.width(12.dp))
                        Column {
                            Text(
                                text = "Website",
                                style = FigmaProductName,
                                color = TaskGoTextBlack,
                                fontWeight = FontWeight.Medium
                            )
                            Text(
                                text = "www.taskgo.com.br",
                                style = FigmaProductDescription,
                                color = TaskGoTextGray
                            )
                        }
                    }
                }
            }
            
            // Contact Information
            Card(
                modifier = Modifier.fillMaxWidth(),
                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
            ) {
                Column(
                    modifier = Modifier.padding(16.dp)
                ) {
                    Text(
                        text = "Contato",
                        style = FigmaSectionTitle,
                        color = TaskGoTextBlack,
                        fontWeight = FontWeight.Bold
                    )
                    
                    Spacer(modifier = Modifier.height(16.dp))
                    
                    // Email
                    Row(
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Icon(
                            imageVector = Icons.Default.Email,
                            contentDescription = null,
                            tint = TaskGoGreen
                        )
                        Spacer(modifier = Modifier.width(12.dp))
                        Column {
                            Text(
                                text = "E-mail",
                                style = FigmaProductName,
                                color = TaskGoTextBlack,
                                fontWeight = FontWeight.Medium
                            )
                            Text(
                                text = "contato@taskgo.com.br",
                                style = FigmaProductDescription,
                                color = TaskGoTextGray
                            )
                        }
                    }
                    
                    Spacer(modifier = Modifier.height(12.dp))
                    
                    // Phone
                    Row(
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Icon(
                            imageVector = Icons.Default.Phone,
                            contentDescription = null,
                            tint = TaskGoGreen
                        )
                        Spacer(modifier = Modifier.width(12.dp))
                        Column {
                            Text(
                                text = "Telefone",
                                style = FigmaProductName,
                                color = TaskGoTextBlack,
                                fontWeight = FontWeight.Medium
                            )
                            Text(
                                text = "(11) 3000-0000",
                                style = FigmaProductDescription,
                                color = TaskGoTextGray
                            )
                        }
                    }
                    
                    Spacer(modifier = Modifier.height(12.dp))
                    
                    // Support
                    Row(
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Icon(
                            imageVector = Icons.Default.Support,
                            contentDescription = null,
                            tint = TaskGoGreen
                        )
                        Spacer(modifier = Modifier.width(12.dp))
                        Column {
                            Text(
                                text = "Suporte",
                                style = FigmaProductName,
                                color = TaskGoTextBlack,
                                fontWeight = FontWeight.Medium
                            )
                            Text(
                                text = "suporte@taskgo.com.br",
                                style = FigmaProductDescription,
                                color = TaskGoTextGray
                            )
                        }
                    }
                }
            }
            
            // Legal Information
            Card(
                modifier = Modifier.fillMaxWidth(),
                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
            ) {
                Column(
                    modifier = Modifier.padding(16.dp)
                ) {
                    Text(
                        text = "Informa√ß√µes Legais",
                        style = FigmaSectionTitle,
                        color = TaskGoTextBlack,
                        fontWeight = FontWeight.Bold
                    )
                    
                    Spacer(modifier = Modifier.height(16.dp))
                    
                    OutlinedButton(
                        onClick = onNavigateToPrivacyPolicy,
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Icon(
                            imageVector = Icons.Default.Policy,
                            contentDescription = null,
                            modifier = Modifier.size(18.dp)
                        )
                        Spacer(modifier = Modifier.width(8.dp))
                        Text("Pol√≠tica de Privacidade")
                    }
                    
                    Spacer(modifier = Modifier.height(12.dp))
                    
                    OutlinedButton(
                        onClick = onNavigateToTermsOfService,
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Icon(
                            imageVector = Icons.Default.Description,
                            contentDescription = null,
                            modifier = Modifier.size(18.dp)
                        )
                        Spacer(modifier = Modifier.width(8.dp))
                        Text("Termos de Uso")
                    }
                    
                    Spacer(modifier = Modifier.height(12.dp))
                    
                    OutlinedButton(
                        onClick = onNavigateToPrivacyPolicy,
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Icon(
                            imageVector = Icons.Default.Security,
                            contentDescription = null,
                            modifier = Modifier.size(18.dp)
                        )
                        Spacer(modifier = Modifier.width(8.dp))
                        Text("LGPD - Lei Geral de Prote√ß√£o de Dados")
                    }
                }
            }
            
            // Development Team
            Card(
                modifier = Modifier.fillMaxWidth(),
                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
            ) {
                Column(
                    modifier = Modifier.padding(16.dp)
                ) {
                    Text(
                        text = "Equipe de Desenvolvimento",
                        style = FigmaSectionTitle,
                        color = TaskGoTextBlack,
                        fontWeight = FontWeight.Bold
                    )
                    
                    Spacer(modifier = Modifier.height(16.dp))
                    
                    Text(
                        text = "O TaskGo foi desenvolvido por uma equipe dedicada de profissionais apaixonados por tecnologia e inova√ß√£o. Nossa equipe trabalha constantemente para melhorar a experi√™ncia do usu√°rio e adicionar novas funcionalidades.",
                        style = FigmaProductDescription,
                        color = TaskGoTextGray
                    )
                    
                    Spacer(modifier = Modifier.height(16.dp))
                    
                    OutlinedButton(
                        onClick = { /* TODO: Implementar p√°gina da equipe */ },
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Icon(
                            imageVector = Icons.Default.Group,
                            contentDescription = null,
                            modifier = Modifier.size(18.dp)
                        )
                        Spacer(modifier = Modifier.width(8.dp))
                        Text("Conhe√ßa Nossa Equipe")
                    }
                }
            }
            
            // App Statistics
            Card(
                modifier = Modifier.fillMaxWidth(),
                colors = CardDefaults.cardColors(
                    containerColor = TaskGoSurfaceGray
                )
            ) {
                Column(
                    modifier = Modifier.padding(16.dp),
                    horizontalAlignment = Alignment.CenterHorizontally
                ) {
                    Text(
                        text = "Estat√≠sticas do App",
                        style = FigmaSectionTitle,
                        color = TaskGoTextBlack,
                        fontWeight = FontWeight.Bold
                    )
                    
                    Spacer(modifier = Modifier.height(16.dp))
                    
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceEvenly
                    ) {
                        Column(
                            horizontalAlignment = Alignment.CenterHorizontally
                        ) {
                            Text(
                                text = "10K+",
                                style = FigmaPrice,
                                fontWeight = FontWeight.Bold,
                                color = TaskGoPriceGreen
                            )
                            Text(
                                text = "Usu√°rios Ativos",
                                style = FigmaStatusText,
                                color = TaskGoTextGray
                            )
                        }
                        
                        Column(
                            horizontalAlignment = Alignment.CenterHorizontally
                        ) {
                            Text(
                                text = "5K+",
                                style = FigmaPrice,
                                fontWeight = FontWeight.Bold,
                                color = TaskGoPriceGreen
                            )
                            Text(
                                text = "Prestadores",
                                style = FigmaStatusText,
                                color = TaskGoTextGray
                            )
                        }
                        
                        Column(
                            horizontalAlignment = Alignment.CenterHorizontally
                        ) {
                            Text(
                                text = "50K+",
                                style = FigmaPrice,
                                fontWeight = FontWeight.Bold,
                                color = TaskGoPriceGreen
                            )
                            Text(
                                text = "Servi√ßos",
                                style = FigmaStatusText,
                                color = TaskGoTextGray
                            )
                        }
                    }
                }
            }
            
            // Copyright
            Card(
                modifier = Modifier.fillMaxWidth(),
                colors = CardDefaults.cardColors(
                    containerColor = TaskGoSurfaceGray
                )
            ) {
                Column(
                    modifier = Modifier.padding(16.dp),
                    horizontalAlignment = Alignment.CenterHorizontally
                ) {
                    Text(
                        text = "¬© 2024 TaskGo Tecnologia Ltda.",
                        style = FigmaProductDescription,
                        color = TaskGoTextGray
                    )
                    
                    Text(
                        text = "Todos os direitos reservados.",
                        style = FigmaStatusText,
                        color = TaskGoTextGray
                    )
                    
                    Spacer(modifier = Modifier.height(8.dp))
                    
                    Text(
                        text = "Made with ‚ù§Ô∏è in Brazil",
                        style = FigmaStatusText,
                        color = TaskGoTextGray
                    )
                }
            }
        }
    }
}





```

## [FRONTEND]: feature/settings/presentation/AccountScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.settings.presentation

import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.PickVisualMediaRequest
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.background
import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import coil.compose.AsyncImage
import androidx.hilt.navigation.compose.hiltViewModel
import com.taskgoapp.taskgo.R
import com.taskgoapp.taskgo.core.design.*
import com.taskgoapp.taskgo.core.model.AccountType
import com.taskgoapp.taskgo.feature.profile.presentation.ProfileViewModel
import com.taskgoapp.taskgo.data.repository.FirestoreAccountChangeRepository
import com.google.firebase.auth.FirebaseAuth
import com.taskgoapp.taskgo.core.theme.*
import com.taskgoapp.taskgo.core.validation.CepService
import com.taskgoapp.taskgo.core.validation.DocumentValidator
import com.taskgoapp.taskgo.core.validation.ValidationResult
import kotlinx.coroutines.launch
import kotlinx.coroutines.delay
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.flow.first

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AccountScreen(
    onBackClick: () -> Unit,
    onNavigateToLogin: () -> Unit = {},
    onNavigateToBankAccounts: () -> Unit = {},
    viewModel: ProfileViewModel = hiltViewModel()
) {
    val state by viewModel.uiState.collectAsState()
    val scope = rememberCoroutineScope()
    val context = LocalContext.current
    val accountChangeRepository = remember { FirestoreAccountChangeRepository(com.taskgoapp.taskgo.core.firebase.FirestoreHelper.getInstance()) }
    val firebaseAuth = remember { FirebaseAuth.getInstance() }
    
    // Estados para di√°logo de solicita√ß√£o de mudan√ßa
    var showChangeAccountDialog by remember { mutableStateOf(false) }
    var selectedNewAccountType by remember { mutableStateOf<AccountType?>(null) }
    var isSubmittingRequest by remember { mutableStateOf(false) }
    var requestSuccessMessage by remember { mutableStateOf<String?>(null) }
    var requestErrorMessage by remember { mutableStateOf<String?>(null) }
    
    // Usar um escopo persistente para opera√ß√µes que precisam continuar ap√≥s o composable sair
    val persistentScope = remember {
        CoroutineScope(
            SupervisorJob() + Dispatchers.IO
        )
    }
    
    // Servi√ßos de valida√ß√£o e busca
    val cepService = remember { CepService() }
    val documentValidator = remember { DocumentValidator() }
    
    // Estados locais - inicializar apenas uma vez quando dados carregarem
    var editedName by remember { mutableStateOf("") }
    var editedEmail by remember { mutableStateOf("") }
    var editedPhone by remember { mutableStateOf("") }
    var editedCity by remember { mutableStateOf("") }
    var editedProfession by remember { mutableStateOf("") }
    var editedType by remember { mutableStateOf(AccountType.CLIENTE) } // Somente leitura agora
    
    // Novos campos
    var editedCpf by remember { mutableStateOf("") }
    var editedRg by remember { mutableStateOf("") }
    var editedState by remember { mutableStateOf("") }
    var editedCountry by remember { mutableStateOf("Brasil") }
    var editedStreet by remember { mutableStateOf("") }
    var editedNumber by remember { mutableStateOf("") }
    var editedNeighborhood by remember { mutableStateOf("") }
    var editedZipCode by remember { mutableStateOf("") }
    var editedComplement by remember { mutableStateOf("") }
    
    // Inicializar apenas uma vez quando dados estiverem dispon√≠veis
    var hasInitialized by remember { mutableStateOf(false) }
    LaunchedEffect(state.id, state.name) {
        if (!hasInitialized && state.id.isNotEmpty() && state.name.isNotEmpty()) {
            editedName = state.name
            editedEmail = state.email
            editedPhone = state.phone
            editedCity = state.city
            editedProfession = state.profession
            editedType = state.accountType
            editedCpf = state.cpf
            editedRg = state.rg
            editedState = state.state
            editedCountry = state.country.ifEmpty { "Brasil" }
            editedStreet = state.street
            editedNumber = state.number
            editedNeighborhood = state.neighborhood
            editedZipCode = state.zipCode
            editedComplement = state.complement
            hasInitialized = true
        }
    }
    
    // Estados de valida√ß√£o e loading
    var cpfError by remember { mutableStateOf<String?>(null) }
    var rgError by remember { mutableStateOf<String?>(null) }
    var cepError by remember { mutableStateOf<String?>(null) }
    var isLoadingCep by remember { mutableStateOf(false) }

    
    // Fun√ß√£o helper para salvar com retry e backoff
    suspend fun retrySaveWithBackoff(block: suspend () -> Unit) {
        var retryCount = 0
        val maxRetries = 3
        var delayMs = 1000L
        
        while (retryCount < maxRetries) {
            try {
                block()
                return // Sucesso, sair do loop
            } catch (e: Exception) {
                retryCount++
                val isSecureTokenError = e.message?.contains("SecureToken", ignoreCase = true) == true ||
                                        e.message?.contains("securetoken", ignoreCase = true) == true
                
                if (isSecureTokenError) {
                    android.util.Log.w("AccountScreen", "Erro do Secure Token API (configura√ß√£o do Google Cloud necess√°ria): ${e.message}")
                    // N√£o tentar novamente para erros de Secure Token API
                    break
                }
                
                if (retryCount < maxRetries) {
                    android.util.Log.w("AccountScreen", "Tentativa $retryCount/$maxRetries falhou, tentando novamente em ${delayMs}ms: ${e.message}")
                    delay(delayMs)
                    delayMs *= 2 // Backoff exponencial
                } else {
                    android.util.Log.e("AccountScreen", "Erro ao salvar ap√≥s $maxRetries tentativas: ${e.message}", e)
                }
            }
        }
    }
    
    // Debounce para salvar automaticamente ap√≥s 2 segundos de inatividade
    var saveJob by remember { mutableStateOf<Job?>(null) }
    
    LaunchedEffect(editedName, editedEmail, editedPhone, editedCity, editedProfession, 
                   editedCpf, editedRg, editedState, editedCountry, editedStreet, editedNumber, 
                   editedNeighborhood, editedZipCode, editedComplement) {
        if (hasInitialized) {
            // Cancelar job anterior
            saveJob?.cancel()
            
            // Atualizar ViewModel imediatamente
            viewModel.onNameChange(editedName)
            viewModel.onEmailChange(editedEmail)
            viewModel.onPhoneChange(editedPhone)
            viewModel.onCityChange(editedCity)
            viewModel.onProfessionChange(editedProfession)
            // N√£o alterar accountType aqui - apenas exibir o atual
            viewModel.onCpfChange(editedCpf)
            viewModel.onRgChange(editedRg)
            viewModel.onStateChange(editedState)
            viewModel.onCountryChange(editedCountry)
            viewModel.onStreetChange(editedStreet)
            viewModel.onNumberChange(editedNumber)
            viewModel.onNeighborhoodChange(editedNeighborhood)
            viewModel.onZipCodeChange(editedZipCode)
            viewModel.onComplementChange(editedComplement)
            
            // Criar novo job com debounce aumentado
            saveJob = persistentScope.launch {
                delay(2000) // 2 segundos de debounce para evitar cancelamentos
                retrySaveWithBackoff {
                    viewModel.save()
                    android.util.Log.d("AccountScreen", "Dados da conta salvos automaticamente")
                }
            }
        }
    }
    
    // Salvar quando sair da tela (garantir salvamento final)
    DisposableEffect(Unit) {
        onDispose {
            // Cancelar job pendente
            saveJob?.cancel()
            
            // Atualizar ViewModel com os valores finais
            viewModel.onNameChange(editedName)
            viewModel.onEmailChange(editedEmail)
            viewModel.onPhoneChange(editedPhone)
            viewModel.onCityChange(editedCity)
            viewModel.onProfessionChange(editedProfession)
            // N√£o alterar accountType aqui - apenas exibir o atual
            viewModel.onCpfChange(editedCpf)
            viewModel.onRgChange(editedRg)
            viewModel.onStateChange(editedState)
            viewModel.onCountryChange(editedCountry)
            viewModel.onStreetChange(editedStreet)
            viewModel.onNumberChange(editedNumber)
            viewModel.onNeighborhoodChange(editedNeighborhood)
            viewModel.onZipCodeChange(editedZipCode)
            viewModel.onComplementChange(editedComplement)
            
            // Salvar no Firebase usando escopo persistente com retry
            persistentScope.launch {
                retrySaveWithBackoff {
                    viewModel.save()
                    android.util.Log.d("AccountScreen", "Dados da conta salvos ao sair da tela")
                }
            }
        }
    }

    val focusManager = androidx.compose.ui.platform.LocalFocusManager.current
    val keyboardController = androidx.compose.ui.platform.LocalSoftwareKeyboardController.current
    
    Scaffold(
        topBar = {
            AppTopBar(
                title = stringResource(R.string.settings_account),
                onBackClick = onBackClick
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .clickable(
                    indication = null,
                    interactionSource = remember { androidx.compose.foundation.interaction.MutableInteractionSource() }
                ) {
                    focusManager.clearFocus()
                    keyboardController?.hide()
                }
        ) {
            // Cabe√ßalho com avatar, nome e fun√ß√£o
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(top = 16.dp),
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                CircularImageCropper(
                    currentImageUri = state.avatarUri,
                    onImageCropped = { uri ->
                        viewModel.onAvatarSelected(uri.toString())
                    },
                    modifier = Modifier,
                    size = 100.dp
                )
                Spacer(modifier = Modifier.height(8.dp))
                Text(
                    text = "Toque para alterar foto",
                    style = FigmaProductDescription,
                    color = TaskGoTextGray,
                    fontSize = 12.sp
                )
                Spacer(modifier = Modifier.height(12.dp))
                Text(text = editedName, style = FigmaProductName, color = TaskGoTextBlack, fontWeight = FontWeight.Bold)
                Text(text = editedProfession, style = FigmaProductDescription, color = TaskGoTextGray)
            }

            // Formul√°rio completo
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp)
                    .verticalScroll(rememberScrollState()),
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                // Informa√ß√µes Pessoais
                Text(
                    text = "Informa√ß√µes Pessoais",
                    style = FigmaProductName,
                    color = TaskGoTextBlack,
                    fontWeight = FontWeight.Bold,
                    modifier = Modifier.padding(bottom = 8.dp)
                )
                
                Text(text = "Nome Completo", style = FigmaButtonText, color = TaskGoTextBlack)
                OutlinedTextField(
                    value = editedName,
                    onValueChange = { editedName = it },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = true,
                    leadingIcon = { Icon(painter = painterResource(TGIcons.Profile), contentDescription = null) }
                )

                Text(text = "Email", style = FigmaButtonText, color = TaskGoTextBlack)
                OutlinedTextField(
                    value = editedEmail,
                    onValueChange = { editedEmail = it },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = true,
                    leadingIcon = { Icon(painter = painterResource(TGIcons.Info), contentDescription = null) }
                )

                Text(text = "Telefone", style = FigmaButtonText, color = TaskGoTextBlack)
                OutlinedTextField(
                    value = editedPhone,
                    onValueChange = { newValue ->
                        val cleanValue = newValue.replace(Regex("[^0-9]"), "")
                        if (cleanValue.length <= 11) {
                            editedPhone = com.taskgoapp.taskgo.core.utils.TextFormatters.formatPhone(cleanValue)
                        }
                    },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = true,
                    leadingIcon = { Icon(painter = painterResource(TGIcons.Phone), contentDescription = null) }
                )

                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    Column(modifier = Modifier.weight(1f)) {
                        Text(text = "CPF", style = FigmaButtonText, color = TaskGoTextBlack)
                        OutlinedTextField(
                            value = editedCpf,
                            onValueChange = { newValue ->
                                val cleanValue = newValue.replace(Regex("[^0-9]"), "")
                                if (cleanValue.length <= 11) {
                                    cpfError = null
                                    if (cleanValue.length == 11) {
                                        editedCpf = com.taskgoapp.taskgo.core.utils.TextFormatters.formatCpf(cleanValue)
                                        val validation = documentValidator.validateCpf(editedCpf)
                                        cpfError = if (validation is ValidationResult.Invalid) validation.message else null
                                    } else {
                                        editedCpf = cleanValue
                                    }
                                }
                            },
                            modifier = Modifier.fillMaxWidth(),
                            singleLine = true,
                            placeholder = { Text("000.000.000-00") },
                            isError = cpfError != null,
                            supportingText = cpfError?.let { { Text(it, color = MaterialTheme.colorScheme.error) } }
                        )
                    }
                    Column(modifier = Modifier.weight(1f)) {
                        Text(text = "RG", style = FigmaButtonText, color = TaskGoTextBlack)
                        OutlinedTextField(
                            value = editedRg,
                            onValueChange = { newValue ->
                                editedRg = newValue.uppercase()
                                if (editedRg.length >= 6) {
                                    val validation = documentValidator.validateRg(editedRg, editedState.takeIf { it.isNotEmpty() })
                                    rgError = if (validation is ValidationResult.Invalid) validation.message else null
                                } else {
                                    rgError = null
                                }
                            },
                            modifier = Modifier.fillMaxWidth(),
                            singleLine = true,
                            placeholder = { Text("00.000.000-0") },
                            isError = rgError != null,
                            supportingText = rgError?.let { { Text(it, color = MaterialTheme.colorScheme.error) } }
                        )
                    }
                }

                // Endere√ßo
                Spacer(modifier = Modifier.height(8.dp))
                Text(
                    text = "Endere√ßo",
                    style = FigmaProductName,
                    color = TaskGoTextBlack,
                    fontWeight = FontWeight.Bold,
                    modifier = Modifier.padding(bottom = 8.dp, top = 8.dp)
                )

                Text(text = "CEP", style = FigmaButtonText, color = TaskGoTextBlack)
                OutlinedTextField(
                    value = editedZipCode,
                    onValueChange = { newValue ->
                        val cleanValue = newValue.replace(Regex("[^0-9]"), "")
                        if (cleanValue.length <= 8) {
                            cepError = null
                            editedZipCode = com.taskgoapp.taskgo.core.utils.TextFormatters.formatCep(cleanValue)
                            
                            if (cleanValue.length == 8) {
                                
                                scope.launch {
                                    isLoadingCep = true
                                    cepError = null
                                    
                                    delay(500)
                                    
                                    cepService.searchCep(cleanValue).fold(
                                        onSuccess = { cepResult ->
                                            editedStreet = cepResult.logradouro
                                            editedNeighborhood = cepResult.bairro
                                            editedCity = cepResult.localidade
                                            editedState = cepResult.uf
                                            cepResult.complemento?.let { editedComplement = it }
                                            isLoadingCep = false
                                        },
                                        onFailure = { error ->
                                            cepError = error.message ?: "CEP n√£o encontrado"
                                            isLoadingCep = false
                                        }
                                    )
                                }
                            }
                        }
                    },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = true,
                    placeholder = { Text("00000-000") },
                    trailingIcon = {
                        if (isLoadingCep) {
                            CircularProgressIndicator(
                                modifier = Modifier.size(20.dp),
                                strokeWidth = 2.dp
                            )
                        }
                    },
                    isError = cepError != null,
                    supportingText = cepError?.let { { Text(it, color = MaterialTheme.colorScheme.error) } },
                    enabled = !isLoadingCep
                )

                Text(text = "Rua", style = FigmaButtonText, color = TaskGoTextBlack)
                OutlinedTextField(
                    value = editedStreet,
                    onValueChange = { editedStreet = it },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = true
                )

                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    Column(modifier = Modifier.weight(2f)) {
                        Text(text = "N√∫mero", style = FigmaButtonText, color = TaskGoTextBlack)
                        OutlinedTextField(
                            value = editedNumber,
                            onValueChange = { editedNumber = it },
                            modifier = Modifier.fillMaxWidth(),
                            singleLine = true
                        )
                    }
                    Column(modifier = Modifier.weight(3f)) {
                        Text(text = "Complemento", style = FigmaButtonText, color = TaskGoTextBlack)
                        OutlinedTextField(
                            value = editedComplement,
                            onValueChange = { editedComplement = it },
                            modifier = Modifier.fillMaxWidth(),
                            singleLine = true,
                            placeholder = { Text("Apto, Bloco, etc.") }
                        )
                    }
                }

                Text(text = "Bairro", style = FigmaButtonText, color = TaskGoTextBlack)
                OutlinedTextField(
                    value = editedNeighborhood,
                    onValueChange = { editedNeighborhood = it },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = true
                )

                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    Column(modifier = Modifier.weight(2f)) {
                        Text(text = "Cidade", style = FigmaButtonText, color = TaskGoTextBlack)
                        OutlinedTextField(
                            value = editedCity,
                            onValueChange = { editedCity = it },
                            modifier = Modifier.fillMaxWidth(),
                            singleLine = true
                        )
                    }
                    Column(modifier = Modifier.weight(1f)) {
                        Text(text = "Estado", style = FigmaButtonText, color = TaskGoTextBlack)
                        OutlinedTextField(
                            value = editedState,
                            onValueChange = { editedState = it },
                            modifier = Modifier.fillMaxWidth(),
                            singleLine = true,
                            placeholder = { Text("UF") }
                        )
                    }
                }

                Text(text = "Pa√≠s", style = FigmaButtonText, color = TaskGoTextBlack)
                OutlinedTextField(
                    value = editedCountry,
                    onValueChange = { editedCountry = it },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = true
                )

                // Tipo de Conta Atual (somente leitura)
                Spacer(modifier = Modifier.height(8.dp))
                Text(
                    text = "Tipo de Conta Atual",
                    style = FigmaProductName,
                    color = TaskGoTextBlack,
                    fontWeight = FontWeight.Bold,
                    modifier = Modifier.padding(bottom = 8.dp, top = 8.dp)
                )
                
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    colors = CardDefaults.cardColors(
                        containerColor = TaskGoSurface
                    )
                ) {
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(16.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(
                            text = when (editedType) {
                                AccountType.PARCEIRO -> "Parceiro"
                                AccountType.PRESTADOR -> "Parceiro" // Legacy
                                AccountType.VENDEDOR -> "Parceiro" // Legacy
                                AccountType.CLIENTE -> stringResource(R.string.profile_account_type_client)
                            },
                            style = FigmaProductName,
                            color = TaskGoTextBlack
                        )
                    }
                }
                
                Spacer(modifier = Modifier.height(16.dp))
                
                // Bot√£o para gerenciar contas banc√°rias (apenas para parceiros/vendedores)
                if (state.accountType == AccountType.PARCEIRO || state.accountType == AccountType.VENDEDOR || state.accountType == AccountType.PRESTADOR) {
                    Button(
                        onClick = { onNavigateToBankAccounts() },
                        modifier = Modifier.fillMaxWidth(),
                        colors = ButtonDefaults.buttonColors(
                            containerColor = TaskGoGreen
                        ),
                        shape = RoundedCornerShape(12.dp)
                    ) {
                        Text(
                            text = "Gerenciar Contas Banc√°rias",
                            style = FigmaButtonText,
                            color = Color.White,
                            fontWeight = FontWeight.Bold
                        )
                    }
                    
                    Spacer(modifier = Modifier.height(0.dp))
                }
                
                // Bot√£o para solicitar mudan√ßa de modo de conta
                Button(
                    onClick = { showChangeAccountDialog = true },
                    modifier = Modifier.fillMaxWidth(),
                    colors = ButtonDefaults.buttonColors(
                        containerColor = TaskGoGreen
                    ),
                    shape = RoundedCornerShape(12.dp)
                ) {
                    Text(
                        text = "Solicitar Mudan√ßa de Modo de Conta",
                        style = FigmaButtonText,
                        color = Color.White,
                        fontWeight = FontWeight.Bold
                    )
                }
                
                Spacer(modifier = Modifier.height(0.dp))
                
                // Bot√£o Sair da Conta
                Button(
                    onClick = {
                        // Fazer logout
                        firebaseAuth.signOut()
                        // Limpar cache local ao fazer logout
                        scope.launch(Dispatchers.IO) {
                            try {
                                val database = com.taskgoapp.taskgo.data.local.TaskGoDatabase.getDatabase(context)
                                // Limpar todos os dados do banco local
                                database.userProfileDao().clear()
                                database.productDao().getAll().forEach { database.productDao().delete(it) }
                                database.cartDao().clearAll()
                                database.addressDao().observeAll().first().forEach { database.addressDao().delete(it) }
                                database.cardDao().observeAll().first().forEach { database.cardDao().delete(it) }
                                // Limpar PreferencesManager
                                val preferencesManager = com.taskgoapp.taskgo.core.data.PreferencesManager(context)
                                preferencesManager.saveUserAvatarUri("")
                                preferencesManager.saveUserProfileImages(emptyList())
                            } catch (e: Exception) {
                                android.util.Log.e("AccountScreen", "Erro ao limpar cache: ${e.message}", e)
                            }
                        }
                        // Navegar para tela de login
                        onNavigateToLogin()
                    },
                    modifier = Modifier.fillMaxWidth(),
                    colors = ButtonDefaults.buttonColors(
                        containerColor = MaterialTheme.colorScheme.error
                    ),
                    shape = RoundedCornerShape(12.dp)
                ) {
                    Text(
                        text = stringResource(R.string.settings_logout),
                        style = FigmaButtonText,
                        color = Color.White,
                        fontWeight = FontWeight.Bold
                    )
                }
                
                Spacer(modifier = Modifier.height(32.dp))
            }
        }
    }
    
    // Di√°logo para solicitar mudan√ßa de modo de conta
    if (showChangeAccountDialog) {
        AlertDialog(
            onDismissRequest = { 
                showChangeAccountDialog = false
                selectedNewAccountType = null
                requestSuccessMessage = null
                requestErrorMessage = null
            },
            title = {
                Text(
                    text = "Solicitar Mudan√ßa de Modo de Conta",
                    style = FigmaProductName,
                    fontWeight = FontWeight.Bold
                )
            },
            text = {
                Column(
                    modifier = Modifier.fillMaxWidth(),
                    verticalArrangement = Arrangement.spacedBy(16.dp)
                ) {
                    Text(
                        text = "Selecione o novo modo de conta desejado. A mudan√ßa ser√° processada ap√≥s 1 dia √∫til.",
                        style = FigmaProductDescription,
                        color = TaskGoTextGray
                    )
                    
                    if (requestSuccessMessage != null) {
                        Text(
                            text = requestSuccessMessage!!,
                            style = FigmaProductDescription,
                            color = TaskGoGreen
                        )
                    }
                    
                    if (requestErrorMessage != null) {
                        Text(
                            text = requestErrorMessage!!,
                            style = FigmaProductDescription,
                            color = MaterialTheme.colorScheme.error
                        )
                    }
                    
                    Column(
                        verticalArrangement = Arrangement.spacedBy(12.dp)
                    ) {
                        // Op√ß√£o Parceiro (unifica√ß√£o de Prestador e Vendedor)
                        if (editedType != AccountType.PARCEIRO && editedType != AccountType.PRESTADOR && editedType != AccountType.VENDEDOR) {
                            Card(
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .clickable { selectedNewAccountType = AccountType.PARCEIRO },
                                colors = CardDefaults.cardColors(
                                    containerColor = if (selectedNewAccountType == AccountType.PARCEIRO) TaskGoGreen.copy(alpha = 0.1f) else TaskGoSurface
                                ),
                                border = if (selectedNewAccountType == AccountType.PARCEIRO) BorderStroke(2.dp, TaskGoGreen) else null
                            ) {
                                Row(
                                    modifier = Modifier
                                        .fillMaxWidth()
                                        .padding(16.dp),
                                    verticalAlignment = Alignment.CenterVertically
                                ) {
                                    RadioButton(
                                        selected = selectedNewAccountType == AccountType.PARCEIRO,
                                        onClick = { selectedNewAccountType = AccountType.PARCEIRO }
                                    )
                                    Spacer(modifier = Modifier.width(12.dp))
                                    Column(modifier = Modifier.weight(1f)) {
                                        Text(
                                            text = "Parceiro",
                                            style = FigmaProductName,
                                            color = TaskGoTextBlack,
                                            fontWeight = FontWeight.Medium
                                        )
                                        Text(
                                            text = "Oferecer servi√ßos e vender produtos",
                                            style = FigmaProductDescription,
                                            color = TaskGoTextGray,
                                            fontSize = 12.sp
                                        )
                                    }
                                }
                            }
                        }
                        
                        // Op√ß√£o Cliente
                        if (editedType != AccountType.CLIENTE) {
                            Card(
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .clickable { selectedNewAccountType = AccountType.CLIENTE },
                                colors = CardDefaults.cardColors(
                                    containerColor = if (selectedNewAccountType == AccountType.CLIENTE) TaskGoGreen.copy(alpha = 0.1f) else TaskGoSurface
                                ),
                                border = if (selectedNewAccountType == AccountType.CLIENTE) BorderStroke(2.dp, TaskGoGreen) else null
                            ) {
                                Row(
                                    modifier = Modifier
                                        .fillMaxWidth()
                                        .padding(16.dp),
                                    verticalAlignment = Alignment.CenterVertically
                                ) {
                                    RadioButton(
                                        selected = selectedNewAccountType == AccountType.CLIENTE,
                                        onClick = { selectedNewAccountType = AccountType.CLIENTE }
                                    )
                                    Spacer(modifier = Modifier.width(12.dp))
                                    Column(modifier = Modifier.weight(1f)) {
                                        Text(
                                            text = stringResource(R.string.profile_account_type_client),
                                            style = FigmaProductName,
                                            color = TaskGoTextBlack,
                                            fontWeight = FontWeight.Medium
                                        )
                                        Text(
                                            text = "Contratar servi√ßos e comprar produtos",
                                            style = FigmaProductDescription,
                                            color = TaskGoTextGray,
                                            fontSize = 12.sp
                                        )
                                    }
                                }
                            }
                        }
                    }
                }
            },
            confirmButton = {
                Button(
                    onClick = {
                        val userId = firebaseAuth.currentUser?.uid
                        if (userId != null && selectedNewAccountType != null) {
                            isSubmittingRequest = true
                            requestErrorMessage = null
                            requestSuccessMessage = null
                            
                            scope.launch {
                                val result = accountChangeRepository.createAccountChangeRequest(
                                    userId = userId,
                                    currentAccountType = editedType.name,
                                    requestedAccountType = selectedNewAccountType!!.name
                                )
                                
                                isSubmittingRequest = false
                                
                                result.fold(
                                    onSuccess = {
                                        requestSuccessMessage = "Solicita√ß√£o enviada com sucesso! A mudan√ßa ser√° processada ap√≥s 1 dia √∫til."
                                        // Fechar di√°logo ap√≥s 2 segundos
                                        kotlinx.coroutines.delay(2000)
                                        showChangeAccountDialog = false
                                        selectedNewAccountType = null
                                        requestSuccessMessage = null
                                    },
                                    onFailure = { exception ->
                                        requestErrorMessage = "Erro ao enviar solicita√ß√£o: ${exception.message}"
                                    }
                                )
                            }
                        } else {
                            requestErrorMessage = "Por favor, selecione um novo modo de conta"
                        }
                    },
                    enabled = !isSubmittingRequest && selectedNewAccountType != null,
                    colors = ButtonDefaults.buttonColors(
                        containerColor = TaskGoGreen
                    )
                ) {
                    if (isSubmittingRequest) {
                        CircularProgressIndicator(
                            modifier = Modifier.size(20.dp),
                            color = Color.White
                        )
                    } else {
                        Text("Enviar Solicita√ß√£o", color = Color.White)
                    }
                }
            },
            dismissButton = {
                TextButton(
                    onClick = { 
                        showChangeAccountDialog = false
                        selectedNewAccountType = null
                        requestSuccessMessage = null
                        requestErrorMessage = null
                    }
                ) {
                    Text("Cancelar", color = TaskGoTextGray)
                }
            }
        )
    }
    
}



```

## [FRONTEND]: feature/settings/presentation/AlterarSenhaScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.settings.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import com.taskgoapp.taskgo.core.theme.*
import androidx.hilt.navigation.compose.hiltViewModel
import com.taskgoapp.taskgo.feature.auth.presentation.AuthViewModel
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.core.design.AppTopBar

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AlterarSenhaScreen(
    onBackClick: () -> Unit,
    viewModel: AuthViewModel = hiltViewModel()
) {
    var novaSenha by remember { mutableStateOf("") }
    var repitaSenha by remember { mutableStateOf("") }
    var currentSenha by remember { mutableStateOf("") }
    val changeState = viewModel.changePasswordState.collectAsState().value

    Scaffold(
        topBar = { 
            AppTopBar(
                title = "Alterar Senha",
                onBackClick = onBackClick
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            Column {
                Text(
                    text = "Senha atual",
                    style = FigmaProductDescription,
                    color = TaskGoTextGray
                )
                Spacer(modifier = Modifier.height(8.dp))
                OutlinedTextField(
                    value = currentSenha,
                    onValueChange = { currentSenha = it },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = true,
                    label = { Text("Senha atual") }
                )
            }

            Column {
                Text(
                    text = "Nova senha",
                    style = FigmaProductDescription,
                    color = TaskGoTextGray
                )
                Spacer(modifier = Modifier.height(8.dp))
                OutlinedTextField(
                    value = novaSenha,
                    onValueChange = { novaSenha = it },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = true,
                    label = { Text("Nova senha") }
                )
            }

            Column {
                Text(
                    text = "Repita a nova senha",
                    style = FigmaProductDescription,
                    color = TaskGoTextGray
                )
                Spacer(modifier = Modifier.height(8.dp))
                OutlinedTextField(
                    value = repitaSenha,
                    onValueChange = { repitaSenha = it },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = true,
                    label = { Text("Repita a nova senha") }
                )
            }

            if (changeState.error != null) {
                Text(changeState.error, color = TaskGoError)
            }

            if (changeState.success) {
                Text("Senha alterada com sucesso!", color = TaskGoGreen)
            }

            Button(
                onClick = {
                    if (novaSenha == repitaSenha && novaSenha.isNotBlank() && currentSenha.isNotBlank()) {
                        viewModel.changePassword(currentSenha, novaSenha)
                    }
                },
                enabled = !changeState.isLoading && novaSenha == repitaSenha && novaSenha.isNotBlank() && currentSenha.isNotBlank(),
                modifier = Modifier.fillMaxWidth(),
                colors = ButtonDefaults.buttonColors(
                    containerColor = TaskGoErrorRed
                )
            ) {
                if (changeState.isLoading) {
                    CircularProgressIndicator(modifier = Modifier.size(20.dp))
                } else {
                    Text(
                        text = "Salvar Altera√ß√µes",
                        style = FigmaButtonText,
                        color = Color.White,
                        fontWeight = FontWeight.Bold
                    )
                }
            }
        }
    }
}

```

## [FRONTEND]: feature/settings/presentation/BankAccountScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.settings.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material.icons.filled.Edit
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.collectAsState
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.TextRange
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.input.TextFieldValue
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.design.OutlinedTextFieldWithValue
import com.taskgoapp.taskgo.core.theme.*
import com.taskgoapp.taskgo.core.data.BrazilianBanks
import com.taskgoapp.taskgo.core.utils.TextFormatters
import com.taskgoapp.taskgo.core.validation.DocumentValidator
import com.taskgoapp.taskgo.core.validation.ValidationResult
import com.taskgoapp.taskgo.data.firestore.models.BankAccount
import com.taskgoapp.taskgo.data.repository.FirestoreBankAccountRepository
import kotlinx.coroutines.launch
import kotlinx.coroutines.flow.asStateFlow
import androidx.lifecycle.viewModelScope
import javax.inject.Inject

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun BankAccountScreen(
    onBackClick: () -> Unit,
    onEditAccount: (String) -> Unit = { /* Fallback para dialog */ },
    viewModel: BankAccountViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    val scope = rememberCoroutineScope()
    
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Contas Banc√°rias",
                onBackClick = onBackClick
            )
        },
        floatingActionButton = {
            FloatingActionButton(
                onClick = { viewModel.showAddDialog() },
                containerColor = TaskGoGreen
            ) {
                Icon(
                    imageVector = Icons.Default.Add,
                    contentDescription = "Adicionar Conta",
                    tint = TaskGoBackgroundWhite
                )
            }
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            when {
                uiState.isLoading -> {
                    Box(
                        modifier = Modifier.fillMaxSize(),
                        contentAlignment = Alignment.Center
                    ) {
                        CircularProgressIndicator(color = TaskGoGreen)
                    }
                }
                uiState.error != null -> {
                    Column(
                        modifier = Modifier
                            .fillMaxSize()
                            .padding(16.dp),
                        horizontalAlignment = Alignment.CenterHorizontally,
                        verticalArrangement = Arrangement.Center
                    ) {
                        Text(
                            text = uiState.error ?: "Erro desconhecido",
                            style = MaterialTheme.typography.bodyLarge,
                            color = MaterialTheme.colorScheme.error
                        )
                        Spacer(modifier = Modifier.height(16.dp))
                        Button(
                            onClick = { viewModel.reload() },
                            colors = ButtonDefaults.buttonColors(containerColor = TaskGoGreen)
                        ) {
                            Text("Tentar Novamente")
                        }
                    }
                }
                uiState.accounts.isEmpty() -> {
                    Box(
                        modifier = Modifier.fillMaxSize(),
                        contentAlignment = Alignment.Center
                    ) {
                        Column(
                            horizontalAlignment = Alignment.CenterHorizontally,
                            verticalArrangement = Arrangement.spacedBy(16.dp)
                        ) {
                            Text(
                                text = "Nenhuma conta banc√°ria cadastrada",
                                style = MaterialTheme.typography.titleMedium,
                                color = TaskGoTextGray
                            )
                            Text(
                                text = "Toque no bot√£o + para adicionar uma conta",
                                style = MaterialTheme.typography.bodyMedium,
                                color = TaskGoTextGray
                            )
                        }
                    }
                }
                else -> {
                    LazyColumn(
                        modifier = Modifier.fillMaxSize(),
                        contentPadding = PaddingValues(16.dp),
                        verticalArrangement = Arrangement.spacedBy(12.dp)
                    ) {
                        items(uiState.accounts) { account ->
                            BankAccountCard(
                                account = account,
                                onEdit = { 
                                    // Navegar para tela de edi√ß√£o
                                    onEditAccount(account.id)
                                },
                                onDelete = { 
                                    scope.launch {
                                        viewModel.deleteAccount(account.id)
                                    }
                                },
                                onSetDefault = {
                                    scope.launch {
                                        viewModel.setDefaultAccount(account.id)
                                    }
                                }
                            )
                        }
                    }
                }
            }
        }
    }
    
    // Dialog para adicionar/editar conta
    if (uiState.showDialog) {
        BankAccountDialog(
            account = uiState.editingAccount,
            onDismiss = { viewModel.hideDialog() },
            onSave = { account ->
                scope.launch {
                    viewModel.saveAccount(account)
                }
            }
        )
    }
}

@Composable
private fun BankAccountCard(
    account: BankAccount,
    onEdit: () -> Unit,
    onDelete: () -> Unit,
    onSetDefault: () -> Unit
) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(
            containerColor = if (account.isDefault) TaskGoGreen.copy(alpha = 0.1f) else TaskGoSurface
        )
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Column(modifier = Modifier.weight(1f)) {
                    Text(
                        text = account.bankName,
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold,
                        color = TaskGoTextBlack
                    )
                    Text(
                        text = "${account.accountType} ‚Ä¢ Ag: ${account.agency} ‚Ä¢ Conta: ${account.account}",
                        style = MaterialTheme.typography.bodySmall,
                        color = TaskGoTextGray
                    )
                    Text(
                        text = account.accountHolderName,
                        style = MaterialTheme.typography.bodySmall,
                        color = TaskGoTextGray
                    )
                }
                if (account.isDefault) {
                    Surface(
                        shape = RoundedCornerShape(12.dp),
                        color = TaskGoGreen.copy(alpha = 0.2f)
                    ) {
                        Text(
                            text = "Padr√£o",
                            modifier = Modifier.padding(horizontal = 8.dp, vertical = 4.dp),
                            style = MaterialTheme.typography.labelSmall,
                            color = TaskGoGreen,
                            fontWeight = FontWeight.Medium
                        )
                    }
                }
            }
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                if (!account.isDefault) {
                    OutlinedButton(
                        onClick = onSetDefault,
                        modifier = Modifier.weight(1f),
                        colors = ButtonDefaults.outlinedButtonColors(
                            contentColor = TaskGoGreen
                        )
                    ) {
                        Text("Definir como Padr√£o")
                    }
                }
                OutlinedButton(
                    onClick = onEdit,
                    modifier = Modifier.weight(1f),
                    colors = ButtonDefaults.outlinedButtonColors(
                        contentColor = TaskGoTextBlack
                    )
                ) {
                    Icon(
                        imageVector = Icons.Default.Edit,
                        contentDescription = "Editar",
                        modifier = Modifier.size(18.dp)
                    )
                    Spacer(modifier = Modifier.width(4.dp))
                    Text("Editar")
                }
                OutlinedButton(
                    onClick = onDelete,
                    modifier = Modifier.weight(1f),
                    colors = ButtonDefaults.outlinedButtonColors(
                        contentColor = MaterialTheme.colorScheme.error
                    )
                ) {
                    Icon(
                        imageVector = Icons.Default.Delete,
                        contentDescription = "Excluir",
                        modifier = Modifier.size(18.dp)
                    )
                    Spacer(modifier = Modifier.width(4.dp))
                    Text("Excluir")
                }
            }
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
private fun BankAccountDialog(
    account: BankAccount?,
    onDismiss: () -> Unit,
    onSave: (BankAccount) -> Unit
) {
    val documentValidator = remember { DocumentValidator() }
    
    // Estados para banco
    var selectedBank by remember(account) { 
        mutableStateOf(
            if (account?.bankCode?.isNotEmpty() == true) {
                BrazilianBanks.getBankByCode(account.bankCode)
            } else null
        )
    }
    var bankExpanded by remember { mutableStateOf(false) }
    var bankSearchQuery by remember { mutableStateOf("") }
    val filteredBanks = remember(bankSearchQuery) {
        if (bankSearchQuery.isBlank()) {
            BrazilianBanks.banks.take(50) // Limitar a 50 para performance
        } else {
            BrazilianBanks.searchBanks(bankSearchQuery).take(50)
        }
    }
    
    // Estados para outros campos
    var agency by remember { mutableStateOf(account?.agency ?: "") }
    var accountNumber by remember { mutableStateOf(account?.account ?: "") }
    var accountType by remember { mutableStateOf(account?.accountType ?: "CHECKING") }
    var holderName by remember { mutableStateOf(account?.accountHolderName ?: "") }
    var holderDocument by remember(account?.accountHolderDocument, account?.accountHolderDocumentType) { 
        mutableStateOf(
            TextFieldValue(
                text = account?.accountHolderDocument ?: "",
                selection = TextRange(account?.accountHolderDocument?.length ?: 0)
            )
        )
    }
    var documentType by remember { mutableStateOf(account?.accountHolderDocumentType ?: "CPF") }
    var isDefault by remember { mutableStateOf(account?.isDefault ?: false) }
    
    // Valida√ß√µes
    var agencyError by remember { mutableStateOf<String?>(null) }
    var accountNumberError by remember { mutableStateOf<String?>(null) }
    var holderNameError by remember { mutableStateOf<String?>(null) }
    var documentError by remember { mutableStateOf<String?>(null) }
    
    // Atualizar banco quando selecionado
    LaunchedEffect(selectedBank) {
        if (selectedBank != null) {
            bankSearchQuery = ""
        }
    }
    
    // Validar documento quando mudar
    LaunchedEffect(holderDocument.text, documentType) {
        val cleanDoc = holderDocument.text.replace(Regex("[^0-9]"), "")
        if (cleanDoc.isNotEmpty()) {
            val validation = if (documentType == "CPF") {
                documentValidator.validateCpf(holderDocument.text)
            } else {
                documentValidator.validateCnpj(holderDocument.text)
            }
            documentError = if (validation is ValidationResult.Invalid) validation.message else null
        } else {
            documentError = null
        }
    }
    
    // Validar ag√™ncia
    val validateAgency: (String) -> Unit = { value ->
        val clean = value.replace(Regex("[^0-9]"), "")
        agencyError = when {
            clean.isEmpty() -> "Ag√™ncia √© obrigat√≥ria"
            clean.length < 4 -> "Ag√™ncia deve ter pelo menos 4 d√≠gitos"
            clean.length > 5 -> "Ag√™ncia deve ter no m√°ximo 5 d√≠gitos"
            else -> null
        }
    }
    
    // Validar conta
    val validateAccount: (String) -> Unit = { value ->
        val clean = value.replace(Regex("[^0-9]"), "")
        accountNumberError = when {
            clean.isEmpty() -> "N√∫mero da conta √© obrigat√≥rio"
            clean.length < 5 -> "Conta deve ter pelo menos 5 d√≠gitos"
            clean.length > 12 -> "Conta deve ter no m√°ximo 12 d√≠gitos"
            else -> null
        }
    }
    
    // Validar nome
    val validateName: (String) -> Unit = { value ->
        holderNameError = when {
            value.isBlank() -> "Nome do titular √© obrigat√≥rio"
            value.length < 3 -> "Nome deve ter pelo menos 3 caracteres"
            else -> null
        }
    }
    
    // Formata√ß√£o do documento
    val onDocumentChange: (TextFieldValue) -> Unit = { newValue ->
        val formatted = if (documentType == "CPF") {
            TextFormatters.formatCpfWithCursor(newValue)
        } else {
            TextFormatters.formatCnpjWithCursor(newValue)
        }
        holderDocument = formatted
    }
    
    // Verificar se pode salvar
    val canSave = selectedBank != null &&
            agencyError == null &&
            accountNumberError == null &&
            holderNameError == null &&
            documentError == null &&
            agency.isNotBlank() &&
            accountNumber.isNotBlank() &&
            holderName.isNotBlank() &&
            holderDocument.text.replace(Regex("[^0-9]"), "").isNotEmpty()
    
    AlertDialog(
        onDismissRequest = onDismiss,
        title = { 
            Text(
                text = if (account == null) "Adicionar Conta Banc√°ria" else "Editar Conta Banc√°ria",
                fontWeight = FontWeight.Bold
            ) 
        },
        text = {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .verticalScroll(rememberScrollState()),
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                // Sele√ß√£o de Banco
                ExposedDropdownMenuBox(
                    expanded = bankExpanded,
                    onExpandedChange = { bankExpanded = it }
                ) {
                    OutlinedTextField(
                        value = if (selectedBank != null) "${selectedBank!!.code} - ${selectedBank!!.name}" else bankSearchQuery,
                        onValueChange = { 
                            bankSearchQuery = it
                            bankExpanded = true
                            if (it.isBlank()) {
                                selectedBank = null
                            }
                        },
                        label = { Text("Banco *") },
                        placeholder = { Text("Busque por nome ou c√≥digo (ex: 001, Ita√∫)") },
                        trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = bankExpanded) },
                        modifier = Modifier
                            .fillMaxWidth()
                            .menuAnchor(),
                        readOnly = selectedBank != null,
                        colors = OutlinedTextFieldDefaults.colors(
                            focusedBorderColor = if (selectedBank == null && agency.isNotBlank()) MaterialTheme.colorScheme.error else TaskGoGreen,
                            unfocusedBorderColor = if (selectedBank == null && agency.isNotBlank()) MaterialTheme.colorScheme.error else TaskGoTextGray
                        ),
                        singleLine = true
                    )
                    
                    ExposedDropdownMenu(
                        expanded = bankExpanded,
                        onDismissRequest = { bankExpanded = false },
                        modifier = Modifier.heightIn(max = 300.dp)
                    ) {
                        if (filteredBanks.isEmpty()) {
                            DropdownMenuItem(
                                text = { Text("Nenhum banco encontrado") },
                                onClick = { bankExpanded = false }
                            )
                        } else {
                            filteredBanks.forEach { bank ->
                                DropdownMenuItem(
                                    text = { Text("${bank.code} - ${bank.name}") },
                                    onClick = {
                                        selectedBank = bank
                                        bankExpanded = false
                                        bankSearchQuery = ""
                                    }
                                )
                            }
                        }
                    }
                }
                
                // Ag√™ncia
                OutlinedTextField(
                    value = agency,
                    onValueChange = { 
                        agency = it.filter { char -> char.isDigit() }
                        validateAgency(agency)
                    },
                    label = { Text("Ag√™ncia *") },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = true,
                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
                    isError = agencyError != null,
                    supportingText = agencyError?.let { { Text(it, color = MaterialTheme.colorScheme.error) } }
                )
                
                // N√∫mero da Conta
                OutlinedTextField(
                    value = accountNumber,
                    onValueChange = { 
                        accountNumber = it.filter { char -> char.isDigit() }
                        validateAccount(accountNumber)
                    },
                    label = { Text("N√∫mero da Conta *") },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = true,
                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
                    isError = accountNumberError != null,
                    supportingText = accountNumberError?.let { { Text(it, color = MaterialTheme.colorScheme.error) } }
                )
                
                // Tipo de Conta
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    FilterChip(
                        selected = accountType == "CHECKING",
                        onClick = { accountType = "CHECKING" },
                        label = { Text("Conta Corrente") },
                        modifier = Modifier.weight(1f)
                    )
                    FilterChip(
                        selected = accountType == "SAVINGS",
                        onClick = { accountType = "SAVINGS" },
                        label = { Text("Poupan√ßa") },
                        modifier = Modifier.weight(1f)
                    )
                }
                
                // Nome do Titular
                OutlinedTextField(
                    value = holderName,
                    onValueChange = { 
                        holderName = it
                        validateName(holderName)
                    },
                    label = { Text("Nome do Titular *") },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = true,
                    isError = holderNameError != null,
                    supportingText = holderNameError?.let { { Text(it, color = MaterialTheme.colorScheme.error) } }
                )
                
                // Tipo de Documento
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    FilterChip(
                        selected = documentType == "CPF",
                        onClick = { 
                            documentType = "CPF"
                            holderDocument = TextFieldValue("")
                            documentError = null
                        },
                        label = { Text("CPF") },
                        modifier = Modifier.weight(1f)
                    )
                    FilterChip(
                        selected = documentType == "CNPJ",
                        onClick = { 
                            documentType = "CNPJ"
                            holderDocument = TextFieldValue("")
                            documentError = null
                        },
                        label = { Text("CNPJ") },
                        modifier = Modifier.weight(1f)
                    )
                }
                
                // Documento (CPF/CNPJ)
                OutlinedTextFieldWithValue(
                    value = holderDocument,
                    onValueChange = onDocumentChange,
                    label = { Text(if (documentType == "CPF") "CPF *" else "CNPJ *") },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = true,
                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
                    isError = documentError != null,
                    supportingText = documentError?.let { { Text(it, color = MaterialTheme.colorScheme.error) } }
                )
                
                // Conta Padr√£o
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Checkbox(
                        checked = isDefault,
                        onCheckedChange = { isDefault = it }
                    )
                    Text(
                        text = "Definir como conta padr√£o",
                        style = MaterialTheme.typography.bodyMedium,
                        modifier = Modifier.weight(1f)
                    )
                }
            }
        },
        confirmButton = {
            Button(
                onClick = {
                    val cleanDocument = holderDocument.text.replace(Regex("[^0-9]"), "")
                    // CR√çTICO: Preservar o ID ao editar, criar novo ID ao adicionar
                    val newAccount = if (account != null) {
                        // Editando - preservar ID e outros campos
                        account.copy(
                            bankName = selectedBank?.name ?: "",
                            bankCode = selectedBank?.code ?: "",
                            agency = agency,
                            account = accountNumber,
                            accountType = accountType,
                            accountHolderName = holderName,
                            accountHolderDocument = cleanDocument,
                            accountHolderDocumentType = documentType,
                            isDefault = isDefault
                        )
                    } else {
                        // Criando nova conta
                        BankAccount(
                            id = "", // Ser√° gerado pelo Firestore
                            bankName = selectedBank?.name ?: "",
                            bankCode = selectedBank?.code ?: "",
                            agency = agency,
                            account = accountNumber,
                            accountType = accountType,
                            accountHolderName = holderName,
                            accountHolderDocument = cleanDocument,
                            accountHolderDocumentType = documentType,
                            isDefault = isDefault
                        )
                    }
                    android.util.Log.d("BankAccountDialog", "Salvando conta - ID: ${newAccount.id}, isNew: ${account == null}")
                    onSave(newAccount)
                },
                enabled = canSave,
                colors = ButtonDefaults.buttonColors(
                    containerColor = TaskGoGreen,
                    disabledContainerColor = TaskGoTextGray.copy(alpha = 0.3f)
                )
            ) {
                Text("Salvar")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Cancelar")
            }
        }
    )
}

data class BankAccountUiState(
    val accounts: List<BankAccount> = emptyList(),
    val isLoading: Boolean = false,
    val showDialog: Boolean = false,
    val editingAccount: BankAccount? = null,
    val error: String? = null
)

@dagger.hilt.android.lifecycle.HiltViewModel
class BankAccountViewModel @Inject constructor(
    private val repository: FirestoreBankAccountRepository
) : androidx.lifecycle.ViewModel() {
    
    private val _uiState = kotlinx.coroutines.flow.MutableStateFlow(BankAccountUiState())
    val uiState: kotlinx.coroutines.flow.StateFlow<BankAccountUiState> = _uiState.asStateFlow()
    
    init {
        reload()
    }
    
    fun reload() {
        viewModelScope.launch {
            try {
                _uiState.value = _uiState.value.copy(isLoading = true, error = null)
                repository.observeUserBankAccounts().collect { accounts ->
                    _uiState.value = _uiState.value.copy(
                        accounts = accounts,
                        isLoading = false,
                        error = null
                    )
                }
            } catch (e: Exception) {
                android.util.Log.e("BankAccountVM", "Erro ao observar contas banc√°rias: ${e.message}", e)
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = e.message ?: "Erro ao carregar contas banc√°rias",
                    accounts = emptyList()
                )
            }
        }
    }
    
    fun showAddDialog() {
        _uiState.value = _uiState.value.copy(
            showDialog = true,
            editingAccount = null
        )
    }
    
    fun showEditDialog(account: BankAccount) {
        _uiState.value = _uiState.value.copy(
            showDialog = true,
            editingAccount = account
        )
    }
    
    fun hideDialog() {
        _uiState.value = _uiState.value.copy(
            showDialog = false,
            editingAccount = null
        )
    }
    
    suspend fun saveAccount(account: BankAccount) {
        _uiState.value = _uiState.value.copy(error = null, isLoading = true)
        android.util.Log.d("BankAccountVM", "Salvando conta banc√°ria - ID: ${account.id}, isNew: ${account.id.isBlank()}")
        
        repository.saveBankAccount(account).fold(
            onSuccess = { accountId ->
                android.util.Log.d("BankAccountVM", "Conta banc√°ria salva com sucesso: $accountId")
                _uiState.value = _uiState.value.copy(isLoading = false)
                hideDialog()
                reload()
            },
            onFailure = { e ->
                android.util.Log.e("BankAccountVM", "Erro ao salvar conta: ${e.message}", e)
                android.util.Log.e("BankAccountVM", "Stack trace:", e)
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = e.message ?: "Erro ao salvar conta banc√°ria"
                )
            }
        )
    }
    
    suspend fun deleteAccount(accountId: String) {
        _uiState.value = _uiState.value.copy(error = null)
        repository.deleteBankAccount(accountId).fold(
            onSuccess = {},
            onFailure = { e ->
                android.util.Log.e("BankAccountVM", "Erro ao deletar conta: ${e.message}", e)
                _uiState.value = _uiState.value.copy(
                    error = e.message ?: "Erro ao deletar conta banc√°ria"
                )
            }
        )
        reload()
    }
    
    suspend fun setDefaultAccount(accountId: String) {
        val account = _uiState.value.accounts.find { it.id == accountId }
        if (account != null) {
            saveAccount(account.copy(isDefault = true))
        }
    }
}


```

## [FRONTEND]: feature/settings/presentation/ConfiguracoesScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.settings.presentation

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowForward
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.collectAsState
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.theme.*
import com.taskgoapp.taskgo.core.model.AccountType
import com.taskgoapp.taskgo.feature.profile.presentation.ProfileViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ConfiguracoesScreen(
    onBackClick: () -> Unit,
    onConta: () -> Unit,
    onPreferencias: () -> Unit,
    onNotificacoes: () -> Unit,
    onIdioma: () -> Unit,
    onPrivacidade: () -> Unit,
    onSuporte: () -> Unit,
    onSobre: () -> Unit,
    onAiSupport: () -> Unit,
    onSeguranca: () -> Unit = {},
    viewModel: ProfileViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    val accountType = uiState.accountType
    val isPartner = accountType == AccountType.PARCEIRO || 
                    accountType == AccountType.PRESTADOR || 
                    accountType == AccountType.VENDEDOR
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Configura√ß√µes",
                onBackClick = onBackClick
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            Card(
                modifier = Modifier.fillMaxWidth(),
                colors = CardDefaults.cardColors(
                    containerColor = TaskGoSurface
                )
            ) {
                Column {
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .clickable { onConta() }
                            .padding(horizontal = 16.dp, vertical = 14.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(
                            text = "Conta",
                            style = FigmaProductName,
                            color = TaskGoTextBlack,
                            modifier = Modifier.weight(1f)
                        )
                        Icon(
                            imageVector = Icons.AutoMirrored.Filled.ArrowForward,
                            contentDescription = null,
                            tint = TaskGoTextGray
                        )
                    }
                    HorizontalDivider(thickness = 0.5.dp, color = TaskGoDivider)
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .clickable { onSeguranca() }
                            .padding(horizontal = 16.dp, vertical = 14.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(
                            text = "Seguran√ßa",
                            style = FigmaProductName,
                            color = TaskGoTextBlack,
                            modifier = Modifier.weight(1f)
                        )
                        Icon(
                            imageVector = Icons.AutoMirrored.Filled.ArrowForward,
                            contentDescription = null,
                            tint = TaskGoTextGray
                        )
                    }
                    HorizontalDivider(thickness = 0.5.dp, color = TaskGoDivider)
                    // Prefer√™ncias: remover para modo PARCEIRO
                    if (!isPartner) {
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .clickable { onPreferencias() }
                                .padding(horizontal = 16.dp, vertical = 14.dp),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Text(
                                text = "Prefer√™ncias",
                                style = FigmaProductName,
                                color = TaskGoTextBlack,
                                modifier = Modifier.weight(1f)
                            )
                            Icon(
                                imageVector = Icons.AutoMirrored.Filled.ArrowForward,
                                contentDescription = null,
                                tint = TaskGoTextGray
                            )
                        }
                        HorizontalDivider(thickness = 0.5.dp, color = TaskGoDivider)
                    }
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .clickable { onNotificacoes() }
                            .padding(horizontal = 16.dp, vertical = 14.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(
                            text = "Notifica√ß√µes",
                            style = FigmaProductName,
                            color = TaskGoTextBlack,
                            modifier = Modifier.weight(1f)
                        )
                        Icon(
                            imageVector = Icons.AutoMirrored.Filled.ArrowForward,
                            contentDescription = null,
                            tint = TaskGoTextGray
                        )
                    }
                    // Idioma removido
                    HorizontalDivider(thickness = 0.5.dp, color = TaskGoDivider)
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .clickable { onPrivacidade() }
                            .padding(horizontal = 16.dp, vertical = 14.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(
                            text = "Privacidade",
                            style = FigmaProductName,
                            color = TaskGoTextBlack,
                            modifier = Modifier.weight(1f)
                        )
                        Icon(
                            imageVector = Icons.AutoMirrored.Filled.ArrowForward,
                            contentDescription = null,
                            tint = TaskGoTextGray
                        )
                    }
                    HorizontalDivider(thickness = 0.5.dp, color = TaskGoDivider)
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .clickable { onSuporte() }
                            .padding(horizontal = 16.dp, vertical = 14.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(
                            text = "Suporte",
                            style = FigmaProductName,
                            color = TaskGoTextBlack,
                            modifier = Modifier.weight(1f)
                        )
                        Icon(
                            imageVector = Icons.AutoMirrored.Filled.ArrowForward,
                            contentDescription = null,
                            tint = TaskGoTextGray
                        )
                    }
                    HorizontalDivider(thickness = 0.5.dp, color = TaskGoDivider)
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .clickable { onAiSupport() }
                            .padding(horizontal = 16.dp, vertical = 14.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(
                            text = "Suporte com IA",
                            style = FigmaProductName,
                            color = TaskGoTextBlack,
                            modifier = Modifier.weight(1f)
                        )
                        Icon(
                            imageVector = Icons.AutoMirrored.Filled.ArrowForward,
                            contentDescription = null,
                            tint = TaskGoTextGray
                        )
                    }
                    HorizontalDivider(thickness = 0.5.dp, color = TaskGoDivider)
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .clickable { onSobre() }
                            .padding(horizontal = 16.dp, vertical = 14.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(
                            text = "Sobre",
                            style = FigmaProductName,
                            color = TaskGoTextBlack,
                            modifier = Modifier.weight(1f)
                        )
                        Icon(
                            imageVector = Icons.AutoMirrored.Filled.ArrowForward,
                            contentDescription = null,
                            tint = TaskGoTextGray
                        )
                    }
                }
            }
        }
    }
}

```

## [FRONTEND]: feature/settings/presentation/ConsentHistoryScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.settings.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import com.google.firebase.auth.FirebaseAuth
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.security.ConsentRecord
import com.taskgoapp.taskgo.core.security.ConsentType
import com.taskgoapp.taskgo.core.security.LGPDComplianceManager
import com.taskgoapp.taskgo.core.theme.*
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.launch
import java.text.SimpleDateFormat
import java.util.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ConsentHistoryScreen(
    onBackClick: () -> Unit
) {
    val context = LocalContext.current
    val lgpdManager = remember(context) {
        LGPDComplianceManager(
            context,
            com.taskgoapp.taskgo.core.firebase.FirestoreHelper.getInstance()
        )
    }
    val auth = FirebaseAuth.getInstance()
    val currentUser = auth.currentUser
    var consentHistory by remember { mutableStateOf<List<ConsentRecord>>(emptyList()) }
    var isLoading by remember { mutableStateOf(true) }
    var error by remember { mutableStateOf<String?>(null) }
    
    val persistentScope = remember {
        CoroutineScope(SupervisorJob() + Dispatchers.IO)
    }
    
    LaunchedEffect(Unit) {
        if (currentUser != null) {
            isLoading = true
            error = null
            persistentScope.launch {
                val result = lgpdManager.getConsentHistory(currentUser.uid)
                result.fold(
                    onSuccess = { history ->
                        consentHistory = history
                        isLoading = false
                    },
                    onFailure = { e ->
                        error = "Erro ao carregar hist√≥rico: ${e.message}"
                        isLoading = false
                    }
                )
            }
        } else {
            error = "Usu√°rio n√£o autenticado"
            isLoading = false
        }
    }
    
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Hist√≥rico de Consentimentos",
                onBackClick = onBackClick
            )
        }
    ) { paddingValues ->
        when {
            isLoading -> {
                Box(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(paddingValues),
                    contentAlignment = Alignment.Center
                ) {
                    CircularProgressIndicator()
                }
            }
            error != null -> {
                Column(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(paddingValues)
                        .padding(16.dp),
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.Center
                ) {
                    Icon(
                        imageVector = Icons.Default.Error,
                        contentDescription = "Erro",
                        tint = TaskGoError,
                        modifier = Modifier.size(64.dp)
                    )
                    Spacer(modifier = Modifier.height(16.dp))
                    Text(
                        text = error ?: "Erro desconhecido",
                        color = TaskGoError,
                        style = MaterialTheme.typography.bodyLarge
                    )
                }
            }
            consentHistory.isEmpty() -> {
                Column(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(paddingValues)
                        .padding(16.dp),
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.Center
                ) {
                    Icon(
                        imageVector = Icons.Default.History,
                        contentDescription = "Sem hist√≥rico",
                        tint = TaskGoTextGray,
                        modifier = Modifier.size(64.dp)
                    )
                    Spacer(modifier = Modifier.height(16.dp))
                    Text(
                        text = "Nenhum consentimento registrado",
                        color = TaskGoTextGray,
                        style = MaterialTheme.typography.bodyLarge
                    )
                }
            }
            else -> {
                LazyColumn(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(paddingValues),
                    contentPadding = PaddingValues(16.dp),
                    verticalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    item {
                        Text(
                            text = "Seus consentimentos de dados",
                            style = MaterialTheme.typography.titleLarge,
                            fontWeight = FontWeight.Bold,
                            color = TaskGoTextDark,
                            modifier = Modifier.padding(bottom = 8.dp)
                        )
                        Text(
                            text = "Total: ${consentHistory.size} registro(s)",
                            style = MaterialTheme.typography.bodyMedium,
                            color = TaskGoTextGray,
                            modifier = Modifier.padding(bottom = 16.dp)
                        )
                    }
                    
                    items(consentHistory) { consent ->
                        ConsentHistoryCard(consent = consent)
                    }
                }
            }
        }
    }
}

@Composable
private fun ConsentHistoryCard(
    consent: ConsentRecord,
    modifier: Modifier = Modifier
) {
    val dateFormat = SimpleDateFormat("dd/MM/yyyy HH:mm", Locale.getDefault())
    val dateString = dateFormat.format(Date(consent.timestamp))
    
    val consentTypeLabel = when (consent.type) {
        ConsentType.ANALYTICS -> "Analytics"
        ConsentType.MARKETING -> "Marketing"
        ConsentType.PERSONALIZATION -> "Personaliza√ß√£o"
        ConsentType.LOCATION -> "Localiza√ß√£o"
        ConsentType.CAMERA -> "C√¢mera"
        ConsentType.CONTACTS -> "Contatos"
        ConsentType.STORAGE -> "Armazenamento"
    }
    
    Card(
        modifier = modifier.fillMaxWidth(),
        shape = RoundedCornerShape(12.dp),
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp),
        colors = CardDefaults.cardColors(
            containerColor = if (consent.granted) {
                TaskGoGreen.copy(alpha = 0.1f)
            } else {
                TaskGoError.copy(alpha = 0.1f)
            }
        )
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = consentTypeLabel,
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold,
                    color = TaskGoTextDark
                )
                
                Surface(
                    color = if (consent.granted) TaskGoGreen else TaskGoError,
                    shape = RoundedCornerShape(8.dp)
                ) {
                    Text(
                        text = if (consent.granted) "Aceito" else "Negado",
                        modifier = Modifier.padding(horizontal = 12.dp, vertical = 4.dp),
                        color = Color.White,
                        fontWeight = FontWeight.Bold,
                        style = MaterialTheme.typography.labelSmall
                    )
                }
            }
            
            if (consent.purpose.isNotBlank()) {
                Text(
                    text = "Finalidade: ${consent.purpose}",
                    style = MaterialTheme.typography.bodyMedium,
                    color = TaskGoTextGray
                )
            }
            
            Row(
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.spacedBy(4.dp)
            ) {
                Icon(
                    imageVector = Icons.Default.Schedule,
                    contentDescription = "Data",
                    tint = TaskGoTextGray,
                    modifier = Modifier.size(16.dp)
                )
                Text(
                    text = dateString,
                    style = MaterialTheme.typography.bodySmall,
                    color = TaskGoTextGray
                )
            }
        }
    }
}


```

## [FRONTEND]: feature/settings/presentation/EditBankAccountScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.settings.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.collectAsState
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.TextRange
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.input.TextFieldValue
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.design.OutlinedTextFieldWithValue
import com.taskgoapp.taskgo.core.theme.*
import com.taskgoapp.taskgo.core.data.BrazilianBanks
import com.taskgoapp.taskgo.core.utils.TextFormatters
import com.taskgoapp.taskgo.core.validation.DocumentValidator
import com.taskgoapp.taskgo.core.validation.ValidationResult
import com.taskgoapp.taskgo.data.firestore.models.BankAccount
import kotlinx.coroutines.launch

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun EditBankAccountScreen(
    accountId: String,
    onBackClick: () -> Unit,
    viewModel: BankAccountViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    val scope = rememberCoroutineScope()
    
    // Carregar conta ao entrar na tela
    LaunchedEffect(accountId) {
        val account = uiState.accounts.find { it.id == accountId }
        if (account != null) {
            viewModel.showEditDialog(account)
        }
    }
    
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Editar Conta Banc√°ria",
                onBackClick = onBackClick
            )
        }
    ) { paddingValues ->
        if (uiState.editingAccount == null) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues),
                contentAlignment = Alignment.Center
            ) {
                CircularProgressIndicator(color = TaskGoGreen)
            }
        } else {
            EditBankAccountForm(
                account = uiState.editingAccount!!,
                onSave = { account ->
                    scope.launch {
                        viewModel.saveAccount(account)
                        if (uiState.error == null) {
                            onBackClick()
                        }
                    }
                },
                onCancel = onBackClick,
                isLoading = uiState.isLoading,
                error = uiState.error,
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues)
            )
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
private fun EditBankAccountForm(
    account: BankAccount,
    onSave: (BankAccount) -> Unit,
    onCancel: () -> Unit,
    isLoading: Boolean,
    error: String?,
    modifier: Modifier = Modifier
) {
    val documentValidator = remember { DocumentValidator() }
    
    // Estados para banco
    var selectedBank by remember(account) { 
        mutableStateOf(
            if (account.bankCode.isNotEmpty()) {
                BrazilianBanks.getBankByCode(account.bankCode)
            } else null
        )
    }
    var bankExpanded by remember { mutableStateOf(false) }
    var bankSearchQuery by remember { mutableStateOf("") }
    val filteredBanks = remember(bankSearchQuery) {
        if (bankSearchQuery.isBlank()) {
            BrazilianBanks.banks.take(50)
        } else {
            BrazilianBanks.searchBanks(bankSearchQuery).take(50)
        }
    }
    
    // Estados para outros campos
    var agency by remember { mutableStateOf(account.agency) }
    var accountNumber by remember { mutableStateOf(account.account) }
    var accountType by remember { mutableStateOf(account.accountType) }
    var holderName by remember { mutableStateOf(account.accountHolderName) }
    var holderDocument by remember { 
        mutableStateOf(
            TextFieldValue(
                text = account.accountHolderDocument,
                selection = TextRange(account.accountHolderDocument.length)
            )
        )
    }
    var documentType by remember { mutableStateOf(account.accountHolderDocumentType) }
    var isDefault by remember { mutableStateOf(account.isDefault) }
    
    // Valida√ß√µes
    var agencyError by remember { mutableStateOf<String?>(null) }
    var accountNumberError by remember { mutableStateOf<String?>(null) }
    var holderNameError by remember { mutableStateOf<String?>(null) }
    var documentError by remember { mutableStateOf<String?>(null) }
    
    // Atualizar banco quando selecionado
    LaunchedEffect(selectedBank) {
        if (selectedBank != null) {
            bankSearchQuery = ""
        }
    }
    
    // Validar documento quando mudar
    LaunchedEffect(holderDocument.text, documentType) {
        val cleanDoc = holderDocument.text.replace(Regex("[^0-9]"), "")
        if (cleanDoc.isNotEmpty()) {
            val validation = if (documentType == "CPF") {
                documentValidator.validateCpf(holderDocument.text)
            } else {
                documentValidator.validateCnpj(holderDocument.text)
            }
            documentError = if (validation is ValidationResult.Invalid) validation.message else null
        } else {
            documentError = null
        }
    }
    
    // Validar ag√™ncia
    val validateAgency: (String) -> Unit = { value ->
        val clean = value.replace(Regex("[^0-9]"), "")
        agencyError = when {
            clean.isEmpty() -> "Ag√™ncia √© obrigat√≥ria"
            clean.length < 4 -> "Ag√™ncia deve ter pelo menos 4 d√≠gitos"
            clean.length > 5 -> "Ag√™ncia deve ter no m√°ximo 5 d√≠gitos"
            else -> null
        }
    }
    
    // Validar conta
    val validateAccount: (String) -> Unit = { value ->
        val clean = value.replace(Regex("[^0-9]"), "")
        accountNumberError = when {
            clean.isEmpty() -> "N√∫mero da conta √© obrigat√≥rio"
            clean.length < 5 -> "Conta deve ter pelo menos 5 d√≠gitos"
            clean.length > 12 -> "Conta deve ter no m√°ximo 12 d√≠gitos"
            else -> null
        }
    }
    
    // Validar nome
    val validateName: (String) -> Unit = { value ->
        holderNameError = when {
            value.isBlank() -> "Nome do titular √© obrigat√≥rio"
            value.length < 3 -> "Nome deve ter pelo menos 3 caracteres"
            else -> null
        }
    }
    
    // Formata√ß√£o do documento
    val onDocumentChange: (TextFieldValue) -> Unit = { newValue ->
        val formatted = if (documentType == "CPF") {
            TextFormatters.formatCpfWithCursor(newValue)
        } else {
            TextFormatters.formatCnpjWithCursor(newValue)
        }
        holderDocument = formatted
    }
    
    // Verificar se pode salvar
    val canSave = selectedBank != null &&
            agencyError == null &&
            accountNumberError == null &&
            holderNameError == null &&
            documentError == null &&
            agency.isNotBlank() &&
            accountNumber.isNotBlank() &&
            holderName.isNotBlank() &&
            holderDocument.text.replace(Regex("[^0-9]"), "").isNotEmpty()
    
    Column(
        modifier = modifier
            .fillMaxSize()
            .verticalScroll(rememberScrollState())
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        // Mensagem de erro
        error?.let {
            Card(
                modifier = Modifier.fillMaxWidth(),
                colors = CardDefaults.cardColors(
                    containerColor = MaterialTheme.colorScheme.errorContainer
                )
            ) {
                Text(
                    text = it,
                    modifier = Modifier.padding(16.dp),
                    color = MaterialTheme.colorScheme.onErrorContainer
                )
            }
        }
        
        // Sele√ß√£o de Banco
        ExposedDropdownMenuBox(
            expanded = bankExpanded,
            onExpandedChange = { bankExpanded = it }
        ) {
            OutlinedTextField(
                value = if (selectedBank != null) "${selectedBank!!.code} - ${selectedBank!!.name}" else bankSearchQuery,
                onValueChange = { 
                    bankSearchQuery = it
                    bankExpanded = true
                    if (it.isBlank()) {
                        selectedBank = null
                    }
                },
                label = { Text("Banco *") },
                placeholder = { Text("Busque por nome ou c√≥digo (ex: 001, Ita√∫)") },
                trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = bankExpanded) },
                modifier = Modifier
                    .fillMaxWidth()
                    .menuAnchor(),
                readOnly = selectedBank != null,
                colors = OutlinedTextFieldDefaults.colors(
                    focusedBorderColor = if (selectedBank == null && agency.isNotBlank()) MaterialTheme.colorScheme.error else TaskGoGreen,
                    unfocusedBorderColor = if (selectedBank == null && agency.isNotBlank()) MaterialTheme.colorScheme.error else TaskGoTextGray
                ),
                singleLine = true
            )
            
            ExposedDropdownMenu(
                expanded = bankExpanded,
                onDismissRequest = { bankExpanded = false },
                modifier = Modifier.heightIn(max = 300.dp)
            ) {
                if (filteredBanks.isEmpty()) {
                    DropdownMenuItem(
                        text = { Text("Nenhum banco encontrado") },
                        onClick = { bankExpanded = false }
                    )
                } else {
                    filteredBanks.forEach { bank ->
                        DropdownMenuItem(
                            text = { Text("${bank.code} - ${bank.name}") },
                            onClick = {
                                selectedBank = bank
                                bankExpanded = false
                                bankSearchQuery = ""
                            }
                        )
                    }
                }
            }
        }
        
        // Ag√™ncia
        OutlinedTextField(
            value = agency,
            onValueChange = { 
                agency = it.filter { char -> char.isDigit() }
                validateAgency(agency)
            },
            label = { Text("Ag√™ncia *") },
            modifier = Modifier.fillMaxWidth(),
            singleLine = true,
            keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
            isError = agencyError != null,
            supportingText = agencyError?.let { { Text(it, color = MaterialTheme.colorScheme.error) } }
        )
        
        // N√∫mero da Conta
        OutlinedTextField(
            value = accountNumber,
            onValueChange = { 
                accountNumber = it.filter { char -> char.isDigit() }
                validateAccount(accountNumber)
            },
            label = { Text("N√∫mero da Conta *") },
            modifier = Modifier.fillMaxWidth(),
            singleLine = true,
            keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
            isError = accountNumberError != null,
            supportingText = accountNumberError?.let { { Text(it, color = MaterialTheme.colorScheme.error) } }
        )
        
        // Tipo de Conta
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            FilterChip(
                selected = accountType == "CHECKING",
                onClick = { accountType = "CHECKING" },
                label = { Text("Conta Corrente") },
                modifier = Modifier.weight(1f)
            )
            FilterChip(
                selected = accountType == "SAVINGS",
                onClick = { accountType = "SAVINGS" },
                label = { Text("Poupan√ßa") },
                modifier = Modifier.weight(1f)
            )
        }
        
        // Nome do Titular
        OutlinedTextField(
            value = holderName,
            onValueChange = { 
                holderName = it
                validateName(holderName)
            },
            label = { Text("Nome do Titular *") },
            modifier = Modifier.fillMaxWidth(),
            singleLine = true,
            isError = holderNameError != null,
            supportingText = holderNameError?.let { { Text(it, color = MaterialTheme.colorScheme.error) } }
        )
        
        // Tipo de Documento
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            FilterChip(
                selected = documentType == "CPF",
                onClick = { 
                    documentType = "CPF"
                    holderDocument = TextFieldValue("")
                    documentError = null
                },
                label = { Text("CPF") },
                modifier = Modifier.weight(1f)
            )
            FilterChip(
                selected = documentType == "CNPJ",
                onClick = { 
                    documentType = "CNPJ"
                    holderDocument = TextFieldValue("")
                    documentError = null
                },
                label = { Text("CNPJ") },
                modifier = Modifier.weight(1f)
            )
        }
        
        // Documento (CPF/CNPJ)
        OutlinedTextFieldWithValue(
            value = holderDocument,
            onValueChange = onDocumentChange,
            label = { Text(if (documentType == "CPF") "CPF *" else "CNPJ *") },
            modifier = Modifier.fillMaxWidth(),
            singleLine = true,
            keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
            isError = documentError != null,
            supportingText = documentError?.let { { Text(it, color = MaterialTheme.colorScheme.error) } }
        )
        
        // Conta Padr√£o
        Row(
            modifier = Modifier.fillMaxWidth(),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Checkbox(
                checked = isDefault,
                onCheckedChange = { isDefault = it }
            )
            Text(
                text = "Definir como conta padr√£o",
                style = MaterialTheme.typography.bodyMedium,
                modifier = Modifier.weight(1f)
            )
        }
        
        // Bot√µes de a√ß√£o
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            OutlinedButton(
                onClick = onCancel,
                modifier = Modifier.weight(1f)
            ) {
                Text("Cancelar")
            }
            Button(
                onClick = {
                    val cleanDocument = holderDocument.text.replace(Regex("[^0-9]"), "")
                    val updatedAccount = account.copy(
                        bankName = selectedBank?.name ?: "",
                        bankCode = selectedBank?.code ?: "",
                        agency = agency,
                        account = accountNumber,
                        accountType = accountType,
                        accountHolderName = holderName,
                        accountHolderDocument = cleanDocument,
                        accountHolderDocumentType = documentType,
                        isDefault = isDefault
                    )
                    onSave(updatedAccount)
                },
                enabled = canSave && !isLoading,
                modifier = Modifier.weight(1f),
                colors = ButtonDefaults.buttonColors(
                    containerColor = TaskGoGreen,
                    disabledContainerColor = TaskGoTextGray.copy(alpha = 0.3f)
                )
            ) {
                if (isLoading) {
                    CircularProgressIndicator(
                        modifier = Modifier.size(20.dp),
                        color = TaskGoBackgroundWhite
                    )
                } else {
                    Text("Salvar")
                }
            }
        }
    }
}

```

## [FRONTEND]: feature/settings/presentation/LanguageScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.settings.presentation

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.*
import com.taskgoapp.taskgo.core.theme.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.hilt.navigation.compose.hiltViewModel
import com.taskgoapp.taskgo.core.design.AppTopBar

enum class Language(val displayName: String) {
    PORTUGUESE("Portugu√™s"),
    ENGLISH("English"),
    SPANISH("Espa√±ol"),
    FRENCH("Fran√ßais"),
    ITALIAN("Italiano"),
    GERMAN("Deutsch")
}

@Composable
fun LanguageScreen(
    onBackClick: () -> Unit,
    onLogout: () -> Unit,
    viewModel: SettingsViewModel = hiltViewModel()
) {
    val settings by viewModel.state.collectAsState()
    var selectedLanguage by remember { mutableStateOf(
        when (settings.language) {
            "en" -> Language.ENGLISH
            "es" -> Language.SPANISH
            "fr" -> Language.FRENCH
            "it" -> Language.ITALIAN
            "de" -> Language.GERMAN
            else -> Language.PORTUGUESE
        }
    ) }
    
    // Salvar automaticamente quando sair da tela
    androidx.compose.runtime.DisposableEffect(selectedLanguage) {
        onDispose {
            val code = when (selectedLanguage) {
                Language.ENGLISH -> "en"
                Language.SPANISH -> "es"
                Language.FRENCH -> "fr"
                Language.ITALIAN -> "it"
                Language.GERMAN -> "de"
                else -> "pt"
            }
            viewModel.saveLanguage(code)
        }
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .background(Color.White)
    ) {
        // Header
        AppTopBar(
            title = "Idioma",
            subtitle = "Defina o idioma exibido no aplicativo",
            onBackClick = onBackClick,
            backgroundColor = TaskGoGreen,
            titleColor = Color.White,
            backIconColor = Color.White
        )

        // Language List
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp)
        ) {
            Language.values().forEach { language ->
                LanguageItem(
                    language = language,
                    isSelected = selectedLanguage == language,
                    onLanguageSelected = { selectedLanguage = language }
                )
                if (language != Language.values().last()) {
                    Spacer(modifier = Modifier.height(1.dp))
                    Box(
                        modifier = Modifier
                            .fillMaxWidth()
                            .height(1.dp)
                            .background(TaskGoDividerLight)
                    )
                }
            }
        }

        Spacer(modifier = Modifier.weight(1f))
    }
}

@Composable
private fun LanguageItem(
    language: Language,
    isSelected: Boolean,
    onLanguageSelected: () -> Unit
) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .clickable { onLanguageSelected() }
            .padding(vertical = 16.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        // Selection indicator
        Box(
            modifier = Modifier
                .size(20.dp)
                .background(
                    color = if (isSelected) TaskGoGreen else TaskGoDivider,
                    shape = RoundedCornerShape(4.dp)
                )
        ) {
            if (isSelected) {
                Box(
                    modifier = Modifier
                        .size(8.dp)
                        .background(
                            color = Color.White,
                            shape = RoundedCornerShape(2.dp)
                        ),
                    contentAlignment = Alignment.Center
                ) {
                }
            }
        }

        Spacer(modifier = Modifier.width(16.dp))

        // Language name
        Text(
            text = language.displayName,
            color = TaskGoTextDarkGray,
            fontSize = 16.sp,
            fontWeight = FontWeight.Normal
        )
    }
}



```

## [FRONTEND]: feature/settings/presentation/NotificationsSettingsScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.settings.presentation

import android.Manifest
import android.os.Build
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import com.google.accompanist.permissions.ExperimentalPermissionsApi
import com.google.accompanist.permissions.PermissionStatus
import com.google.accompanist.permissions.rememberPermissionState
import com.taskgoapp.taskgo.core.design.*
import com.taskgoapp.taskgo.R
import com.taskgoapp.taskgo.core.theme.*
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch

@OptIn(ExperimentalMaterial3Api::class, ExperimentalPermissionsApi::class)
@Composable
fun NotificationsSettingsScreen(
    onNavigateBack: () -> Unit,
    viewModel: SettingsViewModel = hiltViewModel()
) {
    val settings by viewModel.state.collectAsStateWithLifecycle()
    // Estados locais - inicializar apenas uma vez
    var pushNotifications by remember { mutableStateOf(false) }
    var soundEnabled by remember { mutableStateOf(true) }
    var showOnLockScreen by remember { mutableStateOf(true) }
    var promotionalNotifications by remember { mutableStateOf(true) }
    var emailNotifications by remember { mutableStateOf(false) }
    var smsNotifications by remember { mutableStateOf(false) }
    
    // Inicializar apenas uma vez quando dados estiverem dispon√≠veis
    var hasInitialized by remember { mutableStateOf(false) }
    LaunchedEffect(settings.pushEnabled, settings.soundEnabled) {
        if (!hasInitialized) {
            pushNotifications = settings.pushEnabled
            soundEnabled = settings.soundEnabled
            showOnLockScreen = settings.lockscreenEnabled
            promotionalNotifications = settings.promosEnabled
            emailNotifications = settings.emailNotificationsEnabled
            smsNotifications = settings.smsNotificationsEnabled
            hasInitialized = true
        }
    }
    
    val coroutineScope = rememberCoroutineScope()
    var saveJob by remember { mutableStateOf<Job?>(null) }

    fun queueSave() {
        if (!hasInitialized) return
        saveJob?.cancel()
        saveJob = coroutineScope.launch {
            delay(800)
            viewModel.saveNotifications(
                promos = promotionalNotifications,
                sound = soundEnabled,
                push = pushNotifications,
                lockscreen = showOnLockScreen,
                email = emailNotifications,
                sms = smsNotifications
            )
        }
    }

    DisposableEffect(Unit) {
        onDispose {
            saveJob?.cancel()
            viewModel.saveNotifications(
                promos = promotionalNotifications,
                sound = soundEnabled,
                push = pushNotifications,
                lockscreen = showOnLockScreen,
                email = emailNotifications,
                sms = smsNotifications
            )
        }
    }
    
    // Permiss√£o de notifica√ß√µes
    val notificationPermission = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
        rememberPermissionState(Manifest.permission.POST_NOTIFICATIONS)
    } else {
        null
    }
    
    var hasRequestedNotificationPermission by remember { mutableStateOf(false) }
    
    // Solicitar permiss√£o quando a tela abrir se ainda n√£o tiver permiss√£o
    LaunchedEffect(Unit) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU && 
            notificationPermission != null && 
            notificationPermission.status !is PermissionStatus.Granted && 
            !hasRequestedNotificationPermission) {
            hasRequestedNotificationPermission = true
            kotlinx.coroutines.delay(500) // Pequeno delay para melhor UX
            notificationPermission.launchPermissionRequest()
        }
    }
    
    // Solicitar permiss√£o quando pushNotifications for habilitado
    LaunchedEffect(pushNotifications) {
        if (pushNotifications && 
            notificationPermission != null && 
            notificationPermission.status !is PermissionStatus.Granted && 
            !hasRequestedNotificationPermission) {
            hasRequestedNotificationPermission = true
            notificationPermission.launchPermissionRequest()
        } else if (!pushNotifications) {
            hasRequestedNotificationPermission = false
        }
    }
    
    LaunchedEffect(pushNotifications, soundEnabled, showOnLockScreen, promotionalNotifications, emailNotifications, smsNotifications) {
        if (hasInitialized) {
            queueSave()
        }
    }
    
    // Atualizar estado ap√≥s salvar (sincronizar com backend)
    LaunchedEffect(settings.pushEnabled, settings.soundEnabled, settings.lockscreenEnabled, settings.promosEnabled, settings.emailNotificationsEnabled, settings.smsNotificationsEnabled) {
        if (hasInitialized) {
            pushNotifications = settings.pushEnabled
            soundEnabled = settings.soundEnabled
            showOnLockScreen = settings.lockscreenEnabled
            promotionalNotifications = settings.promosEnabled
            emailNotifications = settings.emailNotificationsEnabled
            smsNotifications = settings.smsNotificationsEnabled
        }
    }

    Scaffold(
        topBar = {
            AppTopBar(
                title = stringResource(R.string.settings_notifications),
                subtitle = "Escolha como deseja ser notificado",
                onBackClick = onNavigateBack,
                backgroundColor = TaskGoGreen,
                titleColor = TaskGoBackgroundWhite,
                backIconColor = TaskGoBackgroundWhite
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .verticalScroll(rememberScrollState())
        ) {
            // General Notifications
            Card(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
            ) {
                Column(
                    modifier = Modifier.padding(16.dp)
                ) {
                    Text(
                        text = stringResource(R.string.notifications_general),
                        style = FigmaSectionTitle,
                        color = TaskGoTextBlack,
                        fontWeight = FontWeight.Bold
                    )

                    Spacer(modifier = Modifier.height(16.dp))

                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Column(modifier = Modifier.weight(1f)) {
                            Text(
                                text = stringResource(R.string.notifications_push),
                                style = FigmaProductDescription,
                                color = TaskGoTextBlack
                            )
                            Text(
                                text = stringResource(R.string.notifications_push_desc),
                                style = FigmaStatusText,
                                color = TaskGoTextGray
                            )
                        }
                        Switch(
                            checked = pushNotifications,
                            onCheckedChange = { pushNotifications = it }
                        )
                    }

                    Spacer(modifier = Modifier.height(16.dp))

                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Column(modifier = Modifier.weight(1f)) {
                            Text(
                                text = stringResource(R.string.notifications_email),
                                style = FigmaProductDescription,
                                color = TaskGoTextBlack
                            )
                            Text(
                                text = stringResource(R.string.notifications_email_desc),
                                style = FigmaStatusText,
                                color = TaskGoTextGray
                            )
                        }
                        Switch(
                            checked = emailNotifications,
                            onCheckedChange = { emailNotifications = it }
                        )
                    }

                    Spacer(modifier = Modifier.height(16.dp))

                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Column(modifier = Modifier.weight(1f)) {
                            Text(
                                text = stringResource(R.string.notifications_sms),
                                style = FigmaProductDescription,
                                color = TaskGoTextBlack
                            )
                            Text(
                                text = stringResource(R.string.notifications_sms_desc),
                                style = FigmaStatusText,
                                color = TaskGoTextGray
                            )
                        }
                        Switch(
                            checked = smsNotifications,
                            onCheckedChange = { smsNotifications = it }
                        )
                    }
                }
            }

            // Notification Behavior
            Card(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
            ) {
                Column(
                    modifier = Modifier.padding(16.dp)
                ) {
                    Text(
                        text = stringResource(R.string.notifications_behavior),
                        style = FigmaSectionTitle,
                        color = TaskGoTextBlack,
                        fontWeight = FontWeight.Bold
                    )

                    Spacer(modifier = Modifier.height(16.dp))

                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Column(modifier = Modifier.weight(1f)) {
                            Text(
                                text = stringResource(R.string.notifications_sound),
                                style = FigmaProductDescription,
                                color = TaskGoTextBlack
                            )
                            Text(
                                text = stringResource(R.string.notifications_sound_desc),
                                style = FigmaStatusText,
                                color = TaskGoTextGray
                            )
                        }
                        Switch(
                            checked = soundEnabled,
                            onCheckedChange = { soundEnabled = it }
                        )
                    }

                    Spacer(modifier = Modifier.height(16.dp))

                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Column(modifier = Modifier.weight(1f)) {
                            Text(
                                text = stringResource(R.string.notifications_locked_screen),
                                style = FigmaProductDescription,
                                color = TaskGoTextBlack
                            )
                            Text(
                                text = stringResource(R.string.notifications_locked_screen_desc),
                                style = FigmaStatusText,
                                color = TaskGoTextGray
                            )
                        }
                        Switch(
                            checked = showOnLockScreen,
                            onCheckedChange = { showOnLockScreen = it }
                        )
                    }
                }
            }

            // Specific Notifications
            Card(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
            ) {
                Column(
                    modifier = Modifier.padding(16.dp)
                ) {
                    Text(
                        text = stringResource(R.string.notifications_types),
                        style = FigmaSectionTitle,
                        color = TaskGoTextBlack,
                        fontWeight = FontWeight.Bold
                    )

                    Spacer(modifier = Modifier.height(16.dp))

                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Column(modifier = Modifier.weight(1f)) {
                            Text(
                                text = stringResource(R.string.notifications_promotions),
                                style = FigmaProductDescription,
                                color = TaskGoTextBlack
                            )
                            Text(
                                text = stringResource(R.string.notifications_promotions_desc),
                                style = FigmaStatusText,
                                color = TaskGoTextGray
                            )
                        }
                        Switch(
                            checked = promotionalNotifications,
                            onCheckedChange = { promotionalNotifications = it }
                        )
                    }

                    Spacer(modifier = Modifier.height(16.dp))

                    // Notification Schedule
                    Column(modifier = Modifier.weight(1f)) {
                        Text(
                            text = stringResource(R.string.notifications_schedule),
                            style = FigmaProductDescription,
                            color = TaskGoTextBlack,
                            fontWeight = FontWeight.Medium
                        )
                        Text(
                            text = stringResource(R.string.notifications_schedule_desc),
                            style = FigmaStatusText,
                            color = TaskGoTextGray
                        )
                    }
                }
            }

            Spacer(modifier = Modifier.height(32.dp))
        }
    }
}



```

## [FRONTEND]: feature/settings/presentation/PreferencesScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.settings.presentation

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.theme.*
import kotlinx.coroutines.launch
import kotlinx.coroutines.tasks.await
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay

data class PreferenceCategory(
    val id: String,
    val name: String,
    val icon: ImageVector,
    val description: String,
    val subcategories: List<String> = emptyList()
)

@Composable
fun PreferencesScreen(
    onBackClick: () -> Unit,
    onSaveChanges: () -> Unit = {},
    viewModel: SettingsViewModel = hiltViewModel()
) {
    val settings by viewModel.state.collectAsStateWithLifecycle()
    
    // Lista ampla de prefer√™ncias
    val allPreferences = remember {
        listOf(
            PreferenceCategory(
                id = "services",
                name = "Servi√ßos",
                icon = Icons.Default.Build,
                description = "Servi√ßos que voc√™ precisa",
                subcategories = listOf(
                    "Montagem", "Reforma", "Jardinagem", "El√©trica", "Encanamento",
                    "Pintura", "Limpeza", "Marcenaria", "Alvenaria", "Hidr√°ulica",
                    "Ar Condicionado", "Seguran√ßa", "Piscina", "Paisagismo", "Decora√ß√£o"
                )
            ),
            PreferenceCategory(
                id = "products",
                name = "Produtos",
                icon = Icons.Default.ShoppingCart,
                description = "Produtos que voc√™ procura",
                subcategories = listOf(
                    "Eletr√¥nicos", "Casa e Decora√ß√£o", "Ferramentas", "M√≥veis",
                    "Roupas", "Esportes", "Livros", "Brinquedos", "Beleza e Cuidados",
                    "Automotivo", "Pet Shop", "Alimentos", "Bebidas", "Sa√∫de"
                )
            ),
            PreferenceCategory(
                id = "price_range",
                name = "Faixa de Pre√ßo",
                icon = Icons.Default.AttachMoney,
                description = "Seu or√ßamento preferido",
                subcategories = listOf(
                    "At√© R$ 50", "R$ 50 - R$ 100", "R$ 100 - R$ 250", "R$ 250 - R$ 500",
                    "R$ 500 - R$ 1000", "R$ 1000 - R$ 2500", "Acima de R$ 2500"
                )
            ),
            PreferenceCategory(
                id = "location",
                name = "Localiza√ß√£o",
                icon = Icons.Default.LocationOn,
                description = "Onde voc√™ prefere buscar",
                subcategories = listOf(
                    "Pr√≥ximo a mim (at√© 5km)", "Na minha cidade", "Na minha regi√£o",
                    "Em todo o estado", "Qualquer lugar"
                )
            ),
            PreferenceCategory(
                id = "urgency",
                name = "Urg√™ncia",
                icon = Icons.Default.Schedule,
                description = "Com que frequ√™ncia voc√™ precisa",
                subcategories = listOf(
                    "Imediato (hoje)", "Esta semana", "Este m√™s", "Planejamento futuro"
                )
            ),
            PreferenceCategory(
                id = "quality",
                name = "Qualidade",
                icon = Icons.Default.Star,
                description = "N√≠vel de qualidade desejado",
                subcategories = listOf(
                    "Premium (melhor qualidade)", "Alta qualidade", "Qualidade m√©dia",
                    "Boa rela√ß√£o custo-benef√≠cio"
                )
            )
        )
    }
    
    // Estado das prefer√™ncias selecionadas
    var selectedPreferences by remember { mutableStateOf<Set<String>>(emptySet()) }
    var hasInitialized by remember { mutableStateOf(false) }
    var isSyncingFromRemote by remember { mutableStateOf(true) }
    val coroutineScope = rememberCoroutineScope()
    var saveJob by remember { mutableStateOf<Job?>(null) }
    
    LaunchedEffect(settings.categories) {
        isSyncingFromRemote = true
        val parsed = if (settings.categories.isNotEmpty() && settings.categories != "[]") {
            runCatching {
                settings.categories
                    .removePrefix("[")
                    .removeSuffix("]")
                    .split(",")
                    .map { it.trim().removeSurrounding("\"") }
                    .filter { it.isNotBlank() }
                    .toSet()
            }.getOrDefault(emptySet())
        } else {
            emptySet()
        }
        selectedPreferences = parsed
        hasInitialized = true
        isSyncingFromRemote = false
    }
    
    fun queueSave(preferences: Set<String>) {
        if (!hasInitialized) return
        saveJob?.cancel()
        saveJob = coroutineScope.launch {
            delay(800)
            val json = preferences.joinToString(prefix = "[", postfix = "]") { "\"$it\"" }
            viewModel.saveCategories(json)
        }
    }
    
    LaunchedEffect(selectedPreferences) {
        if (hasInitialized && !isSyncingFromRemote) {
            queueSave(selectedPreferences)
        }
    }
    
    // Salvar quando sair da tela (garantir salvamento final)
    DisposableEffect(Unit) {
        onDispose {
            saveJob?.cancel()
            val json = selectedPreferences.joinToString(prefix = "[", postfix = "]") { "\"$it\"" }
            viewModel.saveCategories(json)
            onSaveChanges()
        }
    }

    Scaffold(
        topBar = {
            AppTopBar(
                title = "Prefer√™ncias",
                subtitle = "Personalize suas recomenda√ß√µes",
                onBackClick = onBackClick,
                backgroundColor = TaskGoGreen,
                titleColor = Color.White,
                subtitleColor = Color.White,
                backIconColor = Color.White
            )
        }
    ) { paddingValues ->
        LazyColumn(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(horizontal = 16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // Header informativo
            item {
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    colors = CardDefaults.cardColors(
                        containerColor = TaskGoBackgroundGray
                    )
                ) {
                    Column(
                        modifier = Modifier.padding(16.dp)
                    ) {
                        Text(
                            text = "Personalize Suas Recomenda√ß√µes",
                            style = MaterialTheme.typography.titleMedium,
                            fontWeight = FontWeight.Bold,
                            color = TaskGoTextBlack
                        )
                        Spacer(modifier = Modifier.height(8.dp))
                        Text(
                            text = "Selecione suas prefer√™ncias para receber recomenda√ß√µes personalizadas de produtos e servi√ßos que realmente interessam a voc√™.",
                            style = MaterialTheme.typography.bodyMedium,
                            color = TaskGoTextGray
                        )
                    }
                }
            }
            
            // Lista de categorias de prefer√™ncias
            items(allPreferences) { category ->
                PreferenceCategoryCard(
                    category = category,
                    selectedSubcategories = selectedPreferences.filter { pref ->
                        category.subcategories.contains(pref)
                    }.toSet(),
                    onSubcategoryToggle = { subcategory ->
                        selectedPreferences = if (selectedPreferences.contains(subcategory)) {
                            selectedPreferences - subcategory
                        } else {
                            selectedPreferences + subcategory
                        }
                    }
                )
            }
            
            // Resumo das prefer√™ncias selecionadas
            item {
                Spacer(modifier = Modifier.height(8.dp))
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    colors = CardDefaults.cardColors(
                        containerColor = TaskGoGreen.copy(alpha = 0.1f)
                    )
                ) {
                    Column(
                        modifier = Modifier.padding(16.dp)
                    ) {
                        Row(
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Icon(
                                imageVector = Icons.Default.Info,
                                contentDescription = null,
                                tint = TaskGoGreen,
                                modifier = Modifier.size(24.dp)
                            )
                            Spacer(modifier = Modifier.width(12.dp))
                            Text(
                                text = "Prefer√™ncias Selecionadas",
                                style = MaterialTheme.typography.titleSmall,
                                fontWeight = FontWeight.Bold,
                                color = TaskGoTextBlack
                            )
                        }
                        Spacer(modifier = Modifier.height(8.dp))
                        Text(
                            text = "${selectedPreferences.size} prefer√™ncias selecionadas",
                            style = MaterialTheme.typography.bodyMedium,
                            color = TaskGoTextGray
                        )
                    }
                }
                Spacer(modifier = Modifier.height(32.dp))
            }
        }
    }
}

@Composable
private fun PreferenceCategoryCard(
    category: PreferenceCategory,
    selectedSubcategories: Set<String>,
    onSubcategoryToggle: (String) -> Unit
) {
    var isExpanded by remember { mutableStateOf(false) }
    
    Card(
        modifier = Modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            // Header da categoria
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .clickable { isExpanded = !isExpanded },
                verticalAlignment = Alignment.CenterVertically
            ) {
                Icon(
                    imageVector = category.icon,
                    contentDescription = null,
                    tint = TaskGoGreen,
                    modifier = Modifier.size(28.dp)
                )
                Spacer(modifier = Modifier.width(12.dp))
                Column(
                    modifier = Modifier.weight(1f)
                ) {
                    Text(
                        text = category.name,
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold,
                        color = TaskGoTextBlack
                    )
                    Text(
                        text = category.description,
                        style = MaterialTheme.typography.bodySmall,
                        color = TaskGoTextGray
                    )
                }
                Icon(
                    imageVector = if (isExpanded) Icons.Default.ExpandLess else Icons.Default.ExpandMore,
                    contentDescription = null,
                    tint = TaskGoTextGray
                )
            }
            
            // Subcategorias (expand√≠vel)
            if (isExpanded) {
                Spacer(modifier = Modifier.height(16.dp))
                Column(
                    verticalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    category.subcategories.forEach { subcategory ->
                        PreferenceChip(
                            text = subcategory,
                            isSelected = selectedSubcategories.contains(subcategory),
                            onClick = { onSubcategoryToggle(subcategory) }
                        )
                    }
                }
            }
        }
    }
}

@Composable
private fun PreferenceChip(
    text: String,
    isSelected: Boolean,
    onClick: () -> Unit
) {
    FilterChip(
        selected = isSelected,
        onClick = onClick,
        label = { Text(text) },
        colors = FilterChipDefaults.filterChipColors(
            selectedContainerColor = TaskGoGreen,
            selectedLabelColor = Color.White,
            containerColor = TaskGoSurfaceGray,
            labelColor = TaskGoTextBlack
        )
    )
}

```

## [FRONTEND]: feature/settings/presentation/PrivacidadeScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.settings.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.theme.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PrivacidadeScreen(
    onBackClick: () -> Unit
) {
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Privacidade",
                onBackClick = onBackClick
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            Text(
                text = "Pol√≠tica de Privacidade",
                style = FigmaTitleLarge,
                color = TaskGoTextBlack,
                fontWeight = FontWeight.Bold
            )
            
            Text(
                text = "√öltima atualiza√ß√£o: 15 de dezembro de 2024",
                style = FigmaProductDescription,
                color = TaskGoTextGray
            )
            
            Text(
                text = "Esta Pol√≠tica de Privacidade descreve como o TaskGo coleta, usa e compartilha suas informa√ß√µes pessoais quando voc√™ usa nosso aplicativo.",
                style = FigmaProductDescription,
                color = TaskGoTextBlack
            )
            
            Text(
                text = "Informa√ß√µes que coletamos:",
                style = FigmaSectionTitle,
                color = TaskGoTextBlack,
                fontWeight = FontWeight.Medium
            )
            
            Text(
                text = "‚Ä¢ Nome e informa√ß√µes de contato\n‚Ä¢ Informa√ß√µes de pagamento\n‚Ä¢ Dados de localiza√ß√£o\n‚Ä¢ Hist√≥rico de servi√ßos e produtos",
                style = FigmaProductDescription,
                color = TaskGoTextBlack
            )
            
            Text(
                text = "Como usamos suas informa√ß√µes:",
                style = FigmaSectionTitle,
                color = TaskGoTextBlack,
                fontWeight = FontWeight.Medium
            )
            
            Text(
                text = "‚Ä¢ Para fornecer nossos servi√ßos\n‚Ä¢ Para processar pagamentos\n‚Ä¢ Para melhorar nossa plataforma\n‚Ä¢ Para comunica√ß√£o com voc√™",
                style = FigmaProductDescription,
                color = TaskGoTextBlack
            )
            
            Text(
                text = "Compartilhamento de dados:",
                style = FigmaSectionTitle,
                color = TaskGoTextBlack,
                fontWeight = FontWeight.Medium
            )
            
            Text(
                text = "N√£o vendemos suas informa√ß√µes pessoais. Compartilhamos dados apenas com prestadores de servi√ßos selecionados e quando exigido por lei.",
                style = FigmaProductDescription,
                color = TaskGoTextBlack
            )
        }
    }
}

```

## [FRONTEND]: feature/settings/presentation/PrivacyPolicyScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.settings.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.theme.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PrivacyPolicyScreen(
    onBackClick: () -> Unit
) {
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Pol√≠tica de Privacidade",
                onBackClick = onBackClick
            )
        }
    ) { paddingValues ->
        val scrollState = rememberScrollState()
        
        val policySections = remember {
            listOf(
            PolicySectionData(
                title = "üìò 1. INFORMA√á√ïES QUE COLETAMOS",
                paragraphs = listOf(
                    "Durante o uso do TaskGo, podemos coletar os seguintes tipos de dados:"
                )
            ),
            PolicySectionData(
                title = "üßç 1.1. Informa√ß√µes pessoais",
                paragraphs = listOf(
                    "‚Ä¢ Nome completo",
                    "‚Ä¢ Endere√ßo de e-mail",
                    "‚Ä¢ N√∫mero de telefone",
                    "‚Ä¢ Documento de identifica√ß√£o (ex: RG, CPF ou CNPJ)",
                    "‚Ä¢ Foto de perfil",
                    "",
                    "Essas informa√ß√µes s√£o utilizadas para criar e verificar sua conta, permitindo que voc√™ contrate ou ofere√ßa servi√ßos e produtos com seguran√ßa."
                )
            ),
            PolicySectionData(
                title = "üìç 1.2. Dados de localiza√ß√£o",
                paragraphs = listOf(
                    "O TaskGo pode coletar e processar informa√ß√µes sobre sua localiza√ß√£o geogr√°fica aproximada ou precisa, com o objetivo de:",
                    "",
                    "‚Ä¢ Exibir servi√ßos e prestadores pr√≥ximos.",
                    "‚Ä¢ Melhorar a experi√™ncia de busca e entrega.",
                    "‚Ä¢ Garantir a veracidade das informa√ß√µes de √°rea de atua√ß√£o.",
                    "",
                    "O compartilhamento da localiza√ß√£o √© opcional e pode ser controlado nas configura√ß√µes do seu dispositivo."
                )
            ),
            PolicySectionData(
                title = "üí¨ 1.3. Mensagens e comunica√ß√µes",
                paragraphs = listOf(
                    "Quando voc√™ utiliza o chat integrado do TaskGo:",
                    "",
                    "‚Ä¢ As mensagens s√£o armazenadas de forma segura e criptografada no Firebase Firestore.",
                    "‚Ä¢ As conversas podem ser revisadas em caso de den√∫ncias, para manter a seguran√ßa da comunidade."
                )
            ),
            PolicySectionData(
                title = "üßæ 1.4. Dados de uso",
                paragraphs = listOf(
                    "Coletamos automaticamente informa√ß√µes sobre como voc√™ interage com o aplicativo, como:",
                    "",
                    "‚Ä¢ Vers√£o do app",
                    "‚Ä¢ Sistema operacional",
                    "‚Ä¢ Tipo de dispositivo",
                    "‚Ä¢ Endere√ßo IP e logs de acesso",
                    "‚Ä¢ Hist√≥rico de navega√ß√£o interna e prefer√™ncias",
                    "",
                    "Esses dados s√£o usados apenas para an√°lises t√©cnicas, m√©tricas e melhorias de desempenho."
                )
            ),
            PolicySectionData(
                title = "üí≥ 1.5. Informa√ß√µes financeiras",
                paragraphs = listOf(
                    "Caso realize pagamentos ou vendas dentro do aplicativo:",
                    "",
                    "‚Ä¢ Os dados de pagamento (cart√£o, conta banc√°ria etc.) s√£o processados exclusivamente por gateways de pagamento confi√°veis, como Stripe ou Mercado Pago.",
                    "‚Ä¢ O TaskGo n√£o armazena dados sens√≠veis de pagamento em seus servidores."
                )
            ),
            PolicySectionData(
                title = "üß† 2. COMO UTILIZAMOS SEUS DADOS",
                paragraphs = listOf(
                    "Os dados coletados s√£o usados para:",
                    "",
                    "‚Ä¢ Criar e gerenciar sua conta.",
                    "‚Ä¢ Permitir intera√ß√µes entre clientes e prestadores/vendedores.",
                    "‚Ä¢ Processar transa√ß√µes e repasses financeiros.",
                    "‚Ä¢ Enviar notifica√ß√µes sobre ordens, mensagens e atualiza√ß√µes.",
                    "‚Ä¢ Melhorar a seguran√ßa, desempenho e personaliza√ß√£o do aplicativo.",
                    "‚Ä¢ Cumprir obriga√ß√µes legais e regulat√≥rias."
                )
            ),
            PolicySectionData(
                title = "üîó 3. COMPARTILHAMENTO DE DADOS",
                paragraphs = listOf(
                    "O TaskGo n√£o vende, aluga ou comercializa seus dados pessoais.",
                    "",
                    "No entanto, podemos compartilhar suas informa√ß√µes com:",
                    "",
                    "‚Ä¢ Firebase (Google LLC) ‚Äî para autentica√ß√£o, banco de dados e armazenamento.",
                    "‚Ä¢ Stripe / Mercado Pago ‚Äî para processamento de pagamentos.",
                    "‚Ä¢ OpenAI ou provedores de IA ‚Äî para o chat automatizado de suporte.",
                    "‚Ä¢ Autoridades legais ‚Äî em caso de investiga√ß√µes, mediante solicita√ß√£o formal.",
                    "",
                    "Todos os parceiros s√£o escolhidos por sua confiabilidade, criptografia e conformidade legal (LGPD e GDPR)."
                )
            ),
            PolicySectionData(
                title = "üß± 4. ARMAZENAMENTO E SEGURAN√áA",
                paragraphs = listOf(
                    "Seus dados s√£o armazenados em servidores seguros do Firebase (Google Cloud Platform), com:",
                    "",
                    "‚Ä¢ Criptografia AES-256 para dados em repouso.",
                    "‚Ä¢ Criptografia TLS 1.3 para dados em tr√¢nsito.",
                    "‚Ä¢ Controle de acesso baseado em autentica√ß√£o (request.auth.uid).",
                    "‚Ä¢ Backups autom√°ticos e logs de auditoria."
                )
            ),
            PolicySectionData(
                title = "üßπ 5. RETEN√á√ÉO E EXCLUS√ÉO DE DADOS",
                paragraphs = listOf(
                    "Seus dados pessoais s√£o mantidos enquanto sua conta estiver ativa.",
                    "",
                    "Voc√™ pode solicitar a exclus√£o definitiva da sua conta e de todos os dados associados a qualquer momento.",
                    "",
                    "Ap√≥s a exclus√£o, apenas registros necess√°rios por lei (ex: transa√ß√µes financeiras) s√£o mantidos temporariamente.",
                    "",
                    "Para solicitar exclus√£o, envie um e-mail para: suporte@taskgo.app"
                )
            ),
            PolicySectionData(
                title = "üß≠ 6. SEUS DIREITOS",
                paragraphs = listOf(
                    "De acordo com a LGPD (Lei n¬∫ 13.709/2018) e o GDPR, voc√™ tem direito a:",
                    "",
                    "‚Ä¢ Acessar seus dados pessoais.",
                    "‚Ä¢ Corrigir informa√ß√µes incorretas.",
                    "‚Ä¢ Solicitar a exclus√£o de dados.",
                    "‚Ä¢ Revogar o consentimento a qualquer momento.",
                    "‚Ä¢ Saber como seus dados s√£o tratados.",
                    "",
                    "Esses direitos podem ser exercidos dentro do app ou por contato direto com nosso suporte."
                )
            ),
            PolicySectionData(
                title = "üëÅ 7. COOKIES E TECNOLOGIAS SIMILARES",
                paragraphs = listOf(
                    "O TaskGo utiliza cookies e identificadores locais apenas para:",
                    "",
                    "‚Ä¢ Manter sua sess√£o autenticada.",
                    "‚Ä¢ Lembrar prefer√™ncias do usu√°rio.",
                    "‚Ä¢ Coletar m√©tricas de uso para melhorias.",
                    "",
                    "Nenhum cookie √© usado para rastreamento publicit√°rio fora do aplicativo."
                )
            ),
            PolicySectionData(
                title = "üåé 8. TRANSFER√äNCIA INTERNACIONAL DE DADOS",
                paragraphs = listOf(
                    "Por utilizar servi√ßos do Google Firebase, alguns dados podem ser processados em servidores localizados fora do Brasil.",
                    "",
                    "Todos os dados transferidos seguem padr√µes internacionais de seguran√ßa e privacidade (GDPR e LGPD)."
                )
            ),
            PolicySectionData(
                title = "üß© 9. ATUALIZA√á√ïES DESTA POL√çTICA",
                paragraphs = listOf(
                    "Podemos atualizar esta Pol√≠tica de Privacidade periodicamente.",
                    "",
                    "A vers√£o mais recente estar√° sempre dispon√≠vel no aplicativo e em nosso site oficial.",
                    "",
                    "Notificaremos voc√™ em caso de altera√ß√µes relevantes."
                )
            ),
            PolicySectionData(
                title = "üì¨ 10. CONTATO",
                paragraphs = listOf(
                    "Se voc√™ tiver d√∫vidas, solicita√ß√µes ou den√∫ncias relacionadas a esta Pol√≠tica de Privacidade, entre em contato conosco:",
                    "",
                    "üìß E-mail: suporte@taskgo.app",
                    "üåê Site: https://taskgo.app",
                    "üìç Empresa: TaskGo Tecnologia Digital LTDA",
                    "üìÑ CNPJ: (adicione aqui seu n√∫mero quando registrar a empresa)"
                )
            ),
            PolicySectionData(
                title = "‚úÖ Conformidade",
                paragraphs = listOf(
                    "Esta Pol√≠tica est√° em conformidade com:",
                    "",
                    "‚Ä¢ Lei Geral de Prote√ß√£o de Dados (LGPD - Lei n¬∫ 13.709/2018)",
                    "‚Ä¢ Regulamento Geral de Prote√ß√£o de Dados (GDPR - Uni√£o Europeia)",
                    "‚Ä¢ Pol√≠ticas de Privacidade do Google Play Developer Program"
                )
            )
            )
        }

        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp)
                .verticalScroll(scrollState)
        ) {
            Text(
                text = "Bem-vindo ao TaskGo",
                style = MaterialTheme.typography.headlineMedium,
                fontWeight = FontWeight.Bold,
                color = TaskGoTextBlack
            )
            Spacer(modifier = Modifier.height(8.dp))
            Text(
                text = "Um aplicativo desenvolvido para conectar pessoas, servi√ßos e produtos de forma simples, segura e inteligente.",
                style = MaterialTheme.typography.bodyMedium,
                color = TaskGoTextGray
            )
            Spacer(modifier = Modifier.height(16.dp))
            Text(
                text = "Esta Pol√≠tica de Privacidade explica como coletamos, usamos, armazenamos e protegemos suas informa√ß√µes pessoais quando voc√™ utiliza nosso aplicativo.",
                style = MaterialTheme.typography.bodyMedium,
                color = TaskGoTextBlack
            )
            Spacer(modifier = Modifier.height(8.dp))
            Text(
                text = "Ao utilizar o TaskGo, voc√™ concorda com os termos descritos nesta pol√≠tica.",
                style = MaterialTheme.typography.bodyMedium,
                color = TaskGoTextBlack,
                fontWeight = FontWeight.Medium
            )
            Spacer(modifier = Modifier.height(24.dp))

            policySections.forEach { section ->
                PolicySection(section)
                Spacer(modifier = Modifier.height(16.dp))
            }

            Spacer(modifier = Modifier.height(24.dp))
        }
    }
}

private data class PolicySectionData(
    val title: String,
    val paragraphs: List<String>
)

@Composable
private fun PolicySection(section: PolicySectionData) {
    Text(
        text = section.title,
        style = MaterialTheme.typography.titleMedium,
        fontWeight = FontWeight.Bold,
        color = TaskGoTextBlack
    )
    Spacer(modifier = Modifier.height(8.dp))
    section.paragraphs.forEachIndexed { index, paragraph ->
        if (paragraph.isNotBlank()) {
            Text(
                text = paragraph,
                style = MaterialTheme.typography.bodyMedium,
                color = TaskGoTextBlack
            )
            if (index != section.paragraphs.lastIndex) {
                Spacer(modifier = Modifier.height(4.dp))
            }
        } else {
            Spacer(modifier = Modifier.height(4.dp))
        }
    }
}

```

## [FRONTEND]: feature/settings/presentation/PrivacyScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.settings.presentation

import android.Manifest
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import com.taskgoapp.taskgo.core.theme.*
import androidx.compose.runtime.*
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.google.accompanist.permissions.ExperimentalPermissionsApi
import com.google.accompanist.permissions.PermissionStatus
import com.google.accompanist.permissions.rememberPermissionState
import com.taskgoapp.taskgo.core.design.*
import com.taskgoapp.taskgo.core.security.LGPDComplianceManager
import com.taskgoapp.taskgo.data.firebase.FirebaseFunctionsService
import com.google.firebase.functions.FirebaseFunctions
import kotlinx.coroutines.launch
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import com.google.firebase.auth.FirebaseAuth

@OptIn(ExperimentalMaterial3Api::class, ExperimentalPermissionsApi::class)
@Composable
fun PrivacyScreen(
    onBackClick: () -> Unit,
    onNavigateToPrivacyPolicy: () -> Unit = {},
    onNavigateToTermsOfService: () -> Unit = {},
    onNavigateToConsentHistory: () -> Unit = {},
    viewModel: SettingsViewModel = androidx.hilt.navigation.compose.hiltViewModel()
) {
    val settings by viewModel.state.collectAsState()
    val auth = FirebaseAuth.getInstance()
    val currentUser = auth.currentUser
    val context = LocalContext.current
    val coroutineScope = rememberCoroutineScope()
    var saveJob by remember { mutableStateOf<Job?>(null) }
    var isSyncingFromRemote by remember { mutableStateOf(true) }
    
    val lgpdManager = remember(context) { 
        com.taskgoapp.taskgo.core.security.LGPDComplianceManager(
            context,
            com.taskgoapp.taskgo.core.firebase.FirestoreHelper.getInstance()
        )
    }
    val functionsService = remember {
        FirebaseFunctionsService(FirebaseFunctions.getInstance())
    }
    // Estados locais - inicializar apenas uma vez
    var locationSharingEnabled by remember { mutableStateOf(true) }
    var profileVisibilityEnabled by remember { mutableStateOf(true) }
    var contactInfoSharingEnabled by remember { mutableStateOf(false) }
    var analyticsEnabled by remember { mutableStateOf(true) }
    var personalizedAdsEnabled by remember { mutableStateOf(false) }
    var dataCollectionEnabled by remember { mutableStateOf(true) }
    var thirdPartySharingEnabled by remember { mutableStateOf(false) }
    
    // Inicializar apenas uma vez quando dados estiverem dispon√≠veis
    var hasInitialized by remember { mutableStateOf(false) }
    LaunchedEffect(
        settings.locationSharingEnabled,
        settings.profileVisible,
        settings.contactInfoSharingEnabled,
        settings.analyticsEnabled,
        settings.personalizedAdsEnabled,
        settings.dataCollectionEnabled,
        settings.thirdPartySharingEnabled
    ) {
        isSyncingFromRemote = true
        locationSharingEnabled = settings.locationSharingEnabled
        profileVisibilityEnabled = settings.profileVisible
        contactInfoSharingEnabled = settings.contactInfoSharingEnabled
        analyticsEnabled = settings.analyticsEnabled
        personalizedAdsEnabled = settings.personalizedAdsEnabled
        dataCollectionEnabled = settings.dataCollectionEnabled
        thirdPartySharingEnabled = settings.thirdPartySharingEnabled
        hasInitialized = true
        isSyncingFromRemote = false
    }
    
    fun queueSave() {
        if (!hasInitialized || isSyncingFromRemote) return
        saveJob?.cancel()
        saveJob = coroutineScope.launch {
            delay(800)
            viewModel.savePrivacySettings(
                locationSharing = locationSharingEnabled,
                profileVisible = profileVisibilityEnabled,
                contactInfoSharing = contactInfoSharingEnabled,
                analytics = analyticsEnabled,
                personalizedAds = personalizedAdsEnabled,
                dataCollection = dataCollectionEnabled,
                thirdPartySharing = thirdPartySharingEnabled
            )
        }
    }
    
    LaunchedEffect(
        locationSharingEnabled,
        profileVisibilityEnabled,
        contactInfoSharingEnabled,
        analyticsEnabled,
        personalizedAdsEnabled,
        dataCollectionEnabled,
        thirdPartySharingEnabled
    ) {
        queueSave()
    }
    
    // Salvar quando sair da tela (garantir salvamento final)
    DisposableEffect(Unit) {
        onDispose {
            saveJob?.cancel()
            viewModel.savePrivacySettings(
                locationSharing = locationSharingEnabled,
                profileVisible = profileVisibilityEnabled,
                contactInfoSharing = contactInfoSharingEnabled,
                analytics = analyticsEnabled,
                personalizedAds = personalizedAdsEnabled,
                dataCollection = dataCollectionEnabled,
                thirdPartySharing = thirdPartySharingEnabled
            )
        }
    }
    
    // Permiss√£o de localiza√ß√£o
    val locationPermission = rememberPermissionState(Manifest.permission.ACCESS_FINE_LOCATION)
    
    // Flag para evitar solicita√ß√µes cont√≠nuas de permiss√£o
    var hasRequestedLocationPermission by remember { mutableStateOf(false) }
    
    // Solicitar permiss√£o apenas uma vez quando locationSharingEnabled for habilitado
    LaunchedEffect(locationSharingEnabled) {
        if (locationSharingEnabled && 
            locationPermission.status !is PermissionStatus.Granted && 
            !hasRequestedLocationPermission) {
            hasRequestedLocationPermission = true
            locationPermission.launchPermissionRequest()
        } else if (!locationSharingEnabled) {
            hasRequestedLocationPermission = false
        }
    }
    
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Privacidade",
                subtitle = "Controle como suas informa√ß√µes s√£o utilizadas",
                onBackClick = onBackClick
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp)
                .verticalScroll(rememberScrollState()),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // Privacy Overview
            Card(
                modifier = Modifier.fillMaxWidth(),
                colors = CardDefaults.cardColors(
                    containerColor = TaskGoBackgroundGray
                )
            ) {
                Column(
                    modifier = Modifier.padding(16.dp)
                ) {
                    Text(
                        text = "Sua Privacidade √© Importante",
                        style = FigmaSectionTitle,
                        color = TaskGoTextBlack,
                        fontWeight = FontWeight.Bold
                    )
                    
                    Spacer(modifier = Modifier.height(8.dp))
                    
                    Text(
                        text = "Controle como suas informa√ß√µes s√£o usadas e compartilhadas no TaskGo. Voc√™ pode alterar essas configura√ß√µes a qualquer momento.",
                        style = FigmaProductDescription,
                        color = TaskGoTextBlack
                    )
                }
            }
            
            // Location Privacy
            Card(
                modifier = Modifier.fillMaxWidth(),
                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
            ) {
                Column(
                    modifier = Modifier.padding(16.dp)
                ) {
                    Text(
                        text = "Localiza√ß√£o",
                        style = FigmaSectionTitle,
                        color = TaskGoTextBlack,
                        fontWeight = FontWeight.Bold
                    )
                    
                    Spacer(modifier = Modifier.height(16.dp))
                    
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Row(
                            modifier = Modifier.weight(1f),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Icon(
                                imageVector = Icons.Default.LocationOn,
                                contentDescription = null,
                                tint = TaskGoGreen,
                                modifier = Modifier.size(24.dp)
                            )
                            Spacer(modifier = Modifier.width(12.dp))
                            Column(
                                modifier = Modifier.weight(1f)
                            ) {
                                Text(
                                    text = "Compartilhar Localiza√ß√£o",
                                    style = FigmaProductName,
                                    color = TaskGoTextBlack,
                                    fontWeight = FontWeight.Medium
                                )
                                Spacer(modifier = Modifier.height(4.dp))
                                Text(
                                    text = "Permitir que prestadores vejam sua localiza√ß√£o para servi√ßos pr√≥ximos",
                                    style = FigmaStatusText,
                                    color = TaskGoTextGray,
                                    modifier = Modifier.fillMaxWidth()
                                )
                            }
                        }
                        
                        Spacer(modifier = Modifier.width(16.dp))
                        
                        Switch(
                            checked = locationSharingEnabled,
                            onCheckedChange = { locationSharingEnabled = it }
                        )
                    }
                    
                    if (locationSharingEnabled) {
                        Spacer(modifier = Modifier.height(12.dp))
                        
                        OutlinedButton(
                            onClick = {
                                // Abrir configura√ß√µes de localiza√ß√£o do Android
                                val intent = android.content.Intent(android.provider.Settings.ACTION_LOCATION_SOURCE_SETTINGS)
                                try {
                                    context.startActivity(intent)
                                } catch (e: Exception) {
                                    android.util.Log.e("PrivacyScreen", "Erro ao abrir configura√ß√µes: ${e.message}", e)
                                }
                            },
                            modifier = Modifier.fillMaxWidth()
                        ) {
                            Icon(
                                imageVector = Icons.Default.Settings,
                                contentDescription = null,
                                modifier = Modifier.size(18.dp)
                            )
                            Spacer(modifier = Modifier.width(8.dp))
                            Text("Configura√ß√µes de Localiza√ß√£o")
                        }
                    }
                }
            }
            
            // Profile Privacy
            Card(
                modifier = Modifier.fillMaxWidth(),
                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
            ) {
                Column(
                    modifier = Modifier.padding(16.dp)
                ) {
                    Text(
                        text = "Perfil e Visibilidade",
                        style = FigmaSectionTitle,
                        color = TaskGoTextBlack,
                        fontWeight = FontWeight.Bold
                    )
                    
                    Spacer(modifier = Modifier.height(16.dp))
                    
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Row(
                            modifier = Modifier.weight(1f),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Icon(
                                imageVector = Icons.Default.Visibility,
                                contentDescription = null,
                                tint = TaskGoGreen,
                                modifier = Modifier.size(24.dp)
                            )
                            Spacer(modifier = Modifier.width(12.dp))
                            Column(
                                modifier = Modifier.weight(1f)
                            ) {
                                Text(
                                    text = "Perfil P√∫blico",
                                    style = FigmaProductName,
                                    color = TaskGoTextBlack,
                                    fontWeight = FontWeight.Medium
                                )
                                Spacer(modifier = Modifier.height(4.dp))
                                Text(
                                    text = "Permitir que outros usu√°rios vejam seu perfil",
                                    style = FigmaStatusText,
                                    color = TaskGoTextGray,
                                    modifier = Modifier.fillMaxWidth()
                                )
                            }
                        }
                        
                        Spacer(modifier = Modifier.width(16.dp))
                        
                        Switch(
                            checked = profileVisibilityEnabled,
                            onCheckedChange = { profileVisibilityEnabled = it }
                        )
                    }
                    
                    Spacer(modifier = Modifier.height(16.dp))
                    
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Row(
                            modifier = Modifier.weight(1f),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Icon(
                                imageVector = Icons.Default.ContactPhone,
                                contentDescription = null,
                                tint = TaskGoGreen,
                                modifier = Modifier.size(24.dp)
                            )
                            Spacer(modifier = Modifier.width(12.dp))
                            Column(
                                modifier = Modifier.weight(1f)
                            ) {
                                Text(
                                    text = "Compartilhar Contato",
                                    style = FigmaProductName,
                                    color = TaskGoTextBlack,
                                    fontWeight = FontWeight.Medium
                                )
                                Spacer(modifier = Modifier.height(4.dp))
                                Text(
                                    text = "Permitir que prestadores vejam seu telefone e e-mail",
                                    style = FigmaStatusText,
                                    color = TaskGoTextGray,
                                    modifier = Modifier.fillMaxWidth()
                                )
                            }
                        }
                        
                        Spacer(modifier = Modifier.width(16.dp))
                        
                        Switch(
                            checked = contactInfoSharingEnabled,
                            onCheckedChange = { contactInfoSharingEnabled = it }
                        )
                    }
                }
            }
            
            // Data Collection
            Card(
                modifier = Modifier.fillMaxWidth(),
                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
            ) {
                Column(
                    modifier = Modifier.padding(16.dp)
                ) {
                    Text(
                        text = "Coleta de Dados",
                        style = FigmaSectionTitle,
                        color = TaskGoTextBlack,
                        fontWeight = FontWeight.Bold
                    )
                    
                    Spacer(modifier = Modifier.height(16.dp))
                    
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Row(
                            modifier = Modifier.weight(1f),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Icon(
                                imageVector = Icons.Default.Analytics,
                                contentDescription = null,
                                tint = TaskGoGreen,
                                modifier = Modifier.size(24.dp)
                            )
                            Spacer(modifier = Modifier.width(12.dp))
                            Column(
                                modifier = Modifier.weight(1f)
                            ) {
                                Text(
                                    text = "Analytics e M√©tricas",
                                    style = FigmaProductName,
                                    color = TaskGoTextBlack,
                                    fontWeight = FontWeight.Medium
                                )
                                Spacer(modifier = Modifier.height(4.dp))
                                Text(
                                    text = "Coletar dados para melhorar o aplicativo",
                                    style = FigmaStatusText,
                                    color = TaskGoTextGray,
                                    modifier = Modifier.fillMaxWidth()
                                )
                            }
                        }
                        
                        Spacer(modifier = Modifier.width(16.dp))
                        
                        Switch(
                            checked = analyticsEnabled,
                            onCheckedChange = { analyticsEnabled = it }
                        )
                    }
                    
                    Spacer(modifier = Modifier.height(16.dp))
                    
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Row(
                            modifier = Modifier.weight(1f),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Icon(
                                imageVector = Icons.Default.DataUsage,
                                contentDescription = null,
                                tint = TaskGoGreen,
                                modifier = Modifier.size(24.dp)
                            )
                            Spacer(modifier = Modifier.width(12.dp))
                            Column(
                                modifier = Modifier.weight(1f)
                            ) {
                                Text(
                                    text = "Coleta de Dados",
                                    style = FigmaProductName,
                                    color = TaskGoTextBlack,
                                    fontWeight = FontWeight.Medium
                                )
                                Spacer(modifier = Modifier.height(4.dp))
                                Text(
                                    text = "Armazenar informa√ß√µes sobre seu uso do aplicativo",
                                    style = FigmaStatusText,
                                    color = TaskGoTextGray,
                                    modifier = Modifier.fillMaxWidth()
                                )
                            }
                        }
                        
                        Spacer(modifier = Modifier.width(16.dp))
                        
                        Switch(
                            checked = dataCollectionEnabled,
                            onCheckedChange = { dataCollectionEnabled = it }
                        )
                    }
                }
            }
            
            // Advertising
            Card(
                modifier = Modifier.fillMaxWidth(),
                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
            ) {
                Column(
                    modifier = Modifier.padding(16.dp)
                ) {
                    Text(
                        text = "Publicidade",
                        style = FigmaSectionTitle,
                        color = TaskGoTextBlack,
                        fontWeight = FontWeight.Bold
                    )
                    
                    Spacer(modifier = Modifier.height(16.dp))
                    
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Row(
                            modifier = Modifier.weight(1f),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Icon(
                                imageVector = Icons.Default.ShoppingCart,
                                contentDescription = null,
                                tint = TaskGoGreen,
                                modifier = Modifier.size(24.dp)
                            )
                            Spacer(modifier = Modifier.width(12.dp))
                            Column(
                                modifier = Modifier.weight(1f)
                            ) {
                                Text(
                                    text = "Publicidade Personalizada",
                                    style = FigmaProductName,
                                    color = TaskGoTextBlack,
                                    fontWeight = FontWeight.Medium
                                )
                                Spacer(modifier = Modifier.height(4.dp))
                                Text(
                                    text = "Mostrar an√∫ncios baseados em seus interesses",
                                    style = FigmaStatusText,
                                    color = TaskGoTextGray,
                                    modifier = Modifier.fillMaxWidth()
                                )
                            }
                        }
                        
                        Spacer(modifier = Modifier.width(16.dp))
                        
                        Switch(
                            checked = personalizedAdsEnabled,
                            onCheckedChange = { personalizedAdsEnabled = it }
                        )
                    }
                    
                    Spacer(modifier = Modifier.height(16.dp))
                    
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Row(
                            modifier = Modifier.weight(1f),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Icon(
                                imageVector = Icons.Default.Share,
                                contentDescription = null,
                                tint = TaskGoGreen,
                                modifier = Modifier.size(24.dp)
                            )
                            Spacer(modifier = Modifier.width(12.dp))
                            Column(
                                modifier = Modifier.weight(1f)
                            ) {
                                Text(
                                    text = "Compartilhamento com Terceiros",
                                    style = FigmaProductName,
                                    color = TaskGoTextBlack,
                                    fontWeight = FontWeight.Medium
                                )
                                Spacer(modifier = Modifier.height(4.dp))
                                Text(
                                    text = "Permitir que parceiros acessem dados para publicidade",
                                    style = FigmaStatusText,
                                    color = TaskGoTextGray,
                                    modifier = Modifier.fillMaxWidth()
                                )
                            }
                        }
                        
                        Spacer(modifier = Modifier.width(16.dp))
                        
                        Switch(
                            checked = thirdPartySharingEnabled,
                            onCheckedChange = { thirdPartySharingEnabled = it }
                        )
                    }
                }
            }
            
            // Privacy Actions
            Card(
                modifier = Modifier.fillMaxWidth(),
                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
            ) {
                Column(
                    modifier = Modifier.padding(16.dp)
                ) {
                    Text(
                        text = "A√ß√µes de Privacidade",
                        style = FigmaSectionTitle,
                        color = TaskGoTextBlack,
                        fontWeight = FontWeight.Bold
                    )
                    
                    Spacer(modifier = Modifier.height(16.dp))
                    
                    var isExporting by remember { mutableStateOf(false) }
                    var exportMessage by remember { mutableStateOf<String?>(null) }
                    
                    OutlinedButton(
                        onClick = {
                            val user = currentUser
                            if (user != null) {
                                isExporting = true
                                coroutineScope.launch {
                                    try {
                                        val result = lgpdManager.exportUserData(user.uid)
                                        result.fold(
                                            onSuccess = { export ->
                                                exportMessage = "Dados exportados com sucesso! Total: ${export.data.size} itens"
                                                isExporting = false
                                            },
                                            onFailure = { error ->
                                                exportMessage = "Erro ao exportar: ${error.message}"
                                                isExporting = false
                                                // Tratar erro espec√≠fico do Secure Token API bloqueado
                                                if (error.message?.contains("SecureToken") == true || error.message?.contains("securetoken") == true) {
                                                    android.util.Log.w("PrivacyScreen", "Firebase Secure Token API bloqueado. Verifique configura√ß√µes do Google Cloud.")
                                                }
                                            }
                                        )
                                    } catch (e: Exception) {
                                        exportMessage = "Erro: ${e.message}"
                                        isExporting = false
                                        if (e.message?.contains("SecureToken") == true || e.message?.contains("securetoken") == true) {
                                            android.util.Log.w("PrivacyScreen", "Firebase Secure Token API bloqueado. Verifique configura√ß√µes do Google Cloud.")
                                        }
                                    }
                                }
                            }
                        },
                        modifier = Modifier.fillMaxWidth(),
                        enabled = !isExporting && currentUser != null
                    ) {
                        if (isExporting) {
                            CircularProgressIndicator(modifier = Modifier.size(18.dp))
                        } else {
                            Icon(
                                imageVector = Icons.Default.Download,
                                contentDescription = null,
                                modifier = Modifier.size(18.dp)
                            )
                        }
                        Spacer(modifier = Modifier.width(8.dp))
                        Text(if (isExporting) "Exportando..." else "Baixar Meus Dados")
                    }
                    
                    if (exportMessage != null) {
                        Text(
                            text = exportMessage!!,
                            style = MaterialTheme.typography.bodySmall,
                            color = if (exportMessage!!.contains("sucesso")) TaskGoGreen else MaterialTheme.colorScheme.error,
                            modifier = Modifier.padding(top = 8.dp)
                        )
                    }
                    
                    Spacer(modifier = Modifier.height(12.dp))
                    
                    var showDeleteConfirmation by remember { mutableStateOf(false) }
                    
                    OutlinedButton(
                        onClick = { showDeleteConfirmation = true },
                        modifier = Modifier.fillMaxWidth(),
                        colors = ButtonDefaults.outlinedButtonColors(
                            containerColor = Color.Transparent,
                            contentColor = TaskGoError
                        )
                    ) {
                        Icon(
                            imageVector = Icons.Default.DeleteForever,
                            contentDescription = null,
                            modifier = Modifier.size(18.dp),
                            tint = TaskGoError
                        )
                        Spacer(modifier = Modifier.width(8.dp))
                        Text("Excluir Meus Dados", color = TaskGoError)
                    }
                    
                    if (showDeleteConfirmation) {
                        AlertDialog(
                            onDismissRequest = { showDeleteConfirmation = false },
                            title = { Text("Confirmar Exclus√£o", color = TaskGoError) },
                            text = { 
                                Text(
                                    "Tem certeza que deseja excluir permanentemente todos os seus dados? Esta a√ß√£o n√£o pode ser desfeita.",
                                    color = TaskGoTextBlack
                                )
                            },
                            confirmButton = {
                                TextButton(
                                    onClick = {
                                        val user = currentUser
                                        if (user != null) {
                                            coroutineScope.launch {
                                                try {
                                                    // Chamar Cloud Function para excluir conta completamente (inclui Firebase Auth)
                                                    val result = functionsService.deleteUserAccount()
                                                    result.fold(
                                                        onSuccess = { data ->
                                                            val message = data["message"] as? String ?: "Conta exclu√≠da com sucesso"
                                                            exportMessage = message
                                                            showDeleteConfirmation = false
                                                            // Fazer logout ap√≥s exclus√£o bem-sucedida
                                                            auth.signOut()
                                                            // Navegar para login ser√° feito pela navega√ß√£o
                                                        },
                                                        onFailure = { error ->
                                                            exportMessage = "Erro ao excluir conta: ${error.message}"
                                                            showDeleteConfirmation = false
                                                            android.util.Log.e("PrivacyScreen", "Erro ao excluir conta", error)
                                                        }
                                                    )
                                                } catch (e: Exception) {
                                                    exportMessage = "Erro: ${e.message}"
                                                    showDeleteConfirmation = false
                                                    android.util.Log.e("PrivacyScreen", "Erro ao excluir conta", e)
                                                }
                                            }
                                        }
                                    },
                                    colors = ButtonDefaults.textButtonColors(
                                        contentColor = TaskGoError
                                    )
                                ) {
                                    Text("Excluir", fontWeight = FontWeight.Bold)
                                }
                            },
                            dismissButton = {
                                TextButton(onClick = { showDeleteConfirmation = false }) {
                                    Text("Cancelar")
                                }
                            }
                        )
                    }
                    
                    Spacer(modifier = Modifier.height(12.dp))
                    
                    OutlinedButton(
                        onClick = onNavigateToPrivacyPolicy,
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Icon(
                            imageVector = Icons.Default.Policy,
                            contentDescription = null,
                            modifier = Modifier.size(18.dp)
                        )
                        Spacer(modifier = Modifier.width(8.dp))
                        Text("Pol√≠tica de Privacidade")
                    }
                    
                    Spacer(modifier = Modifier.height(12.dp))
                    
                    OutlinedButton(
                        onClick = onNavigateToTermsOfService,
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Icon(
                            imageVector = Icons.Default.Description,
                            contentDescription = null,
                            modifier = Modifier.size(18.dp)
                        )
                        Spacer(modifier = Modifier.width(8.dp))
                        Text("Termos de Uso")
                    }
                    
                    Spacer(modifier = Modifier.height(12.dp))
                    
                    OutlinedButton(
                        onClick = onNavigateToConsentHistory,
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Icon(
                            imageVector = Icons.Default.History,
                            contentDescription = null,
                            modifier = Modifier.size(18.dp)
                        )
                        Spacer(modifier = Modifier.width(8.dp))
                        Text("Hist√≥rico de Consentimentos")
                    }
                }
            }
            
            // Privacy Status
            Card(
                modifier = Modifier.fillMaxWidth(),
                colors = CardDefaults.cardColors(
                    containerColor = TaskGoSurfaceGray
                )
            ) {
                Column(
                    modifier = Modifier.padding(16.dp),
                    horizontalAlignment = Alignment.CenterHorizontally
                ) {
                    Text(
                        text = "Status da Privacidade",
                        style = FigmaSectionTitle,
                        color = TaskGoTextBlack,
                        fontWeight = FontWeight.Bold
                    )
                    
                    Spacer(modifier = Modifier.height(8.dp))
                    
                    val privacyScore = calculatePrivacyScore(
                        locationSharingEnabled,
                        profileVisibilityEnabled,
                        contactInfoSharingEnabled,
                        analyticsEnabled,
                        personalizedAdsEnabled,
                        dataCollectionEnabled,
                        thirdPartySharingEnabled
                    )
                    
                    Text(
                        text = "Sua privacidade est√° ${getPrivacyStatus(privacyScore)}",
                        style = FigmaProductDescription,
                        color = TaskGoTextGray
                    )
                    
                    Spacer(modifier = Modifier.height(8.dp))
                    
                    LinearProgressIndicator(
                        modifier = Modifier.fillMaxWidth(),
                        color = getPrivacyColor(privacyScore),
                        progress = { privacyScore / 100f }
                    )
                    
                    Spacer(modifier = Modifier.height(8.dp))
                    
                    Text(
                        text = "$privacyScore%",
                        style = FigmaProductName,
                        color = TaskGoTextBlack,
                        fontWeight = FontWeight.Bold
                    )
                }
            }
            
        }
    }
}

private fun calculatePrivacyScore(
    locationSharing: Boolean,
    profileVisibility: Boolean,
    contactInfoSharing: Boolean,
    analytics: Boolean,
    personalizedAds: Boolean,
    dataCollection: Boolean,
    thirdPartySharing: Boolean
): Int {
    var score = 100
    
    if (locationSharing) score -= 15
    if (profileVisibility) score -= 10
    if (contactInfoSharing) score -= 20
    if (analytics) score -= 10
    if (personalizedAds) score -= 15
    if (dataCollection) score -= 10
    if (thirdPartySharing) score -= 20
    
    return maxOf(score, 0)
}

private fun getPrivacyStatus(score: Int): String {
    return when {
        score >= 80 -> "muito bem protegida"
        score >= 60 -> "bem protegida"
        score >= 40 -> "moderadamente protegida"
        score >= 20 -> "pouco protegida"
        else -> "muito exposta"
    }
}

private fun getPrivacyColor(score: Int): Color {
    return when {
        score >= 80 -> TaskGoSuccessGreen
        score >= 60 -> Color(0xFF8BC34A)
        score >= 40 -> TaskGoAmber
        score >= 20 -> TaskGoOrange
        else -> Color(0xFFF44336)
    }
}





```

## [FRONTEND]: feature/settings/presentation/SecuritySettingsScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.settings.presentation

import android.app.Activity
import androidx.compose.foundation.background
import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowForward
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.collectAsState
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.theme.*
import com.taskgoapp.taskgo.data.local.datastore.PreferencesManager
import com.taskgoapp.taskgo.core.security.LGPDComplianceManager
import com.taskgoapp.taskgo.core.security.PDFExporter
import com.google.firebase.auth.FirebaseAuth
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.launch
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.Dispatchers
import android.content.Intent
import android.net.Uri
import android.widget.Toast
import androidx.core.content.FileProvider
import com.taskgoapp.taskgo.data.repository.FirestoreUserRepository
import javax.inject.Inject

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun SecuritySettingsScreen(
    onBackClick: () -> Unit,
    onNavigateToIdentityVerification: () -> Unit,
    onNavigateToConsentHistory: () -> Unit = {},
    onNavigateToLogin: () -> Unit = {}, // Callback para navegar para login ap√≥s logout
    viewModel: SecuritySettingsViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    val context = LocalContext.current
    val auth = FirebaseAuth.getInstance()
    val currentUser = auth.currentUser
    
    // Usar um escopo persistente para opera√ß√µes que precisam continuar ap√≥s o composable sair
    val persistentScope = remember {
        CoroutineScope(
            SupervisorJob() + Dispatchers.IO
        )
    }
    
    val lgpdManager = remember(context) {
        com.taskgoapp.taskgo.core.security.LGPDComplianceManager(
            context,
            com.taskgoapp.taskgo.core.firebase.FirestoreHelper.getInstance()
        )
    }
    val pdfExporter = remember(context) {
        com.taskgoapp.taskgo.core.security.PDFExporter(context)
    }
    
    var showChangeMethodDialog by remember { mutableStateOf(false) }
    var showDeleteConfirmation by remember { mutableStateOf(false) }
    var showExportMessage by remember { mutableStateOf<String?>(null) }
    var isExporting by remember { mutableStateOf(false) }
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Seguran√ßa",
                subtitle = "Autentica√ß√£o de duas etapas e prote√ß√£o de dados",
                onBackClick = onBackClick,
                backgroundColor = TaskGoGreen,
                titleColor = Color.White,
                backIconColor = Color.White
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .background(TaskGoBackgroundWhite)
                .verticalScroll(rememberScrollState())
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // Verifica√ß√£o de Identidade
            Card(
                modifier = Modifier.fillMaxWidth(),
                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
            ) {
                Column(
                    modifier = Modifier.padding(16.dp)
                ) {
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Column(modifier = Modifier.weight(1f)) {
                            Text(
                                text = "Verifica√ß√£o de Identidade",
                                style = MaterialTheme.typography.titleMedium,
                                fontWeight = FontWeight.Bold,
                                color = TaskGoTextBlack
                            )
                            Spacer(modifier = Modifier.height(4.dp))
                            Text(
                                text = "Envie seus documentos para verifica√ß√£o",
                                style = MaterialTheme.typography.bodySmall,
                                color = TaskGoTextGray
                            )
                        }
                        IconButton(onClick = onNavigateToIdentityVerification) {
                            Icon(
                                imageVector = Icons.AutoMirrored.Filled.ArrowForward,
                                contentDescription = "Verificar identidade",
                                tint = TaskGoGreen
                            )
                        }
                    }
                }
            }
            
            // Biometria removida - login apenas no primeiro acesso
            
            // Autentica√ß√£o de Duas Etapas
            Card(
                modifier = Modifier.fillMaxWidth(),
                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
            ) {
                Column(
                    modifier = Modifier.padding(16.dp)
                ) {
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Column(modifier = Modifier.weight(1f)) {
                            Text(
                                text = "Autentica√ß√£o de Duas Etapas",
                                style = MaterialTheme.typography.titleMedium,
                                fontWeight = FontWeight.Bold,
                                color = TaskGoTextBlack
                            )
                            Spacer(modifier = Modifier.height(4.dp))
                            Text(
                                text = "Receba um c√≥digo por email ou telefone ao fazer login",
                                style = MaterialTheme.typography.bodySmall,
                                color = TaskGoTextGray
                            )
                        }
                        Switch(
                            checked = uiState.twoFactorEnabled,
                            onCheckedChange = { viewModel.toggleTwoFactor(it) }
                        )
                    }
                    
                    if (uiState.twoFactorEnabled) {
                        Spacer(modifier = Modifier.height(12.dp))
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.SpaceBetween,
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Text(
                                text = "M√©todo: ${uiState.twoFactorMethod ?: "Email ou Telefone"}",
                                style = MaterialTheme.typography.bodySmall,
                                color = TaskGoTextGray
                            )
                            TextButton(onClick = { showChangeMethodDialog = true }) {
                                Text("Alterar", color = TaskGoGreen)
                            }
                        }
                    }
                }
            }
            
            // Gerenciamento de Prote√ß√£o de Dados (LGPD)
            Card(
                modifier = Modifier.fillMaxWidth(),
                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
            ) {
                Column(
                    modifier = Modifier.padding(16.dp),
                    verticalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    Text(
                        text = "Prote√ß√£o de Dados (LGPD)",
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold,
                        color = TaskGoTextBlack
                    )
                    
                    // Exportar dados
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Column(modifier = Modifier.weight(1f)) {
                            Text(
                                text = "Exportar Meus Dados",
                                style = MaterialTheme.typography.bodyLarge,
                                fontWeight = FontWeight.Medium,
                                color = TaskGoTextBlack
                            )
                            Spacer(modifier = Modifier.height(4.dp))
                            Text(
                                text = "Baixe uma c√≥pia dos seus dados",
                                style = MaterialTheme.typography.bodySmall,
                                color = TaskGoTextGray
                            )
                        }
                        TextButton(
                            onClick = {
                                if (currentUser != null) {
                                    isExporting = true
                                    persistentScope.launch {
                                        try {
                                            // Primeiro, obter os dados
                                            val dataResult = lgpdManager.exportUserData(currentUser.uid)
                                            dataResult.fold(
                                                onSuccess = { export ->
                                                    // Gerar PDF
                                                    val pdfResult = pdfExporter.exportUserDataToPDF(
                                                        currentUser.uid,
                                                        export.data
                                                    )
                                                    pdfResult.fold(
                                                        onSuccess = { pdfFile ->
                                                            // Compartilhar o arquivo
                                                            val intent = Intent(Intent.ACTION_VIEW).apply {
                                                                val uri = if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.N) {
                                                                    FileProvider.getUriForFile(
                                                                        context,
                                                                        "${context.packageName}.fileprovider",
                                                                        pdfFile
                                                                    )
                                                                } else {
                                                                    Uri.fromFile(pdfFile)
                                                                }
                                                                setDataAndType(uri, "application/pdf")
                                                                addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
                                                            }
                                                            context.startActivity(Intent.createChooser(intent, "Abrir PDF com"))
                                                            
                                                            showExportMessage = "PDF exportado com sucesso!\nLocaliza√ß√£o: ${pdfFile.absolutePath}"
                                                            isExporting = false
                                                        },
                                                        onFailure = { error ->
                                                            showExportMessage = "Erro ao gerar PDF: ${error.message}"
                                                            isExporting = false
                                                        }
                                                    )
                                                },
                                                onFailure = { error ->
                                                    showExportMessage = "Erro ao obter dados: ${error.message}"
                                                    isExporting = false
                                                    // Tratar erro espec√≠fico do Secure Token API bloqueado
                                                    if (error.message?.contains("SecureToken") == true || error.message?.contains("securetoken") == true) {
                                                        android.util.Log.w("SecuritySettingsScreen", "Firebase Secure Token API bloqueado. Verifique configura√ß√µes do Google Cloud.")
                                                    }
                                                }
                                            )
                                        } catch (e: Exception) {
                                            showExportMessage = "Erro: ${e.message}"
                                            isExporting = false
                                            if (e.message?.contains("SecureToken") == true || e.message?.contains("securetoken") == true) {
                                                android.util.Log.w("SecuritySettingsScreen", "Firebase Secure Token API bloqueado. Verifique configura√ß√µes do Google Cloud.")
                                            }
                                        }
                                    }
                                }
                            },
                            enabled = !isExporting && currentUser != null
                        ) {
                            if (isExporting) {
                                CircularProgressIndicator(modifier = Modifier.size(16.dp))
                            } else {
                                Text("Exportar", color = TaskGoGreen)
                            }
                        }
                    }
                    
                    HorizontalDivider()
                    
                    // Excluir conta
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Column(modifier = Modifier.weight(1f)) {
                            Text(
                                text = "Excluir Minha Conta",
                                style = MaterialTheme.typography.bodyLarge,
                                fontWeight = FontWeight.Medium,
                                color = TaskGoError
                            )
                            Spacer(modifier = Modifier.height(4.dp))
                            Text(
                                text = "Remover permanentemente todos os seus dados",
                                style = MaterialTheme.typography.bodySmall,
                                color = TaskGoTextGray
                            )
                        }
                        TextButton(onClick = { showDeleteConfirmation = true }) {
                            Text("Excluir", color = TaskGoError)
                        }
                    }
                    
                    HorizontalDivider()
                    
                    // Hist√≥rico de consentimentos
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Column(modifier = Modifier.weight(1f)) {
                            Text(
                                text = "Hist√≥rico de Consentimentos",
                                style = MaterialTheme.typography.bodyLarge,
                                fontWeight = FontWeight.Medium,
                                color = TaskGoTextBlack
                            )
                            Spacer(modifier = Modifier.height(4.dp))
                            Text(
                                text = "Visualize seus consentimentos de dados",
                                style = MaterialTheme.typography.bodySmall,
                                color = TaskGoTextGray
                            )
                        }
                        IconButton(onClick = onNavigateToConsentHistory) {
                            Icon(
                                imageVector = Icons.AutoMirrored.Filled.ArrowForward,
                                contentDescription = "Ver hist√≥rico",
                                tint = TaskGoGreen
                            )
                        }
                    }
                }
            }
            
            // Informa√ß√µes
            Card(
                modifier = Modifier.fillMaxWidth(),
                colors = CardDefaults.cardColors(
                    containerColor = Color(0xFFE3F2FD)
                )
            ) {
                Column(
                    modifier = Modifier.padding(16.dp)
                ) {
                    Row(
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Icon(
                            imageVector = Icons.Default.Info,
                            contentDescription = null,
                            tint = TaskGoGreen,
                            modifier = Modifier.size(24.dp)
                        )
                        Spacer(modifier = Modifier.width(8.dp))
                        Text(
                            text = "Dicas de Seguran√ßa",
                            style = MaterialTheme.typography.titleSmall,
                            fontWeight = FontWeight.Bold,
                            color = TaskGoTextBlack
                        )
                    }
                    Spacer(modifier = Modifier.height(8.dp))
                    Text(
                        text = "‚Ä¢ Mantenha seus dados atualizados\n‚Ä¢ Use senhas fortes\n‚Ä¢ Ative a autentica√ß√£o de duas etapas\n‚Ä¢ Verifique sua identidade\n‚Ä¢ Revise regularmente suas configura√ß√µes de privacidade",
                        style = MaterialTheme.typography.bodySmall,
                        color = TaskGoTextGray
                    )
                }
            }
            
            // Di√°logos e mensagens
            if (showChangeMethodDialog) {
                AlertDialog(
                    onDismissRequest = { showChangeMethodDialog = false },
                    title = { 
                        Text(
                            "Alterar M√©todo de 2FA",
                            fontWeight = FontWeight.Bold,
                            color = TaskGoTextBlack
                        ) 
                    },
                    text = {
                        Column(
                            modifier = Modifier.fillMaxWidth(),
                            verticalArrangement = Arrangement.spacedBy(12.dp)
                        ) {
                            Text(
                                text = "Escolha o m√©todo de autentica√ß√£o de duas etapas:",
                                style = MaterialTheme.typography.bodyMedium,
                                color = TaskGoTextGray
                            )
                            
                            data class TwoFactorMethod(
                                val key: String,
                                val icon: androidx.compose.ui.graphics.vector.ImageVector,
                                val title: String,
                                val description: String
                            )
                            
                            val methods = listOf(
                                TwoFactorMethod("email", Icons.Default.Email, "Email", "C√≥digo enviado por email"),
                                TwoFactorMethod("sms", Icons.Default.Phone, "Telefone", "C√≥digo enviado por SMS"),
                                TwoFactorMethod("email e telefone", Icons.Default.VerifiedUser, "Email e Telefone", "C√≥digo enviado por ambos")
                            )
                            
                            methods.forEach { method ->
                                val methodKey = method.key
                                val icon = method.icon
                                val title = method.title
                                val description = method.description
                                Card(
                                    modifier = Modifier
                                        .fillMaxWidth()
                                        .clickable {
                                            viewModel.changeTwoFactorMethod(methodKey)
                                            showChangeMethodDialog = false
                                        },
                                    colors = CardDefaults.cardColors(
                                        containerColor = if (uiState.twoFactorMethod == methodKey) 
                                            TaskGoGreen.copy(alpha = 0.1f) 
                                        else 
                                            MaterialTheme.colorScheme.surface
                                    ),
                                    border = if (uiState.twoFactorMethod == methodKey) 
                                        BorderStroke(2.dp, TaskGoGreen) 
                                    else null
                                ) {
                                    Row(
                                        modifier = Modifier
                                            .fillMaxWidth()
                                            .padding(16.dp),
                                        verticalAlignment = Alignment.CenterVertically
                                    ) {
                                        RadioButton(
                                            selected = uiState.twoFactorMethod == methodKey,
                                            onClick = {
                                                viewModel.changeTwoFactorMethod(methodKey)
                                                showChangeMethodDialog = false
                                            },
                                            colors = RadioButtonDefaults.colors(
                                                selectedColor = TaskGoGreen
                                            )
                                        )
                                        Spacer(modifier = Modifier.width(12.dp))
                                        Icon(
                                            imageVector = icon,
                                            contentDescription = null,
                                            tint = if (uiState.twoFactorMethod == methodKey) 
                                                TaskGoGreen 
                                            else 
                                                TaskGoTextGray,
                                            modifier = Modifier.size(24.dp)
                                        )
                                        Spacer(modifier = Modifier.width(12.dp))
                                        Column(modifier = Modifier.weight(1f)) {
                                            Text(
                                                text = title,
                                                style = MaterialTheme.typography.bodyLarge,
                                                fontWeight = FontWeight.Medium,
                                                color = TaskGoTextBlack
                                            )
                                            Text(
                                                text = description,
                                                style = MaterialTheme.typography.bodySmall,
                                                color = TaskGoTextGray
                                            )
                                        }
                                    }
                                }
                            }
                        }
                    },
                    confirmButton = {
                        TextButton(onClick = { showChangeMethodDialog = false }) {
                            Text("Fechar", color = TaskGoGreen)
                        }
                    }
                )
            }
            
            if (showDeleteConfirmation) {
                AlertDialog(
                    onDismissRequest = { showDeleteConfirmation = false },
                    title = { Text("Confirmar Exclus√£o", color = TaskGoError) },
                    text = {
                        Text(
                            "Tem certeza que deseja excluir permanentemente sua conta? Esta a√ß√£o n√£o pode ser desfeita.",
                            color = TaskGoTextBlack
                        )
                    },
                    confirmButton = {
                        TextButton(
                            onClick = {
                                if (currentUser != null) {
                                    persistentScope.launch {
                                        try {
                                            // 1. Chamar Cloud Function para deletar dados
                                            val functionsService = com.taskgoapp.taskgo.data.firebase.FirebaseFunctionsService(
                                                com.google.firebase.functions.FirebaseFunctions.getInstance()
                                            )
                                            val deleteResult = functionsService.deleteUserAccount()
                                            
                                            // Fazer logout IMEDIATAMENTE antes mesmo de aguardar resultado
                                            // Isso garante que o usu√°rio seja deslogado mesmo se houver erro na fun√ß√£o
                                            auth.signOut()
                                            
                                            // Aguardar um pouco para garantir que o signOut foi processado
                                            kotlinx.coroutines.delay(500)
                                            
                                            // Navegar para login ap√≥s logout
                                            kotlinx.coroutines.withContext(kotlinx.coroutines.Dispatchers.Main) {
                                                showDeleteConfirmation = false
                                                showExportMessage = null
                                                // Navegar para login - o MainActivity ir√° detectar que n√£o h√° usu√°rio autenticado
                                                onNavigateToLogin()
                                            }
                                            
                                            deleteResult.fold(
                                                onSuccess = { data ->
                                                    val message = data["message"] as? String ?: "Conta exclu√≠da com sucesso"
                                                    android.util.Log.d("SecuritySettingsScreen", message)
                                                    // Mensagem n√£o precisa ser mostrada, pois j√° navegamos para login
                                                },
                                                onFailure = { error ->
                                                    android.util.Log.e("SecuritySettingsScreen", "Erro ao excluir conta", error)
                                                    // Logout j√° foi feito e navega√ß√£o j√° ocorreu, apenas logamos o erro
                                                }
                                            )
                                        } catch (e: Exception) {
                                            showExportMessage = "Erro: ${e.message}"
                                            showDeleteConfirmation = false
                                        }
                                    }
                                }
                            },
                            colors = ButtonDefaults.textButtonColors(contentColor = TaskGoError)
                        ) {
                            Text("Excluir", fontWeight = FontWeight.Bold)
                        }
                    },
                    dismissButton = {
                        TextButton(onClick = { showDeleteConfirmation = false }) {
                            Text("Cancelar")
                        }
                    }
                )
            }
            
            if (showExportMessage != null) {
                AlertDialog(
                    onDismissRequest = { showExportMessage = null },
                    title = { Text("Exporta√ß√£o de Dados") },
                    text = { Text(showExportMessage!!) },
                    confirmButton = {
                        TextButton(onClick = { showExportMessage = null }) {
                            Text("OK")
                        }
                    }
                )
            }
        }
    }
}

data class SecuritySettingsUiState(
    val biometricEnabled: Boolean = false,
    val twoFactorEnabled: Boolean = false,
    val twoFactorMethod: String? = null,
    val isLoading: Boolean = false,
    val errorMessage: String? = null
)

@HiltViewModel
class SecuritySettingsViewModel @Inject constructor(
    private val preferencesManager: PreferencesManager,
    private val firestoreUserRepository: FirestoreUserRepository,
    private val auth: FirebaseAuth
) : ViewModel() {
    
    private val _uiState = kotlinx.coroutines.flow.MutableStateFlow(SecuritySettingsUiState())
    val uiState: kotlinx.coroutines.flow.StateFlow<SecuritySettingsUiState> = _uiState.asStateFlow()
    
    init {
        loadSettings()
    }
    
    private fun loadSettings() {
        viewModelScope.launch {
            val biometricEnabled = preferencesManager.biometricEnabled.first()
            val twoFactorEnabled = preferencesManager.twoFactorEnabled.first()
            val twoFactorMethod = preferencesManager.twoFactorMethod.first()
            
            _uiState.value = _uiState.value.copy(
                biometricEnabled = biometricEnabled,
                twoFactorEnabled = twoFactorEnabled,
                twoFactorMethod = twoFactorMethod
            )
        }
    }
    
    // Biometria removida - login apenas no primeiro acesso
    
    fun toggleTwoFactor(enabled: Boolean) {
        viewModelScope.launch {
            try {
                preferencesManager.updateTwoFactorEnabled(enabled)
                val method = if (enabled) "email" else null
                preferencesManager.updateTwoFactorMethod(method)
                
                // Salvar no Firestore
                val currentUser = auth.currentUser
                if (currentUser != null) {
                    val user = firestoreUserRepository.getUser(currentUser.uid)
                    if (user != null) {
                        val updatedUser = user.copy(
                            twoFactorEnabled = enabled,
                            twoFactorMethod = method
                        )
                        firestoreUserRepository.updateUser(updatedUser)
                    }
                }
                
                _uiState.value = _uiState.value.copy(
                    twoFactorEnabled = enabled,
                    twoFactorMethod = method
                )
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    errorMessage = "Erro ao atualizar 2FA: ${e.message}"
                )
            }
        }
    }
    
    fun changeTwoFactorMethod(method: String) {
        viewModelScope.launch {
            try {
                preferencesManager.updateTwoFactorMethod(method)
                
                // Salvar no Firestore
                val currentUser = auth.currentUser
                if (currentUser != null) {
                    val user = firestoreUserRepository.getUser(currentUser.uid)
                    if (user != null) {
                        val updatedUser = user.copy(
                            twoFactorMethod = method
                        )
                        firestoreUserRepository.updateUser(updatedUser)
                    }
                }
                
                _uiState.value = _uiState.value.copy(
                    twoFactorMethod = method
                )
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    errorMessage = "Erro ao alterar m√©todo: ${e.message}"
                )
            }
        }
    }
}


```

## [FRONTEND]: feature/settings/presentation/SettingsScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.settings.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.ui.res.painterResource
import com.taskgoapp.taskgo.core.design.TGIcons
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.core.design.*
import androidx.compose.foundation.clickable
import androidx.compose.foundation.BorderStroke
import androidx.compose.ui.graphics.Color
import com.taskgoapp.taskgo.core.theme.*


@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun SettingsScreen(
    onNavigateToAccount: () -> Unit,
    onNavigateToPreferences: () -> Unit,
    onNavigateToNotifications: () -> Unit,
    onNavigateToLanguage: () -> Unit,
    onNavigateToPrivacy: () -> Unit,
    onNavigateToSupport: () -> Unit,
    onNavigateToAbout: () -> Unit,
    onNavigateToAiSupport: () -> Unit,
    onNavigateToSecurity: () -> Unit = {}
) {
    val settingsOptions = listOf(
        SettingsOption(
            icon = TGIcons.Profile,
            title = "Conta",
            subtitle = "Dados pessoais e seguran√ßa",
            onClick = onNavigateToAccount
        ),
        SettingsOption(
            icon = TGIcons.Settings,
            title = "Seguran√ßa",
            subtitle = "Biometria e autentica√ß√£o",
            onClick = onNavigateToSecurity
        ),
        SettingsOption(
            icon = TGIcons.Edit,
            title = "Prefer√™ncias",
            subtitle = "Configura√ß√µes do app",
            onClick = onNavigateToPreferences
        ),
        SettingsOption(
            icon = TGIcons.Bell,
            title = "Notifica√ß√µes",
            subtitle = "Configurar alertas",
            onClick = onNavigateToNotifications
        ),
        // Idioma desativado temporariamente
        // SettingsOption(
        //     icon = TGIcons.Language,
        //     title = "Idioma",
        //     subtitle = "Portugu√™s (Brasil)",
        //     onClick = onNavigateToLanguage
        // ),
        SettingsOption(
            icon = TGIcons.Privacy,
            title = "Privacidade",
            subtitle = "Configura√ß√µes de privacidade",
            onClick = onNavigateToPrivacy
        ),
        SettingsOption(
            icon = TGIcons.Support,
            title = "Suporte",
            subtitle = "Central de ajuda",
            onClick = onNavigateToSupport
        ),
        SettingsOption(
            icon = TGIcons.Messages,
            title = "AI TaskGo",
            subtitle = "Suporte com intelig√™ncia artificial",
            onClick = onNavigateToAiSupport
        ),
        SettingsOption(
            icon = TGIcons.Info,
            title = "Sobre",
            subtitle = "Vers√£o 1.0.0",
            onClick = onNavigateToAbout
        )
    )
    
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Configura√ß√µes",
                onBackClick = { /* TODO: Implementar navega√ß√£o de volta */ }
            )
        }
    ) { paddingValues ->
        LazyColumn(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            items(settingsOptions) { option ->
                SettingsOptionCard(option = option)
            }
            
            // Logout Button
            item {
                Spacer(modifier = Modifier.height(32.dp))
                OutlinedButton(
                    onClick = { /* TODO: Implementar logout */ },
                    modifier = Modifier.fillMaxWidth(),
                    colors = ButtonDefaults.outlinedButtonColors(
                        containerColor = Color.Transparent
                    ),
                    border = BorderStroke(1.dp, TaskGoError)
                ) {
                    Icon(
                        painter = painterResource(TGIcons.Edit),
                        contentDescription = null,
                        modifier = Modifier.size(18.dp),
                        tint = TaskGoError
                    )
                    Spacer(modifier = Modifier.width(8.dp))
                    Text("Sair da Conta", color=TaskGoError)
                }
            }
        }
    }
}

@Composable
fun SettingsOptionCard(
    option: SettingsOption,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier
            .fillMaxWidth()
            .clickable { option.onClick() },
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Icon(
                painter = painterResource(option.icon),
                contentDescription = null,
                modifier = Modifier.size(24.dp),
                tint = TaskGoGreen
            )
            
            Spacer(modifier = Modifier.width(16.dp))
            
            Column(
                modifier = Modifier.weight(1f)
            ) {
                Text(
                    text = option.title,
                    style = FigmaProductName,
                    color = TaskGoTextBlack,
                    fontWeight = FontWeight.Medium
                )
                Text(
                    text = option.subtitle,
                    style = FigmaStatusText,
                    color = TaskGoTextGray
                )
            }
            
            Icon(
                painter = painterResource(TGIcons.Back),
                contentDescription = "Acessar",
                tint = TaskGoTextGray
            )
        }
    }
}

data class SettingsOption(
    val icon: Int,
    val title: String,
    val subtitle: String,
    val onClick: () -> Unit
)

```

## [FRONTEND]: feature/settings/presentation/SettingsViewModel.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.settings.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.taskgoapp.taskgo.domain.usecase.SettingsUseCase
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch

@HiltViewModel
class SettingsViewModel @Inject constructor(
    private val settingsUseCase: SettingsUseCase
) : ViewModel() {

    val state: StateFlow<com.taskgoapp.taskgo.domain.usecase.SettingsState> =
        settingsUseCase.observeSettings().stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000),
            com.taskgoapp.taskgo.domain.usecase.SettingsState(
                promosEnabled = true,
                soundEnabled = true,
                pushEnabled = true,
                lockscreenEnabled = true,
                emailNotificationsEnabled = false,
                smsNotificationsEnabled = false,
                language = "pt",
                theme = "system",
                categories = "[]",
                locationSharingEnabled = true,
                profileVisible = true,
                contactInfoSharingEnabled = false,
                analyticsEnabled = true,
                personalizedAdsEnabled = false,
                dataCollectionEnabled = true,
                thirdPartySharingEnabled = false,
                currentUser = null
            )
        )
    
    init {
        viewModelScope.launch {
            settingsUseCase.syncRemoteSettings()
        }
    }

    fun saveNotifications(
        promos: Boolean,
        sound: Boolean,
        push: Boolean,
        lockscreen: Boolean,
        email: Boolean,
        sms: Boolean
    ) {
        viewModelScope.launch {
            settingsUseCase.updateNotificationSettings(
                promos = promos,
                sound = sound,
                push = push,
                lockscreen = lockscreen,
                email = email,
                sms = sms
            )
        }
    }

    fun saveLanguage(language: String) {
        viewModelScope.launch { settingsUseCase.updateLanguage(language) }
    }

    fun saveTheme(theme: String) {
        viewModelScope.launch { settingsUseCase.updateTheme(theme) }
    }

    fun saveCategories(json: String) {
        viewModelScope.launch { settingsUseCase.updateCategories(json) }
    }
    
    fun savePrivacySettings(
        locationSharing: Boolean,
        profileVisible: Boolean,
        contactInfoSharing: Boolean,
        analytics: Boolean,
        personalizedAds: Boolean,
        dataCollection: Boolean,
        thirdPartySharing: Boolean
    ) {
        viewModelScope.launch {
            settingsUseCase.updatePrivacySettings(
                locationSharing = locationSharing,
                profileVisible = profileVisible,
                contactInfoSharing = contactInfoSharing,
                analytics = analytics,
                personalizedAds = personalizedAds,
                dataCollection = dataCollection,
                thirdPartySharing = thirdPartySharing
            )
        }
    }
    
    fun refreshSettings() {
        viewModelScope.launch {
            settingsUseCase.syncRemoteSettings()
        }
    }
}



```

## [FRONTEND]: feature/settings/presentation/SobreScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.settings.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Check
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.theme.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun SobreScreen(
    onBackClick: () -> Unit
) {
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Sobre",
                onBackClick = onBackClick
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.spacedBy(24.dp)
        ) {
            // App logo
            Row(
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Icon(
                    imageVector = Icons.Default.Check,
                    contentDescription = null,
                    tint = TaskGoGreen,
                    modifier = Modifier.size(48.dp)
                )
                Text(
                    text = "TaskGo",
                    style = FigmaTitleLarge,
                    color = TaskGoTextBlack,
                    fontWeight = FontWeight.Bold
                )
            }
            
            Text(
                text = "Vers√£o 1.0.0",
                style = FigmaProductDescription,
                color = TaskGoTextGray
            )
            
            Text(
                text = "TaskGo √© uma plataforma que conecta pessoas que precisam de servi√ßos com profissionais qualificados. Nossa miss√£o √© facilitar a contrata√ß√£o de servi√ßos de qualidade de forma r√°pida e segura.",
                style = FigmaProductDescription,
                color = TaskGoTextBlack,
                textAlign = androidx.compose.ui.text.style.TextAlign.Center
            )
            
            Text(
                text = "¬© 2024 TaskGo. Todos os direitos reservados.",
                style = FigmaStatusText,
                color = TaskGoTextGray,
                textAlign = androidx.compose.ui.text.style.TextAlign.Center
            )
        }
    }
}

```

## [FRONTEND]: feature/settings/presentation/SuporteScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.settings.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.Chat
import androidx.compose.material.icons.filled.Info
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.theme.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun SuporteScreen(
    onBackClick: () -> Unit,
    onChatAi: () -> Unit,
    onSobre: () -> Unit
) {
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Suporte",
                onBackClick = onBackClick
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // Op√ß√£o: Chat AI TaskGo
            Card(
                modifier = Modifier.fillMaxWidth()
            ) {
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Icon(
                        imageVector = Icons.AutoMirrored.Filled.Chat,
                        contentDescription = null,
                        tint = TaskGoGreen
                    )
                    Spacer(modifier = Modifier.width(16.dp))
                    Column(modifier = Modifier.weight(1f)) {
                        Text(
                            text = "Chat AI TaskGo",
                            style = FigmaProductName,
                            color = TaskGoTextBlack,
                            fontWeight = FontWeight.Medium
                        )
                        Text(
                            text = "Tire d√∫vidas com nossa IA",
                            style = FigmaProductDescription,
                            color = TaskGoTextGray
                        )
                    }
                    TextButton(onClick = onChatAi) { Text("Abrir") }
                }
            }

            // Op√ß√£o: Sobre o TaskGo
            Card(
                modifier = Modifier.fillMaxWidth()
            ) {
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Icon(
                        imageVector = Icons.Default.Info,
                        contentDescription = null,
                        tint = TaskGoGreen
                    )
                    Spacer(modifier = Modifier.width(16.dp))
                    Column(modifier = Modifier.weight(1f)) {
                        Text(
                            text = "Sobre o TaskGo",
                            style = FigmaProductName,
                            color = TaskGoTextBlack,
                            fontWeight = FontWeight.Medium
                        )
                        Text(
                            text = "Informa√ß√µes do aplicativo",
                            style = FigmaProductDescription,
                            color = TaskGoTextGray
                        )
                    }
                    TextButton(onClick = onSobre) { Text("Abrir") }
                }
            }

            Spacer(modifier = Modifier.weight(1f))

            // Contato
            Button(
                onClick = onChatAi,
                modifier = Modifier.fillMaxWidth(),
                colors = ButtonDefaults.buttonColors(containerColor = TaskGoGreen)
            ) { Text("Entrar em Contato", style = FigmaButtonText, color = TaskGoBackgroundWhite) }
        }
    }
}

```

## [FRONTEND]: feature/settings/presentation/SupportScreen.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.feature.settings.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.core.design.*
import com.taskgoapp.taskgo.core.theme.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun SupportScreen(
    onBackClick: () -> Unit
) {
    var selectedCategory by remember { mutableStateOf("") }
    var message by remember { mutableStateOf("") }
    var showContactDialog by remember { mutableStateOf(false) }
    
    val supportCategories = remember {
        listOf(
            SupportCategory(
                id = "account",
                title = "Conta e Login",
                description = "Problemas com login, cadastro ou configura√ß√µes da conta",
                icon = Icons.Default.Person
            ),
            SupportCategory(
                id = "services",
                title = "Servi√ßos",
                description = "D√∫vidas sobre contrata√ß√£o, propostas ou prestadores",
                icon = Icons.Default.Build
            ),
            SupportCategory(
                id = "products",
                title = "Produtos e Compras",
                description = "Problemas com produtos, carrinho ou pagamentos",
                icon = Icons.Default.ShoppingCart
            ),
            SupportCategory(
                id = "payments",
                title = "Pagamentos",
                description = "Problemas com cart√µes, Pix ou reembolsos",
                icon = Icons.Default.Payment
            ),
            SupportCategory(
                id = "technical",
                title = "Problemas T√©cnicos",
                description = "Erros, travamentos ou problemas de funcionamento",
                icon = Icons.Default.BugReport
            ),
            SupportCategory(
                id = "other",
                title = "Outros",
                description = "Outras d√∫vidas ou solicita√ß√µes",
                icon = Icons.Default.Help
            )
        )
    }
    
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Suporte",
                onBackClick = onBackClick
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp)
                .verticalScroll(rememberScrollState()),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // Support Header
            Card(
                modifier = Modifier.fillMaxWidth(),
                colors = CardDefaults.cardColors(
                    containerColor = TaskGoBackgroundGray
                )
            ) {
                Column(
                    modifier = Modifier.padding(20.dp),
                    horizontalAlignment = Alignment.CenterHorizontally
                ) {
                    Icon(
                        imageVector = Icons.Default.Support,
                        contentDescription = null,
                        modifier = Modifier.size(48.dp),
                        tint = TaskGoTextBlack
                    )
                    
                    Spacer(modifier = Modifier.height(16.dp))
                    
                    Text(
                        text = "Central de Suporte",
                        style = FigmaTitleLarge,
                        color = TaskGoTextBlack,
                        fontWeight = FontWeight.Bold
                    )
                    
                    Spacer(modifier = Modifier.height(8.dp))
                    
                    Text(
                        text = "Estamos aqui para ajudar! Escolha uma categoria ou entre em contato conosco.",
                        style = FigmaProductDescription,
                        color = TaskGoTextBlack,
                        modifier = Modifier.padding(horizontal = 16.dp)
                    )
                }
            }
            
            // Quick Actions
            Card(
                modifier = Modifier.fillMaxWidth(),
                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
            ) {
                Column(
                    modifier = Modifier.padding(16.dp)
                ) {
                    Text(
                        text = "A√ß√µes R√°pidas",
                        style = FigmaSectionTitle,
                        color = TaskGoTextBlack,
                        fontWeight = FontWeight.Bold
                    )
                    
                    Spacer(modifier = Modifier.height(16.dp))
                    
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.spacedBy(12.dp)
                    ) {
                        OutlinedButton(
                            onClick = { /* TODO: Implementar FAQ */ },
                            modifier = Modifier.weight(1f)
                        ) {
                            Icon(
                                imageVector = Icons.Default.QuestionAnswer,
                                contentDescription = null,
                                modifier = Modifier.size(18.dp)
                            )
                            Spacer(modifier = Modifier.width(8.dp))
                            Text("FAQ")
                        }
                        
                        OutlinedButton(
                            onClick = { /* TODO: Implementar tutoriais */ },
                            modifier = Modifier.weight(1f)
                        ) {
                            Icon(
                                imageVector = Icons.Default.School,
                                contentDescription = null,
                                modifier = Modifier.size(18.dp)
                            )
                            Spacer(modifier = Modifier.width(8.dp))
                            Text("Tutoriais")
                        }
                    }
                    
                    Spacer(modifier = Modifier.height(12.dp))
                    
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.spacedBy(12.dp)
                    ) {
                        OutlinedButton(
                            onClick = { /* TODO: Implementar status do sistema */ },
                            modifier = Modifier.weight(1f)
                        ) {
                            Icon(
                                imageVector = Icons.Default.Info,
                                contentDescription = null,
                                modifier = Modifier.size(18.dp)
                            )
                            Spacer(modifier = Modifier.width(8.dp))
                            Text("Status")
                        }
                        
                        OutlinedButton(
                            onClick = { showContactDialog = true },
                            modifier = Modifier.weight(1f)
                        ) {
                            Icon(
                                imageVector = Icons.Default.ContactSupport,
                                contentDescription = null,
                                modifier = Modifier.size(18.dp)
                            )
                            Spacer(modifier = Modifier.width(8.dp))
                            Text("Contato")
                        }
                    }
                }
            }
            
            // Support Categories
            Card(
                modifier = Modifier.fillMaxWidth(),
                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
            ) {
                Column(
                    modifier = Modifier.padding(16.dp)
                ) {
                    Text(
                        text = "Categorias de Suporte",
                        style = FigmaSectionTitle,
                        color = TaskGoTextBlack,
                        fontWeight = FontWeight.Bold
                    )
                    
                    Spacer(modifier = Modifier.height(16.dp))
                    
                    supportCategories.forEach { category ->
                        SupportCategoryItem(
                            category = category,
                            isSelected = selectedCategory == category.id,
                            onCategorySelected = { selectedCategory = category.id }
                        )
                        
                        if (category != supportCategories.last()) {
                            Spacer(modifier = Modifier.height(8.dp))
                        }
                    }
                }
            }
            
            // Contact Form
            if (selectedCategory.isNotEmpty()) {
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
                ) {
                    Column(
                        modifier = Modifier.padding(16.dp)
                    ) {
                        Text(
                            text = "Enviar Mensagem",
                            style = FigmaSectionTitle,
                        color = TaskGoTextBlack,
                            fontWeight = FontWeight.Bold
                        )
                        
                        Spacer(modifier = Modifier.height(16.dp))
                        
                        OutlinedTextField(
                            value = message,
                            onValueChange = { message = it },
                            label = { Text("Descreva seu problema ou d√∫vida") },
                            modifier = Modifier.fillMaxWidth(),
                            minLines = 4,
                            maxLines = 6
                        )
                        
                        Spacer(modifier = Modifier.height(16.dp))
                        
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.spacedBy(12.dp)
                        ) {
                            OutlinedButton(
                                onClick = { 
                                    selectedCategory = ""
                                    message = ""
                                },
                                modifier = Modifier.weight(1f)
                            ) {
                                Text("Cancelar")
                            }
                            
                            PrimaryButton(
                                text = "Enviar",
                                onClick = { /* TODO: Implementar envio da mensagem */ },
                                modifier = Modifier.weight(1f),
                                enabled = message.isNotBlank()
                            )
                        }
                    }
                }
            }
            
            // Contact Information
            Card(
                modifier = Modifier.fillMaxWidth(),
                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
            ) {
                Column(
                    modifier = Modifier.padding(16.dp)
                ) {
                    Text(
                        text = "Informa√ß√µes de Contato",
                        style = FigmaSectionTitle,
                        color = TaskGoTextBlack,
                        fontWeight = FontWeight.Bold
                    )
                    
                    Spacer(modifier = Modifier.height(16.dp))
                    
                    // Email
                    Row(
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Icon(
                            imageVector = Icons.Default.Email,
                            contentDescription = null,
                            tint = TaskGoGreen
                        )
                        Spacer(modifier = Modifier.width(12.dp))
                        Column {
                            Text(
                                text = "E-mail",
                                style = FigmaProductName,
                                color = TaskGoTextBlack,
                                fontWeight = FontWeight.Medium
                            )
                            Text(
                                text = "suporte@taskgo.com.br",
                                style = FigmaProductDescription,
                                color = TaskGoTextGray
                            )
                        }
                    }
                    
                    Spacer(modifier = Modifier.height(12.dp))
                    
                    // Phone
                    Row(
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Icon(
                            imageVector = Icons.Default.Phone,
                            contentDescription = null,
                            tint = TaskGoGreen
                        )
                        Spacer(modifier = Modifier.width(12.dp))
                        Column {
                            Text(
                                text = "Telefone",
                                style = FigmaProductName,
                                color = TaskGoTextBlack,
                                fontWeight = FontWeight.Medium
                            )
                            Text(
                                text = "0800 123 4567",
                                style = FigmaProductDescription,
                                color = TaskGoTextGray
                            )
                        }
                    }
                    
                    Spacer(modifier = Modifier.height(12.dp))
                    
                    // WhatsApp
                    Row(
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Icon(
                            imageVector = Icons.Default.Chat,
                            contentDescription = null,
                            tint = TaskGoGreen
                        )
                        Spacer(modifier = Modifier.width(12.dp))
                        Column {
                            Text(
                                text = "WhatsApp",
                                style = FigmaProductName,
                                color = TaskGoTextBlack,
                                fontWeight = FontWeight.Medium
                            )
                            Text(
                                text = "(11) 99999-9999",
                                style = FigmaProductDescription,
                                color = TaskGoTextGray
                            )
                        }
                    }
                    
                    Spacer(modifier = Modifier.height(16.dp))
                    
                    Text(
                        text = "Hor√°rio de Atendimento: Segunda a Sexta, das 8h √†s 18h",
                        style = FigmaStatusText,
                        color = TaskGoTextGray
                    )
                }
            }
            
            // Social Media
            Card(
                modifier = Modifier.fillMaxWidth(),
                colors = CardDefaults.cardColors(
                    containerColor = TaskGoSurfaceGray
                )
            ) {
                Column(
                    modifier = Modifier.padding(16.dp),
                    horizontalAlignment = Alignment.CenterHorizontally
                ) {
                    Text(
                        text = "Siga-nos nas Redes Sociais",
                        style = FigmaSectionTitle,
                        color = TaskGoTextBlack,
                        fontWeight = FontWeight.Bold
                    )
                    
                    Spacer(modifier = Modifier.height(16.dp))
                    
                    Row(
                        horizontalArrangement = Arrangement.spacedBy(16.dp)
                    ) {
                        OutlinedButton(
                            onClick = { /* TODO: Implementar link para Facebook */ }
                        ) {
                            Icon(
                                imageVector = Icons.Default.Share,
                                contentDescription = null,
                                modifier = Modifier.size(18.dp)
                            )
                            Spacer(modifier = Modifier.width(8.dp))
                            Text("Facebook")
                        }
                        
                        OutlinedButton(
                            onClick = { /* TODO: Implementar link para Instagram */ }
                        ) {
                            Icon(
                                imageVector = Icons.Default.Share,
                                contentDescription = null,
                                modifier = Modifier.size(18.dp)
                            )
                            Spacer(modifier = Modifier.width(8.dp))
                            Text("Instagram")
                        }
                        
                        OutlinedButton(
                            onClick = { /* TODO: Implementar link para LinkedIn */ }
                        ) {
                            Icon(
                                imageVector = Icons.Default.Share,
                                contentDescription = null,
                                modifier = Modifier.size(18.dp)
                            )
                            Spacer(modifier = Modifier.width(8.dp))
                            Text("LinkedIn")
                        }
                    }
                }
            }
        }
    }
    
    // Contact Dialog
    if (showContactDialog) {
        AlertDialog(
            onDismissRequest = { showContactDialog = false },
            title = { Text("Entre em Contato") },
            text = { 
                Text("Escolha a melhor forma de entrar em contato conosco:")
            },
            confirmButton = {
                TextButton(
                    onClick = { showContactDialog = false }
                ) {
                    Text("Fechar")
                }
            },
            dismissButton = {
                Column {
                    TextButton(
                        onClick = { 
                            /* TODO: Implementar e-mail */
                            showContactDialog = false 
                        }
                    ) {
                        Icon(
                            imageVector = Icons.Default.Email,
                            contentDescription = null,
                            modifier = Modifier.size(18.dp)
                        )
                        Spacer(modifier = Modifier.width(8.dp))
                        Text("E-mail")
                    }
                    
                    TextButton(
                        onClick = { 
                            /* TODO: Implementar WhatsApp */
                            showContactDialog = false 
                        }
                    ) {
                        Icon(
                            imageVector = Icons.Default.Chat,
                            contentDescription = null,
                            modifier = Modifier.size(18.dp)
                        )
                        Spacer(modifier = Modifier.width(8.dp))
                        Text("WhatsApp")
                    }
                    
                    TextButton(
                        onClick = { 
                            /* TODO: Implementar telefone */
                            showContactDialog = false 
                        }
                    ) {
                        Icon(
                            imageVector = Icons.Default.Phone,
                            contentDescription = null,
                            modifier = Modifier.size(18.dp)
                        )
                        Spacer(modifier = Modifier.width(8.dp))
                        Text("Telefone")
                    }
                }
            }
        )
    }
}

@Composable
private fun SupportCategoryItem(
    category: SupportCategory,
    isSelected: Boolean,
    onCategorySelected: () -> Unit
) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp),
        colors = CardDefaults.cardColors(
            containerColor = if (isSelected) 
                TaskGoBackgroundGray 
            else 
                TaskGoSurface
        )
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Icon(
                imageVector = category.icon,
                contentDescription = null,
                tint = if (isSelected) 
                    TaskGoTextBlack 
                else 
                    TaskGoGreen
            )
            
            Spacer(modifier = Modifier.width(16.dp))
            
            Column(
                modifier = Modifier.weight(1f)
            ) {
                Text(
                    text = category.title,
                    style = FigmaProductName,
                    fontWeight = FontWeight.Bold,
                    color = if (isSelected) 
                        TaskGoTextBlack 
                    else 
                        TaskGoTextGray
                )
                
                Text(
                    text = category.description,
                    style = FigmaStatusText,
                    color = if (isSelected) 
                        TaskGoTextBlack 
                    else 
                        TaskGoTextGray
                )
            }
            
            if (isSelected) {
                Icon(
                    imageVector = Icons.Default.CheckCircle,
                    contentDescription = null,
                    tint = TaskGoTextBlack,
                    modifier = Modifier.size(24.dp)
                )
            }
        }
        
        // Clickable area
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(16.dp),
            contentAlignment = Alignment.CenterEnd
        ) {
            TextButton(
                onClick = onCategorySelected,
                modifier = Modifier.align(Alignment.CenterEnd)
            ) {
                Text(
                    text = if (isSelected) "Selecionado" else "Selecionar",
                    style = FigmaStatusText,
                    color = TaskGoTextGray
                )
            }
        }
    }
}

data class SupportCategory(
    val id: String,
    val title: String,
    val description: String,
    val icon: androidx.compose.ui.graphics.vector.ImageVector
)





```

## [FRONTEND]: feature/settings/presentation/TermsOfServiceScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.settings.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.taskgoapp.taskgo.core.design.AppTopBar
import com.taskgoapp.taskgo.core.theme.*
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun TermsOfServiceScreen(
    onBackClick: () -> Unit
) {
    Scaffold(
        topBar = {
            AppTopBar(
                title = "Termos de Uso",
                onBackClick = onBackClick
            )
        }
    ) { paddingValues ->
        val scrollState = rememberScrollState()
        val lastUpdated = remember {
            "Novembro de 2025"
        }
        
        val termsSections = listOf(
            TermsSectionData(
                title = "üìò 1. DEFINI√á√ïES",
                paragraphs = listOf(
                    "Para os fins deste Termo, considera-se:",
                    "",
                    "‚Ä¢ Aplicativo / Plataforma / TaskGo ‚Äî o aplicativo m√≥vel e seus servi√ßos associados.",
                    "‚Ä¢ Usu√°rio ‚Äî toda pessoa f√≠sica ou jur√≠dica que acessa, utiliza ou se cadastra no TaskGo.",
                    "‚Ä¢ Prestador / Vendedor ‚Äî usu√°rio que oferece servi√ßos ou produtos por meio do aplicativo.",
                    "‚Ä¢ Cliente / Comprador ‚Äî usu√°rio que contrata servi√ßos ou compra produtos atrav√©s da plataforma.",
                    "‚Ä¢ Conta ‚Äî o perfil cadastrado pelo usu√°rio para utiliza√ß√£o dos recursos do TaskGo.",
                    "‚Ä¢ Transa√ß√£o ‚Äî qualquer intera√ß√£o comercial, financeira ou contratual realizada no app."
                )
            ),
            TermsSectionData(
                title = "üßæ 2. ACEITA√á√ÉO DOS TERMOS",
                paragraphs = listOf(
                    "O uso do aplicativo implica aceita√ß√£o integral e irrevog√°vel destes Termos de Uso e da Pol√≠tica de Privacidade.",
                    "",
                    "Caso o usu√°rio n√£o concorde com qualquer cl√°usula, dever√° abster-se de utilizar o TaskGo e desinstalar o aplicativo."
                )
            ),
            TermsSectionData(
                title = "üë§ 3. CADASTRO E CONTA DE USU√ÅRIO",
                paragraphs = listOf(
                    "3.1. Requisitos",
                    "",
                    "Para criar uma conta no TaskGo, o usu√°rio deve:",
                    "",
                    "‚Ä¢ Ter 18 anos ou mais (ou estar assistido por respons√°vel legal).",
                    "‚Ä¢ Fornecer informa√ß√µes verdadeiras, completas e atualizadas.",
                    "‚Ä¢ Manter a confidencialidade de suas credenciais de acesso.",
                    "",
                    "3.2. Responsabilidade",
                    "",
                    "O usu√°rio √© inteiramente respons√°vel por todas as atividades realizadas em sua conta, incluindo:",
                    "",
                    "‚Ä¢ Intera√ß√µes, publica√ß√µes e negocia√ß√µes.",
                    "‚Ä¢ Cadastramento de produtos, servi√ßos e informa√ß√µes.",
                    "‚Ä¢ Cumprimento de compromissos assumidos com outros usu√°rios.",
                    "",
                    "A TaskGo n√£o se responsabiliza por danos ou preju√≠zos decorrentes do uso indevido da conta por terceiros."
                )
            ),
            TermsSectionData(
                title = "üß© 4. FUNCIONALIDADES DA PLATAFORMA",
                paragraphs = listOf(
                    "O TaskGo oferece as seguintes funcionalidades:",
                    "",
                    "‚Ä¢ Cadastro e autentica√ß√£o de usu√°rios.",
                    "‚Ä¢ Busca e oferta de servi√ßos e produtos.",
                    "‚Ä¢ Cria√ß√£o de ordens de servi√ßo e pedidos de compra.",
                    "‚Ä¢ Chat em tempo real entre usu√°rios.",
                    "‚Ä¢ Sistema de pagamentos seguro via parceiros externos.",
                    "‚Ä¢ Avalia√ß√µes e feedbacks entre clientes e prestadores.",
                    "‚Ä¢ Verifica√ß√£o de documentos e identidade.",
                    "‚Ä¢ Notifica√ß√µes push e alertas de status.",
                    "",
                    "O aplicativo pode ser atualizado periodicamente para incluir novas funcionalidades ou remover aquelas que se tornem obsoletas."
                )
            ),
            TermsSectionData(
                title = "üí≥ 5. TRANSA√á√ïES, PAGAMENTOS E TAXAS",
                paragraphs = listOf(
                    "5.1. Pagamentos",
                    "",
                    "Todos os pagamentos s√£o processados de forma segura por gateways de pagamento (como Stripe, Mercado Pago ou equivalentes).",
                    "",
                    "O TaskGo n√£o armazena dados financeiros sens√≠veis (cart√µes, senhas, chaves PIX etc).",
                    "",
                    "5.2. Taxas",
                    "",
                    "A TaskGo poder√° cobrar taxas de servi√ßo ou comiss√µes sobre transa√ß√µes realizadas na plataforma.",
                    "",
                    "Essas taxas ser√£o sempre informadas de forma clara antes da conclus√£o da transa√ß√£o.",
                    "",
                    "5.3. Disputas",
                    "",
                    "Eventuais conflitos ou reembolsos entre usu√°rios dever√£o ser resolvidos inicialmente entre as partes por meio do chat.",
                    "",
                    "Caso n√£o haja acordo, a modera√ß√£o da TaskGo poder√° intervir e propor uma solu√ß√£o imparcial."
                )
            ),
            TermsSectionData(
                title = "üì¶ 6. PRODUTOS E SERVI√áOS OFERECIDOS",
                paragraphs = listOf(
                    "Os prestadores e vendedores s√£o exclusivamente respons√°veis por:",
                    "",
                    "‚Ä¢ Cumprir as condi√ß√µes acordadas com os clientes.",
                    "‚Ä¢ Garantir a qualidade, legalidade e entrega do servi√ßo/produto.",
                    "‚Ä¢ Fornecer informa√ß√µes corretas, imagens reais e descri√ß√µes verdadeiras.",
                    "",
                    "A TaskGo atua apenas como intermediadora tecnol√≥gica entre usu√°rios, n√£o sendo parte direta nas transa√ß√µes."
                )
            ),
            TermsSectionData(
                title = "üö´ 7. CONDUTAS PROIBIDAS",
                paragraphs = listOf(
                    "√â expressamente proibido:",
                    "",
                    "‚Ä¢ Fornecer informa√ß√µes falsas ou enganosas.",
                    "‚Ä¢ Publicar conte√∫dos ofensivos, discriminat√≥rios ou ilegais.",
                    "‚Ä¢ Utilizar o TaskGo para atividades il√≠citas, fraudulentas ou imorais.",
                    "‚Ä¢ Cadastrar produtos ou servi√ßos proibidos por lei.",
                    "‚Ä¢ Copiar, modificar ou redistribuir o aplicativo sem autoriza√ß√£o.",
                    "‚Ä¢ Violar direitos de propriedade intelectual da TaskGo ou de terceiros.",
                    "‚Ä¢ Tentar obter acesso n√£o autorizado a dados, contas ou servidores.",
                    "",
                    "O descumprimento de qualquer dessas regras poder√° resultar em suspens√£o, exclus√£o da conta e reporte √†s autoridades competentes."
                )
            ),
            TermsSectionData(
                title = "üîê 8. PRIVACIDADE E SEGURAN√áA",
                paragraphs = listOf(
                    "O tratamento dos dados pessoais dos usu√°rios √© regido pela Pol√≠tica de Privacidade do TaskGo, dispon√≠vel em:",
                    "",
                    "üëâ https://taskgo.app/politica-de-privacidade",
                    "",
                    "Em resumo:",
                    "",
                    "‚Ä¢ Os dados s√£o coletados apenas para funcionamento e seguran√ßa do app.",
                    "‚Ä¢ Todas as informa√ß√µes s√£o armazenadas em servidores seguros do Firebase (Google Cloud).",
                    "‚Ä¢ O usu√°rio pode solicitar exclus√£o definitiva de sua conta a qualquer momento."
                )
            ),
            TermsSectionData(
                title = "‚öô 9. LICEN√áA DE USO",
                paragraphs = listOf(
                    "A TaskGo concede ao usu√°rio uma licen√ßa limitada, n√£o exclusiva e intransfer√≠vel para utilizar o aplicativo.",
                    "",
                    "O usu√°rio n√£o adquire propriedade intelectual sobre o software, interface ou c√≥digo.",
                    "",
                    "√â proibido:",
                    "",
                    "‚Ä¢ Copiar, descompilar ou modificar partes do app.",
                    "‚Ä¢ Comercializar ou redistribuir o TaskGo sem autoriza√ß√£o formal."
                )
            ),
            TermsSectionData(
                title = "üß† 10. PROPRIEDADE INTELECTUAL",
                paragraphs = listOf(
                    "Todo o conte√∫do, layout, logotipo, c√≥digo, design e banco de dados do TaskGo pertencem exclusivamente √† TaskGo Tecnologia Digital LTDA, sendo protegidos pelas leis de direitos autorais e propriedade industrial.",
                    "",
                    "O uso indevido desses elementos poder√° gerar responsabilidade civil e criminal."
                )
            ),
            TermsSectionData(
                title = "üßæ 11. SUPORTE E COMUNICA√á√ÉO",
                paragraphs = listOf(
                    "O usu√°rio pode entrar em contato com a equipe de suporte pelos canais oficiais:",
                    "",
                    "üìß E-mail: suporte@taskgo.app",
                    "üåê Site: https://taskgo.app",
                    "",
                    "O suporte atende a d√∫vidas t√©cnicas, den√∫ncias, problemas com pagamentos e solicita√ß√µes de exclus√£o de conta."
                )
            ),
            TermsSectionData(
                title = "üß≠ 12. RESPONSABILIDADES",
                paragraphs = listOf(
                    "Do Usu√°rio:",
                    "",
                    "‚Ä¢ Fornecer informa√ß√µes ver√≠dicas e manter o comportamento √©tico.",
                    "‚Ä¢ Cumprir compromissos financeiros e contratuais.",
                    "‚Ä¢ Respeitar outros usu√°rios e as normas legais vigentes.",
                    "",
                    "Da TaskGo:",
                    "",
                    "‚Ä¢ Garantir a disponibilidade t√©cnica da plataforma.",
                    "‚Ä¢ Adotar medidas de seguran√ßa e privacidade adequadas.",
                    "‚Ä¢ Intervir em casos de den√∫ncia, fraude ou viola√ß√£o dos termos.",
                    "",
                    "A TaskGo n√£o se responsabiliza por:",
                    "",
                    "‚Ä¢ Erros cometidos pelos usu√°rios.",
                    "‚Ä¢ Perdas financeiras decorrentes de m√° conduta de terceiros.",
                    "‚Ä¢ Indisponibilidade tempor√°ria do servi√ßo por manuten√ß√£o ou for√ßa maior."
                )
            ),
            TermsSectionData(
                title = "üîÑ 13. ATUALIZA√á√ïES DOS TERMOS",
                paragraphs = listOf(
                    "A TaskGo poder√° atualizar este Termo de Uso a qualquer momento.",
                    "",
                    "Altera√ß√µes relevantes ser√£o comunicadas no aplicativo e/ou por e-mail.",
                    "",
                    "O uso continuado do TaskGo ap√≥s altera√ß√µes constitui aceita√ß√£o das novas condi√ß√µes."
                )
            ),
            TermsSectionData(
                title = "‚öñ 14. LEGISLA√á√ÉO E FORO",
                paragraphs = listOf(
                    "Este Termo √© regido pelas leis da Rep√∫blica Federativa do Brasil.",
                    "",
                    "Qualquer controv√©rsia ser√° dirimida no foro da comarca de [sua cidade e estado], com exclus√£o de qualquer outro, por mais privilegiado que seja."
                )
            ),
            TermsSectionData(
                title = "‚úÖ 15. CONTATO E INFORMA√á√ïES DA EMPRESA",
                paragraphs = listOf(
                    "TaskGo Tecnologia Digital LTDA",
                    "",
                    "üìß E-mail: suporte@taskgo.app",
                    "üåê Site: https://taskgo.app",
                    "üìç Localiza√ß√£o: [insira cidade/estado]",
                    "üìÑ CNPJ: [insira n√∫mero quando dispon√≠vel]"
                )
            ),
            TermsSectionData(
                title = "üìå Resumo",
                paragraphs = listOf(
                    "O TaskGo √© uma plataforma que conecta pessoas, servi√ßos e produtos de forma segura e colaborativa.",
                    "",
                    "Ao utilizar o app, voc√™ concorda em agir com responsabilidade, respeitar outros usu√°rios e cumprir as leis aplic√°veis."
                )
            )
        )

        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp)
                .verticalScroll(scrollState)
        ) {
            Text(
                text = "üìú Termos de Uso ‚Äî TaskGo",
                style = MaterialTheme.typography.headlineMedium,
                fontWeight = FontWeight.Bold,
                color = TaskGoTextBlack
            )
            Spacer(modifier = Modifier.height(8.dp))
            Text(
                text = "√öltima atualiza√ß√£o: $lastUpdated",
                style = MaterialTheme.typography.bodySmall,
                color = TaskGoTextGray
            )
            Spacer(modifier = Modifier.height(16.dp))
            Text(
                text = "Bem-vindo ao TaskGo, um aplicativo desenvolvido por TaskGo Tecnologia Digital LTDA, criado para conectar pessoas que oferecem e buscam servi√ßos e produtos em um ambiente seguro, pr√°tico e inteligente.",
                style = MaterialTheme.typography.bodyMedium,
                color = TaskGoTextBlack
            )
            Spacer(modifier = Modifier.height(8.dp))
            Text(
                text = "Estes Termos de Uso regulam o acesso e utiliza√ß√£o do aplicativo, do site e de todos os servi√ßos relacionados oferecidos pela TaskGo.",
                style = MaterialTheme.typography.bodyMedium,
                color = TaskGoTextBlack
            )
            Spacer(modifier = Modifier.height(8.dp))
            Text(
                text = "Ao utilizar o aplicativo, voc√™ declara que leu, compreendeu e concorda integralmente com estes termos.",
                style = MaterialTheme.typography.bodyMedium,
                color = TaskGoTextBlack,
                fontWeight = FontWeight.Medium
            )
            Spacer(modifier = Modifier.height(24.dp))

            termsSections.forEach { section ->
                TermsSection(section)
                Spacer(modifier = Modifier.height(16.dp))
            }

            Spacer(modifier = Modifier.height(24.dp))
        }
    }
}

private data class TermsSectionData(
    val title: String,
    val paragraphs: List<String>
)

@Composable
private fun TermsSection(section: TermsSectionData) {
    Text(
        text = section.title,
        style = MaterialTheme.typography.titleMedium,
        fontWeight = FontWeight.Bold,
        color = TaskGoTextBlack
    )
    Spacer(modifier = Modifier.height(8.dp))
    section.paragraphs.forEachIndexed { index, paragraph ->
        if (paragraph.isNotBlank()) {
            Text(
                text = paragraph,
                style = MaterialTheme.typography.bodyMedium,
                color = TaskGoTextBlack
            )
            if (index != section.paragraphs.lastIndex) {
                Spacer(modifier = Modifier.height(4.dp))
            }
        } else {
            Spacer(modifier = Modifier.height(4.dp))
        }
    }
}

```

# Features - splash


## [FRONTEND]: feature/splash/presentation/SplashScreen.kt

```kotlin
package com.taskgoapp.taskgo.feature.splash.presentation

import android.Manifest
import android.os.Build
import android.util.Log
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.size
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.taskgoapp.taskgo.core.design.TGIcons
import com.taskgoapp.taskgo.core.permissions.PermissionHandler
import com.taskgoapp.taskgo.core.permissions.rememberMultiplePermissionsLauncher
import com.taskgoapp.taskgo.core.theme.TaskGoGreen
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch

@Composable
fun SplashScreen(
    onNavigateToLogin: () -> Unit,
    onNavigateToHome: () -> Unit,
    onNavigateToBiometricAuth: () -> Unit = {}, // Mantido para compatibilidade, mas n√£o ser√° usado
    viewModel: SplashViewModel = hiltViewModel()
) {
    val context = LocalContext.current
    val scope = rememberCoroutineScope()
    val permissionsRequested by viewModel.permissionsRequested.collectAsState(initial = false)
    
    // Preparar lista de permiss√µes necess√°rias
    val requiredPermissions = remember {
        mutableListOf<String>().apply {
            add(Manifest.permission.CAMERA)
            add(Manifest.permission.ACCESS_FINE_LOCATION)
            add(Manifest.permission.ACCESS_COARSE_LOCATION)
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                add(Manifest.permission.POST_NOTIFICATIONS)
                add(Manifest.permission.READ_MEDIA_IMAGES)
                add(Manifest.permission.READ_MEDIA_VIDEO)
            } else {
                add(Manifest.permission.READ_EXTERNAL_STORAGE)
                add(Manifest.permission.WRITE_EXTERNAL_STORAGE)
            }
        }.toTypedArray()
    }
    
    // Launcher para solicitar m√∫ltiplas permiss√µes
    val permissionsLauncher = rememberMultiplePermissionsLauncher(
        onAllPermissionsGranted = {
            Log.d("SplashScreen", "Todas as permiss√µes foram concedidas")
            viewModel.setPermissionsRequested(true)
            // Continuar com a navega√ß√£o ap√≥s um pequeno delay
            scope.launch {
                delay(500)
                viewModel.checkAuthState(
                    onNavigateToBiometricAuth = {},
                    onNavigateToHome = onNavigateToHome,
                    onNavigateToLogin = onNavigateToLogin
                )
            }
        },
        onPermissionDenied = {
            Log.d("SplashScreen", "Algumas permiss√µes foram negadas, mas continuando...")
            viewModel.setPermissionsRequested(true)
            // Continuar mesmo se algumas permiss√µes foram negadas
            scope.launch {
                delay(500)
                viewModel.checkAuthState(
                    onNavigateToBiometricAuth = {},
                    onNavigateToHome = onNavigateToHome,
                    onNavigateToLogin = onNavigateToLogin
                )
            }
        }
    )
    
    LaunchedEffect(Unit) {
        Log.d("SplashScreen", "=== Iniciando SplashScreen ===")
        delay(2000) // 2 segundos de delay
        
        // Verificar quais permiss√µes ainda n√£o foram concedidas
        val missingPermissions = requiredPermissions.filter { permission ->
            !PermissionHandler.hasPermission(context, permission)
        }
        
        Log.d("SplashScreen", "Permiss√µes necess√°rias: ${requiredPermissions.joinToString()}")
        Log.d("SplashScreen", "Permiss√µes faltando: ${missingPermissions.joinToString()}")
        Log.d("SplashScreen", "Permiss√µes j√° solicitadas antes: $permissionsRequested")
        
        // SEMPRE solicitar permiss√µes no primeiro acesso, mesmo que j√° tenham sido solicitadas antes
        // Isso garante que todas as permiss√µes sejam solicitadas
        if (!permissionsRequested || missingPermissions.isNotEmpty()) {
            // Solicitar TODAS as permiss√µes (o Android vai mostrar apenas as que ainda n√£o foram concedidas)
            Log.d("SplashScreen", "Solicitando TODAS as permiss√µes: ${requiredPermissions.joinToString()}")
            permissionsLauncher.launch(requiredPermissions)
        } else {
            // Todas as permiss√µes j√° foram concedidas, apenas navegar
            Log.d("SplashScreen", "Todas as permiss√µes j√° foram concedidas, navegando...")
            viewModel.checkAuthState(
                onNavigateToBiometricAuth = {},
                onNavigateToHome = onNavigateToHome,
                onNavigateToLogin = onNavigateToLogin
            )
        }
    }

    Box(
        modifier = Modifier
            .fillMaxSize()
            .background(TaskGoGreen), // Verde #00BD48 do Figma
        contentAlignment = Alignment.Center
    ) {
        // Logo vertical do TaskGo (aumentado)
        Image(
            painter = painterResource(id = TGIcons.TaskGoLogoVertical),
            contentDescription = "TaskGo Logo",
            modifier = Modifier.size(200.dp)
        )
    }
}

```

## [FRONTEND]: feature/splash/presentation/SplashViewModel.kt

```kotlin
package com.taskgoapp.taskgo.feature.splash.presentation

import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.taskgoapp.taskgo.data.local.datastore.PreferencesManager
import com.taskgoapp.taskgo.data.repository.FirebaseAuthRepository
import com.taskgoapp.taskgo.core.location.LocationStateManager
import com.taskgoapp.taskgo.core.location.LocationState
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.timeout
import kotlinx.coroutines.withTimeoutOrNull
import kotlinx.coroutines.launch
import kotlinx.coroutines.tasks.await
import javax.inject.Inject
import kotlin.time.Duration.Companion.seconds

@HiltViewModel
class SplashViewModel @Inject constructor(
    private val preferencesManager: PreferencesManager,
    private val authRepository: FirebaseAuthRepository,
    private val initialDataSyncManager: com.taskgoapp.taskgo.core.sync.InitialDataSyncManager,
    private val locationStateManager: LocationStateManager
) : ViewModel() {
    
    val permissionsRequested = preferencesManager.permissionsRequested
    
    fun setPermissionsRequested(requested: Boolean) {
        viewModelScope.launch {
            preferencesManager.setPermissionsRequested(requested)
        }
    }
    
    fun checkAuthState(
        onNavigateToBiometricAuth: () -> Unit,
        onNavigateToHome: () -> Unit,
        onNavigateToLogin: () -> Unit
    ) {
        viewModelScope.launch {
            try {
                Log.d("SplashViewModel", "=== Verificando estado de autentica√ß√£o ===")
                
                // Usar getCurrentUser() diretamente - mais confi√°vel no primeiro acesso
                // observeAuthState() pode retornar usu√°rio em cache que n√£o √© v√°lido
                val currentUser = authRepository.getCurrentUser()
                
                Log.d("SplashViewModel", "currentUser: ${currentUser?.email}, uid: ${currentUser?.uid}")
                
                if (currentUser != null) {
                    // CR√çTICO: Validar token antes de considerar usu√°rio autenticado
                    // getCurrentUser() pode retornar usu√°rio em cache que n√£o √© mais v√°lido
                    var tokenValid = false
                    try {
                        // Tentar obter token com timeout curto
                        val token = withTimeoutOrNull(3.seconds) {
                            currentUser.getIdToken(false).await()
                        }
                        if (token != null) {
                            tokenValid = true
                            Log.d("SplashViewModel", "Token do usu√°rio v√°lido")
                        } else {
                            // Se falhar, tentar com refresh (pode demorar mais)
                            Log.w("SplashViewModel", "Token inicial falhou, tentando refresh...")
                            val refreshedToken = withTimeoutOrNull(5.seconds) {
                                currentUser.getIdToken(true).await()
                            }
                            if (refreshedToken != null) {
                                tokenValid = true
                                Log.d("SplashViewModel", "Token do usu√°rio validado ap√≥s refresh")
                            } else {
                                Log.w("SplashViewModel", "Refresh do token falhou (timeout)")
                                tokenValid = false
                            }
                        }
                    } catch (e: Exception) {
                        Log.w("SplashViewModel", "Erro ao validar token: ${e.message}")
                        // Se houver erro espec√≠fico de token inv√°lido/expirado, fazer signOut
                        if (e.message?.contains("auth/invalid-user-token") == true ||
                            e.message?.contains("auth/user-token-expired") == true ||
                            e.message?.contains("auth/user-disabled") == true) {
                            Log.w("SplashViewModel", "Token inv√°lido/expirado, fazendo signOut e navegando para login")
                            try {
                                authRepository.signOut()
                            } catch (signOutError: Exception) {
                                Log.e("SplashViewModel", "Erro ao fazer signOut: ${signOutError.message}")
                            }
                            onNavigateToLogin()
                            return@launch
                        }
                        tokenValid = false
                    }
                    
                    // CR√çTICO: S√≥ navegar para home se o token for v√°lido E localiza√ß√£o estiver pronta
                    if (tokenValid) {
                        // ‚ö†Ô∏è ETAPA 4: Garantir localiza√ß√£o no login/primeiro uso
                        // Aguardar localiza√ß√£o estar pronta antes de navegar para home
                        Log.d("SplashViewModel", "Aguardando localiza√ß√£o estar pronta...")
                        
                        // Aguardar localiza√ß√£o com timeout de 10 segundos
                        val locationState = withTimeoutOrNull(10.seconds) {
                            locationStateManager.locationState.first { it is LocationState.Ready || it is LocationState.Error }
                        }
                        
                        when (locationState) {
                            is LocationState.Ready -> {
                                Log.d("SplashViewModel", """
                                    Localiza√ß√£o pronta:
                                    City: ${locationState.city}
                                    State: ${locationState.state}
                                    LocationId: ${locationState.locationId}
                                """.trimIndent())
                                
                                // Verificar se precisa fazer sync inicial (em background, n√£o bloqueia navega√ß√£o)
                                val needsSync = !preferencesManager.isInitialSyncCompleted(currentUser.uid)
                                if (needsSync) {
                                    Log.d("SplashViewModel", "Primeiro acesso do usu√°rio, iniciando sincroniza√ß√£o em background...")
                                    // Executar sync em background sem bloquear navega√ß√£o
                                    viewModelScope.launch {
                                        try {
                                            initialDataSyncManager.syncAllUserData()
                                            preferencesManager.setInitialSyncCompleted(currentUser.uid)
                                            Log.d("SplashViewModel", "Sincroniza√ß√£o inicial conclu√≠da")
                                        } catch (e: Exception) {
                                            Log.e("SplashViewModel", "Erro ao sincronizar dados iniciais: ${e.message}", e)
                                            // Continuar mesmo se o sync falhar - n√£o √© cr√≠tico para login
                                        }
                                    }
                                }
                                
                                // Localiza√ß√£o pronta - navegar para home
                                Log.d("SplashViewModel", "Usu√°rio autenticado e localiza√ß√£o pronta, navegando para home")
                                onNavigateToHome()
                            }
                            is LocationState.Error -> {
                                Log.e("SplashViewModel", "Erro ao obter localiza√ß√£o: ${locationState.reason}")
                                // Continuar para home mesmo sem localiza√ß√£o (pode ser corrigido depois)
                                // Mas isso n√£o deve acontecer se o usu√°rio tem city/state no perfil
                                Log.w("SplashViewModel", "Navegando para home sem localiza√ß√£o v√°lida (pode causar problemas)")
                                onNavigateToHome()
                            }
                            else -> {
                                Log.w("SplashViewModel", "Timeout aguardando localiza√ß√£o (10s), navegando para home mesmo assim")
                                // Continuar para home mesmo sem localiza√ß√£o (pode ser corrigido depois)
                                onNavigateToHome()
                            }
                        }
                    } else {
                        // Token inv√°lido - fazer signOut e ir para login
                        Log.w("SplashViewModel", "Token inv√°lido, fazendo signOut e navegando para login")
                        try {
                            authRepository.signOut()
                        } catch (signOutError: Exception) {
                            Log.e("SplashViewModel", "Erro ao fazer signOut: ${signOutError.message}")
                        }
                        onNavigateToLogin()
                    }
                } else {
                    // Se n√£o estiver logado, ir para login
                    Log.d("SplashViewModel", "Usu√°rio n√£o logado, navegando para login")
                    onNavigateToLogin()
                }
            } catch (e: Exception) {
                Log.e("SplashViewModel", "Erro ao verificar credenciais", e)
                // Em caso de erro, ir para login
                onNavigateToLogin()
            }
        }
    }
}


```

# Features - stories


## [FRONTEND]: feature/stories/presentation/StoriesViewModel.kt

```kotlin
package com.taskgoapp.taskgo.feature.stories.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.taskgoapp.taskgo.core.model.Result
import com.taskgoapp.taskgo.core.model.Story
import com.taskgoapp.taskgo.data.repository.FeedMediaRepository
import com.taskgoapp.taskgo.data.repository.FirebaseAuthRepository
import com.taskgoapp.taskgo.domain.repository.StoriesRepository
import com.taskgoapp.taskgo.domain.repository.UserRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import java.util.Date
import java.util.UUID
import javax.inject.Inject

data class StoriesUiState(
    val stories: List<Story> = emptyList(),
    val isLoading: Boolean = false,
    val error: String? = null,
    val currentUserId: String? = null,
    val currentUserAvatarUrl: String? = null,
    val currentUserName: String = ""
)

@HiltViewModel
class StoriesViewModel @Inject constructor(
    private val storiesRepository: StoriesRepository,
    private val feedMediaRepository: FeedMediaRepository,
    private val authRepository: FirebaseAuthRepository,
    private val userRepository: UserRepository
) : ViewModel() {
    
    private val _uiState = MutableStateFlow(StoriesUiState())
    val uiState: StateFlow<StoriesUiState> = _uiState.asStateFlow()
    
    init {
        loadCurrentUserProfile()
    }
    
    private fun loadCurrentUserProfile() {
        viewModelScope.launch {
            try {
                val currentUserId = authRepository.getCurrentUser()?.uid
                _uiState.value = _uiState.value.copy(currentUserId = currentUserId)
                
                userRepository.observeCurrentUser().collect { user ->
                    user?.let {
                        _uiState.value = _uiState.value.copy(
                            currentUserAvatarUrl = it.avatarUri,
                            currentUserName = it.name
                        )
                    }
                }
            } catch (e: Exception) {
                android.util.Log.e("StoriesViewModel", "Erro ao carregar perfil: ${e.message}", e)
            }
        }
    }
    
    fun observeStories(radiusKm: Double = 50.0, userLocation: Pair<Double, Double>? = null) {
        viewModelScope.launch {
            val currentUserId = authRepository.getCurrentUser()?.uid
            if (currentUserId == null) {
                _uiState.value = _uiState.value.copy(
                    error = "Usu√°rio n√£o autenticado",
                    isLoading = false
                )
                return@launch
            }
            
            _uiState.value = _uiState.value.copy(isLoading = true, error = null)
            
            storiesRepository.observeStories(currentUserId, radiusKm, userLocation)
                .catch { e ->
                    android.util.Log.e("StoriesViewModel", "Erro ao observar stories: ${e.message}", e)
                    _uiState.value = _uiState.value.copy(
                        error = e.message ?: "Erro ao carregar stories",
                        isLoading = false
                    )
                }
                .collect { stories ->
                    _uiState.value = _uiState.value.copy(
                        stories = stories,
                        isLoading = false,
                        error = null
                    )
                }
        }
    }
    
    fun createStory(
        mediaUri: android.net.Uri,
        mediaType: String,
        caption: String? = null,
        location: com.taskgoapp.taskgo.core.model.StoryLocation? = null
    ) {
        viewModelScope.launch {
            try {
                val currentUserId = authRepository.getCurrentUser()?.uid
                    ?: run {
                        _uiState.value = _uiState.value.copy(error = "Usu√°rio n√£o autenticado")
                        return@launch
                    }
                
                val currentUser = _uiState.value
                val userName = currentUser.currentUserName.ifEmpty { "Usu√°rio" }
                val userAvatarUrl = currentUser.currentUserAvatarUrl
                
                _uiState.value = _uiState.value.copy(isLoading = true, error = null)
                
                // Upload da m√≠dia usando o m√©todo espec√≠fico para stories
                val uploadResult = feedMediaRepository.uploadStoryMedia(
                    uri = mediaUri,
                    userId = currentUserId,
                    mediaType = mediaType
                )
                
                when (uploadResult) {
                    is Result.Success -> {
                        val mediaUrl = uploadResult.data
                        val createdAt = Date()
                        val expiresAt = Date(createdAt.time + 24 * 60 * 60 * 1000) // +24 horas
                        
                        val story = Story(
                            id = UUID.randomUUID().toString(),
                            userId = currentUserId,
                            userName = userName,
                            userAvatarUrl = userAvatarUrl,
                            mediaUrl = mediaUrl,
                            mediaType = mediaType,
                            caption = caption,
                            createdAt = createdAt,
                            expiresAt = expiresAt,
                            location = location
                        )
                        
                        val createResult = storiesRepository.createStory(story)
                        when (createResult) {
                            is Result.Success -> {
                                _uiState.value = _uiState.value.copy(isLoading = false)
                            }
                            is Result.Error -> {
                                _uiState.value = _uiState.value.copy(
                                    isLoading = false,
                                    error = createResult.exception.message ?: "Erro ao criar story"
                                )
                            }
                            else -> {
                                _uiState.value = _uiState.value.copy(
                                    isLoading = false,
                                    error = "Erro desconhecido ao criar story"
                                )
                            }
                        }
                    }
                    is Result.Error -> {
                        _uiState.value = _uiState.value.copy(
                            isLoading = false,
                            error = uploadResult.exception.message ?: "Erro ao fazer upload da m√≠dia"
                        )
                    }
                    else -> {
                        _uiState.value = _uiState.value.copy(
                            isLoading = false,
                            error = "Erro desconhecido ao fazer upload"
                        )
                    }
                }
            } catch (e: Exception) {
                android.util.Log.e("StoriesViewModel", "Erro ao criar story: ${e.message}", e)
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = e.message ?: "Erro ao criar story"
                )
            }
        }
    }
    
    fun markStoryAsViewed(storyId: String) {
        viewModelScope.launch {
            try {
                val currentUserId = authRepository.getCurrentUser()?.uid
                    ?: return@launch
                
                storiesRepository.markStoryAsViewed(storyId, currentUserId)
            } catch (e: Exception) {
                android.util.Log.e("StoriesViewModel", "Erro ao marcar story como visualizada: ${e.message}", e)
            }
        }
    }
    
    fun deleteStory(storyId: String) {
        viewModelScope.launch {
            try {
                val currentUserId = authRepository.getCurrentUser()?.uid
                    ?: run {
                        _uiState.value = _uiState.value.copy(error = "Usu√°rio n√£o autenticado")
                        return@launch
                    }
                
                _uiState.value = _uiState.value.copy(isLoading = true)
                
                val result = storiesRepository.deleteStory(storyId, currentUserId)
                when (result) {
                    is Result.Success -> {
                        _uiState.value = _uiState.value.copy(isLoading = false)
                    }
                    is Result.Error -> {
                        _uiState.value = _uiState.value.copy(
                            isLoading = false,
                            error = result.exception.message ?: "Erro ao deletar story"
                        )
                    }
                    else -> {
                        _uiState.value = _uiState.value.copy(
                            isLoading = false,
                            error = "Erro desconhecido"
                        )
                    }
                }
            } catch (e: Exception) {
                android.util.Log.e("StoriesViewModel", "Erro ao deletar story: ${e.message}", e)
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = e.message ?: "Erro ao deletar story"
                )
            }
        }
    }
    
    fun clearError() {
        _uiState.value = _uiState.value.copy(error = null)
    }
}


```

# Outros


## [FRONTEND]: MainActivity.kt

```kotlin
package com.taskgoapp.taskgo

import android.content.res.Configuration
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.DisposableEffect
import androidx.compose.ui.Modifier
import androidx.navigation.compose.currentBackStackEntryAsState
import androidx.navigation.compose.rememberNavController
import com.taskgoapp.taskgo.core.navigation.BottomNavigationBar
import com.taskgoapp.taskgo.core.theme.TaskGoTheme
import com.taskgoapp.taskgo.core.model.AccountType
import com.taskgoapp.taskgo.navigation.TaskGoNavGraph
import androidx.hilt.navigation.compose.hiltViewModel
import dagger.hilt.android.AndroidEntryPoint
import java.util.Locale
import androidx.work.Constraints
import androidx.work.ExistingPeriodicWorkPolicy
import androidx.work.NetworkType
import androidx.work.PeriodicWorkRequestBuilder
import androidx.work.WorkManager
import java.util.concurrent.TimeUnit
import com.taskgoapp.taskgo.core.sync.SyncWorker
import com.taskgoapp.taskgo.core.work.AccountChangeProcessorWorker

@AndroidEntryPoint
class MainActivity : ComponentActivity() {
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            MainContent()
        }
        // Agendar sincroniza√ß√£o peri√≥dica (a cada 15 minutos)
        // Aguardar para garantir que o HiltWorkerFactory est√° pronto
        scheduleWorkers()
    }
    
    override fun onResume() {
        super.onResume()
        // Login apenas no primeiro acesso - removida l√≥gica de biometria
    }
    
    private fun scheduleWorkers() {
        // Aguardar para garantir que Hilt est√° totalmente inicializado
        android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({
            try {
                val workManager = WorkManager.getInstance(this)
                
                // Verificar se WorkManager est√° configurado corretamente
                android.util.Log.d("MainActivity", "Agendando Workers...")
                
                // Agendar sincroniza√ß√£o peri√≥dica (a cada 15 minutos)
                val syncWork = PeriodicWorkRequestBuilder<SyncWorker>(15, TimeUnit.MINUTES)
                    .addTag("taskgo_periodic_sync")
                    .setConstraints(
                        Constraints.Builder()
                            .setRequiredNetworkType(NetworkType.CONNECTED)
                            .build()
                    )
                    .build()
                
                workManager.enqueueUniquePeriodicWork(
                    "taskgo_periodic_sync",
                    ExistingPeriodicWorkPolicy.KEEP,
                    syncWork
                )
                android.util.Log.d("MainActivity", "‚úÖ SyncWorker agendado com sucesso")
                
                // Agendar processamento de mudan√ßas de conta (diariamente)
                val accountChangeWork = PeriodicWorkRequestBuilder<AccountChangeProcessorWorker>(1, TimeUnit.DAYS)
                    .addTag("account_change_processor")
                    .setConstraints(
                        Constraints.Builder()
                            .setRequiredNetworkType(NetworkType.CONNECTED)
                            .build()
                    )
                    .build()
                
                workManager.enqueueUniquePeriodicWork(
                    "account_change_processor",
                    ExistingPeriodicWorkPolicy.KEEP,
                    accountChangeWork
                )
                android.util.Log.d("MainActivity", "‚úÖ AccountChangeProcessorWorker agendado com sucesso")
            } catch (e: Exception) {
                android.util.Log.e("MainActivity", "‚ùå Falha ao agendar Workers: ${e.message}", e)
                android.util.Log.e("MainActivity", "Tipo de erro: ${e.javaClass.simpleName}")
                android.util.Log.e("MainActivity", "Stack trace completo: ${e.stackTraceToString()}")
                
                // Tentar novamente ap√≥s mais tempo se for erro de inicializa√ß√£o
                if (e is java.lang.NoSuchMethodException || 
                    e.message?.contains("Worker", ignoreCase = true) == true) {
                    android.util.Log.w("MainActivity", "Tentando agendar novamente ap√≥s 5 segundos...")
                    android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({
                        scheduleWorkers()
                    }, 5000)
                }
            }
        }, 2000) // Aguardar 2 segundos inicialmente
    }
}

@Composable
private fun MainContent() {
    val viewModel: MainActivityViewModel = hiltViewModel()
    val authRepository = viewModel.authRepository
    val preferencesManager = viewModel.preferencesManager
    
    // Observar idioma selecionado
    val languageCode by preferencesManager.language.collectAsState(initial = "pt")
    
    TaskGoTheme(languageCode = languageCode) {
        Surface(
            modifier = Modifier.fillMaxSize(),
            color = MaterialTheme.colorScheme.background
        ) {
            val navController = rememberNavController()
            val navBackStackEntry by navController.currentBackStackEntryAsState()
            val currentRoute = navBackStackEntry?.destination?.route ?: "splash"
            
            // Processar deep links quando o app √© aberto via link
            val activity = androidx.compose.ui.platform.LocalContext.current as? MainActivity
            LaunchedEffect(Unit) {
                activity?.intent?.data?.let { uri ->
                    android.util.Log.d("MainActivity", "Processando deep link: $uri")
                    
                    // Extrair postId do URI
                    when {
                        uri.scheme == "https" &&
                                (uri.host == "taskgo.app" || uri.host == "taskgoapps.com") &&
                                uri.path?.startsWith("/post/") == true -> {
                            val postId = uri.pathSegments.getOrNull(1)
                            if (postId != null) {
                                android.util.Log.d("MainActivity", "Navegando para post: $postId (host=${uri.host})")
                                navController.navigate("post/$postId") {
                                    // Garantir que o usu√°rio esteja autenticado antes de navegar
                                    popUpTo("splash") { inclusive = false }
                                }
                            }
                        }
                        uri.scheme == "taskgo" && uri.host == "post" -> {
                            val postId = uri.pathSegments.firstOrNull()
                            if (postId != null) {
                                android.util.Log.d("MainActivity", "Navegando para post (scheme customizado): $postId")
                                navController.navigate("post/$postId") {
                                    popUpTo("splash") { inclusive = false }
                                }
                            }
                        }
                    }
                }
            }
            
            // Observar mudan√ßas no estado de autentica√ß√£o do Firebase
            val authState by authRepository.observeAuthState().collectAsState(initial = authRepository.getCurrentUser())
            val isAuthenticated = authState != null
            
            // Rotas principais onde a barra DEVE aparecer
            val mainRoutes = listOf(
                "home",
                "services",
                "products",
                "feed",
                "profile"
            )
            
            // Rotas onde a barra NUNCA deve aparecer (autentica√ß√£o e splash)
            val authRoutes = listOf(
                "splash",
                "login_person",
                "login_store",
                "forgot_password",
                "signup",
                "signup_success",
                "identity_verification",
                "facial_verification",
                "two_factor_auth"
            )
            
            // Estado local para controlar quando mostrar a barra
            // S√≥ mostrar quando estiver em uma rota principal E autenticado E n√£o estiver em splash
            var showBottomBar by remember { mutableStateOf(false) }
            
            // Observar mudan√ßas na rota e autentica√ß√£o
            LaunchedEffect(currentRoute, isAuthenticated) {
                // Mostrar barra quando estiver em uma rota principal, autenticado, e n√£o estiver em splash/login
                showBottomBar = mainRoutes.contains(currentRoute) && 
                               isAuthenticated &&
                               !authRoutes.contains(currentRoute) &&
                               !currentRoute.startsWith("signup") &&
                               !currentRoute.startsWith("login") &&
                               !currentRoute.startsWith("identity") &&
                               !currentRoute.startsWith("facial") &&
                               !currentRoute.startsWith("two_factor")
            }
            
            // Garantir que a barra s√≥ apare√ßa quando todas as condi√ß√µes forem atendidas
            val shouldShowBottomBar = showBottomBar && 
                                     mainRoutes.contains(currentRoute) && 
                                     isAuthenticated &&
                                     currentRoute != "splash" &&
                                     !authRoutes.contains(currentRoute) &&
                                     !currentRoute.startsWith("signup") &&
                                     !currentRoute.startsWith("login") &&
                                     !currentRoute.startsWith("identity") &&
                                     !currentRoute.startsWith("facial") &&
                                     !currentRoute.startsWith("two_factor")
            
            Box(modifier = Modifier.fillMaxSize()) {
                Column(
                    modifier = Modifier.fillMaxSize()
                ) {
                    // Conte√∫do principal
                    TaskGoNavGraph(
                        navController = navController,
                        modifier = Modifier.weight(1f)
                    )

                    // Barra de navega√ß√£o inferior - aparece em todas as telas principais (home, services, products, messages, profile)
                    // mas NUNCA durante splash ou telas de autentica√ß√£o
                    // Obter accountType para usar label din√¢mico "Loja" vs "Produtos"
                    val accountType by viewModel.accountType.collectAsState()
                    
                    if (shouldShowBottomBar) {
                        BottomNavigationBar(
                            currentRoute = currentRoute,
                            accountType = accountType, // Passar accountType para label din√¢mico
                            onNavigate = { route ->
                                navController.navigate(route) {
                                    popUpTo(navController.graph.startDestinationId) {
                                        saveState = true
                                    }
                                    launchSingleTop = true
                                    restoreState = true
                                }
                            }
                        )
                    }
                }
            }
        }
    }
}

```

## [FRONTEND]: MainActivityViewModel.kt

```kotlin
package com.taskgoapp.taskgo

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.taskgoapp.taskgo.core.model.AccountType
import com.taskgoapp.taskgo.data.repository.FirebaseAuthRepository
import com.taskgoapp.taskgo.data.local.datastore.PreferencesManager
import com.taskgoapp.taskgo.domain.repository.UserRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.flow.SharingStarted
import javax.inject.Inject

@HiltViewModel
class MainActivityViewModel @Inject constructor(
    val authRepository: FirebaseAuthRepository,
    val preferencesManager: PreferencesManager,
    private val userRepository: UserRepository
) : ViewModel() {
    
    // Observar accountType do usu√°rio atual para usar na BottomNavigationBar
    val accountType: StateFlow<AccountType?> = userRepository
        .observeCurrentUser()
        .map { user -> user?.accountType }
        .stateIn(
            viewModelScope,
            SharingStarted.WhileSubscribed(5_000),
            null
        )
}


```

## [FRONTEND]: navigation/OrderChatNavigationScreen.kt

```kotlin
package com.taskgoapp.taskgo.navigation

import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.hilt.navigation.compose.hiltViewModel
import com.google.firebase.firestore.FirebaseFirestore
import com.taskgoapp.taskgo.data.repository.FirebaseAuthRepository
import com.taskgoapp.taskgo.data.repository.FirestoreOrderRepository
import com.taskgoapp.taskgo.data.repository.FirestoreUserRepository
import com.taskgoapp.taskgo.feature.messages.presentation.MessagesViewModel

@Composable
fun OrderChatNavigationScreen(
    orderId: String,
    onNavigateToChat: (String) -> Unit,
    onNavigateBack: () -> Unit
) {
    val messagesViewModel: MessagesViewModel = hiltViewModel()
    
    LaunchedEffect(orderId) {
        try {
            // Instanciar repositories diretamente
            val firestore = com.taskgoapp.taskgo.core.firebase.FirestoreHelper.getInstance()
            val authRepository = FirebaseAuthRepository(com.google.firebase.auth.FirebaseAuth.getInstance())
            val orderRepository = FirestoreOrderRepository(firestore, authRepository)
            val userRepository = FirestoreUserRepository(firestore)
            
            val threadId = messagesViewModel.getOrCreateThreadForOrder(orderId, orderRepository, userRepository)
            onNavigateToChat(threadId)
        } catch (exception: Exception) {
            android.util.Log.e("OrderChatNavigation", "Erro ao obter/criar thread: ${exception.message}", exception)
            onNavigateBack()
        }
    }
    
    Box(
        modifier = Modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        CircularProgressIndicator()
    }
}


```

## [FRONTEND]: navigation/TaskGoNavGraph.kt

```kotlin
package com.taskgoapp.taskgo.navigation

import android.net.Uri
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.navigation.NavHostController
import androidx.navigation.NavType
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.navArgument
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import androidx.lifecycle.viewmodel.compose.viewModel
import com.taskgoapp.taskgo.feature.home.presentation.HomeScreen
import com.taskgoapp.taskgo.feature.splash.presentation.SplashScreen
import com.taskgoapp.taskgo.feature.auth.presentation.LoginPersonScreen
import com.taskgoapp.taskgo.feature.auth.presentation.LoginStoreScreen
import com.taskgoapp.taskgo.feature.auth.presentation.SignUpScreen
import com.taskgoapp.taskgo.feature.auth.presentation.SignUpSuccessScreen
import com.taskgoapp.taskgo.feature.services.presentation.ServicesScreen
import com.taskgoapp.taskgo.feature.services.presentation.LocalProvidersScreen
import com.taskgoapp.taskgo.feature.services.presentation.LocalServiceOrdersScreen
import com.taskgoapp.taskgo.feature.services.presentation.ServiceOrderDetailScreen
import com.taskgoapp.taskgo.navigation.OrderChatNavigationScreen
import com.taskgoapp.taskgo.feature.services.presentation.ProposalsReceivedScreen
import com.taskgoapp.taskgo.feature.services.presentation.ProposalDetailScreen
import com.taskgoapp.taskgo.feature.services.presentation.ProposalsViewModel
import com.taskgoapp.taskgo.feature.services.presentation.ServiceHistoryScreen
import com.taskgoapp.taskgo.feature.services.presentation.RateProviderScreen
import com.taskgoapp.taskgo.feature.services.presentation.HistoricoServicosScreen
import com.taskgoapp.taskgo.feature.services.presentation.AvaliarPrestadorScreen
import com.taskgoapp.taskgo.feature.products.presentation.ProductsScreen
import com.taskgoapp.taskgo.feature.products.presentation.DiscountedProductsScreen
import com.taskgoapp.taskgo.feature.products.presentation.CreateProductScreen
import com.taskgoapp.taskgo.feature.products.presentation.EditProductScreen
import com.taskgoapp.taskgo.feature.products.presentation.ManageProductsScreen
import com.taskgoapp.taskgo.feature.messages.presentation.MessagesScreen
import com.taskgoapp.taskgo.feature.feed.presentation.FeedScreen
import com.taskgoapp.taskgo.feature.feed.presentation.PostDetailScreen
import com.taskgoapp.taskgo.feature.profile.presentation.ProfileScreen
import com.taskgoapp.taskgo.feature.profile.presentation.MyDataScreen
import com.taskgoapp.taskgo.feature.profile.presentation.MyReviewsScreen
import com.taskgoapp.taskgo.feature.profile.presentation.ProviderProfileScreen
import com.taskgoapp.taskgo.feature.profile.presentation.PublicUserProfileScreen
import com.taskgoapp.taskgo.feature.ads.presentation.ComprarBannerScreen
import com.taskgoapp.taskgo.feature.checkout.presentation.CheckoutScreen
import com.taskgoapp.taskgo.feature.checkout.presentation.OrderSummaryScreen
import com.taskgoapp.taskgo.feature.checkout.presentation.PixPaymentScreen
import com.taskgoapp.taskgo.feature.checkout.presentation.CardDetailsScreen
import com.taskgoapp.taskgo.feature.checkout.presentation.PaymentSuccessScreen
import com.taskgoapp.taskgo.feature.orders.presentation.OrderSuccessScreen
import com.taskgoapp.taskgo.feature.notifications.presentation.NotificationsScreen
import com.taskgoapp.taskgo.feature.notifications.presentation.NotificationDetailScreen
import com.taskgoapp.taskgo.feature.orders.presentation.MeusPedidosScreen
import com.taskgoapp.taskgo.feature.orders.presentation.MyOrdersInProgressScreen
import com.taskgoapp.taskgo.feature.orders.presentation.MyOrdersCompletedScreen
import com.taskgoapp.taskgo.feature.orders.presentation.MyOrdersCanceledScreen
import com.taskgoapp.taskgo.feature.products.presentation.CartScreen
import com.taskgoapp.taskgo.feature.products.presentation.ProductDetailScreen
import com.taskgoapp.taskgo.feature.products.presentation.CarrinhoScreen
import com.taskgoapp.taskgo.feature.products.presentation.DetalhesProdutoScreen
import com.taskgoapp.taskgo.feature.products.presentation.EditarProdutoScreen
import com.taskgoapp.taskgo.feature.products.presentation.GerenciarProdutosScreen
import com.taskgoapp.taskgo.feature.products.presentation.CriarProdutoScreen
import com.taskgoapp.taskgo.feature.products.presentation.OrderTrackingScreen
import com.taskgoapp.taskgo.feature.products.presentation.CheckoutScreen as CheckoutScreenLegacy
import com.taskgoapp.taskgo.feature.services.presentation.CreateWorkOrderScreen
import com.taskgoapp.taskgo.feature.services.presentation.DetalhesServicoScreen
import com.taskgoapp.taskgo.feature.services.presentation.GerenciarPropostasScreen
import com.taskgoapp.taskgo.feature.services.presentation.ConfirmarPropostaScreen
import com.taskgoapp.taskgo.feature.services.presentation.DetalhesPropostaScreen
import com.taskgoapp.taskgo.feature.settings.presentation.ConfiguracoesScreen
import com.taskgoapp.taskgo.feature.auth.presentation.ForgotPasswordScreen
import com.taskgoapp.taskgo.feature.settings.presentation.AccountScreen
import com.taskgoapp.taskgo.feature.settings.presentation.PreferencesScreen
import com.taskgoapp.taskgo.feature.settings.presentation.NotificationsSettingsScreen
import com.taskgoapp.taskgo.feature.settings.presentation.LanguageScreen
import com.taskgoapp.taskgo.feature.settings.presentation.PrivacyScreen
import com.taskgoapp.taskgo.feature.settings.presentation.SupportScreen
import com.taskgoapp.taskgo.feature.settings.presentation.AboutScreen
import com.taskgoapp.taskgo.feature.settings.presentation.PrivacyPolicyScreen
import com.taskgoapp.taskgo.feature.settings.presentation.TermsOfServiceScreen
import com.taskgoapp.taskgo.feature.settings.presentation.ConsentHistoryScreen
import com.taskgoapp.taskgo.feature.settings.presentation.AlterarSenhaScreen
import com.taskgoapp.taskgo.feature.settings.presentation.PrivacidadeScreen
import com.taskgoapp.taskgo.feature.settings.presentation.SobreScreen
import com.taskgoapp.taskgo.feature.settings.presentation.SuporteScreen
import com.taskgoapp.taskgo.feature.settings.presentation.SettingsScreen
import com.taskgoapp.taskgo.feature.messages.presentation.ChatScreen
import com.taskgoapp.taskgo.feature.products.presentation.MeusProdutosScreen
import com.taskgoapp.taskgo.feature.services.presentation.MeusServicosScreen
import com.taskgoapp.taskgo.feature.services.presentation.ServiceFormScreen
import com.taskgoapp.taskgo.feature.services.presentation.MyServiceOrdersScreen
import com.taskgoapp.taskgo.feature.checkout.presentation.AddressBookScreen
import com.taskgoapp.taskgo.feature.checkout.presentation.CadastrarEnderecoScreen
import com.taskgoapp.taskgo.feature.checkout.presentation.PaymentMethodScreen
import com.taskgoapp.taskgo.feature.checkout.presentation.FormaPagamentoScreen
import com.taskgoapp.taskgo.feature.checkout.presentation.FinalizarPedidoScreen
import com.taskgoapp.taskgo.feature.checkout.presentation.ConfirmacaoPixScreen
import com.taskgoapp.taskgo.feature.checkout.presentation.CartaoCreditoScreen
import com.taskgoapp.taskgo.feature.checkout.presentation.CartaoDebitoScreen
import com.taskgoapp.taskgo.feature.orders.presentation.DetalhesPedidoScreen
import com.taskgoapp.taskgo.feature.orders.presentation.RastreamentoPedidoScreen
import com.taskgoapp.taskgo.feature.orders.presentation.ResumoPedidoScreen
import com.taskgoapp.taskgo.feature.products.presentation.ProductFormScreen
import com.taskgoapp.taskgo.feature.ads.presentation.AdsScreen
import com.taskgoapp.taskgo.feature.chatai.presentation.AiSupportScreen
import com.taskgoapp.taskgo.feature.chatai.presentation.ChatListScreen
import com.taskgoapp.taskgo.feature.search.presentation.UniversalSearchScreen
import com.taskgoapp.taskgo.feature.reviews.presentation.UserReviewsScreen
import com.taskgoapp.taskgo.feature.reviews.presentation.ReviewsScreen
import com.taskgoapp.taskgo.feature.reviews.presentation.CreateReviewScreen
import com.taskgoapp.taskgo.core.model.ReviewType
import com.taskgoapp.taskgo.feature.auth.presentation.IdentityVerificationScreen
import com.taskgoapp.taskgo.feature.auth.presentation.TwoFactorAuthScreen
import com.taskgoapp.taskgo.feature.settings.presentation.SecuritySettingsScreen

@Composable
fun TaskGoNavGraph(
    navController: NavHostController,
    startDestination: String = "splash",
    modifier: Modifier = Modifier
) {
    NavHost(
        navController = navController,
        startDestination = startDestination,
        modifier = modifier
    ) {
        composable("splash") {
            SplashScreen(
                onNavigateToLogin = {
                    navController.navigate("login_person") {
                        popUpTo("splash") { inclusive = true }
                    }
                },
                onNavigateToHome = {
                    navController.navigate("home") {
                        popUpTo("splash") { inclusive = true }
                    }
                },
                onNavigateToBiometricAuth = {
                    // Biometria removida - navegar direto para home
                    navController.navigate("home") {
                        popUpTo("splash") { inclusive = true }
                    }
                }
            )
        }
        
        // Rota de biometria removida - login apenas no primeiro acesso

        composable("forgot_password") {
            ForgotPasswordScreen(
                onBackClick = { navController.popBackStack() },
                onResetSent = { navController.popBackStack() }
            )
        }

        // Rotas de autentica√ß√£o
        composable("login_person") {
            LoginPersonScreen(
                onNavigateToStoreLogin = { navController.navigate("login_store") },
                onNavigateToSignUp = { navController.navigate("signup") },
                onNavigateToHome = { navController.navigate("home") },
                onNavigateToForgotPassword = { navController.navigate("forgot_password") },
                onNavigateToTwoFactor = { navController.navigate("two_factor_auth") },
                onNavigateToIdentityVerification = { navController.navigate("identity_verification") }
            )
        }
        
        composable("two_factor_auth") {
            TwoFactorAuthScreen(
                onVerificationSuccess = {
                    // Navegar para home, removendo todas as telas de login do back stack
                    navController.navigate("home") {
                        popUpTo("login_person") { inclusive = true }
                        popUpTo("login_store") { inclusive = true }
                    }
                },
                onVerificationFailed = {
                    navController.popBackStack()
                }
            )
        }
        
        composable("login_store") {
            LoginStoreScreen(
                onNavigateToPersonLogin = { navController.navigate("login_person") },
                onNavigateToSignUp = { navController.navigate("signup") },
                onNavigateToHome = { navController.navigate("home") },
                onNavigateToForgotPassword = { navController.navigate("forgot_password") }
            )
        }
        
        composable("signup") {
            SignUpScreen(
                onNavigateToLogin = { navController.navigate("login_person") },
                onNavigateToHome = { navController.navigate("signup_success") },
                onNavigateToDocumentVerification = { navController.navigate("identity_verification") },
                onBackClick = { navController.popBackStack() }
            )
        }
        
        composable("signup_success") {
            SignUpSuccessScreen(
                onNavigateToHome = { navController.navigate("home") },
                onNavigateToLogin = { navController.navigate("login_person") }
            )
        }

            composable("home") {
                HomeScreen(
                    onNavigateToService = { serviceId ->
                        navController.navigate("service_detail/$serviceId")
                    },
                    onNavigateToProduct = { productId ->
                        navController.navigate("product_detail/$productId")
                    },
                    onNavigateToCreateWorkOrder = {
                        navController.navigate("create_work_order")
                    },
                    onNavigateToProposals = {
                        navController.navigate("proposals_inbox")
                    },
                    onNavigateToBuyBanner = {
                        navController.navigate("comprar_banner")
                    },
                    onNavigateToNotifications = {
                        navController.navigate("notifications")
                    },
                    onNavigateToSettings = {
                        navController.navigate("configuracoes")
                    },
                    onNavigateToMessages = {
                        navController.navigate("messages")
                    },
                    onNavigateToCart = {
                        navController.navigate("cart")
                    },
                    onNavigateToSearch = {
                        navController.navigate("universal_search")
                    },
                    onNavigateToLocalProviders = {
                        navController.navigate("local_providers")
                    },
                    onNavigateToDiscountedProducts = {
                        navController.navigate("discounted_products")
                    },
                    onNavigateToLocalServiceOrders = {
                        navController.navigate("local_service_orders")
                    },
                    onNavigateToProviderProfile = { providerId, isStore ->
                        // Usar a nova rota unificada de perfil
                        navController.navigate("user_profile/$providerId")
                    }
                )
            }
            
            composable("universal_search") {
                UniversalSearchScreen(
                    onNavigateBack = {
                        navController.popBackStack()
                    },
                    onNavigateToProduct = { productId ->
                        navController.navigate("product_detail/$productId")
                    },
                    onNavigateToService = { serviceId ->
                        navController.navigate("service_detail/$serviceId")
                    }
                )
            }

            composable("home_products") {
                HomeScreen(
                    onNavigateToService = { serviceId ->
                        navController.navigate("service_detail/$serviceId")
                    },
                    onNavigateToProduct = { productId ->
                        navController.navigate("product_detail/$productId")
                    },
                    onNavigateToCreateWorkOrder = {
                        navController.navigate("create_work_order")
                    },
                    onNavigateToProposals = {
                        navController.navigate("proposals_inbox")
                    },
                    onNavigateToBuyBanner = {
                        navController.navigate("comprar_banner")
                    },
                    onNavigateToNotifications = {
                        navController.navigate("notifications")
                    },
                    onNavigateToSettings = {
                        navController.navigate("configuracoes")
                    },
                    onNavigateToMessages = {
                        navController.navigate("messages")
                    },
                    onNavigateToCart = {
                        navController.navigate("cart")
                    },
                    onNavigateToLocalProviders = {
                        navController.navigate("local_providers")
                    },
                    onNavigateToDiscountedProducts = {
                        navController.navigate("discounted_products")
                    },
                    onNavigateToLocalServiceOrders = {
                        navController.navigate("local_service_orders")
                    },
                    variant = "products"
                )
            }
            composable("home_services") {
                HomeScreen(
                    onNavigateToService = { serviceId ->
                        navController.navigate("service_detail/$serviceId")
                    },
                    onNavigateToProduct = { productId ->
                        navController.navigate("product_detail/$productId")
                    },
                    onNavigateToCreateWorkOrder = {
                        navController.navigate("create_work_order")
                    },
                    onNavigateToProposals = {
                        navController.navigate("proposals_inbox")
                    },
                    onNavigateToBuyBanner = {
                        navController.navigate("comprar_banner")
                    },
                    onNavigateToNotifications = {
                        navController.navigate("notifications")
                    },
                    onNavigateToSettings = {
                        navController.navigate("configuracoes")
                    },
                    onNavigateToMessages = {
                        navController.navigate("messages")
                    },
                    onNavigateToCart = {
                        navController.navigate("cart")
                    },
                    onNavigateToLocalProviders = {
                        navController.navigate("local_providers")
                    },
                    onNavigateToDiscountedProducts = {
                        navController.navigate("discounted_products")
                    },
                    onNavigateToLocalServiceOrders = {
                        navController.navigate("local_service_orders")
                    },
                    variant = "services"
                )
            }
            composable("home_messages") {
                HomeScreen(
                    onNavigateToService = { serviceId ->
                        navController.navigate("service_detail/$serviceId")
                    },
                    onNavigateToProduct = { productId ->
                        navController.navigate("product_detail/$productId")
                    },
                    onNavigateToCreateWorkOrder = {
                        navController.navigate("create_work_order")
                    },
                    onNavigateToProposals = {
                        navController.navigate("proposals_inbox")
                    },
                    onNavigateToBuyBanner = {
                        navController.navigate("comprar_banner")
                    },
                    onNavigateToNotifications = {
                        navController.navigate("notifications")
                    },
                    onNavigateToSettings = {
                        navController.navigate("configuracoes")
                    },
                    onNavigateToMessages = {
                        navController.navigate("messages")
                    },
                    onNavigateToCart = {
                        navController.navigate("cart")
                    },
                    onNavigateToLocalProviders = {
                        navController.navigate("local_providers")
                    },
                    onNavigateToDiscountedProducts = {
                        navController.navigate("discounted_products")
                    },
                    onNavigateToLocalServiceOrders = {
                        navController.navigate("local_service_orders")
                    },
                    variant = "messages"
                )
            }
            composable("home_profile") {
                HomeScreen(
                    onNavigateToService = { serviceId ->
                        navController.navigate("service_detail/$serviceId")
                    },
                    onNavigateToProduct = { productId ->
                        navController.navigate("product_detail/$productId")
                    },
                    onNavigateToCreateWorkOrder = {
                        navController.navigate("create_work_order")
                    },
                    onNavigateToProposals = {
                        navController.navigate("proposals_inbox")
                    },
                    onNavigateToBuyBanner = {
                        navController.navigate("comprar_banner")
                    },
                    onNavigateToNotifications = {
                        navController.navigate("notifications")
                    },
                    onNavigateToSettings = {
                        navController.navigate("configuracoes")
                    },
                    onNavigateToMessages = {
                        navController.navigate("messages")
                    },
                    onNavigateToCart = {
                        navController.navigate("cart")
                    },
                    onNavigateToLocalProviders = {
                        navController.navigate("local_providers")
                    },
                    onNavigateToDiscountedProducts = {
                        navController.navigate("discounted_products")
                    },
                    onNavigateToLocalServiceOrders = {
                        navController.navigate("local_service_orders")
                    },
                    variant = "profile"
                )
            }

            // Novas rotas de banners promocionais
            composable("local_service_orders") {
                LocalServiceOrdersScreen(
                    onBackClick = { navController.popBackStack() },
                    onOrderClick = { orderId ->
                        navController.navigate("service_order_detail/$orderId")
                    }
                )
            }
            composable(
                route = "service_order_detail/{orderId}",
                arguments = listOf(
                    navArgument("orderId") {
                        type = NavType.StringType
                    }
                )
            ) { backStackEntry ->
                val orderId = backStackEntry.arguments?.getString("orderId") ?: ""
                ServiceOrderDetailScreen(
                    orderId = orderId,
                    onBackClick = { navController.popBackStack() },
                    onSendProposal = { orderId ->
                        // Navegar para mensagens
                        // A abertura autom√°tica da conversa ser√° implementada no MessagesScreen
                        // quando receber orderId via par√¢metro
                        navController.navigate("messages")
                    },
                    onNavigateToChat = { orderIdForChat ->
                        // Navegar para rota que obt√©m/cria thread e redireciona para chat
                        navController.navigate("chat_for_order/$orderIdForChat")
                    }
                )
            }
            composable("local_providers") {
                LocalProvidersScreen(
                    onNavigateToServiceDetail = { providerId ->
                        navController.navigate("provider_profile/$providerId")
                    },
                    onNavigateToCreateWorkOrder = {
                        navController.navigate("create_work_order")
                    },
                    onBackClick = { navController.popBackStack() }
                )
            }
            
            // Rota de perfil p√∫blico unificado (usu√°rio gen√©rico)
            composable(
                route = "user_profile/{userId}",
                arguments = listOf(
                    navArgument("userId") {
                        type = NavType.StringType
                    }
                )
            ) { backStackEntry ->
                val userId = backStackEntry.arguments?.getString("userId") ?: ""
                PublicUserProfileScreen(
                    userId = userId,
                    onBackClick = { navController.popBackStack() },
                    onMessageClick = { userId ->
                        navController.navigate("messages")
                    },
                    onRateClick = { userId ->
                        navController.navigate("rate_provider/$userId")
                    },
                    onPostClick = { targetUserId ->
                        // Navegar para o feed (funcionalidade completa de postar no feed de outro usu√°rio pode ser implementada depois)
                        navController.navigate("feed")
                    },
                    onServiceClick = { serviceId ->
                        navController.navigate("service_detail/$serviceId")
                    },
                    onProductClick = { productId ->
                        navController.navigate("product_detail/$productId")
                    }
                )
            }
            
            // Rota de perfil do prestador/loja (mantida para compatibilidade)
            composable(
                route = "provider_profile/{providerId}",
                arguments = listOf(
                    navArgument("providerId") {
                        type = NavType.StringType
                    }
                )
            ) { backStackEntry ->
                val providerId = backStackEntry.arguments?.getString("providerId") ?: ""
                // Redirecionar para a nova rota unificada
                navController.navigate("user_profile/$providerId") {
                    popUpTo("provider_profile/$providerId") { inclusive = true }
                }
            }
            
            composable(
                route = "provider_profile_legacy/{providerId}",
                arguments = listOf(
                    navArgument("providerId") {
                        type = NavType.StringType
                    }
                )
            ) { backStackEntry ->
                val providerId = backStackEntry.arguments?.getString("providerId") ?: ""
                // Por padr√£o, assumir que √© prestador (n√£o loja)
                // Se precisar diferenciar, pode passar via query parameter ou criar rota separada
                val isStore = false
                ProviderProfileScreen(
                    providerId = providerId,
                    isStore = isStore,
                    onBackClick = { navController.popBackStack() },
                    onRateClick = { providerId ->
                        navController.navigate("rate_provider/$providerId")
                    },
                    onMessageClick = { providerId ->
                        // Navegar para mensagens
                        // A abertura autom√°tica da conversa ser√° implementada no MessagesScreen
                        // quando receber providerId via par√¢metro
                        navController.navigate("messages")
                    },
                    onServiceClick = { serviceId ->
                        navController.navigate("service_detail/$serviceId")
                    }
                )
            }
            
            composable("discounted_products") {
                DiscountedProductsScreen(
                    onNavigateToProductDetail = { productId ->
                        navController.navigate("product_detail/$productId")
                    },
                    onNavigateToCart = {
                        navController.navigate("cart")
                    },
                    onBackClick = { navController.popBackStack() }
                )
            }

            // Rotas das abas da navega√ß√£o inferior
            composable("services") {
                ServicesScreen(
                    onNavigateToServiceDetail = { serviceId ->
                        navController.navigate("service_detail/$serviceId") {
                            // Salvar a rota "services" no back stack para poder voltar
                            launchSingleTop = true
                        }
                    },
                    onNavigateToCreateWorkOrder = {
                        navController.navigate("create_work_order")
                    },
                    onNavigateToNotifications = {
                        navController.navigate("notifications")
                    },
                    onNavigateToCart = {
                        navController.navigate("cart")
                    },
                    onNavigateToMessages = {
                        navController.navigate("messages")
                    },
                    onNavigateToSearch = {
                        navController.navigate("universal_search")
                    }
                )
            }

            composable("products") {
                ProductsScreen(
                    onNavigateToProductDetail = { productId ->
                        navController.navigate("product_detail/$productId")
                    },
                    onNavigateToCart = {
                        navController.navigate("cart")
                    },
                    onNavigateToAddProduct = {
                        navController.navigate("create_product")
                    },
                    onNavigateToNotifications = {
                        navController.navigate("notifications")
                    },
                    onNavigateToMessages = {
                        navController.navigate("messages")
                    },
                    onNavigateToSearch = {
                        navController.navigate("universal_search")
                    },
                    onNavigateToSellerProfile = { sellerId ->
                        navController.navigate("user_profile/$sellerId")
                    }
                )
            }

            composable("feed") {
                FeedScreen(
                    onNavigateToMessages = {
                        navController.navigate("messages")
                    },
                    onNavigateToUserProfile = { userId ->
                        navController.navigate("user_profile/$userId")
                    },
                    onNavigateToSearch = {
                        navController.navigate("universal_search")
                    },
                    onNavigateToNotifications = {
                        navController.navigate("notifications")
                    },
                    onNavigateToCart = {
                        navController.navigate("cart")
                    }
                )
            }
            
            // Tela de detalhes do post (deep link: https://taskgo.app/post/{postId})
            composable(
                route = "post/{postId}",
                arguments = listOf(
                    navArgument("postId") { type = NavType.StringType }
                )
            ) { backStackEntry ->
                val postId = backStackEntry.arguments?.getString("postId") ?: ""
                PostDetailScreen(
                    postId = postId,
                    onBackClick = { navController.popBackStack() },
                    onNavigateToUserProfile = { userId ->
                        navController.navigate("user_profile/$userId")
                    }
                )
            }
            
            // Rotas de mensagens mantidas (acess√≠veis via bot√£o do topbar)
            composable("messages") {
                MessagesScreen(
                    onBackClick = { navController.popBackStack() },
                    onNavigateToChat = { chatId ->
                        navController.navigate("chat/$chatId")
                    },
                    onNavigateToCreateWorkOrder = {
                        navController.navigate("create_work_order")
                    },
                    onNavigateToProposals = {
                        navController.navigate("proposals_inbox")
                    },
                    onNavigateToNotifications = {
                        navController.navigate("notifications")
                    },
                    onNavigateToSettings = {
                        navController.navigate("configuracoes")
                    },
                    onNavigateToCart = {
                        navController.navigate("cart")
                    },
                    onNavigateToProviders = {
                        navController.navigate("local_providers")
                    },
                    onNavigateToServiceOrders = {
                        navController.navigate("local_service_orders")
                    }
                )
            }
        composable("messages_empty") {
            MessagesScreen(
                onBackClick = { navController.popBackStack() },
                onNavigateToChat = { chatId -> navController.navigate("chat/$chatId") },
                onNavigateToCreateWorkOrder = { navController.navigate("create_work_order") },
                onNavigateToProposals = { navController.navigate("proposals_inbox") },
                onNavigateToNotifications = { navController.navigate("notifications") },
                onNavigateToSettings = { navController.navigate("configuracoes") },
                onNavigateToCart = { navController.navigate("cart") },
                onNavigateToProviders = { navController.navigate("local_providers") },
                onNavigateToServiceOrders = { navController.navigate("local_service_orders") },
                variant = "empty"
            )
        }
        composable("messages_loading") {
            MessagesScreen(
                onBackClick = { navController.popBackStack() },
                onNavigateToChat = { chatId -> navController.navigate("chat/$chatId") },
                onNavigateToCreateWorkOrder = { navController.navigate("create_work_order") },
                onNavigateToProposals = { navController.navigate("proposals_inbox") },
                onNavigateToNotifications = { navController.navigate("notifications") },
                onNavigateToSettings = { navController.navigate("configuracoes") },
                onNavigateToCart = { navController.navigate("cart") },
                onNavigateToProviders = { navController.navigate("local_providers") },
                onNavigateToServiceOrders = { navController.navigate("local_service_orders") },
                variant = "loading"
            )
        }
        composable("messages_unread") {
            MessagesScreen(
                onBackClick = { navController.popBackStack() },
                onNavigateToChat = { chatId -> navController.navigate("chat/$chatId") },
                onNavigateToCreateWorkOrder = { navController.navigate("create_work_order") },
                onNavigateToProposals = { navController.navigate("proposals_inbox") },
                onNavigateToNotifications = { navController.navigate("notifications") },
                onNavigateToSettings = { navController.navigate("configuracoes") },
                onNavigateToCart = { navController.navigate("cart") },
                onNavigateToProviders = { navController.navigate("local_providers") },
                onNavigateToServiceOrders = { navController.navigate("local_service_orders") },
                variant = "unread"
            )
        }

            composable("profile") {
                ProfileScreen(
                    onNavigateToSettings = {
                        navController.navigate("configuracoes")
                    },
                    onNavigateToMyOrders = {
                        navController.navigate("meus_pedidos")
                    },
                    onNavigateToMyServices = {
                        navController.navigate("meus_servicos")
                    },
                    onNavigateToMyProducts = {
                        navController.navigate("gerenciar_produtos")
                    },
                    onNavigateToMyServiceOrders = {
                        navController.navigate("minhas_ordens_servico")
                    },
                    onNavigateToAboutMe = {
                        navController.navigate("sobre_mim")
                    },
                    onNavigateToUserReviews = { userId, userName ->
                        navController.navigate("user_reviews/$userId/$userName")
                    }
                )
            }

        // Profile extras
        composable("my_data") { MyDataScreen(onNavigateBack = { navController.popBackStack() }) }
        composable("sobre_mim") {
            com.taskgoapp.taskgo.feature.profile.presentation.AboutMeScreen(
                onBackClick = { navController.popBackStack() },
                onNavigateToReviews = { userId, userName ->
                    navController.navigate("user_reviews/$userId/$userName")
                }
            )
        }
        composable("my_reviews") { MyReviewsScreen(onNavigateBack = { navController.popBackStack() }) }
        composable("user_reviews/{userId}/{userName}") { backStackEntry ->
            val userId = backStackEntry.arguments?.getString("userId") ?: ""
            val userName = backStackEntry.arguments?.getString("userName") ?: "Usu√°rio"
            UserReviewsScreen(
                userId = userId,
                userName = userName,
                onNavigateBack = { navController.popBackStack() }
            )
        }
        composable("identity_verification") {
            IdentityVerificationScreen(
                onBackClick = { navController.popBackStack() },
                onSkipVerification = { navController.navigate("home") },
                onVerificationComplete = { navController.navigate("home") },
                onNavigateToFacialVerification = { navController.navigate("facial_verification") }
            )
        }
        
        composable("facial_verification") {
            com.taskgoapp.taskgo.feature.auth.presentation.FacialVerificationScreen(
                onBackClick = { navController.popBackStack() },
                onVerificationComplete = { navController.popBackStack() }
            )
        }

        // Rotas de produtos
        composable("product_detail/{productId}") { backStackEntry ->
            val productId = backStackEntry.arguments?.getString("productId") ?: ""
            ProductDetailScreen(
                productId = productId,
                onBackClick = { navController.popBackStack() },
                onAddToCart = { navController.navigate("cart") },
                onNavigateToReviews = { targetId ->
                    navController.navigate("reviews/$targetId/PRODUCT")
                }
            )
        }

        composable("product_detail_reviews/{productId}") { backStackEntry ->
            val productId = backStackEntry.arguments?.getString("productId") ?: ""
            ProductDetailScreen(
                productId = productId,
                onBackClick = { navController.popBackStack() },
                onAddToCart = { navController.navigate("cart") },
                variant = "reviews"
            )
        }

        composable("product_detail_gallery/{productId}") { backStackEntry ->
            val productId = backStackEntry.arguments?.getString("productId") ?: ""
            ProductDetailScreen(
                productId = productId,
                onBackClick = { navController.popBackStack() },
                onAddToCart = { navController.navigate("cart") },
                variant = "gallery"
            )
        }
        
        // Rotas de avalia√ß√µes
        composable("reviews/{targetId}/{type}") { backStackEntry ->
            val targetId = backStackEntry.arguments?.getString("targetId") ?: ""
            val typeString = backStackEntry.arguments?.getString("type") ?: "PRODUCT"
            val type = when (typeString) {
                "PRODUCT" -> ReviewType.PRODUCT
                "SERVICE" -> ReviewType.SERVICE
                "PROVIDER" -> ReviewType.PROVIDER
                else -> ReviewType.PRODUCT
            }
            ReviewsScreen(
                targetId = targetId,
                type = type,
                targetName = "Item", // TODO: Buscar nome do target
                onNavigateBack = { navController.popBackStack() },
                onNavigateToCreateReview = {
                    navController.navigate("create_review/$targetId/$typeString")
                }
            )
        }
        
        composable("create_review/{targetId}/{type}") { backStackEntry ->
            val targetId = backStackEntry.arguments?.getString("targetId") ?: ""
            val typeString = backStackEntry.arguments?.getString("type") ?: "PRODUCT"
            val type = when (typeString) {
                "PRODUCT" -> ReviewType.PRODUCT
                "SERVICE" -> ReviewType.SERVICE
                "PROVIDER" -> ReviewType.PROVIDER
                else -> ReviewType.PRODUCT
            }
            CreateReviewScreen(
                targetId = targetId,
                type = type,
                targetName = "Item", // TODO: Buscar nome do target
                orderId = null, // TODO: Passar orderId se dispon√≠vel
                onNavigateBack = { navController.popBackStack() },
                onReviewCreated = { navController.popBackStack() }
            )
        }
        
        composable("create_review/{targetId}/{type}/{orderId}") { backStackEntry ->
            val targetId = backStackEntry.arguments?.getString("targetId") ?: ""
            val typeString = backStackEntry.arguments?.getString("type") ?: "PRODUCT"
            val orderId = backStackEntry.arguments?.getString("orderId")
            val type = when (typeString) {
                "PRODUCT" -> ReviewType.PRODUCT
                "SERVICE" -> ReviewType.SERVICE
                "PROVIDER" -> ReviewType.PROVIDER
                else -> ReviewType.PRODUCT
            }
            CreateReviewScreen(
                targetId = targetId,
                type = type,
                targetName = "Item", // TODO: Buscar nome do target
                orderId = orderId,
                onNavigateBack = { navController.popBackStack() },
                onReviewCreated = { navController.popBackStack() }
            )
        }

        composable("cart") {
            CartScreen(
                onNavigateToCheckout = { navController.navigate("checkout") },
                onNavigateToProductDetail = { productId -> 
                    navController.navigate("product_detail/$productId")
                },
                onNavigateBack = { navController.popBackStack() },
                onNavigateToProducts = { navController.navigate("products") }
            )
        }

        composable("cart_filled") {
            CartScreen(
                onNavigateToCheckout = { navController.navigate("checkout") },
                onNavigateToProductDetail = { productId -> 
                    navController.navigate("product_detail/$productId")
                },
                onNavigateBack = { navController.popBackStack() },
                onNavigateToProducts = { navController.navigate("products") },
                variant = "filled"
            )
        }
        
        composable("create_product") {
            ProductFormScreen(
                productId = null,
                onBack = { navController.popBackStack() },
                onSaved = { 
                    navController.navigate("gerenciar_produtos") {
                        popUpTo("create_product") { inclusive = true }
                    }
                }
            )
        }
        
        composable("edit_product/{productId}") { backStackEntry ->
            val productId = backStackEntry.arguments?.getString("productId") ?: ""
            ProductFormScreen(
                productId = productId,
                onBack = { navController.popBackStack() },
                onSaved = { 
                    navController.navigate("gerenciar_produtos") {
                        popUpTo("edit_product/$productId") { inclusive = true }
                    }
                }
            )
        }
        
        composable("manage_products") {
            // Redirecionar para a tela correta
            navController.navigate("gerenciar_produtos") {
                popUpTo("manage_products") { inclusive = true }
            }
        }

        composable("checkout") {
            val checkoutViewModel: com.taskgoapp.taskgo.feature.checkout.presentation.CheckoutViewModel = hiltViewModel()
            CheckoutScreen(
                onBackClick = { navController.popBackStack() },
                onAddressSelection = { 
                    navController.navigate("address_selection") {
                        // Garantir que o ViewModel seja compartilhado
                        launchSingleTop = true
                    }
                },
                onPaymentMethodSelection = { 
                    navController.navigate("payment_method_selection") {
                        launchSingleTop = true
                    }
                },
                onOrderSummary = { addressId, paymentType ->
                    val encodedAddress = Uri.encode(addressId)
                    navController.navigate("order_summary/$encodedAddress/${paymentType.name}")
                },
                viewModel = checkoutViewModel
            )
        }

        composable(
            route = "order_summary/{addressId}/{paymentType}",
            arguments = listOf(
                navArgument("addressId") { type = NavType.StringType },
                navArgument("paymentType") { type = NavType.StringType }
            )
        ) { backStackEntry ->
            val addressId = Uri.decode(backStackEntry.arguments?.getString("addressId").orEmpty())
            val paymentType = backStackEntry.arguments?.getString("paymentType").orEmpty()
            OrderSummaryScreen(
                onNavigateBack = { navController.popBackStack() },
                addressId = addressId,
                paymentTypeName = paymentType,
                onOrderFinished = { orderId, total, trackingCode ->
                    val trackingParam = Uri.encode(trackingCode)
                    navController.navigate(
                        "payment_success?orderId=$orderId&total=$total&tracking=$trackingParam"
                    ) {
                        popUpTo("checkout") { inclusive = false }
                    }
                },
                onNavigateToPix = { orderId, total ->
                    val encodedOrderId = Uri.encode(orderId)
                    navController.navigate("pix_payment/$encodedOrderId/$total") {
                        popUpTo("checkout") { inclusive = false }
                    }
                }
            )
        }

        // Varia√ß√µes de m√©todo de pagamento e finalizar pedido
        composable("payment_method_two_options") {
            // Para esta rota, criar um ViewModel tempor√°rio ou usar hiltViewModel
            val tempViewModel: com.taskgoapp.taskgo.feature.checkout.presentation.CheckoutViewModel = hiltViewModel()
            PaymentMethodScreen(
                onNavigateBack = { navController.popBackStack() },
                onPaymentMethodSelected = { methodName ->
                    when (methodName) {
                        "Cart√£o de Cr√©dito" -> navController.navigate("cartao_credito")
                        "Cart√£o de D√©bito" -> navController.navigate("cartao_debito")
                        else -> navController.popBackStack()
                    }
                },
                variant = "two_options",
                viewModel = tempViewModel
            )
        }

        // Checkout auxiliary routes
        composable("address_selection") {
            // Usar o mesmo ViewModel do checkout atrav√©s do navController
            val checkoutBackStackEntry = remember(navController) {
                navController.getBackStackEntry("checkout")
            }
            val checkoutViewModel: com.taskgoapp.taskgo.feature.checkout.presentation.CheckoutViewModel = 
                viewModel(checkoutBackStackEntry)
            AddressBookScreen(
                onNavigateBack = { navController.popBackStack() },
                onAddressSelected = { addressId ->
                    // A sele√ß√£o j√° foi salva no ViewModel pela AddressBookScreen
                    navController.popBackStack()
                },
                onAddAddress = { navController.navigate("add_address") },
                viewModel = checkoutViewModel
            )
        }

        composable("add_address") {
            CadastrarEnderecoScreen(
                onBackClick = { navController.popBackStack() },
                onSave = { navController.popBackStack() }
            )
        }

        composable("payment_method_selection") {
            // Usar o mesmo ViewModel do checkout atrav√©s do navController
            val checkoutBackStackEntry = remember(navController) {
                navController.getBackStackEntry("checkout")
            }
            val checkoutViewModel: com.taskgoapp.taskgo.feature.checkout.presentation.CheckoutViewModel = 
                viewModel(checkoutBackStackEntry)
            PaymentMethodScreen(
                onNavigateBack = { navController.popBackStack() },
                onPaymentMethodSelected = { methodName ->
                    // A sele√ß√£o j√° foi salva no ViewModel pela PaymentMethodScreen
                    when (methodName) {
                        "Pix" -> navController.popBackStack() // PIX n√£o precisa de tela adicional
                        "Cart√£o de Cr√©dito" -> navController.navigate("cartao_credito")
                        "Cart√£o de D√©bito" -> navController.navigate("cartao_debito")
                        "Google Pay" -> navController.popBackStack() // Google Pay j√° processado
                        else -> navController.popBackStack()
                    }
                },
                viewModel = checkoutViewModel
            )
        }

        // Optional PT-BR named routes for fidelity with Figma
        composable("forma_pagamento") {
            FormaPagamentoScreen(
                onBackClick = { navController.popBackStack() },
                onPix = { navController.navigate("pix_payment") },
                onCartaoCredito = { navController.navigate("cartao_credito") },
                onCartaoDebito = { navController.navigate("cartao_debito") }
            )
        }
        composable("forma_pagamento_pix_only") {
            FormaPagamentoScreen(
                onBackClick = { navController.popBackStack() },
                onPix = { navController.navigate("pix_payment") },
                onCartaoCredito = { navController.navigate("cartao_credito") },
                onCartaoDebito = { navController.navigate("cartao_debito") },
                variant = "pix_only"
            )
        }
        composable("finalizar_pedido") {
            FinalizarPedidoScreen(
                onBackClick = { navController.popBackStack() },
                onFinalizar = { navController.navigate("payment_success") }
            )
        }
        composable("finalizar_pedido_processing") {
            FinalizarPedidoScreen(
                onBackClick = { navController.popBackStack() },
                onFinalizar = { },
                variant = "processing"
            )
        }
        composable("finalizar_pedido_pending") {
            FinalizarPedidoScreen(
                onBackClick = { navController.popBackStack() },
                onFinalizar = { },
                variant = "pending"
            )
        }
        composable("finalizar_pedido_payment_error") {
            FinalizarPedidoScreen(
                onBackClick = { navController.popBackStack() },
                onFinalizar = { },
                variant = "payment_error"
            )
        }
        composable("finalizar_pedido_success") {
            FinalizarPedidoScreen(
                onBackClick = { navController.popBackStack() },
                onFinalizar = { },
                variant = "success"
            )
        }
        composable("confirmacao_pix") {
            ConfirmacaoPixScreen(onContinue = { navController.popBackStack() })
        }
        composable("cartao_credito") {
            CartaoCreditoScreen(onBackClick = { navController.popBackStack() })
        }
        composable("cartao_debito") {
            CartaoDebitoScreen(onBackClick = { navController.popBackStack() })
        }
        composable("cartao_credito_alt") {
            CartaoCreditoScreen(onBackClick = { navController.popBackStack() }, isAlt = true)
        }
        composable("cartao_debito_alt") {
            CartaoDebitoScreen(onBackClick = { navController.popBackStack() }, isAlt = true)
        }
        
        composable(
            route = "pix_payment/{orderId}/{total}",
            arguments = listOf(
                navArgument("orderId") { type = NavType.StringType },
                navArgument("total") { type = NavType.StringType }
            )
        ) { backStackEntry ->
            val orderId = Uri.decode(backStackEntry.arguments?.getString("orderId").orEmpty())
            val total = backStackEntry.arguments?.getString("total")?.toDoubleOrNull() ?: 0.0
            PixPaymentScreen(
                orderId = orderId,
                totalAmount = total,
                onPaymentSuccess = { 
                    navController.navigate("payment_success?orderId=$orderId&total=$total") {
                        popUpTo("checkout") { inclusive = false }
                    }
                },
                onBackClick = { navController.popBackStack() }
            )
        }
        composable(
            route = "pix_payment_waiting/{orderId}/{total}",
            arguments = listOf(
                navArgument("orderId") { type = NavType.StringType },
                navArgument("total") { type = NavType.StringType }
            )
        ) { backStackEntry ->
            val orderId = Uri.decode(backStackEntry.arguments?.getString("orderId").orEmpty())
            val total = backStackEntry.arguments?.getString("total")?.toDoubleOrNull() ?: 0.0
            PixPaymentScreen(
                orderId = orderId,
                totalAmount = total,
                onPaymentSuccess = { navController.navigate("payment_success?orderId=$orderId&total=$total") },
                onBackClick = { navController.popBackStack() },
                variant = "waiting"
            )
        }
        composable(
            route = "pix_payment_error/{orderId}/{total}",
            arguments = listOf(
                navArgument("orderId") { type = NavType.StringType },
                navArgument("total") { type = NavType.StringType }
            )
        ) { backStackEntry ->
            val orderId = Uri.decode(backStackEntry.arguments?.getString("orderId").orEmpty())
            val total = backStackEntry.arguments?.getString("total")?.toDoubleOrNull() ?: 0.0
            PixPaymentScreen(
                orderId = orderId,
                totalAmount = total,
                onPaymentSuccess = { navController.navigate("payment_success?orderId=$orderId&total=$total") },
                onBackClick = { navController.popBackStack() },
                variant = "error"
            )
        }
        composable(
            route = "pix_payment_success/{orderId}/{total}",
            arguments = listOf(
                navArgument("orderId") { type = NavType.StringType },
                navArgument("total") { type = NavType.StringType }
            )
        ) { backStackEntry ->
            val orderId = Uri.decode(backStackEntry.arguments?.getString("orderId").orEmpty())
            val total = backStackEntry.arguments?.getString("total")?.toDoubleOrNull() ?: 0.0
            PixPaymentScreen(
                orderId = orderId,
                totalAmount = total,
                onPaymentSuccess = { navController.navigate("payment_success?orderId=$orderId&total=$total") },
                onBackClick = { navController.popBackStack() },
                variant = "success"
            )
        }
        
        composable("card_details") {
            CardDetailsScreen(
                onPaymentSuccess = { navController.navigate("payment_success") },
                onBackClick = { navController.popBackStack() }
            )
        }

        composable(
            route = "payment_success?orderId={orderId}&total={total}&tracking={tracking}",
            arguments = listOf(
                navArgument("orderId") {
                    type = NavType.StringType
                    defaultValue = ""
                },
                navArgument("total") {
                    type = NavType.FloatType
                    defaultValue = 0f
                },
                navArgument("tracking") {
                    type = NavType.StringType
                    defaultValue = ""
                }
            )
        ) { backStackEntry ->
            val orderId = backStackEntry.arguments?.getString("orderId").orEmpty().ifBlank { "#TG-0000" }
            val total = backStackEntry.arguments?.getFloat("total")?.toDouble() ?: 0.0
            val tracking = backStackEntry.arguments?.getString("tracking").orEmpty()
            PaymentSuccessScreen(
                totalAmount = total,
                orderId = orderId,
                trackingCode = tracking,
                onContinue = {
                    navController.navigate("home") {
                        popUpTo(navController.graph.startDestinationId) { inclusive = false }
                        launchSingleTop = true
                    }
                }
            )
        }

        // Alternative order success variants
        composable("order_success/{orderId}") { backStackEntry ->
            val orderId = backStackEntry.arguments?.getString("orderId") ?: ""
            OrderSuccessScreen(
                orderId = orderId,
                totalAmount = 250.0,
                address = "", // Dados v√™m do Firestore
                onHome = {
                    navController.navigate("home") {
                        popUpTo(navController.graph.startDestinationId) { inclusive = false }
                        launchSingleTop = true
                    }
                },
                onViewOrder = { navController.navigate("order_detail/$orderId") }
            )
        }
        composable("order_success_pending/{orderId}") { backStackEntry ->
            val orderId = backStackEntry.arguments?.getString("orderId") ?: ""
            OrderSuccessScreen(
                orderId = orderId,
                totalAmount = 250.0,
                address = "", // Dados v√™m do Firestore
                onHome = { navController.navigate("home") },
                onViewOrder = { navController.navigate("order_detail/$orderId") },
                variant = "pending"
            )
        }
        composable("order_success_error/{orderId}") { backStackEntry ->
            val orderId = backStackEntry.arguments?.getString("orderId") ?: ""
            OrderSuccessScreen(
                orderId = orderId,
                totalAmount = 250.0,
                address = "", // Dados v√™m do Firestore
                onHome = { navController.navigate("home") },
                onViewOrder = { navController.navigate("order_detail/$orderId") },
                variant = "error"
            )
        }

        // Rotas de servi√ßos
        composable("service_detail/{serviceId}") { backStackEntry ->
            val serviceId = backStackEntry.arguments?.getString("serviceId") ?: ""
            DetalhesServicoScreen(
                serviceId = serviceId,
                onBackClick = { 
                    // Tentar voltar, se n√£o conseguir, navegar para services
                    if (!navController.popBackStack()) {
                        navController.navigate("services") {
                            popUpTo(navController.graph.startDestinationId) { inclusive = false }
                            launchSingleTop = true
                        }
                    }
                },
                onEditService = { serviceId ->
                    navController.navigate("service_form/$serviceId")
                },
                onNavigateToReviews = { targetId ->
                    navController.navigate("reviews/$targetId/SERVICE")
                },
                onNavigateToProviderProfile = { providerId ->
                    navController.navigate("user_profile/$providerId")
                },
                onNavigateToChat = { threadId ->
                    navController.navigate("chat/$threadId")
                }
            )
        }

        composable("create_work_order") {
            CreateWorkOrderScreen(
                onBackClick = { navController.popBackStack() },
                onWorkOrderCreated = { navController.navigate("minhas_ordens_servico") {
                    popUpTo("services") { inclusive = false }
                }},
                onNavigateToIdentityVerification = { navController.navigate("identity_verification") }
            )
        }
        
        composable("proposals_received") {
            val proposalsViewModel: ProposalsViewModel = hiltViewModel()
            ProposalsReceivedScreen(
                onBackClick = { navController.popBackStack() },
                onProposalClick = { proposalId -> navController.navigate("proposal_detail/$proposalId") },
                onAcceptProposal = { proposalId -> 
                    proposalsViewModel.acceptProposal(proposalId)
                    navController.popBackStack()
                },
                onRejectProposal = { proposalId -> 
                    proposalsViewModel.rejectProposal(proposalId)
                    navController.popBackStack()
                }
            )
        }
        
        composable("proposal_detail/{proposalId}") { backStackEntry ->
            val proposalId = backStackEntry.arguments?.getString("proposalId") ?: ""
            val proposalsViewModel: ProposalsViewModel = hiltViewModel()
            ProposalDetailScreen(
                proposalId = proposalId,
                onBackClick = { navController.popBackStack() },
                onAcceptProposal = { proposalId -> 
                    proposalsViewModel.acceptProposal(proposalId)
                    navController.popBackStack()
                },
                onRejectProposal = { proposalId -> 
                    proposalsViewModel.rejectProposal(proposalId)
                    navController.popBackStack()
                }
            )
        }
        
        composable("service_history") {
            ServiceHistoryScreen(
                onBackClick = { navController.popBackStack() },
                onServiceClick = { serviceId -> navController.navigate("service_detail/$serviceId") },
                onRateService = { serviceId -> navController.navigate("rate_provider/$serviceId") }
            )
        }
        // Legacy/alternate services routes
        composable("historico_servicos") {
            HistoricoServicosScreen(
                onBackClick = { navController.popBackStack() },
                onVerDetalhes = { id -> navController.navigate("service_detail/$id") }
            )
        }
        composable("avaliar_prestador/{serviceId}") { _ ->
            AvaliarPrestadorScreen(
                onBackClick = { navController.popBackStack() }
            )
        }
        
        composable("rate_provider/{serviceId}") { backStackEntry ->
            val serviceId = backStackEntry.arguments?.getString("serviceId") ?: ""
            val createReviewViewModel: com.taskgoapp.taskgo.feature.reviews.presentation.CreateReviewViewModel = hiltViewModel()
            val orderDetailViewModel: com.taskgoapp.taskgo.feature.services.presentation.ServiceOrderDetailViewModel = hiltViewModel()
            
            // Tentar buscar como ordem primeiro
            LaunchedEffect(serviceId) {
                orderDetailViewModel.loadOrder(serviceId)
            }
            
            val orderState by orderDetailViewModel.uiState.collectAsStateWithLifecycle()
            val providerName = orderState.order?.providerId ?: "Prestador"
            val serviceTitle = orderState.order?.details ?: "Servi√ßo"
            val providerId = orderState.order?.providerId ?: serviceId
            val orderId = if (orderState.order != null) serviceId else null
            
            LaunchedEffect(providerId, orderId) {
                createReviewViewModel.initialize(
                    targetId = providerId,
                    type = com.taskgoapp.taskgo.core.model.ReviewType.PROVIDER,
                    orderId = orderId
                )
            }
            
            RateProviderScreen(
                providerName = providerName,
                serviceTitle = serviceTitle,
                onBackClick = { navController.popBackStack() },
                onRatingSubmitted = { rating, comment -> 
                    createReviewViewModel.createReview(rating, comment)
                    navController.popBackStack()
                }
            )
        }

        composable("proposals_inbox") {
            GerenciarPropostasScreen(
                onBackClick = { navController.popBackStack() },
                onVerProposta = { proposalId -> 
                    navController.navigate("proposal_detail/$proposalId")
                }
            )
        }

        // Fluxo de proposta: confirmar e detalhes com varia√ß√µes
        composable("confirmar_proposta") {
            ConfirmarPropostaScreen(
                onBackClick = { navController.popBackStack() },
                onConfirmar = { navController.popBackStack() }
            )
        }
        composable("confirmar_proposta_pendente") {
            ConfirmarPropostaScreen(
                onBackClick = { navController.popBackStack() },
                onConfirmar = { navController.popBackStack() },
                variant = "pendente"
            )
        }
        composable("confirmar_proposta_aceita") {
            ConfirmarPropostaScreen(
                onBackClick = { navController.popBackStack() },
                onConfirmar = { navController.popBackStack() },
                variant = "aceita"
            )
        }
        composable("confirmar_proposta_recusada") {
            ConfirmarPropostaScreen(
                onBackClick = { navController.popBackStack() },
                onConfirmar = { navController.popBackStack() },
                variant = "recusada"
            )
        }
        composable("confirmar_proposta_erro") {
            ConfirmarPropostaScreen(
                onBackClick = { navController.popBackStack() },
                onConfirmar = { navController.popBackStack() },
                variant = "erro"
            )
        }
        composable("confirmar_proposta_sucesso") {
            ConfirmarPropostaScreen(
                onBackClick = { navController.popBackStack() },
                onConfirmar = { navController.popBackStack() },
                variant = "sucesso"
            )
        }

        composable("detalhes_proposta/{propostaId}") { backStackEntry ->
            val propostaId = backStackEntry.arguments?.getString("propostaId") ?: ""
            DetalhesPropostaScreen(
                propostaId = propostaId,
                onBackClick = { navController.popBackStack() },
                onConfirmar = { navController.popBackStack() }
            )
        }
        composable("detalhes_proposta_aceita/{propostaId}") { backStackEntry ->
            val propostaId = backStackEntry.arguments?.getString("propostaId") ?: ""
            DetalhesPropostaScreen(
                propostaId = propostaId,
                onBackClick = { navController.popBackStack() },
                onConfirmar = { navController.popBackStack() },
                variant = "aceita"
            )
        }
        composable("detalhes_proposta_recusada/{propostaId}") { backStackEntry ->
            val propostaId = backStackEntry.arguments?.getString("propostaId") ?: ""
            DetalhesPropostaScreen(
                propostaId = propostaId,
                onBackClick = { navController.popBackStack() },
                onConfirmar = { navController.popBackStack() },
                variant = "recusada"
            )
        }
        composable("detalhes_proposta_pendente/{propostaId}") { backStackEntry ->
            val propostaId = backStackEntry.arguments?.getString("propostaId") ?: ""
            DetalhesPropostaScreen(
                propostaId = propostaId,
                onBackClick = { navController.popBackStack() },
                onConfirmar = { navController.popBackStack() },
                variant = "pendente"
            )
        }
        composable("detalhes_proposta_erro/{propostaId}") { backStackEntry ->
            val propostaId = backStackEntry.arguments?.getString("propostaId") ?: ""
            DetalhesPropostaScreen(
                propostaId = propostaId,
                onBackClick = { navController.popBackStack() },
                onConfirmar = { navController.popBackStack() },
                variant = "erro"
            )
        }

        // Rotas de an√∫ncios - Removidas: anuncios e anuncio_detalhe n√£o s√£o mais usadas
        // A navega√ß√£o vai direto para comprar_banner
        
        composable("comprar_banner") {
            ComprarBannerScreen(
                onBackClick = { navController.popBackStack() },
                onConfirmarCompra = { _ -> navController.popBackStack() }
            )
        }

        // Ads variants - Removidas: variantes de anuncios n√£o s√£o mais usadas
        composable("comprar_banner_disabled") {
            ComprarBannerScreen(
                onBackClick = { navController.popBackStack() },
                onConfirmarCompra = { },
                variant = "disabled"
            )
        }

        // Rotas de notifica√ß√µes
        composable("notifications") {
            NotificationsScreen(
                onBackClick = { navController.popBackStack() },
                onNavigateToNotificationsSettings = { navController.navigate("notification_settings") },
                onNotificationClick = { notificationId ->
                    navController.navigate("notification_detail/$notificationId")
                }
            )
        }
        composable("notifications_empty") {
            NotificationsScreen(
                onBackClick = { navController.popBackStack() },
                onNavigateToNotificationsSettings = { navController.navigate("notification_settings") },
                onNotificationClick = { notificationId -> navController.navigate("notification_detail/$notificationId") },
                variant = "empty"
            )
        }
        composable("notifications_unread") {
            NotificationsScreen(
                onBackClick = { navController.popBackStack() },
                onNavigateToNotificationsSettings = { navController.navigate("notification_settings") },
                onNotificationClick = { notificationId -> navController.navigate("notification_detail/$notificationId") },
                variant = "unread"
            )
        }
        composable("notifications_settings_mode") {
            NotificationsScreen(
                onBackClick = { navController.popBackStack() },
                onNavigateToNotificationsSettings = { navController.navigate("notification_settings") },
                onNotificationClick = { notificationId -> navController.navigate("notification_detail/$notificationId") },
                variant = "settings"
            )
        }

        composable("notification_detail/{notificationId}") { backStackEntry ->
            val notificationId = backStackEntry.arguments?.getString("notificationId") ?: ""
            NotificationDetailScreen(
                notificationId = notificationId,
                title = "Atualiza√ß√£o",
                message = "Seu pedido foi despachado e est√° a caminho.",
                timestamp = "Hoje, 08:12",
                onBackClick = { navController.popBackStack() }
            )
        }


        // Rotas de configura√ß√µes
        composable("configuracoes") {
            ConfiguracoesScreen(
                onBackClick = { navController.popBackStack() },
                onConta = { navController.navigate("account") },
                onPreferencias = { navController.navigate("preferences") },
                onNotificacoes = { navController.navigate("notification_settings") },
                onIdioma = { /* Idioma desativado */ },
                onPrivacidade = { navController.navigate("privacy") },
                onSuporte = { navController.navigate("support") },
                onSobre = { navController.navigate("about") },
                onAiSupport = { navController.navigate("ai_support") },
                onSeguranca = { navController.navigate("security_settings") }
            )
        }

        // Settings routes
        composable("account") { 
            AccountScreen(
                onBackClick = { navController.popBackStack() },
                onNavigateToLogin = {
                    navController.navigate("login_person") {
                        popUpTo(navController.graph.startDestinationId) { inclusive = true }
                        launchSingleTop = true
                    }
                },
                onNavigateToBankAccounts = { navController.navigate("bank_accounts") }
            ) 
        }
        composable("bank_accounts") {
            com.taskgoapp.taskgo.feature.settings.presentation.BankAccountScreen(
                onBackClick = { navController.popBackStack() },
                onEditAccount = { accountId ->
                    navController.navigate("edit_bank_account/$accountId")
                }
            )
        }
        
        composable("edit_bank_account/{accountId}") { backStackEntry ->
            val accountId = backStackEntry.arguments?.getString("accountId") ?: ""
            com.taskgoapp.taskgo.feature.settings.presentation.EditBankAccountScreen(
                accountId = accountId,
                onBackClick = { navController.popBackStack() }
            )
        }
        composable("security_settings") {
            SecuritySettingsScreen(
                onBackClick = { navController.popBackStack() },
                onNavigateToIdentityVerification = { navController.navigate("identity_verification") },
                onNavigateToConsentHistory = { navController.navigate("consent_history") },
                onNavigateToLogin = {
                    // Navegar para login e limpar o back stack
                    navController.navigate("login_person") {
                        popUpTo(navController.graph.startDestinationId) { inclusive = true }
                        launchSingleTop = true
                    }
                }
            )
        }
        composable("preferences") {
            PreferencesScreen(
                onBackClick = { navController.popBackStack() },
                onSaveChanges = { navController.popBackStack() }
            )
        }
        composable("notification_settings") {
            NotificationsSettingsScreen(onNavigateBack = { navController.popBackStack() })
        }
        // Idioma desativado - rota removida
        // composable("language") {
        //     LanguageScreen(
        //         onBackClick = { navController.popBackStack() },
        //         onLogout = { /* no-op */ }
        //     )
        // }
        composable("privacy") { 
            PrivacyScreen(
                onBackClick = { navController.popBackStack() },
                onNavigateToPrivacyPolicy = { navController.navigate("privacy_policy") },
                onNavigateToTermsOfService = { navController.navigate("terms_of_service") },
                onNavigateToConsentHistory = { navController.navigate("consent_history") }
            ) 
        }
        composable("support") { SupportScreen(onBackClick = { navController.popBackStack() }) }
        composable("about") { 
            AboutScreen(
                onBackClick = { navController.popBackStack() },
                onNavigateToPrivacyPolicy = { navController.navigate("privacy_policy") },
                onNavigateToTermsOfService = { navController.navigate("terms_of_service") }
            ) 
        }
        composable("privacy_policy") {
            PrivacyPolicyScreen(onBackClick = { navController.popBackStack() })
        }
        composable("terms_of_service") {
            TermsOfServiceScreen(onBackClick = { navController.popBackStack() })
        }
        composable("consent_history") {
            ConsentHistoryScreen(
                onBackClick = { navController.popBackStack() }
            )
        }

        // Legacy/alternate settings routes
        composable("alterar_senha") { AlterarSenhaScreen(onBackClick = { navController.popBackStack() }) }
        composable("privacidade_alt") { PrivacidadeScreen(onBackClick = { navController.popBackStack() }) }
        composable("sobre_alt") { SobreScreen(onBackClick = { navController.popBackStack() }) }
        composable("suporte_alt") {
            SuporteScreen(
                onBackClick = { navController.popBackStack() },
                onChatAi = { navController.navigate("ai_support") },
                onSobre = { navController.navigate("about") }
            )
        }
        composable("settings_legacy") {
            SettingsScreen(
                onNavigateToAccount = { navController.navigate("account") },
                onNavigateToPreferences = { navController.navigate("preferences") },
                onNavigateToNotifications = { navController.navigate("notification_settings") },
                onNavigateToLanguage = { /* Idioma desativado temporariamente */ },
                onNavigateToPrivacy = { navController.navigate("privacy") },
                onNavigateToSupport = { navController.navigate("support") },
                onNavigateToAbout = { navController.navigate("about") },
                onNavigateToAiSupport = { navController.navigate("ai_support") },
                onNavigateToSecurity = { navController.navigate("security_settings") }
            )
        }

        // Messages
        composable("chat/{chatId}") { backStackEntry ->
            val chatId = backStackEntry.arguments?.getString("chatId") ?: ""
            ChatScreen(
                threadId = chatId,
                onNavigateBack = { navController.popBackStack() }
            )
        }
        
        composable("chat_for_order/{orderId}") { backStackEntry ->
            val orderId = backStackEntry.arguments?.getString("orderId") ?: ""
            // Composable helper que obt√©m/cria thread e navega para chat
            OrderChatNavigationScreen(
                orderId = orderId,
                onNavigateToChat = { threadId ->
                    navController.navigate("chat/$threadId") {
                        popUpTo("chat_for_order/$orderId") { inclusive = true }
                    }
                },
                onNavigateBack = { navController.popBackStack() }
            )
        }

        // Profile subroutes
        composable("meus_servicos") {
            MeusServicosScreen(
                onBackClick = { navController.popBackStack() },
                onCriarServico = { navController.navigate("service_form") },
                onEditarServico = { serviceId -> navController.navigate("service_form/$serviceId") },
                onViewService = { serviceId -> navController.navigate("service_detail/$serviceId") },
                onOrderClick = { orderId -> navController.navigate("service_order_detail/$orderId") }
            )
        }
        
        composable("minhas_ordens_servico") {
            MyServiceOrdersScreen(
                onBackClick = { navController.popBackStack() },
                onEditOrder = { orderId -> navController.navigate("create_work_order?orderId=$orderId") },
                onCreateOrder = { navController.navigate("create_work_order") }
            )
        }
        
        composable("service_form") {
            ServiceFormScreen(
                serviceId = null,
                onBack = { navController.popBackStack() },
                onSaved = { 
                    navController.navigate("meus_servicos") {
                        popUpTo("home") { inclusive = false }
                    }
                }
            )
        }
        
        composable("service_form/{serviceId}") { backStackEntry ->
            val serviceId = backStackEntry.arguments?.getString("serviceId") ?: ""
            ServiceFormScreen(
                serviceId = serviceId,
                onBack = { navController.popBackStack() },
                onSaved = { navController.popBackStack() }
            )
        }
        composable("meus_produtos") {
            MeusProdutosScreen(
                onBackClick = { navController.popBackStack() },
                onCriarProduto = { navController.navigate("create_product") },
                onEditarProduto = { productId -> navController.navigate("edit_product/$productId") }
            )
        }

        // Misc routes
        composable("product_form") {
            ProductFormScreen(
                productId = null,
                onBack = { navController.popBackStack() },
                onSaved = { _ -> navController.navigate("gerenciar_produtos") }
            )
        }

        composable("ads_alt") { AdsScreen(onBackClick = { navController.popBackStack() }) }
        composable("ai_support") {
            val chatListViewModel: com.taskgoapp.taskgo.feature.chatai.presentation.ChatListViewModel = hiltViewModel()
            ChatListScreen(
                onBackClick = { navController.popBackStack() },
                onChatClick = { chatId ->
                    navController.navigate("ai_chat/$chatId")
                },
                viewModel = chatListViewModel
            )
        }
        composable("ai_chat/{chatId}") { backStackEntry ->
            val chatId = backStackEntry.arguments?.getString("chatId") ?: ""
            val chatListViewModel: com.taskgoapp.taskgo.feature.chatai.presentation.ChatListViewModel = hiltViewModel()
            AiSupportScreen(
                chatId = chatId,
                onBackClick = { navController.popBackStack() },
                onChatUpdated = { id, message, isFirstMessage ->
                    chatListViewModel.updateChatLastMessage(id, message, isFirstMessage)
                }
            )
        }

        // Rotas de pedidos
        composable("meus_pedidos") {
            MeusPedidosScreen(
                onBackClick = { navController.popBackStack() },
                onOrderClick = { orderId -> 
                    navController.navigate("order_detail/$orderId")
                },
                onNavigateToCreateReview = { targetId, type, orderId ->
                    if (orderId != null) {
                        navController.navigate("create_review/$targetId/$type/$orderId")
                    } else {
                        navController.navigate("create_review/$targetId/$type")
                    }
                }
            )
        }

        composable("order_detail/{orderId}") { backStackEntry ->
            val orderId = backStackEntry.arguments?.getString("orderId") ?: ""
            DetalhesPedidoScreen(
                orderId = orderId,
                onBackClick = { navController.popBackStack() },
                onRastrearPedido = { navController.navigate("order_tracking_legacy/$it") },
                onVerResumo = { id -> navController.navigate("order_summary_alt/$id") },
                onEnviarPedido = { navController.navigate("shipment/$it") } // Para vendedores
            )
        }
        composable("order_detail_pending/{orderId}") { backStackEntry ->
            val orderId = backStackEntry.arguments?.getString("orderId") ?: ""
            DetalhesPedidoScreen(
                orderId = orderId,
                onBackClick = { navController.popBackStack() },
                onRastrearPedido = { navController.navigate("order_tracking/$orderId") },
                onVerResumo = { id -> navController.navigate("order_summary_alt/$id") },
                variant = "pending"
            )
        }
        composable("order_detail_canceled/{orderId}") { backStackEntry ->
            val orderId = backStackEntry.arguments?.getString("orderId") ?: ""
            DetalhesPedidoScreen(
                orderId = orderId,
                onBackClick = { navController.popBackStack() },
                onRastrearPedido = { },
                onVerResumo = { },
                variant = "canceled"
            )
        }

        composable("order_tracking/{orderId}") { backStackEntry ->
            val orderId = backStackEntry.arguments?.getString("orderId") ?: ""
            RastreamentoPedidoScreen(
                orderId = orderId,
                onBackClick = { navController.popBackStack() },
                onVerDetalhes = { id -> navController.navigate("order_detail/$id") }
            )
        }
        composable("order_tracking_delivered/{orderId}") { backStackEntry ->
            val orderId = backStackEntry.arguments?.getString("orderId") ?: ""
            RastreamentoPedidoScreen(
                orderId = orderId,
                onBackClick = { navController.popBackStack() },
                onVerDetalhes = { id -> navController.navigate("order_detail/$id") },
                variant = "delivered"
            )
        }
        composable("order_tracking_delayed/{orderId}") { backStackEntry ->
            val orderId = backStackEntry.arguments?.getString("orderId") ?: ""
            RastreamentoPedidoScreen(
                orderId = orderId,
                onBackClick = { navController.popBackStack() },
                onVerDetalhes = { id -> navController.navigate("order_detail/$id") },
                variant = "delayed"
            )
        }
        composable("order_tracking_canceled/{orderId}") { backStackEntry ->
            val orderId = backStackEntry.arguments?.getString("orderId") ?: ""
            RastreamentoPedidoScreen(
                orderId = orderId,
                onBackClick = { navController.popBackStack() },
                onVerDetalhes = { id -> navController.navigate("order_detail/$id") },
                variant = "canceled"
            )
        }

        composable("order_summary_alt/{orderId}") { backStackEntry ->
            val orderId = backStackEntry.arguments?.getString("orderId") ?: ""
            ResumoPedidoScreen(
                orderId = orderId,
                onBackClick = { navController.popBackStack() },
                onIrParaPedidos = { navController.navigate("meus_pedidos") }
            )
        }
        composable("order_summary_discount/{orderId}") { backStackEntry ->
            val orderId = backStackEntry.arguments?.getString("orderId") ?: ""
            ResumoPedidoScreen(
                orderId = orderId,
                onBackClick = { navController.popBackStack() },
                onIrParaPedidos = { navController.navigate("meus_pedidos") },
                variant = "discount"
            )
        }
        composable("order_summary_voucher/{orderId}") { backStackEntry ->
            val orderId = backStackEntry.arguments?.getString("orderId") ?: ""
            ResumoPedidoScreen(
                orderId = orderId,
                onBackClick = { navController.popBackStack() },
                onIrParaPedidos = { navController.navigate("meus_pedidos") },
                variant = "voucher"
            )
        }

        composable("my_orders_in_progress") {
            MyOrdersInProgressScreen(
                onBackClick = { navController.popBackStack() },
                onOrderClick = { orderId -> navController.navigate("order_detail/$orderId") }
            )
        }

        composable("my_orders_completed") {
            MyOrdersCompletedScreen(
                onBackClick = { navController.popBackStack() },
                onOrderClick = { orderId -> navController.navigate("order_detail/$orderId") }
            )
        }

        composable("my_orders_canceled") {
            MyOrdersCanceledScreen(
                onBackClick = { navController.popBackStack() },
                onOrderClick = { orderId -> navController.navigate("order_detail/$orderId") }
            )
        }

        // Legacy product/checkout routes for compatibility with existing files
        composable("carrinho_legacy") {
            CarrinhoScreen(
                onBackClick = { navController.popBackStack() },
                onContinuar = { navController.navigate("checkout_legacy") }
            )
        }
        composable("detalhes_produto_legacy/{productId}") { _ ->
            DetalhesProdutoScreen(
                onBackClick = { navController.popBackStack() },
                onAdicionarCarrinho = { navController.navigate("cart") }
            )
        }
        composable("editar_produto_legacy/{productId}") { _ ->
            EditarProdutoScreen(
                onBackClick = { navController.popBackStack() }
            )
        }
        composable("gerenciar_produtos") {
            MeusProdutosScreen(
                onBackClick = { navController.popBackStack() },
                onCriarProduto = { navController.navigate("create_product") },
                onEditarProduto = { id -> navController.navigate("edit_product/$id") }
            )
        }
        composable("order_tracking_legacy/{orderId}") { backStackEntry ->
            val orderId = backStackEntry.arguments?.getString("orderId") ?: ""
            OrderTrackingScreen(
                orderId = orderId,
                onNavigateBack = { navController.popBackStack() }
            )
        }
        composable("shipment/{orderId}") { backStackEntry ->
            val orderId = backStackEntry.arguments?.getString("orderId") ?: ""
            com.taskgoapp.taskgo.feature.orders.presentation.ShipmentScreen(
                orderId = orderId,
                onBackClick = { navController.popBackStack() },
                onShipmentConfirmed = { navController.popBackStack() }
            )
        }
        composable("checkout_legacy") {
            CheckoutScreenLegacy(
                onBackClick = { navController.popBackStack() },
                onAddressSelection = { navController.navigate("address_selection") },
                onPaymentMethodSelection = { navController.navigate("payment_method_selection") },
                onOrderSummary = { navController.navigate("order_summary") }
            )
        }
    }
}
```

## [FRONTEND]: TaskGoApp.kt

```kotlin
package com.taskgoapp.taskgo

import android.app.Application
import android.util.Log
import androidx.hilt.work.HiltWorkerFactory
import androidx.work.Configuration
import javax.inject.Inject
import com.google.firebase.FirebaseApp
import com.google.firebase.appcheck.FirebaseAppCheck
import com.google.firebase.appcheck.debug.DebugAppCheckProviderFactory
import com.google.firebase.appcheck.playintegrity.PlayIntegrityAppCheckProviderFactory
import com.google.firebase.crashlytics.FirebaseCrashlytics
import com.taskgoapp.taskgo.BuildConfig
import dagger.hilt.android.HiltAndroidApp
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.launch

@HiltAndroidApp
class TaskGoApp : Application(), Configuration.Provider {
    
    private val applicationScope = CoroutineScope(SupervisorJob() + Dispatchers.IO)
    
    @Inject
    lateinit var workerFactory: HiltWorkerFactory

    override fun onCreate() {
        super.onCreate()
        Log.d(TAG, "WorkManager configurado com HiltWorkerFactory")
        
        Log.d(TAG, "Inicializando TaskGoApp...")
        Log.d(TAG, "BuildConfig.USE_EMULATOR: ${BuildConfig.USE_EMULATOR}")
        Log.d(TAG, "BuildConfig.DEBUG: ${BuildConfig.DEBUG}")
        
        // Diagnosticar conectividade de rede
        Log.d(TAG, "=== DIAGN√ìSTICO DE REDE ===")
        applicationScope.launch {
            try {
                val diagnostic = com.taskgoapp.taskgo.core.network.NetworkDiagnostic.diagnose(this@TaskGoApp)
                Log.d(TAG, "Resultado do diagn√≥stico: ${diagnostic}")
                if (!diagnostic.isHealthy) {
                    Log.e(TAG, "‚ö†Ô∏è PROBLEMA DE CONECTIVIDADE DETECTADO:")
                    Log.e(TAG, "   - Internet: ${diagnostic.hasInternet}")
                    Log.e(TAG, "   - Firebase: ${diagnostic.canReachFirebase}")
                    Log.e(TAG, "   - Google: ${diagnostic.canReachGoogle}")
                    Log.e(TAG, "   - reCAPTCHA: ${diagnostic.canReachRecaptcha}")
                    Log.e(TAG, "   - Erro: ${diagnostic.error ?: "N/A"}")
                    Log.e(TAG, "üìã Consulte DIAGNOSTICO_CONECTIVIDADE.md para resolver")
                } else {
                    Log.d(TAG, "‚úÖ Conectividade OK")
                }
            } catch (e: Exception) {
                Log.e(TAG, "Erro ao diagnosticar rede: ${e.message}", e)
            }
        }
        
        // Initialize Firebase - CR√çTICO: Deve ser a primeira coisa
        try {
            // Firebase √© inicializado automaticamente pelo google-services.json
            // Apenas verificar se est√° inicializado
            val firebaseApp = FirebaseApp.getInstance()
            
            Log.d(TAG, "‚úÖ Firebase inicializado com sucesso")
            Log.d(TAG, "Firebase Project ID: ${firebaseApp.options.projectId}")
            Log.d(TAG, "Firebase Application ID: ${firebaseApp.options.applicationId}")
            
            // Initialize Firebase Crashlytics
            val crashlytics = FirebaseCrashlytics.getInstance()
            crashlytics.setCrashlyticsCollectionEnabled(!BuildConfig.DEBUG)
            if (BuildConfig.DEBUG) {
                Log.d(TAG, "Crashlytics desabilitado em modo DEBUG")
            } else {
                Log.d(TAG, "Crashlytics habilitado para produ√ß√£o")
            }
            
            // Garantir que Firebase Auth est√° pronto
            try {
                val auth = com.google.firebase.auth.FirebaseAuth.getInstance()
                Log.d(TAG, "‚úÖ Firebase Auth inicializado")
            } catch (e: Exception) {
                Log.e(TAG, "‚ùå Erro ao inicializar Firebase Auth: ${e.message}", e)
            }
            
            // Validar configura√ß√µes do Firebase em background (n√£o bloqueia)
            applicationScope.launch {
                try {
                    val validation = com.taskgoapp.taskgo.core.firebase.FirebaseConfigValidator.validate(this@TaskGoApp)
                    if (!validation.isValid) {
                        Log.e(TAG, "‚ö†Ô∏è CONFIGURA√á√ïES DO FIREBASE INV√ÅLIDAS!")
                        Log.e(TAG, "Consulte VERIFICACAO_FIREBASE_CONFIG.md para resolver")
                    }
                } catch (e: Exception) {
                    Log.e(TAG, "Erro ao validar configura√ß√µes do Firebase: ${e.message}", e)
                }
            }
        } catch (e: IllegalStateException) {
            // Firebase n√£o inicializado - tentar inicializar manualmente
            Log.e(TAG, "Firebase n√£o inicializado, tentando inicializar manualmente...")
            try {
                FirebaseApp.initializeApp(this)
                Log.d(TAG, "‚úÖ Firebase inicializado manualmente")
            } catch (initError: Exception) {
                Log.e(TAG, "‚ùå ERRO CR√çTICO: N√£o foi poss√≠vel inicializar Firebase: ${initError.message}", initError)
            }
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Erro ao inicializar Firebase: ${e.message}", e)
        }
        
        // Initialize Firebase App Check
        if (BuildConfig.FIREBASE_APP_CHECK_ENABLED) {
            try {
                val appCheck = FirebaseAppCheck.getInstance()
                
                if (BuildConfig.DEBUG) {
                    // Para builds de debug, usar DebugAppCheckProviderFactory
                    val debugToken = BuildConfig.FIREBASE_DEBUG_APP_CHECK_TOKEN
                    val debugTokenName = BuildConfig.FIREBASE_DEBUG_APP_CHECK_TOKEN_NAME
                    if (debugToken.isNotBlank()) {
                        val persistenceKey = FirebaseApp.getInstance().persistenceKey
                        val sharedPrefsName = "com.google.firebase.appcheck.debug.store.$persistenceKey"
                        val debugSecretKey = "com.google.firebase.appcheck.debug.DEBUG_SECRET"

                        getSharedPreferences(sharedPrefsName, MODE_PRIVATE)
                            .edit()
                            .putString(debugSecretKey, debugToken)
                            .apply()

                        Log.d(TAG, "‚úÖ App Check DEBUG configurado com token: ${debugTokenName}")
                    }

                    appCheck.installAppCheckProviderFactory(
                        DebugAppCheckProviderFactory.getInstance()
                    )
                } else {
                    // Para builds de release, usar Play Integrity
                    Log.d(TAG, "=== CONFIGURANDO APP CHECK RELEASE ===")
                    Log.d(TAG, "Provider: PlayIntegrityAppCheckProviderFactory")
                    
                    try {
                        appCheck.installAppCheckProviderFactory(
                            PlayIntegrityAppCheckProviderFactory.getInstance()
                        )
                        Log.d(TAG, "‚úÖ Play Integrity Provider instalado")
                        
                        // Tentar obter token para verificar se est√° funcionando
                        applicationScope.launch {
                            kotlinx.coroutines.delay(5000) // Aguardar 5 segundos para Play Integrity inicializar
                            try {
                                appCheck.getAppCheckToken(false).addOnSuccessListener { token ->
                                    Log.d(TAG, "‚úÖ App Check token obtido com sucesso (Play Integrity)")
                                    Log.d(TAG, "Token (primeiros 20 chars): ${token.token.take(20)}...")
                                    Log.d(TAG, "Token expira em: ${token.expireTimeMillis - System.currentTimeMillis()}ms")
                                }.addOnFailureListener { e ->
                                    Log.e(TAG, "‚ùå FALHA AO OBTER APP CHECK TOKEN")
                                    Log.e(TAG, "Erro: ${e.message}")
                                    Log.e(TAG, "Tipo: ${e.javaClass.simpleName}")
                                    
                                    // An√°lise detalhada do erro
                                    val errorMessage = e.message ?: ""
                                    when {
                                        errorMessage.contains("403", ignoreCase = true) ||
                                        errorMessage.contains("App attestation failed", ignoreCase = true) ||
                                        errorMessage.contains("attestation", ignoreCase = true) -> {
                                            Log.e(TAG, "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
                                            Log.e(TAG, "ERRO CR√çTICO: App Attestation Failed (403)")
                                            Log.e(TAG, "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
                                            Log.e(TAG, "CAUSA PRINCIPAL: SHA-256 do App Signing Key n√£o cadastrado")
                                            Log.e(TAG, "")
                                            Log.e(TAG, "SOLU√á√ÉO:")
                                            Log.e(TAG, "1. Acesse Google Play Console ‚Üí App Signing")
                                            Log.e(TAG, "2. Copie o SHA-256 do 'App signing certificate'")
                                            Log.e(TAG, "3. Firebase Console ‚Üí Configura√ß√µes do Projeto ‚Üí Android App")
                                            Log.e(TAG, "4. Adicione o SHA-256 do App Signing Key")
                                            Log.e(TAG, "5. Aguarde 5-10 minutos para propaga√ß√£o")
                                            Log.e(TAG, "")
                                            Log.e(TAG, "IMPORTANTE: Use o SHA-256 do App Signing Key,")
                                            Log.e(TAG, "N√ÉO o SHA-256 do Upload Key!")
                                            Log.e(TAG, "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
                                        }
                                        errorMessage.contains("API", ignoreCase = true) &&
                                        errorMessage.contains("not", ignoreCase = true) -> {
                                            Log.e(TAG, "CAUSA: Play Integrity API n√£o habilitada")
                                            Log.e(TAG, "SOLU√á√ÉO: Habilitar Play Integrity API no Google Cloud Console")
                                        }
                                        errorMessage.contains("network", ignoreCase = true) ||
                                        errorMessage.contains("connection", ignoreCase = true) -> {
                                            Log.e(TAG, "CAUSA: Problema de rede")
                                            Log.e(TAG, "SOLU√á√ÉO: Verificar conectividade")
                                        }
                                        else -> {
                                            Log.e(TAG, "CAUSA DESCONHECIDA - Verificar logs completos")
                                            Log.e(TAG, "Stack trace:", e)
                                        }
                                    }
                                }
                            } catch (e: Exception) {
                                Log.e(TAG, "Erro ao verificar token: ${e.message}", e)
                            }
                        }
                    } catch (e: Exception) {
                        Log.e(TAG, "‚ùå ERRO ao instalar Play Integrity Provider: ${e.message}", e)
                        throw e
                    }
                    
                    Log.d(TAG, "‚úÖ App Check RELEASE configurado com Play Integrity")
                }
                
                Log.d(TAG, "‚úÖ Firebase App Check inicializado")
            } catch (e: Exception) {
                Log.e(TAG, "‚ùå Erro ao inicializar Firebase App Check: ${e.message}", e)
                throw e // Lan√ßar exce√ß√£o para identificar problema
            }
        } else {
            Log.d(TAG, "‚ÑπÔ∏è Firebase App Check desativado via configura√ß√£o")
        }
    }
    
    companion object {
        private const val TAG = "TaskGoApp"
    }
    
    override val workManagerConfiguration: Configuration
        get() {
            return if (::workerFactory.isInitialized) {
                Configuration.Builder()
                    .setWorkerFactory(workerFactory)
                    .setMinimumLoggingLevel(Log.DEBUG)
                    .build()
            } else {
                Log.w(TAG, "HiltWorkerFactory n√£o inicializado, usando configura√ß√£o padr√£o")
                Configuration.Builder()
                    .setMinimumLoggingLevel(Log.DEBUG)
                    .build()
            }
        }
}





```

## [FRONTEND]: ui/theme/Color.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.ui.theme

import androidx.compose.ui.graphics.Color

val Purple80 = Color(0xFFD0BCFF)
val PurpleGrey80 = Color(0xFFCCC2DC)
val Pink80 = Color(0xFFEFB8C8)

val Purple40 = Color(0xFF6650a4)
val PurpleGrey40 = Color(0xFF625b71)
val Pink40 = Color(0xFF7D5260)
```

## [FRONTEND]: ui/theme/Theme.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.ui.theme

import android.os.Build
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.dynamicDarkColorScheme
import androidx.compose.material3.dynamicLightColorScheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.ui.platform.LocalContext

private val DarkColorScheme = darkColorScheme(
    primary = Purple80,
    secondary = PurpleGrey80,
    tertiary = Pink80
)

private val LightColorScheme = lightColorScheme(
    primary = Purple40,
    secondary = PurpleGrey40,
    tertiary = Pink40

    /* Other default colors to override
    background = Color(0xFFFFFBFE),
    surface = Color(0xFFFFFBFE),
    onPrimary = Color.White,
    onSecondary = Color.White,
    onTertiary = Color.White,
    onBackground = Color(0xFF1C1B1F),
    onSurface = Color(0xFF1C1B1F),
    */
)

@Composable
fun TaskGoAppTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    // Dynamic color is available on Android 12+
    dynamicColor: Boolean = true,
    content: @Composable () -> Unit
) {
    val colorScheme = when {
        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
            val context = LocalContext.current
            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
        }

        darkTheme -> DarkColorScheme
        else -> LightColorScheme
    }

    MaterialTheme(
        colorScheme = colorScheme,
        typography = Typography,
        content = content
    )
}
```

## [FRONTEND]: ui/theme/Type.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.ui.theme

import androidx.compose.material3.Typography
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp

// Set of Material typography styles to start with
val Typography = Typography(
    bodyLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 16.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.5.sp
    )
    /* Other default text styles to override
    titleLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 22.sp,
        lineHeight = 28.sp,
        letterSpacing = 0.sp
    ),
    labelSmall = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Medium,
        fontSize = 11.sp,
        lineHeight = 16.sp,
        letterSpacing = 0.5.sp
    )
    */
)
```

## [FRONTEND]: utils/FirebaseErrorHandler.kt

```kotlin
Ôªøpackage com.taskgoapp.taskgo.utils

import com.google.firebase.functions.FirebaseFunctionsException
import com.google.firebase.FirebaseException
import android.util.Log

object FirebaseErrorHandler {
    
    fun getErrorMessage(error: Throwable): String {
        return when (error) {
            is FirebaseFunctionsException -> getFunctionErrorMessage(error)
            is FirebaseException -> error.message ?: "Erro no Firebase"
            else -> error.message ?: "Erro desconhecido"
        }
    }
    
    private fun getFunctionErrorMessage(error: FirebaseFunctionsException): String {
        return when (error.code) {
            FirebaseFunctionsException.Code.NOT_FOUND -> "Recurso n√£o encontrado"
            FirebaseFunctionsException.Code.PERMISSION_DENIED -> "Permiss√£o negada"
            FirebaseFunctionsException.Code.ABORTED -> "Opera√ß√£o abortada"
            FirebaseFunctionsException.Code.UNAVAILABLE -> "Servi√ßo temporariamente indispon√≠vel"
            FirebaseFunctionsException.Code.DEADLINE_EXCEEDED -> "Timeout na requisi√ß√£o"
            FirebaseFunctionsException.Code.INTERNAL -> "Erro interno do servidor"
            FirebaseFunctionsException.Code.INVALID_ARGUMENT -> "Argumentos inv√°lidos"
            FirebaseFunctionsException.Code.UNAUTHENTICATED -> "N√£o autenticado"
            else -> error.message ?: "Erro ao processar requisi√ß√£o"
        }
    }
    
    fun logError(tag: String, error: Throwable) {
        Log.e(tag, "Error: ${error.message}", error)
    }
}


```
